/*
 * Copyright (C) 1999-2011 University of Connecticut Health Center
 *
 * Licensed under the MIT License (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *  http://www.opensource.org/licenses/mit-license.php
 */

package cbit.gui.graph;
import java.awt.Component;
import java.awt.Dimension;
import java.util.*;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class GraphPane extends javax.swing.JPanel implements GraphListener, java.awt.event.MouseListener, javax.swing.Scrollable {
	private GraphModel graphModel = null;
	private GraphLayoutManager layoutManager = new GraphLayout();
	private static final Dimension defaultPrefSize = new Dimension(50,50);

/**
 * Constructor
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
public GraphPane() {
	super();
	initialize();
	addMouseListener(this);
}

/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void clear(java.awt.Graphics g) {
	super.paint(g);
}


/**
 * This method was created by a SmartGuide.
 * @return java.awt.Frame
 */
public java.awt.Frame getFrame() {
	java.awt.Component comp = getParent();
	while (comp!=null){
		if (comp instanceof java.awt.Frame){
			return (java.awt.Frame)comp;
		}
		comp = comp.getParent();
	}
	return null;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.graph.GraphModel
 */
public GraphModel getGraphModel() {
	return graphModel;
}


/**
 * Insert the method's description here.
 * Creation date: (3/28/01 5:38:58 PM)
 * @return javax.swing.JScrollPane
 */
private javax.swing.JScrollPane getJScrollPaneParent() {
	if (getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent();
	}else if (getParent() instanceof javax.swing.JViewport && getParent().getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent().getParent();
	}else{
		return null;
	}
}


	/**
	 * Returns the preferred size of the viewport for a view component.
	 * For example the preferredSize of a JList component is the size
	 * required to acommodate all of the cells in its list however the
	 * value of preferredScrollableViewportSize is the size required for
	 * JList.getVisibleRowCount() rows.   A component without any properties
	 * that would effect the viewport size should just return 
	 * getPreferredSize() here.
	 * 
	 * @return The preferredSize of a JViewport whose view is this Scrollable.
	 * @see JViewport#getPreferredSize
	 */
public java.awt.Dimension getPreferredScrollableViewportSize() {
	return getPreferredSize();
}


/**
 * Insert the method's description here.
 * Creation date: (9/6/2002 12:17:16 PM)
 * @return java.awt.Dimension
 */
public Dimension getPreferredSize() {
	if (graphModel!=null){
		Dimension prefSize = graphModel.getPreferedSize((java.awt.Graphics2D)getGraphics());
		if (getJScrollPaneParent()!=null){
			java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
			prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
		}
		return prefSize;
	}else{
		return super.getPreferredSize();
	}
	
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one block
	 * of rows or columns, depending on the value of orientation. 
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a block scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "block" increment for scrolling in the specified direction.
	 * @see JScrollBar#setBlockIncrement
	 */
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	if (javax.swing.SwingConstants.VERTICAL == orientation){
		return visibleRect.height/4;
	}else{
		return visibleRect.width/4;
	}
}


	/**
	 * Return true if a viewport should always force the height of this 
	 * Scrollable to match the height of the viewport.  For example a 
	 * columnar text view that flowed text in left to right columns 
	 * could effectively disable vertical scrolling by returning
	 * true here.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables height to match its own.
	 */
public boolean getScrollableTracksViewportHeight() {
	return false;
}


	/**
	 * Return true if a viewport should always force the width of this 
	 * Scrollable to match the width of the viewport.  For example a noraml 
	 * text view that supported line wrapping would return true here, since it
	 * would be undesirable for wrapped lines to disappear beyond the right
	 * edge of the viewport.  Note that returning true for a Scrollable
	 * whose ancestor is a JScrollPane effectively disables horizontal
	 * scrolling.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables width to match its own.
	 */
public boolean getScrollableTracksViewportWidth() {
	return false;
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one new row
	 * or column, depending on the value of orientation.  Ideally, 
	 * components should handle a partially exposed row or column by 
	 * returning the distance required to completely expose the item.
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a unit scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "unit" increment for scrolling in the specified direction
	 * @see JScrollBar#setUnitIncrement
	 */
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	return 1;
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void graphChanged(GraphEvent graphEvent) {
	updateAll();			
}


/**
 * Called whenever the part throws an exception.
 * @param exception java.lang.Throwable
 */
private void handleException(Throwable exception) {

	/* Uncomment the following lines to print uncaught exceptions to stdout */
	 System.out.println("--------- UNCAUGHT EXCEPTION --------- in CartoonCanvas");
	 exception.printStackTrace(System.out);
}

/**
 * Initialize class
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private void initialize() {
	try {
		// user code begin {1}
		// user code end
		setName("GraphPane");
		setLayout(null);
		setBackground(java.awt.Color.gray);
		setSize(150, 150);
	} catch (java.lang.Throwable ivjExc) {
		handleException(ivjExc);
	}
	// user code begin {2}
	// user code end
}

/**
 * Returns the value of a flag that indicates whether
 * this component can be traversed using
 * Tab or Shift-Tab keyboard focus traversal.  If this method
 * returns "false", this component may still request the keyboard
 * focus using <code>requestFocus()</code>, but it will not automatically
 * be assigned focus during tab traversal.
 * @return    <code>true</code> if this component is
 *            focus-traverable; <code>false</code> otherwise.
 * @since     JDK1.1
 */

//override isFocusTraversable() to return true (Canvas returns false by default) 
//catch the mouse-down event on the component and invoke requestFocus() (to implement click-to-type for your component) 
//when your component gets focus, provide visual feedback indicating it has the focus 

public boolean isFocusTraversable() {
	return true;
}

/**
 * main entrypoint - starts the part when it is run as an application
 * @param args java.lang.String[]
 */
public static void main(java.lang.String[] args) {
	try {
		javax.swing.JFrame frame = new javax.swing.JFrame();
		javax.swing.JDesktopPane desktop = new org.vcell.util.gui.JDesktopPaneEnhanced();
		javax.swing.JInternalFrame iframe = new org.vcell.util.gui.JInternalFrameEnhanced("", true, true, true, true);
		javax.swing.JPanel panel = new javax.swing.JPanel();
		GraphPane aGraphPane = new GraphPane();
		panel.setName("JInternalFrameContentPane");
		panel.setLayout(new java.awt.BorderLayout());
		panel.add(aGraphPane, "Center");
		panel.add(new javax.swing.JButton("hello"), "South");
		iframe.setName("JInternalFrame");
		iframe.setBounds(50, 50, 400, 300);
		iframe.setTitle("GraphPane");
		iframe.getContentPane().add(panel);
//		iframe.setContentPane(panel);
		desktop.setName("JDesktopPane1");
		desktop.add(iframe, iframe.getName());
		frame.getContentPane().setLayout(new java.awt.BorderLayout());
		frame.getContentPane().add(desktop, "Center");
		frame.setSize(iframe.getSize());
		frame.addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent e) {
				System.exit(0);
			};
		});
		frame.setVisible(true);
	} catch (Throwable exception) {
		System.err.println("Exception occurred in main() of cbit.vcell.graph.GraphPane");
		exception.printStackTrace(System.out);
	}
}


	/**
	 * Invoked when the mouse has been clicked on a component.
	 */
public void mouseClicked(java.awt.event.MouseEvent e) {

}


	/**
	 * Invoked when the mouse enters a component.
	 */
public void mouseEntered(java.awt.event.MouseEvent e) {}


	/**
	 * Invoked when the mouse exits a component.
	 */
public void mouseExited(java.awt.event.MouseEvent e) {}


	/**
	 * Invoked when a mouse button has been pressed on a component.
	 */
public void mousePressed(java.awt.event.MouseEvent e) {
	
//override isFocusTraversable() to return true (Canvas returns false by default) 
//catch the mouse-down event on the component and invoke requestFocus() (to implement click-to-type for your component) 
//when your component gets focus, provide visual feedback indicating it has the focus 

	requestFocus();
}


	/**
	 * Invoked when a mouse button has been released on a component.
	 */
public void mouseReleased(java.awt.event.MouseEvent e) {}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void paintComponent(java.awt.Graphics argGraphics) {
	super.paintComponent(argGraphics);
	try {
		java.awt.Graphics2D g = (java.awt.Graphics2D)argGraphics;
		if (graphModel!=null){
			try {
				layoutManager.layout(graphModel,this);
			}catch (LayoutException e){
				System.out.println("Layout error: "+e.getMessage());
			}
			graphModel.paint(g,this);
		}	
	}catch (Exception e){
		handleException(e);
	}		
}


/**
 * This method was created by a SmartGuide.
 * @param graphModel cbit.vcell.graph.GraphModel
 */
public void setGraphModel(GraphModel argGraphModel) {
	
	if (this.graphModel != null){
		this.graphModel.removeGraphListener(this);
	}
	
	this.graphModel = argGraphModel;
	
	if (this.graphModel != null){
		this.graphModel.addGraphListener(this);
	}
	
	updateAll();
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void updateAll() {
	try {
		if (graphModel!=null){
			if (getJScrollPaneParent()!=null){
				invalidate();
				getJScrollPaneParent().revalidate();
			}
			repaint();
		}
	}catch (Exception e){
		handleException(e);
	}			
}


/**
 * 
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private static void getBuilderData() {
/*V1.1
**start of data**
	D0CB838494G88G88GCAFBB0B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E13598EDECD357B52C0131AED2C1259BD45D0A3AB0E5A86B58C7856B72A36D58E0AD522688A4FE8489897ECC4AB624318D31C83B366360G8D2625052928F3828CCABE48D7C9B0A9EB881F2BBB32468B06C4AB4F760D7D12E7BF7779B9CEE8E8F74E7D30DF028DABAA160E6E3B675C73F14FBD675CF3CD8E7CED2953E6BFC0084DC9442F5BC648620304EC1EDF35CC62FA0ED754914B2F81E0BF192A290171
	8A50F63CDBD167A6AFCC3BE0BE82733DB0879164B5727369625761A30F1EE92095DE5F71783D756C33CBBD3B587C4B1E3DB056835C829C0E2547D17F531EC382DFA87092ECF6C2A6CF601A67BD0785EE9B2CF1812E8B604A893E7E960C5C00395E9E31EEE4E189597E12E1FF8565D8E4CAA8973CDB4568A1BBEDC5EF232EAD4CCE64B98CF3BFGEE5EC13E65FA8B465E01714839D0D0B5DBA3A935B5E2A8092857FB990781A5CE89F11DC499CD8DAE46C3482F00FF91439D1FC039BE788E83CC1F147862B462B742
	77B6GD7135C4B3B47FB052D01CFD612759D311AFDF97662E962FB3852145D0BA736497ED76677EB8E74EFA150CAG4AGB68310660ABA8F401B6C3C076CA7E16C8B1A7DFAAC26477B920973DA5878C08FD38D3E3DDE20885C07B4249BE1C278197E5A531C431EFB81677B53676663BEA9691467DB7A6133247207DF336F4A61134A12CF6CBD4D5C97834DD91FF05DED8D79F4A71AE7465FCC5D5709D577025FEDF0B8F368AE2D5C60A894F296DBF42FED46337EB7BB6BD570ED93714171438C3F37A50B67315842
	E286670701D650A2E3A3D0AFED7155BCC35C6DDF4F690745AF96593736F09B2ADBE65BF2E892E51FE865BAED99DB9A983E4B026736ACCF4B3CF88FE845GBC3E82CE4CCD57290A3A23G3DGFEG93E081C071A999E3CF5BCF7D1FB1B620986679142A0529C1B8EF4071860CF452B4142B71242944C3F4C8B1D4A52851A491EB94877AA0B803EF1445FE88F4DC26F1EAA8262A47C13A9223A6B512FC0D6E580FEB8C4A28FEB5C6C1C1ACC1245C3463B598B5A5E97EA791D6CC1ADD41691FB970CCA614A110888260
	1B7BE5EEAD7AEBB56C3F9220AA63071DCC5E7B5408D34D6B75697AF8AA61471D101EB67473E5D6BB88FC9FEA13BE1E338BF153B0DF54A66534573CEA11F3C18D21790AB1A5F36CFA9A6BEFC91B0C195F86E44CDCF8653B24F94393B9E34633E903233C0D474A4636593923B019E8971FF7CE84AC3CA5ED397367C1016B704D506178826557E74E2AAB00E7C55AAB6A8E837436CB9FEBB59E9E336715A415D1FA4D00G23612C47391DEFCD120C4D47AD5FAB5201AF505E5CBE7A45C35541FD91F4627DC3A7E85C3C
	C093B49E060F242029CE0CB1111F23FA06C7E7788464F3BFA4D0B203CFB9B1679453B454E04A240354B455F8A4CB3F43F4A5D341C43694C8DD05CE2C3BFA9A72B9337EABCE4C05109E0FD3F6A89996C17FAA4BC52A5198985D2F2762A647AF2C45F89E27D32296BCD1DBCBB01735945695FE6F2FD076609E8CB586C70D2509ACEA47BC7DEF43810B0F7C00437E2520DD66DB7A084C3723373FC34ABFCA58F35D970B17BDE62FEC67F9332DBD1BEF5C1EF93BF25BDD446A0140A7391D4405FAAD2D08086D588D1461
	6E007A8C505BA1E35B65C23A2C9FA2287BF5CD63AE4C78569BF063D9500FD3944AAE962A77B37E6A8B3CBA0BB6A4FC4769D78368BB4DD263382D6E7318D759DEEAA2C4B56D2EEE0A77D2EBD8BD44B877F7C85F5E39A4FB23C563A524EC5F9D7B1E9C3EC5A86A903DE6C75637836B7E68603ED9F993E5D7812DBA63175581EBFD6ECBA675104A2E863127648D2B6FB9EE7246EE98C7D5A3E9DE054418147B7F74865A0BF707C00BFCDDF7D78F626E64769D053127736EBA4A6D7D7DB0461C8F68D100820045G2BBA
	256D35B7BB49FD6E580B13F0754595EDF0C6F289FB4BEEBAF8BE08F979CD274C8798797D34051D47C650D90536B25C33C790676E2A28BB51A5F15BCD4475425C5FA56D7B73F07E9AE29F49DDC3DCA339EBC87D48FE0E8799560EC1525F9849D7E39C0C3E3321161D4D141EB2A1773A50667D0D72ADB2897385G2B81B6F6717360FCBFBB02E79DD4C2639183B292FA6170BB483B097920873EAF3CA35F8C5FCFE3DC0EC243812A8793B4C4FACF635ABDA9292784561681D482D4839C86BA6F374EB44AFE2B90F0E5
	27254CC86331CC6E6831D6B598EBCDCD44DA152059CA432A69757EAB25E9BE31AD719E1953689232361F166F0E6FB1794D5DE0AF40C8374C2D493F4B5CAA7D76B364D655FAC72EB754E67F9D3B59AD7A5C6EECEEF5413BE3FDB73E871B42A46333AA93F3EACC19D0DA1534598AD5C6B7B05D27C4EF3DB4EDFD37756C7ED24EDA09F028076BEA96E3756BCF5A789E5BD3F20FE120BD5503380FD2569A0D36344002D698B9FD618CBA464BE5E2257FF4863D6EAE7EBF4C20234D7D021F6F6B65E3521755AF2FA05AF3
	05F95F23DB45FEDCE77838E06B92DB610E5B8EDEAF7E5178E06F2C8F9E10EF5E676663EF07B9C7B0265EBBB37BCD71A8437B4E4CFED3BC170971G504A4E48FE77A90A79617142FD85608750G0AGCA3C3216140E34117B54BA3F1E70C13151AC65011F4BAF072D7166FED233CB3BE66F2B4C4B4FE32DB79B635CC6E784632D9A70074ECA1B9261A6980714B1E14DC5C8C85DE066GF240509354B027B8165D14425F27D38F769EFEE1170C2F9FBD3F1C2C1AF7A16FBD58F3165B9F906309ADCBEC59FB65F6947D
	BD9FE845GEB81B683EC87585BAB7736B25C4C7D0D66771926920A329BD0BAFBC82569AC9A0B1D785F6788494455824B77CF9A9FFEDF3C7E216A60FED9C6735FE925B4771D76831A7BCEDBC56F5D9717537CFD719AEA6D0B7939FEC3A5995E6B23477245A61C5EBF21B6DF8B0EC16F67D7A2991E5D11FA2BBDBCE485EDFF84EB1F9AD7CDD551545B2CC59A04057188573DFC8C699E081FDE00DBGA6407CCCBCAD0DB472F84A91CB9743915A2F33173EA975BD924D6F67C723777FFF6071A83B37F55354E3A8DF62
	17C4B1D6CCBD41109C774DA81E0F21C622A6DFAA7045D14CF90D0EB234B84B317CF67DF86C7EF63DB8467AC910671FCA8819EB4630B751C7C713B4337FF5E36E8C6EEAF2C0CF2A68F17EFFADF1EC023174B74419B4C87D4CFB56366C60A36E47BAD3F6623AC4EAC795AD91D52E92A7EB6AFCE4CF106D129A3056A4EE9F721E825ED30C772C0F58C3C9133C194507904F290389A5C4E1C9DDD8B14619040F492744B6CC6AC60DC810A9B009FD7852B028E5B3A4BBFCE437994553B541AFA6B91895BD2028784AE104
	3313788F8C79CBC1C1C1027D082CF9EFFFE62D5DBB660672768A3D6744FF0067E6576E0493FDDE847812F3B29E4BEBDA6E119F03B1C553CCC59B6F0B07B1D74ECF19547A1EC579C939C690B9ED1A3D0147ACBC7F83D0CB8788EBCD3DA10B89GG4097GGD0CB818294G94G88G88GCAFBB0B6EBCD3DA10B89GG4097GG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGG4589GGGG
**end of data**/
}
}
