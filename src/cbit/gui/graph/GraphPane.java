package cbit.gui.graph;
import java.awt.Dimension;
/**
 * This class was generated by a SmartGuide.
 * 
 */
@SuppressWarnings("serial")
public class GraphPane extends javax.swing.JPanel implements GraphListener, java.awt.event.MouseListener, javax.swing.Scrollable {
	private GraphModel graphModel = null;
	private GraphLayoutManager layoutManager = new GraphLayout();

	public GraphPane() {
		super();
		initialize();
		addMouseListener(this);
	}

	public void clear(java.awt.Graphics g) {
		super.paint(g);
	}

	public java.awt.Frame getFrame() {
		java.awt.Component comp = getParent();
		while (comp!=null){
			if (comp instanceof java.awt.Frame){
				return (java.awt.Frame)comp;
			}
			comp = comp.getParent();
		}
		return null;
	}

	public GraphModel getGraphModel() {
		return graphModel;
	}


	private javax.swing.JScrollPane getJScrollPaneParent() {
		if (getParent() instanceof javax.swing.JScrollPane){
			return (javax.swing.JScrollPane)getParent();
		}else if (getParent() instanceof javax.swing.JViewport && getParent().getParent() instanceof javax.swing.JScrollPane){
			return (javax.swing.JScrollPane)getParent().getParent();
		}else{
			return null;
		}
	}


	/**
	 * Returns the preferred size of the viewport for a view component.
	 * For example the preferredSize of a JList component is the size
	 * required to acommodate all of the cells in its list however the
	 * value of preferredScrollableViewportSize is the size required for
	 * JList.getVisibleRowCount() rows.   A component without any properties
	 * that would effect the viewport size should just return 
	 * getPreferredSize() here.
	 * 
	 * @return The preferredSize of a JViewport whose view is this Scrollable.
	 * @see JViewport#getPreferredSize
	 */
	public java.awt.Dimension getPreferredScrollableViewportSize() {
		return getPreferredSize();
	}


	/**
	 * Insert the method's description here.
	 * Creation date: (9/6/2002 12:17:16 PM)
	 * @return java.awt.Dimension
	 */
	@Override
	public Dimension getPreferredSize() {
		if (graphModel!=null){
			Dimension prefSize = graphModel.getPreferedSize((java.awt.Graphics2D)getGraphics());
			if (getJScrollPaneParent()!=null){
				java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
				prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
			}
			return prefSize;
		}else{
			return super.getPreferredSize();
		}

	}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one block
	 * of rows or columns, depending on the value of orientation. 
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a block scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "block" increment for scrolling in the specified direction.
	 * @see JScrollBar#setBlockIncrement
	 */
	public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
		if (javax.swing.SwingConstants.VERTICAL == orientation){
			return visibleRect.height/4;
		}else{
			return visibleRect.width/4;
		}
	}


	/**
	 * Return true if a viewport should always force the height of this 
	 * Scrollable to match the height of the viewport.  For example a 
	 * columnar text view that flowed text in left to right columns 
	 * could effectively disable vertical scrolling by returning
	 * true here.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables height to match its own.
	 */
	public boolean getScrollableTracksViewportHeight() {
		return false;
	}


	/**
	 * Return true if a viewport should always force the width of this 
	 * Scrollable to match the width of the viewport.  For example a noraml 
	 * text view that supported line wrapping would return true here, since it
	 * would be undesirable for wrapped lines to disappear beyond the right
	 * edge of the viewport.  Note that returning true for a Scrollable
	 * whose ancestor is a JScrollPane effectively disables horizontal
	 * scrolling.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables width to match its own.
	 */
	public boolean getScrollableTracksViewportWidth() {
		return false;
	}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one new row
	 * or column, depending on the value of orientation.  Ideally, 
	 * components should handle a partially exposed row or column by 
	 * returning the distance required to completely expose the item.
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a unit scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "unit" increment for scrolling in the specified direction
	 * @see JScrollBar#setUnitIncrement
	 */
	public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
		return 1;
	}


	/**
	 * This method was created by a SmartGuide.
	 * @param o java.util.Observable
	 * @param obj java.lang.Object
	 */
	public void graphChanged(GraphEvent graphEvent) {
		updateAll();			
	}


	/**
	 * Called whenever the part throws an exception.
	 * @param exception java.lang.Throwable
	 */
	private void handleException(Throwable exception) {

		/* Uncomment the following lines to print uncaught exceptions to stdout */
		System.out.println("--------- UNCAUGHT EXCEPTION --------- in CartoonCanvas");
		exception.printStackTrace(System.out);
	}

	/**
	 * Initialize class
	 */
	/* WARNING: THIS METHOD WILL BE REGENERATED. */
	private void initialize() {
		try {
			// user code begin {1}
			// user code end
			setName("GraphPane");
			setLayout(null);
			setBackground(java.awt.Color.gray);
			setSize(150, 150);
		} catch (java.lang.Throwable ivjExc) {
			handleException(ivjExc);
		}
		// user code begin {2}
		// user code end
	}

	/**
	 * Returns the value of a flag that indicates whether
	 * this component can be traversed using
	 * Tab or Shift-Tab keyboard focus traversal.  If this method
	 * returns "false", this component may still request the keyboard
	 * focus using <code>requestFocus()</code>, but it will not automatically
	 * be assigned focus during tab traversal.
	 * @return    <code>true</code> if this component is
	 *            focus-traverable; <code>false</code> otherwise.
	 * @since     JDK1.1
	 */

	//override isFocusTraversable() to return true (Canvas returns false by default) 
	//catch the mouse-down event on the component and invoke requestFocus() (to implement click-to-type for your component) 
	//when your component gets focus, provide visual feedback indicating it has the focus 

	@Override
	public boolean isFocusTraversable() {
		return true;
	}

	/**
	 * main entrypoint - starts the part when it is run as an application
	 * @param args java.lang.String[]
	 */
	public static void main(java.lang.String[] args) {
		try {
			javax.swing.JFrame frame = new javax.swing.JFrame();
			javax.swing.JDesktopPane desktop = new org.vcell.util.gui.JDesktopPaneEnhanced();
			javax.swing.JInternalFrame iframe = new org.vcell.util.gui.JInternalFrameEnhanced("", true, true, true, true);
			javax.swing.JPanel panel = new javax.swing.JPanel();
			GraphPane aGraphPane = new GraphPane();
			panel.setName("JInternalFrameContentPane");
			panel.setLayout(new java.awt.BorderLayout());
			panel.add(aGraphPane, "Center");
			panel.add(new javax.swing.JButton("hello"), "South");
			iframe.setName("JInternalFrame");
			iframe.setBounds(50, 50, 400, 300);
			iframe.setTitle("GraphPane");
			iframe.getContentPane().add(panel);
			//		iframe.setContentPane(panel);
			desktop.setName("JDesktopPane1");
			desktop.add(iframe, iframe.getName());
			frame.getContentPane().setLayout(new java.awt.BorderLayout());
			frame.getContentPane().add(desktop, "Center");
			frame.setSize(iframe.getSize());
			frame.addWindowListener(new java.awt.event.WindowAdapter() {
				@Override
				public void windowClosing(java.awt.event.WindowEvent e) {
					System.exit(0);
				};
			});
			frame.setVisible(true);
		} catch (Throwable exception) {
			System.err.println("Exception occurred in main() of cbit.vcell.graph.GraphPane");
			exception.printStackTrace(System.out);
		}
	}


	/**
	 * Invoked when the mouse has been clicked on a component.
	 */
	public void mouseClicked(java.awt.event.MouseEvent e) {

	}


	/**
	 * Invoked when the mouse enters a component.
	 */
	public void mouseEntered(java.awt.event.MouseEvent e) {}


	/**
	 * Invoked when the mouse exits a component.
	 */
	public void mouseExited(java.awt.event.MouseEvent e) {}


	/**
	 * Invoked when a mouse button has been pressed on a component.
	 */
	public void mousePressed(java.awt.event.MouseEvent e) {

		//override isFocusTraversable() to return true (Canvas returns false by default) 
		//catch the mouse-down event on the component and invoke requestFocus() (to implement click-to-type for your component) 
		//when your component gets focus, provide visual feedback indicating it has the focus 

		requestFocus();
	}


	/**
	 * Invoked when a mouse button has been released on a component.
	 */
	public void mouseReleased(java.awt.event.MouseEvent e) {}


	/**
	 * This method was created by a SmartGuide.
	 * @param g java.awt.Graphics
	 */
	@Override
	public void paintComponent(java.awt.Graphics argGraphics) {
		super.paintComponent(argGraphics);
		try {
			java.awt.Graphics2D g = (java.awt.Graphics2D)argGraphics;
			if (graphModel!=null){
				try {
					layoutManager.layout(graphModel,this);
				}catch (LayoutException e){
					System.out.println("Layout error: "+e.getMessage());
				}
				graphModel.paint(g,this);
			}	
		}catch (Exception e){
			handleException(e);
		}		
	}


	/**
	 * This method was created by a SmartGuide.
	 * @param graphModel cbit.vcell.graph.GraphModel
	 */
	public void setGraphModel(GraphModel argGraphModel) {

		if (this.graphModel != null){
			this.graphModel.removeGraphListener(this);
		}

		this.graphModel = argGraphModel;

		if (this.graphModel != null){
			this.graphModel.addGraphListener(this);
		}

		updateAll();
	}


	/**
	 * This method was created by a SmartGuide.
	 * @param o java.util.Observable
	 * @param obj java.lang.Object
	 */
	public void updateAll() {
		try {
			if (graphModel!=null){
				if (getJScrollPaneParent()!=null){
					invalidate();
					getJScrollPaneParent().revalidate();
				}
				repaint();
			}
		}catch (Exception e){
			handleException(e);
		}			
	}

}