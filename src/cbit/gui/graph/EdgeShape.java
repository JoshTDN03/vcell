package cbit.gui.graph;
/*�
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
�*/
import java.awt.*;
import java.awt.geom.*;

import cbit.gui.graph.visualstate.EdgeDefaultVisualState;
import cbit.gui.graph.visualstate.EdgeVisualState;
import cbit.gui.graph.visualstate.VisualState;
/**
 * This Class was generated by a SmartGuide.
 * 
 */
public abstract class EdgeShape extends Shape implements EdgeVisualState.Owner {

	public static final int LINE_STYLE_SOLID = 0;
	public static final int LINE_STYLE_DASHED = 1;

	protected ElipseShape startShape = null;
	protected ElipseShape endShape = null;
	protected Point start = new Point();
	protected Point end = new Point();

	protected static final double CONTROL_WEIGHT = 50.0;
	protected static final double FRACT_WEIGHT = 0.25;
	protected Point lastCurve_Start = null;
	protected Point lastCurve_End = null;
	protected java.awt.geom.CubicCurve2D.Double lastCurve = null;
	//protected static final float DASH_ARRAY[] = new float[] { 5,3 };
	protected static final java.awt.BasicStroke DASHED_STROKE =
		new java.awt.BasicStroke(1,java.awt.BasicStroke.CAP_BUTT,BasicStroke.JOIN_MITER,10f,new float[] { 5,3 }/*DASH_ARRAY*/,10f);

	public EdgeShape (ElipseShape startShape, ElipseShape endShape, GraphModel graphModel) {
		super(graphModel);
		this.startShape = startShape;
		this.endShape = endShape;
		defaultFG = java.awt.Color.black;
		defaultFGselect = java.awt.Color.red;
	}

	public EdgeShape(Point start, Point end, GraphModel graphModel) {
		super(graphModel);
		this.startShape = null;
		this.endShape = null;
		this.start = start;
		this.end = end;
		defaultFG = java.awt.Color.black;
		defaultFGselect = java.awt.Color.red;
	}

	@Override
	public VisualState createVisualState() { return new EdgeDefaultVisualState(this); }

	public ElipseShape getStartShape() { return startShape; }
	public ElipseShape getEndShape() { return endShape; }

	protected static Point2D evaluate(CubicCurve2D curve, double t) {
		//double a0x = curve.getX1();
		//double a0y = curve.getY1();
		//double a1x = curve.getCtrlX1();
		//double a1y = curve.getCtrlY1();
		//double a2x = -3*curve.getX1() + 3*curve.getX2() - 2*curve.getCtrlX1() - curve.getCtrlX2();
		//double a2y = -3*curve.getY1() + 3*curve.getY2() - 2*curve.getCtrlY1() - curve.getCtrlY2();
		//double a3x =  2*curve.getX1() - 2*curve.getX2() +   curve.getCtrlX1() + curve.getCtrlX2();
		//double a3y =  2*curve.getY1() - 2*curve.getY2() +   curve.getCtrlY1() + curve.getCtrlY2();

		//double t2 = t*t;
		//double t3 = t2*t;
		//return new Point2D.Double(a3x*t3+a2x*t2+a1x*t+a0x, a3y*t3+a2y*t2+a1y*t+a0y);

		double u = 1 - t;
		double x = curve.getX1()*u*u*u + 3*curve.getCtrlX1()*t*u*u + 3*curve.getCtrlX2()*t*t*u + curve.getX2()*t*t*t;
		double y = curve.getY1()*u*u*u + 3*curve.getCtrlY1()*t*u*u + 3*curve.getCtrlY2()*t*t*u + curve.getY2()*t*t*t;
		return new Point2D.Double(x,y);

	}


	/**
	 * Insert the method's description here.
	 * Creation date: (8/12/2002 9:08:38 PM)
	 * @return cbit.vcell.graph.Shape
	 * @param front java.awt.geom.Point2D
	 * @param back java.awt.geom.Point2D
	 */
	protected static GeneralPath getArrow(Point2D front, Point2D back, double width) {
		double deltaX = back.getX() - front.getX();
		double deltaY = back.getY() - front.getY();
		double distance = Math.sqrt(deltaX*deltaX+deltaY*deltaY);
		//
		// take straight-line approximation for direction (given right.p1 and right.p2 as end points)
		// use 10 and 30 "pixels" away for the arrowhead.
		//
		double X1 = front.getX();
		double Y1 = front.getY();
		double X2 = front.getX()+1.5*deltaX;
		double Y2 = front.getY()+1.5*deltaY;
		double X3 = X2+0.5*width*deltaY/distance;
		double Y3 = Y2-0.5*width*deltaX/distance;
		double X4 = X2-0.5*width*deltaY/distance;
		double Y4 = Y2+0.5*width*deltaX/distance;

		GeneralPath arrow = new GeneralPath();
		arrow.moveTo((float)X1,(float)Y1);
		arrow.lineTo((float)X3,(float)Y3);
		arrow.lineTo((float)X4,(float)Y4);
		arrow.lineTo((float)X1,(float)Y1);
		arrow.setWindingRule(Path2D.WIND_NON_ZERO);

		return arrow;
	}


	/**
	 * Insert the method's description here.
	 * Creation date: (8/12/2002 11:51:55 AM)
	 * @return java.awt.geom.CubicCurve2D
	 */
	protected java.awt.geom.CubicCurve2D.Double getCurve() {

		if(lastCurve != null && 
				lastCurve_Start != null && lastCurve_Start.equals(start) &&
				lastCurve_End != null && lastCurve_End.equals(end)){
			//Do Nothing
		}else{
			//
			// default behavior of control points is for direction at ends to follow secant between end-points.
			//
			java.awt.geom.Point2D.Double p1ctrl = new java.awt.geom.Point2D.Double((1.0-FRACT_WEIGHT)*start.getX()+FRACT_WEIGHT*end.getX(),(1.0-FRACT_WEIGHT)*start.getY()+FRACT_WEIGHT*end.getY());
			java.awt.geom.Point2D.Double p2ctrl = new java.awt.geom.Point2D.Double(FRACT_WEIGHT*start.getX()+(1.0-FRACT_WEIGHT)*end.getX(),FRACT_WEIGHT*start.getY()+(1.0-FRACT_WEIGHT)*end.getY());

			lastCurve = new java.awt.geom.CubicCurve2D.Double(start.getX(),start.getY(),p1ctrl.getX(),p1ctrl.getY(),p2ctrl.getX(),p2ctrl.getY(),end.getX(),end.getY());

			lastCurve_Start = new Point(start);
			lastCurve_End = new Point(end);
		}

		return lastCurve;
	}


	/**
	 * This method was created in VisualAge.
	 * @return int
	 */
	protected int getEndAttachment() {
		return ATTACH_CENTER;
	}


	/**
	 * Insert the method's description here.
	 * Creation date: (1/15/2004 9:24:48 PM)
	 * @return int
	 */
	public int getLineStyle() {
		return LINE_STYLE_SOLID;
	}


	/**
	 * Insert the method's description here.
	 * Creation date: (8/12/2002 10:46:11 PM)
	 * @return java.awt.geom.Point2D
	 * @param centerX double
	 * @param centerY double
	 * @param radius double
	 */
	protected static double getParameterAtArcLength(CubicCurve2D curve, double startT, double endT, double arcLength, int numIntervals) {
		double currentT = startT;
		double totalLength = 0.0;
		double deltaT = (endT-startT)/numIntervals;
		Point2D curr = evaluate(curve,currentT);
		for (int i = 0; i < numIntervals && totalLength<arcLength; i++){
			currentT = startT+i*deltaT;
			Point2D next = evaluate(curve,currentT);
			double dx = next.getX()-curr.getX();
			double dy = next.getY()-curr.getY();
			totalLength += Math.sqrt(dx*dx + dy*dy);
			curr = next;
		}
		return currentT;
	}


	/**
	 * This method was created by a SmartGuide.
	 * @return int
	 * @param g java.awt.Graphics
	 */
	@Override
	public Dimension getPreferedSize(java.awt.Graphics2D g) {
		java.awt.FontMetrics fm = g.getFontMetrics();
		labelSize.height = fm.getMaxAscent() + fm.getMaxDescent();
		labelSize.width = fm.stringWidth(getLabel());
		preferredSize.height = labelSize.height + 10;
		preferredSize.width = labelSize.width + 10;
		return preferredSize;
	}


	/**
	 * This method was created in VisualAge.
	 * @return int
	 */
	protected int getStartAttachment() {
		return ATTACH_CENTER;
	}


	/**
	 * Insert the method's description here.
	 * Creation date: (8/14/2002 9:59:45 AM)
	 * @return double
	 * @param cubicCurve java.awt.geom.CubicCurve2D
	 * @param t1 double
	 * @param t2 double
	 */
	protected static double integrateArcLength(CubicCurve2D cubicCurve, double t1, double t2, int numIntervals) {
		double arcLength = 0.0;
		double currentT = t1;
		double deltaT = (t2-t1)/numIntervals;
		Point2D curr = evaluate(cubicCurve,currentT);
		for (int i = 0; i < numIntervals; i++){
			Point2D next = evaluate(cubicCurve,currentT+deltaT);
			double dx = next.getX()-curr.getX();
			double dy = next.getY()-curr.getY();
			arcLength += Math.sqrt(dx*dx + dy*dy);
			curr = next;
			currentT = t1+i*deltaT;
		}
		return arcLength;
	}


	/**
	 * Insert the method's description here.
	 * Creation date: (8/12/2002 10:46:11 PM)
	 * @return java.awt.geom.Point2D
	 * @param centerX double
	 * @param centerY double
	 * @param radius double
	 */
	protected static double intersectWithCircle(CubicCurve2D curve, double startT, double endT, double centerX, double centerY, double radius) {

		double radiusSquared = radius*radius;
		double bestT = -1.0;
		double bestError = 10e10;
		double deltaT = (endT-startT)/200;
		for (double t = startT;((deltaT>0)?(t<=endT):(t>=endT));t+=deltaT){
			double u = 1 - t;
			double x = curve.getX1()*u*u*u + 3*curve.getCtrlX1()*t*u*u + 3*curve.getCtrlX2()*t*t*u + curve.getX2()*t*t*t;
			double y = curve.getY1()*u*u*u + 3*curve.getCtrlY1()*t*u*u + 3*curve.getCtrlY2()*t*t*u + curve.getY2()*t*t*t;
			double tempRadiusSquared = (x-centerX)*(x-centerX) + (y-centerY)*(y-centerY);
			double error = Math.abs(tempRadiusSquared-radiusSquared);
			if (error < bestError){
				bestError = error;
				bestT = t;
			}else{
				//			break;
			}
		}	
		return bestT;
	}


	/**
	 * This method was created by a SmartGuide.
	 * @return boolean
	 * @param p java.awt.Point
	 */
	@Override
	public final boolean isInside (Point p ) {
		java.awt.geom.CubicCurve2D curve = getCurve();
		return curve.intersects(p.getX()-2,p.getY()-2,4,4);


		//double tolerance = 4.0;
		////
		//// this takes the distance between point p0 and the line segment from start to end
		////
		//Point p0 = new Point(p);
		//Point line = new Point(end.x-start.x,end.y-start.y);  // from start to end
		//Point line0 = new Point(p0.x-start.x,p0.y-start.y);  // from start to point
		////
		//// 
		////
		//double lengthSquared = line.x*line.x + line.y*line.y;
		//double s0 = (line0.x*line.x + line0.y*line.y) / lengthSquared;
		//if (s0 > 0.0 && s0 < 1.0){
		//double length = Math.abs(line0.x*line.y-line.x*line0.y)/Math.sqrt(lengthSquared);
		//if (length < tolerance){
		////			System.out.println("point is inside line, distance = "+length);
		//return true;
		//}else{
		////			System.out.println("point is outside line, distance = "+length);
		//return false;
		//}
		//}else{
		////		System.out.println("point is outside of envelope");
		//return false;
		//}
	}


	/**
	 * This method was created by a SmartGuide.
	 * @return boolean
	 * @param p java.awt.Point
	 */
	@Override
	public final boolean isOnBorder(Point p) {
		return isInside(p);
	}


	/**
	 * This method was created by a SmartGuide.
	 * @return int
	 * @param g java.awt.Graphics
	 */
	@Override
	public void layout() {

		if (startShape!=null){
			start = startShape.getAttachmentLocation(getStartAttachment());
			start.x += startShape.getAbsLocation().x;
			start.y += startShape.getAbsLocation().y;
		}

		if (endShape!=null){
			end = endShape.getAttachmentLocation(getEndAttachment());
			end.x += endShape.getAbsLocation().x;
			end.y += endShape.getAbsLocation().y;
		}

		relativePos.x = Math.min(start.x,end.x);
		relativePos.y = Math.min(start.y,end.y);
		shapeSize.width = Math.abs(start.x-end.x);
		shapeSize.height = Math.abs(start.y-end.y);

		//
		// this is like a row/column layout  (1 column)
		//
		int centerX = shapeSize.width/2;
		int centerY = shapeSize.height/2;

		//
		// position label
		//
		labelPos.x = centerX - labelSize.width/2;
		labelPos.y = centerY - labelSize.height/2;
	}

	@Override
	public void paintSelf(Graphics2D g2D, int xPos, int yPos) {

		g2D.setRenderingHint(
				java.awt.RenderingHints.KEY_ANTIALIASING,
				java.awt.RenderingHints.VALUE_ANTIALIAS_ON);

		paint0(g2D,xPos,yPos);
	}

	public void paint_NoAntiAlias(Graphics2D g2D, int xPos, int yPos) {

		//
		// to accommdate a Machintosh Java 1.4.2 bug (can't properly XOR paint with anti-aliasing)
		//
		g2D.setRenderingHint(
				java.awt.RenderingHints.KEY_ANTIALIASING,
				java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
		g2D.setRenderingHint(
				java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
				java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);

		paint0(g2D,xPos,yPos);
	}


	/**
	 * This method was created by a SmartGuide.
	 * @param g java.awt.Graphics
	 */
	private void paint0(Graphics2D g2D, int xPos, int yPos) {

		//int absPosX = screenPos.x + parentOffsetX;
		//int absPosY = screenPos.y + parentOffsetY;
		//
		// draw cubic spline with horizontal reactant-end (p' = 0) at reaction
		//
		//java.awt.geom.CubicCurve2D.Double cubicCurve = getCurve();
		//java.awt.geom.Point2D.Double p1 = (java.awt.geom.Point2D.Double) cubicCurve.getP1();
		//java.awt.geom.Point2D.Double p2 = (java.awt.geom.Point2D.Double) cubicCurve.getP2();
		//java.awt.geom.Point2D.Double p1ctrl = (java.awt.geom.Point2D.Double) cubicCurve.getCtrlP1();
		//java.awt.geom.Point2D.Double p2ctrl = (java.awt.geom.Point2D.Double) cubicCurve.getCtrlP2();

		//
		// render curve (make CatalystShapes draw with a dashed line)
		//
		g2D.setColor(forgroundColor);
		if (getLineStyle() == LINE_STYLE_DASHED){
			Stroke oldStroke = g2D.getStroke();
			//float dashArray[] = new float[] { 5,3 };
			//java.awt.BasicStroke dashedStroke = new java.awt.BasicStroke(1,java.awt.BasicStroke.CAP_BUTT,BasicStroke.JOIN_MITER,10f,dashArray,10f);
			g2D.setStroke(DASHED_STROKE);
			g2D.draw(getCurve());
			g2D.setStroke(oldStroke);
		}else{
			g2D.draw(getCurve());
		}
		//
		// draw control points
		//
		//if (isSelected()){
		//g2D.draw(new Ellipse2D.Double(p1ctrl.getX()-2,p1ctrl.getY()-2,4,4));
		//g2D.draw(new Ellipse2D.Double(p2ctrl.getX()-2,p2ctrl.getY()-2,4,4));
		//g2D.draw(new Line2D.Double(p1ctrl.getX(),p1ctrl.getY(),p1.getX(),p1.getY()));
		//g2D.draw(new Line2D.Double(p2ctrl.getX(),p2ctrl.getY(),p2.getX(),p2.getY()));
		//}

		//
		// draw label
		//
		if (getLabel() != null && getLabel().length()>0) {
			g2D.drawString(getLabel(), (start.x + end.x) / 2, (start.y + end.y) / 2);
		}
		return;
	}


	/**
	 * This method was created in VisualAge.
	 * @param shape cbit.vcell.graph.ElipseShape
	 */
	public void setEnd(ElipseShape shape) throws Exception {
		endShape = shape;

		layout();
	}


	/**
	 * This method was created in VisualAge.
	 * @param start java.awt.Point
	 * @param end java.awt.Point
	 */
	public void setEnd(Point end) throws Exception {

		this.end = end;
		endShape = null;

		layout();
	}
}