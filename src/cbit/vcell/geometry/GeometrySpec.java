package cbit.vcell.geometry;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.beans.PropertyChangeListener;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.io.Serializable;
import java.util.Enumeration;
import java.util.TreeSet;
import java.util.Vector;

import org.vcell.util.Compare;
import org.vcell.util.Coordinate;
import org.vcell.util.Extent;
import org.vcell.util.ISize;
import org.vcell.util.Matchable;
import org.vcell.util.Origin;
import org.vcell.util.document.Version;

import cbit.gui.PropertyChangeListenerProxyVCell;
import cbit.image.ImageException;
import cbit.image.VCImage;
import cbit.image.VCImageUncompressed;
import cbit.image.VCPixelClass;
import cbit.vcell.client.server.VCellThreadChecker;
import cbit.vcell.math.VCML;
import cbit.vcell.parser.ExpressionException;
/**
 * This interface was generated by a SmartGuide.
 * 
 */
public class GeometrySpec implements Matchable, PropertyChangeListener, VetoableChangeListener, Serializable {

	public final static int IMAGE_SIZE_LIMIT =  4000000;
	
	private VCImage vcImage = null;
	private transient byte[] uncompressedPixels = null;
	private transient VCImage sampledImage = null;
	//
	// zero dimension is a point geometry object
	//
	private int dimension = 0;
	private Extent extent = new Extent(10,10,10);
	private Origin origin = new Origin(0,0,0);
//	private Vector subVolumeList = new Vector();
	//private Vector curveTypeList = new Vector();
	protected transient java.beans.PropertyChangeSupport propertyChange;
	protected transient java.beans.VetoableChangeSupport vetoPropertyChange;
	private cbit.vcell.geometry.SubVolume[] fieldSubVolumes = new SubVolume[0];
	private FilamentGroup fieldFilamentGroup = new FilamentGroup();
	public static final String ORIGIN_PROPERTY = "origin";
	public static final String EXTENT_PROPERTY = "extent";
	
	private boolean fieldValid = true;
	private java.lang.String fieldWarningMessage = "";

/**
 * This method was created in VisualAge.
 * @param name java.lang.String
 */
public GeometrySpec(Version aVersion, int aDimension) {
	addVetoableChangeListener(this);
	addPropertyChangeListener(this);
	this.dimension = aDimension;
	if (dimension==0){
		try {
			setSubVolumes(new SubVolume[] { new CompartmentSubVolume(null,0) });
		}catch (PropertyVetoException e){
			e.printStackTrace(System.out);
			System.out.println("<<<<<<<<<PropertyVetoException in Geometry(Version,int=0): this should never happen>>>>>>>>>>>");
		}
	}
}


/**
 * This method was created in VisualAge.
 * @param name java.lang.String
 */
public GeometrySpec(Version aVersion, VCImage aVCImage) {
	addVetoableChangeListener(this);
	addPropertyChangeListener(this);
	try {
		setImage(aVCImage);
	}catch (PropertyVetoException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}


/**
 * This method was created in VisualAge.
 * @param name java.lang.String
 */
public GeometrySpec(GeometrySpec geometrySpec){
	addVetoableChangeListener(this);
	addPropertyChangeListener(this);
	if(geometrySpec.vcImage != null){
		try {
			this.vcImage = new VCImageUncompressed(geometrySpec.vcImage);
		} catch (ImageException e) {
			e.printStackTrace();
			throw new RuntimeException(e.getMessage(), e);
		}
	}
	this.dimension = geometrySpec.dimension;
	try {
		SubVolume[] newSubvolumes = new SubVolume[geometrySpec.fieldSubVolumes.length];
		for (int i = 0; i < newSubvolumes.length; i++) {
			if(geometrySpec.fieldSubVolumes[i] instanceof ImageSubVolume){
				ImageSubVolume oldImagesuImageSubVolume = (ImageSubVolume)(geometrySpec.fieldSubVolumes[i]);
				newSubvolumes[i] = new ImageSubVolume(oldImagesuImageSubVolume);
				VCPixelClass newVCPixelClass = this.vcImage.getPixelClassFromName(oldImagesuImageSubVolume.getPixelClass().getPixelClassName());
				((ImageSubVolume)newSubvolumes[i]).setPixelClass(newVCPixelClass);
			}else if(geometrySpec.fieldSubVolumes[i] instanceof AnalyticSubVolume){
				newSubvolumes[i] = new AnalyticSubVolume((AnalyticSubVolume)(geometrySpec.fieldSubVolumes[i]));
			}else if(geometrySpec.fieldSubVolumes[i] instanceof CompartmentSubVolume){
				newSubvolumes[i] = new CompartmentSubVolume(geometrySpec.fieldSubVolumes[i].getKey(), geometrySpec.fieldSubVolumes[i].getHandle());
			}else{
				throw new RuntimeException("Unknown SubVolume "+geometrySpec.fieldSubVolumes[i]);
			}
		}
		setSubVolumes(newSubvolumes);
	}catch (PropertyVetoException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
	//this.curveTypeList = (Vector)geometry.curveTypeList.clone();
	this.extent = geometrySpec.getExtent(); // Extent is immutable
	this.origin = geometrySpec.getOrigin(); // Origin is immutable
}

/**
 * This method was created in VisualAge.
 * @param name java.lang.String
 */
public GeometrySpec(String aName, int aDimension) {
	addVetoableChangeListener(this);
	addPropertyChangeListener(this);
	this.dimension = aDimension;
	if (dimension==0){
		try {
			setSubVolumes(new SubVolume[] { new CompartmentSubVolume(null,0) });
		}catch (PropertyVetoException e){
			e.printStackTrace(System.out);
			System.out.println("<<<<<<<<<PropertyVetoException in Geometry(String,int=0): this should never happen>>>>>>>>>>>");
		}
	}
}


/**
 * This method was created in VisualAge.
 * @param name java.lang.String
 */
public GeometrySpec(String aName, VCImage aVCImage) {
	addVetoableChangeListener(this);
	addPropertyChangeListener(this);
	try {
		setImage(aVCImage);
	}catch (PropertyVetoException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}


/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
	PropertyChangeListenerProxyVCell.addProxyListener(getPropertyChange(), listener);
}


public void addSubVolume(AnalyticSubVolume subVolume) throws PropertyVetoException {
	addSubVolume(subVolume, false);
}
/**
 * This method was created in VisualAge.
 * @param subVolume cbit.vcell.geometry.SubVolume
 */
public void addSubVolume(AnalyticSubVolume subVolume,boolean bFront) throws PropertyVetoException {

	if (getSubVolumeIndex(subVolume) != -1){
		throw new IllegalArgumentException("subdomain "+subVolume+" cannot be added, already exists");
	}

	//
	// add after last analytic subvolume (but before imageSubVolumes)
	//
	int firstImageIndex = -1;
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (fieldSubVolumes[i] instanceof ImageSubVolume){
			firstImageIndex = i;
			break;
		}
	}
	
	SubVolume newArray[] = new SubVolume[fieldSubVolumes.length+1];
	
	if (firstImageIndex == -1){
		//
		// no image subvolumes
		//
		if(bFront){
			newArray[0] = subVolume;
			if (fieldSubVolumes.length>0){
				System.arraycopy(fieldSubVolumes,0,newArray,1,fieldSubVolumes.length);
			}
		}else{
			//add to end of analytics
			// copy first N elements
			if (fieldSubVolumes.length>0){
				System.arraycopy(fieldSubVolumes,0,newArray,0,fieldSubVolumes.length);
			}
			// add new element to end
			newArray[fieldSubVolumes.length] = subVolume;
		}
		
	}else{
	//
	// first imageSubVolume at index 'firstImageIndex'
	// insert subVolume at this index (before first ImageSubVolume) 
	// and push all of the imageSubVolumes back
	//
		int newIndex = 0;
		for (int i=0;i<fieldSubVolumes.length;i++){
			if(bFront){
				if (i == 0){
					newArray[newIndex++] = subVolume;
				}				
			}else{
				if (i == firstImageIndex){
					newArray[newIndex++] = subVolume;
				}				
			}
			newArray[newIndex++] = fieldSubVolumes[i];
		}
	}	

	subVolume.setHandle(getFreeSubVolumeHandle());
	setSubVolumes(newArray);	
		
/*
	if (!subVolumeList.contains(subVolume)){
		for (int i=0;i<subVolumeList.size();i++){
			SubVolume sv = (SubVolume)subVolumeList.elementAt(i);
			if (sv instanceof ImageSubVolume){
				if (subVolume.getHandle()>=0){
					throw new RuntimeException("subVolume already has handle set");
				}
				subVolume.setHandle(getFreeSubVolumeHandle());
				insertSubVolumeAt0(subVolume,i);
				setChanged();
				notifyObservers(subVolume);
				return;
			}
		}
		subVolume.setHandle(getFreeSubVolumeHandle());
		addSubVolume0(subVolume);
		setChanged();
		notifyObservers(subVolume);
	}
*/
}


/**
 * The addVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void addVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().addVetoableChangeListener(listener);
}


/**
 * This method was created in VisualAge.
 * @param subVolume cbit.vcell.geometry.SubVolume
 */
public void bringForward(AnalyticSubVolume subVolume) throws PropertyVetoException {

	//
	// copy existing array
	//
	SubVolume newArray[] = (SubVolume[])fieldSubVolumes.clone();
	
	//
	// find index of subVolume in newArray
	//
	int index = -1;
	for (int i=0;i<newArray.length;i++){
		if (newArray[i] == subVolume){
			index = i;
		}
	}

	if (index == -1){
		throw new IllegalArgumentException("subdomain "+subVolume+" not found");
	}

	//
	// if not already the first AnalyticSubVolume, then swap with neighbor at index-1
	//
	if ((index > 0) && (newArray[index-1] instanceof AnalyticSubVolume)){
		AnalyticSubVolume tempSubVolume = (AnalyticSubVolume)newArray[index-1];
		newArray[index-1] = subVolume;
		newArray[index] = tempSubVolume;
	
		setSubVolumes(newArray);
	}

	
/*
	int index = subVolumeList.indexOf(subVolume);
	if (index>0){
		AnalyticSubVolume prevSubVolume = (AnalyticSubVolume)subVolumeList.elementAt(index-1);
		subVolumeList.setElementAt(subVolume,index-1);
		subVolumeList.setElementAt(prevSubVolume,index);
		setChanged();
		notifyObservers();
	}
*/
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param object java.lang.Object
 */
public boolean compareEqual(Matchable object) {
	if (object == null || !(object instanceof GeometrySpec)){
		return false;
	}
	GeometrySpec geometrySpec = (GeometrySpec)object;
	
	if (dimension != geometrySpec.dimension){
		return false;
	}
	if (!org.vcell.util.Compare.isEqual(getExtent(), geometrySpec.getExtent())){
		return false;
	}

	if (!org.vcell.util.Compare.isEqual(getOrigin(), geometrySpec.getOrigin())){
		return false;
	}
	
	//
	// if only one is null, bad
	//
	if (!Compare.isEqualOrNull(vcImage,geometrySpec.vcImage)){
		return false;
	}

	if (fieldSubVolumes.length != geometrySpec.fieldSubVolumes.length){
		return false;
	}

	for (int i=0;i<fieldSubVolumes.length;i++){
		if (!fieldSubVolumes[i].compareEqual(geometrySpec.fieldSubVolumes[i])){
			return false;
		}
	}
	//
	// FilamentGroup
	//
	if(!org.vcell.util.Compare.isEqual(fieldFilamentGroup,geometrySpec.fieldFilamentGroup)){
		return false;
	}
	return true;
}


/**
 * This method was created in VisualAge.
 * @return cbit.image.VCImage
 */
public VCImage createSampledImage(ISize sampleSize) throws GeometryException, ImageException, ExpressionException {

	VCellThreadChecker.checkCpuIntensiveInvocation();
	
	byte handles[] = new byte[sampleSize.getX()*sampleSize.getY()*sampleSize.getZ()];
	for (int i=0;i<handles.length;i++){
		handles[i] = -1;
	}
	//
	// compartmental
	//
	if (dimension==0){
		handles[0] = 0;
	}
	
	//
	// if image exists, preload with pixels (translated into handles)
	//
	if (vcImage!=null){
		//
		// make lookup table of pixel values ----> handles
		//
		byte handleLookupTable[] = new byte[256];
		for (int i=0;i<fieldSubVolumes.length;i++){
			SubVolume sv = fieldSubVolumes[i];
			if (sv instanceof ImageSubVolume){
				ImageSubVolume isv = (ImageSubVolume)sv;
				handleLookupTable[isv.getPixelValue()] = (byte)isv.getHandle();
			}
		}
		
		byte vciPixels[] = vcImage.getPixels();
		if (vcImage.getNumX()==sampleSize.getX() && vcImage.getNumY()==sampleSize.getY() && vcImage.getNumZ()==sampleSize.getZ()){
			//
			// image and sample same size, just translate pixels to handles
			//
			for (int j=0;j<vciPixels.length;j++){
				handles[j] = handleLookupTable[0xff&(int)vciPixels[j]];
			}
		}else{
			//
			// image and sample same size, just translate pixels to handles
			//
			double deltaX = (sampleSize.getX()>1)?(getExtent().getX()/(sampleSize.getX()-1)):0;
			double deltaY = (sampleSize.getY()>1)?(getExtent().getY()/(sampleSize.getY()-1)):0;
			double deltaZ = (sampleSize.getZ()>1)?(getExtent().getZ()/(sampleSize.getZ()-1)):0;
			double ox = getOrigin().getX();
			double oy = getOrigin().getY();
			double oz = getOrigin().getZ();
			int handleIndex = 0;
			for (int k = 0; k < sampleSize.getZ(); k++){
				double coordZ = oz + deltaZ*k;
				for (int j = 0; j < sampleSize.getY(); j++){
					double coordY = oy + deltaY*j;
					for (int i = 0; i < sampleSize.getX(); i++){
						double coordX = ox + deltaX*i;
						int imageIndex = getImageIndex(coordX,coordY,coordZ);
						handles[handleIndex++] = handleLookupTable[0xff&(int)vciPixels[imageIndex]];
					}
				}
			}
		}
	}
	
	//
	// go through AnalyticSubVolumes to overlay over ImageSubVolumes
	//
	int displayIndex = 0;
	//double deltaX = (sampleSize.getX()>1)?(getExtent().getX()/(sampleSize.getX()-1)):0;
	//double deltaY = (sampleSize.getY()>1)?(getExtent().getY()/(sampleSize.getY()-1)):0;
	//double deltaZ = (sampleSize.getZ()>1)?(getExtent().getZ()/(sampleSize.getZ()-1)):0;
	double ox = getOrigin().getX();
	double oy = getOrigin().getY();
	double oz = getOrigin().getZ();
	int numX = sampleSize.getX();
	int numY = sampleSize.getY();
	int numZ = sampleSize.getZ();
	
	//
	// rebind x,y,z,t and set Index values
	//
	Enumeration enumASV = getAnalyticSubVolumes();
	while (enumASV.hasMoreElements()){
		((AnalyticSubVolume)enumASV.nextElement()).rebind();
	}

	if (getNumAnalyticSubVolumes()>0){
		for (int k=0;k<sampleSize.getZ();k++){
			double unit_z = (numZ>1)?((double)k)/(numZ-1):0.5;
			double coordZ = oz + extent.getZ() * unit_z;
			for (int j=0;j<sampleSize.getY();j++){
				double unit_y = (numY>1)?((double)j)/(numY-1):0.5;
				double coordY = oy + extent.getY() * unit_y;
				for (int i=0;i<sampleSize.getX();i++){
					double unit_x = (numX>1)?((double)i)/(numX-1):0.5;
					double coordX = ox + extent.getX() * unit_x;
					AnalyticSubVolume subVolume = getAnalyticSubVolume(coordX,coordY,coordZ);
					if (subVolume!=null){
						handles[displayIndex] = (byte)subVolume.getHandle();
					}
					displayIndex++;
				}
			}
		}
	}

	return new VCImageUncompressed(null,handles,getExtent(), sampleSize.getX(),sampleSize.getY(),sampleSize.getZ());
}


/**
 * Insert the method's description here.
 * Creation date: (8/8/00 5:17:17 PM)
 * @return boolean
 * @param curve cbit.vcell.geometry.Curve
 */
private boolean curveSatisfyGeometryConstraints(Curve curve) {
	int master = -1;
	for (double i = 0; i < 1.0; i += .01) {
		double x = curve.getX(i); 
		double y = curve.getY(i); 
		double z = curve.getZ(i); 
		int handle = -1; 
		try {
			handle = getSubVolume(x, y, z).getHandle();
		} catch (Throwable e) {
			throw new RuntimeException(e.toString());
		}
		if (i == 0) {
			master = handle;
		}
		if (handle != master) {
			return false; 
		}
	}
	return true;
}


/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}


/**
 * The fireVetoableChange method was generated to support the vetoPropertyChange field.
 */
public void fireVetoableChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) throws java.beans.PropertyVetoException {
	getVetoPropertyChange().fireVetoableChange(propertyName, oldValue, newValue);
}


/**
 * This method was created by a SmartGuide.
 * @return int
 * @param x double
 * @param y double
 */
private AnalyticSubVolume getAnalyticSubVolume(double x, double y, double z) throws GeometryException, ImageException, ExpressionException {
	for (int i=0;i<fieldSubVolumes.length;i++){
		SubVolume subVolume = fieldSubVolumes[i];
		if (subVolume instanceof AnalyticSubVolume){
			if (subVolume.isInside(x,y,z,this)){
				return (AnalyticSubVolume)subVolume;
			}
		}
	}
	return null;
}

/**
 * This method was created by a SmartGuide.
 * @return int[]
 */
public Enumeration getAnalyticSubVolumes() {
	Vector analSubVolList = new Vector();
	for (int i=0;i<fieldSubVolumes.length;i++){
		SubVolume sv = fieldSubVolumes[i];
		if (sv instanceof AnalyticSubVolume){
			analSubVolList.addElement(sv);
		}
	}
	return analSubVolList.elements();
}


/**
 * This method was created in VisualAge.
 * @return cbit.image.VCImage
 */
public ISize getDefaultSampledImageSize() {

	//
	// determine size of sampled image
	//
	ISize sampleSize = null;
	if (getImage()!=null){
		
		// if image exists, then use that as the sampled image size
		
		sampleSize = new ISize(getImage().getNumX(),getImage().getNumY(),getImage().getNumZ());
	}else{
		//
		// if no image, then use that as the sampled image size
		//
		int dim = getDimension();
		switch (dim){
			case 0:{
				sampleSize = new ISize(1,1,1);
				break;
			}
			case 1:{
				sampleSize = new ISize(50,1,1);
				break;
			}
			case 2:{
				//
				// choose so that the aspect ratio is correct and about 3000 total pixels
				//
				//    so x * y = Max2D    and x/y = extentX/extentY
				//
				double max2D = 101*101;
				double xyRatio = getExtent().getX()/getExtent().getY();
				double y = Math.sqrt(max2D/xyRatio);
				double x = max2D/y;
				sampleSize = new ISize((int)x,(int)y,1);
				break;
			}
			case 3:{
				//
				// choose so that the aspect ratio is correct and about 15000 total pixels
				//
				//       x * y * z = 15000    
				//           y / x = extentY/extentX = yxRatio
				//           z / x = extentZ/extentX = zxRatio
				//
				//    thus  x = pow(1500/(yxRatio*zxRatio),1/3)
				//          y = yxRatio * x;
				//          z = zxRatio * x;
				//
				double max3D = 101*101*101;
				double yxRatio = getExtent().getY()/getExtent().getX();
				double zxRatio = getExtent().getZ()/getExtent().getX();
				double x = Math.pow(max3D/(yxRatio*zxRatio),1.0/3.0);
				double y = yxRatio * x;
				double z = zxRatio * x;
				sampleSize = new ISize((int)x,(int)y,(int)z);
				break;
			}
		}
	}

	return sampleSize;
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getDimension() {
	return dimension;
}


/**
 * This method was created by a SmartGuide.
 * @return double
 */
public Extent getExtent() {
	if (vcImage!=null){
		return vcImage.getExtent();
	}else{
		return extent;
	}
}	


/**
 * Gets the filamentGroup property (cbit.vcell.geometry.FilamentGroup) value.
 * @return The filamentGroup property value.
 * @see #setFilamentGroup
 */
public FilamentGroup getFilamentGroup() {
	if(getDimension() == 0){
		throw new RuntimeException("FilamentGroup undefined for 0 dimesnion geometry");
	}
	return fieldFilamentGroup;
}


/**
 * This method was created in VisualAge.
 * @return java.lang.String
 */
private int getFreeSubVolumeHandle() {
	int count=0;
	while (getSubVolume(count)!=null){
		count++;
	}
	return count;
}


/**
 * This method was created in VisualAge.
 * @return java.lang.String
 */
public String getFreeSubVolumeName() {
	String featureName = "subdomain";
	int count=0;
	while (getSubVolume(featureName+count)!=null){
		count++;
	}
	return featureName+count;
}


/**
 * This method was created in VisualAge.
 * @return java.awt.image.IndexColorModel
 */
public static final java.awt.image.IndexColorModel getHandleColorMap() {

	int[] contrastColors = cbit.image.DisplayAdapterService.createContrastColorModel();

	byte red[] = new byte[contrastColors.length];
	byte green[] = new byte[contrastColors.length];
	byte blue[] = new byte[contrastColors.length];

	for (int i=0;i<contrastColors.length;i++){
		java.awt.Color color = new java.awt.Color(contrastColors[i]);
		red[i] = (byte)color.getRed();
		green[i] = (byte)color.getGreen();
		blue[i] = (byte)color.getBlue();
	}

	return new java.awt.image.IndexColorModel(8,contrastColors.length,red,green,blue);
}


/**
 * This method was created in VisualAge.
 * @return cbit.image.FileImage
 */
public VCImage getImage() {
	return vcImage;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param x double
 * @param y double
 * @param z double
 */
int getImageIndex(double x, double y, double z) throws GeometryException {
	if (vcImage==null){
		throw new GeometryException("image not defined in geometry");
	}
	int i = (int)(((vcImage.getNumX()-1)*(x-getOrigin().getX())/getExtent().getX())+0.5);
	int j = (int)(((vcImage.getNumY()-1)*(y-getOrigin().getY())/getExtent().getY())+0.5);
	int k = (int)(((vcImage.getNumZ()-1)*(z-getOrigin().getZ())/getExtent().getZ())+0.5);
	int index = i + j*vcImage.getNumX() + k*vcImage.getNumX()*vcImage.getNumY();
	return index;
}


/**
 * This method was created in VisualAge.
 * @param name java.lang.String
 * @param pixelValue int
 */
public ImageSubVolume getImageSubVolumeFromPixelValue(int pixelValue) {
	if (getImage() == null){
		throw new RuntimeException("Geometry doesn't have an image");
	}
	for (int i=0;i<fieldSubVolumes.length;i++){
		SubVolume subVolume = fieldSubVolumes[i];
		if (subVolume instanceof ImageSubVolume){
			ImageSubVolume isv = (ImageSubVolume)subVolume;
			if (isv.getPixelValue()==pixelValue){
				return isv;
			}
		}
	}
	return null;
}


/**
 * This method was created in VisualAge.
 * @return int
 */
public int getNumAnalyticSubVolumes() {
	int count = 0;
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (fieldSubVolumes[i] instanceof AnalyticSubVolume){
			count++;
		}
	}
	return count;
}


/**
 * This method was created in VisualAge.
 * @return int
 */
public int getNumSubVolumes() {
	return fieldSubVolumes.length;
}


/**
 * This method was created by a SmartGuide.
 * @return double
 */
public Origin getOrigin() {
	return origin;
}


/**
 * Accessor for the propertyChange field.
 */
protected java.beans.PropertyChangeSupport getPropertyChange() {
	if (propertyChange == null) {
		propertyChange = new java.beans.PropertyChangeSupport(this);
	};
	return propertyChange;
}


/**
 * This method was created in VisualAge.
 * @return cbit.image.VCImage
 */
public VCImage getSampledImage() throws GeometryException, ImageException, ExpressionException {

	if (sampledImage == null){
		ISize sampleSize = getDefaultSampledImageSize();
		VCImage oldImage = sampledImage;
		sampledImage = createSampledImage(sampleSize);
		//firePropertyChange("sampledImage",oldImage,sampledImage);
		try {
			verifyCompleteSampling(sampledImage);
			setWarningMessage("");
			setValid(true);
		}catch (ImageException e){
			setWarningMessage(e.getMessage());
			setValid(false);
		}
	}
	return sampledImage;
}


/**
 * This method was created by a SmartGuide.
 * @return int
 * @param x double
 * @param y double
 */
public SubVolume getSubVolume(double x, double y, double z) throws GeometryException, ImageException, ExpressionException {
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (fieldSubVolumes[i].isInside(x,y,z,this)){
			return fieldSubVolumes[i];
		}
	}
	if (vcImage!=null){
		int index = getImageIndex(x,y,z);
		//
		// get pixel value
		//
		int pixel = 0xff&(int)getUncompressedPixels()[index];
		System.out.println("there was no subVolume defined for pixel value <"+pixel+"> at imageIndex("+index+"), coord=("+x+","+y+","+z+")");
	}
	return null;	
}

/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.SubVolume
 * @param name java.lang.String
 */
public SubVolume getSubVolume(int handle) {
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (fieldSubVolumes[i].getHandle() == handle){
			return fieldSubVolumes[i];
		}
	}
	return null;
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.SubVolume
 * @param name java.lang.String
 */
public SubVolume getSubVolume(String name) {
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (fieldSubVolumes[i].getName().equals(name)){
			return fieldSubVolumes[i];
		}
	}
	return null;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param subVolume cbit.vcell.geometry.SubVolume
 */
public int getSubVolumeIndex(SubVolume subVolume) {
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (fieldSubVolumes[i] == subVolume){
			return i;
		}
	}
	return -1;
}


/**
 * Gets the subVolumes property (cbit.vcell.geometry.SubVolume[]) value.
 * @return The subVolumes property value.
 * @see #setSubVolumes
 */
public cbit.vcell.geometry.SubVolume[] getSubVolumes() {
	return fieldSubVolumes;
}


/**
 * Gets the subVolumes index property (cbit.vcell.geometry.SubVolume) value.
 * @return The subVolumes property value.
 * @param index The index value into the property array.
 * @see #setSubVolumes
 */
public SubVolume getSubVolumes(int index) {
	return getSubVolumes()[index];
}


/**
 * This method was created in VisualAge.
 * @return byte[]
 */
byte[] getUncompressedPixels() throws cbit.image.ImageException {
	if (uncompressedPixels==null){
		if (getImage()!=null){
			uncompressedPixels = getImage().getPixels();
		}
	}
	return uncompressedPixels;
}


/**
 * Gets the valid property (boolean) value.
 * @return The valid property value.
 * @see #setValid
 */
public boolean getValid() {
	return fieldValid;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String getVCML() {
	StringBuffer buffer = new StringBuffer();
	buffer.append("\t" + VCML.Dimension+"   " + getDimension() + "\n");
	buffer.append("\t" + VCML.Size+"        " + getExtent().getX() + "  "+getExtent().getY() + "  "+getExtent().getZ() + "\n");
	buffer.append("\t" + VCML.Origin+"      " + getOrigin().getX() + "  "+getOrigin().getY() + "  "+getOrigin().getZ() + "\n");
	if (vcImage != null && vcImage.getVersion() != null){
		buffer.append("\t" + VCML.Image + "\t" + vcImage.getVersion().getVersionKey() + "\n");
	} else if (vcImage != null){
		buffer.append("\t" + VCML.Image + "\t <null image key>\n");
	}
	for (int i = 0; i < fieldSubVolumes.length; i++){
		buffer.append(fieldSubVolumes[i].getVCML());
	}
	return(buffer.toString());		
}


/**
 * Accessor for the vetoPropertyChange field.
 */
protected java.beans.VetoableChangeSupport getVetoPropertyChange() {
	if (vetoPropertyChange == null) {
		vetoPropertyChange = new java.beans.VetoableChangeSupport(this);
	};
	return vetoPropertyChange;
}


/**
 * Gets the warningMessage property (java.lang.String) value.
 * @return The warningMessage property value.
 * @see #setWarningMessage
 */
public java.lang.String getWarningMessage() {
	return fieldWarningMessage;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 */
public boolean hasImage() {
	return (getImage() != null);
}


/**
 * Insert the method's description here.
 * Creation date: (8/15/00 12:33:13 PM)
 * @return boolean
 * @param filamentName java.lang.String
 * @param curve cbit.vcell.geometry.Curve
 */
public boolean isCurveValid(Curve curve) {
	if (!curve.isValid()) {
		return false;
	}
	if (!curve.isInside(getOrigin(), getExtent(), new Coordinate(0, 0, 0))) {
		return false;
	}
	if (!curveSatisfyGeometryConstraints(curve)) {
		return false;
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (6/3/00 9:58:08 AM)
 * @param event java.beans.PropertyChangeEvent
 */
public void propertyChange(java.beans.PropertyChangeEvent event) {
	if (event.getSource() == this && event.getPropertyName().equals("subVolumes")) {
		SubVolume oldSubVolumes[] = (SubVolume[])event.getOldValue();
		SubVolume newSubVolumes[] = (SubVolume[])event.getNewValue();
		if (!Compare.isEqualOrdered(oldSubVolumes,newSubVolumes)){  // ignore if just a change of instances
			VCImage oldSampledImage = sampledImage;
			//
			// RATIONALE:
			//
			// The "sampledImage" is a pull-model (creates "only as necessary").
			// Creating the "sampledImage" is expensive, (so only want to
			// create if someone is listening and want the image (calls the get()).
			//
			// invalidate the present sampledImage and send a propertyChangeEvent to prompt
			// the user to check for a new sampledImage (which can create one on the fly)
			//
			sampledImage = null;
			firePropertyChange("sampledImage",oldSampledImage,sampledImage);
		}
	}
	if (event.getSource() == this && (event.getPropertyName().equals("extent") || event.getPropertyName().equals("origin"))){
		Matchable oldExtentOrOrigin = (Matchable)event.getOldValue();
		Matchable newExtentOrOrigin = (Matchable)event.getNewValue();
		if (!Compare.isEqual(oldExtentOrOrigin,newExtentOrOrigin)){
			VCImage oldSampledImage = sampledImage;
			//
			// RATIONALE:
			//
			// The "sampledImage" is a pull-model (creates "only as necessary").
			// Creating the "sampledImage" is expensive, (so only want to
			// create if someone is listening and want the image (calls the get()).
			//
			// invalidate the present sampledImage and send a propertyChangeEvent to prompt
			// the user to check for a new sampledImage (which can create one on the fly)
			//
			sampledImage = null;
			firePropertyChange("sampledImage",oldSampledImage,sampledImage);
		}
	}
	if (event.getSource() instanceof AnalyticSubVolume && event.getPropertyName().equals("expression")) {
		cbit.vcell.parser.Expression oldExpression = (cbit.vcell.parser.Expression)event.getOldValue();
		cbit.vcell.parser.Expression newExpression = (cbit.vcell.parser.Expression)event.getNewValue();
		if (!Compare.isEqual(oldExpression,newExpression)) {
			VCImage oldSampledImage = sampledImage;
			//
			// RATIONALE:
			//
			// The "sampledImage" is a pull-model (creates "only as necessary").
			// Creating the "sampledImage" is expensive, (so only want to
			// create if someone is listening and want the image (calls the get()).
			//
			// invalidate the present sampledImage and send a propertyChangeEvent to prompt
			// the user to check for a new sampledImage (which can create one on the fly)
			//
			sampledImage = null;
			firePropertyChange("sampledImage",oldSampledImage,sampledImage);
		}
	}
}


/**
 * This method was created in VisualAge.
 */
private void refreshAllImageSubVolumes() {
	
	if (vcImage==null) return;

	if (getDimension()==0) return;
	
}


/**
 * This method was created in VisualAge.
 */
public void refreshDependencies() {
	//
	// Geometry Listens to itself
	//
	removePropertyChangeListener(this);
	removeVetoableChangeListener(this);
	addPropertyChangeListener(this);
	addVetoableChangeListener(this);

	//
	// Geometry Listens to it's subVolumes
	//
	for (int i=0;i<fieldSubVolumes.length;i++){
		SubVolume sv = fieldSubVolumes[i];
		sv.removePropertyChangeListener(this);
		sv.removeVetoableChangeListener(this);
		sv.addPropertyChangeListener(this);
		sv.addVetoableChangeListener(this);
		if (sv instanceof AnalyticSubVolume){
			try {
				((AnalyticSubVolume)sv).rebind();
			}catch (ExpressionException e){
				e.printStackTrace(System.out);
			}
		}
	}
}


/**
 * This method was created in VisualAge.
 * @param subVolume cbit.vcell.geometry.SubVolume
 */
public void removeAnalyticSubVolume(AnalyticSubVolume subVolume) throws PropertyVetoException {

	
	int subVolumeIndex = getSubVolumeIndex(subVolume);
	if (subVolumeIndex == -1){
		throw new IllegalArgumentException("subdomain "+subVolume+" cannot be removed, it doesn't belong to this Geometry");
	}

	SubVolume newArray[] = new SubVolume[fieldSubVolumes.length-1];
	
	int newIndex = 0;
	for (int i=0;i<fieldSubVolumes.length;i++){
		if (i != subVolumeIndex){
			newArray[newIndex++] = fieldSubVolumes[i];
		}
	}

	setSubVolumes(newArray);
}


/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
	PropertyChangeListenerProxyVCell.removeProxyListener(getPropertyChange(),listener);
}


/**
 * The removeVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void removeVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().removeVetoableChangeListener(listener);
}


/**
 * This method was created in VisualAge.
 * @param subVolume cbit.vcell.geometry.SubVolume
 */
public void sendBackward(AnalyticSubVolume subVolume) throws PropertyVetoException {

	//
	// copy existing array
	//
	SubVolume newArray[] = (SubVolume[])fieldSubVolumes.clone();
	
	//
	// find index of subVolume in newArray
	//
	int index = -1;
	for (int i=0;i<newArray.length;i++){
		if (newArray[i] == subVolume){
			index = i;
		}
	}

	if (index == -1){
		throw new IllegalArgumentException("subdomain "+subVolume+" not found");
	}

	//
	// if not already the last AnalyticSubVolume, then swap with neighbor at index+1
	//
	if ((index < (newArray.length-1)) && (newArray[index+1] instanceof AnalyticSubVolume)){
		AnalyticSubVolume tempSubVolume = (AnalyticSubVolume)newArray[index+1];
		newArray[index+1] = subVolume;
		newArray[index] = tempSubVolume;

		setSubVolumes(newArray);
	}
	
/*
	int index = subVolumeList.indexOf(subVolume);
	if (index<subVolumeList.size()-1){
		AnalyticSubVolume nextSubVolume = (AnalyticSubVolume)subVolumeList.elementAt(index+1);
		subVolumeList.setElementAt(subVolume,index+1);
		subVolumeList.setElementAt(nextSubVolume,index);
		setChanged();
		notifyObservers();
	}
*/
}


/**
 * This method was created by a SmartGuide.
 * @param x double
 * @param y double
 */
public void setExtent(Extent aExtent) throws PropertyVetoException {
	if (!this.extent.compareEqual(aExtent)){
		Extent oldExtent = this.extent;
		fireVetoableChange("extent",oldExtent,extent);
		
		//
		// if image exists, then synchronize the image sizes
		//
		if (vcImage != null){
			vcImage.setExtent(aExtent);
		}
		
		this.extent = aExtent;

		firePropertyChange("extent",oldExtent,getExtent());
	}

	return;
}


/**
 * This method was created in VisualAge.
 * @param image cbit.image.FileImage
 */
public void setImage(VCImage image) throws PropertyVetoException {
	
	VCImage oldImage = this.vcImage;
	fireVetoableChange("image",oldImage,image);
	//
	//This used to be a PRIVATE method.  It was made public to allow the DbGeomDriver to save Images on the fly.
	//
	
	if (this.vcImage != image){
		uncompressedPixels = null;
		if (image!=null){
			setExtent(image.getExtent());
			if (image.getNumY()==1 && image.getNumZ()==1){
				dimension = 1;
			}else if (image.getNumZ()==1){
				dimension = 2;
			}else{
				dimension = 3;
			}
		}
		this.vcImage = image;

		SubVolume newImageSubVolumes[] = new SubVolume[vcImage.getNumPixelClasses()];
		int svCount = 0;
		cbit.image.VCPixelClass vcPixelClasses[] = vcImage.getPixelClasses();
		for (int i = 0; i < vcPixelClasses.length; i++){
			ImageSubVolume isv = new ImageSubVolume(null,vcPixelClasses[i],svCount);
			//
			// if this is just refreshing the list of subvolumes, make sure previous subvolume names and handles are preserved.
			//
			if (getSubVolumes()!=null && getSubVolumes().length>i && getSubVolumes().length == vcPixelClasses.length){
				isv.setName(getSubVolumes()[i].getName());
				isv.setHandle(getSubVolumes()[i].getHandle());
			}else{
				isv.setHandle(svCount);
			}
			newImageSubVolumes[svCount++] = isv;
		}
		//
		//merge existing analytic subvolumes with the new image subvolumes
		//
		SubVolume[] allSubVolumes = new SubVolume[newImageSubVolumes.length+getNumAnalyticSubVolumes()];
		Enumeration<AnalyticSubVolume> analyticSubVolumeEnum = getAnalyticSubVolumes();
		svCount = 0;
		TreeSet<Integer> analyticSubVolHandlesTreeSet = new TreeSet<Integer>();
		while(analyticSubVolumeEnum.hasMoreElements()){
			allSubVolumes[svCount] = analyticSubVolumeEnum.nextElement();
			analyticSubVolHandlesTreeSet.add(allSubVolumes[svCount].getHandle());
			svCount++;
		}
		for (int i = 0; i < newImageSubVolumes.length; i++) {
			allSubVolumes[svCount] = newImageSubVolumes[i];
			if(analyticSubVolHandlesTreeSet.contains(allSubVolumes[svCount].getHandle())){
				throw new RuntimeException("Duplicate Subvolume handles found while setting new Image");
			}
			svCount++;
		}
		
		setSubVolumes(allSubVolumes);
	}
	firePropertyChange("image",oldImage,image);
}


/**
 * This method was created by a SmartGuide.
 * @param x double
 * @param y double
 */
public void setOrigin(Origin aOrigin) {
	if (!this.origin.compareEqual(aOrigin)){
		Origin oldOrigin = this.origin;
		this.origin = aOrigin;
		firePropertyChange("origin",oldOrigin,origin);
	}
	return;
}


/**
 * Sets the subVolumes property (cbit.vcell.geometry.SubVolume[]) value.
 * @param subVolumes The new value for the property.
 * @exception java.beans.PropertyVetoException The exception description.
 * @see #getSubVolumes
 */
public void setSubVolumes(cbit.vcell.geometry.SubVolume[] subVolumes) throws java.beans.PropertyVetoException {
	cbit.vcell.geometry.SubVolume[] oldSubVolumes = fieldSubVolumes;
	fireVetoableChange("subVolumes", oldSubVolumes, subVolumes);
	fieldSubVolumes = subVolumes;
	for (int i=0;i<oldSubVolumes.length;i++){
		oldSubVolumes[i].removePropertyChangeListener(this);
		oldSubVolumes[i].removeVetoableChangeListener(this);
	}
	for (int i=0;i<subVolumes.length;i++){
		fieldSubVolumes[i].addPropertyChangeListener(this);
		fieldSubVolumes[i].addVetoableChangeListener(this);
	}
	firePropertyChange("subVolumes", oldSubVolumes, subVolumes);
}


/**
 * Sets the valid property (boolean) value.
 * @param valid The new value for the property.
 * @see #getValid
 */
private void setValid(boolean valid) {
	boolean oldValue = fieldValid;
	fieldValid = valid;
	firePropertyChange("valid", new Boolean(oldValue), new Boolean(valid));
}


/**
 * Sets the warningMessage property (java.lang.String) value.
 * @param warningMessage The new value for the property.
 * @see #getWarningMessage
 */
private void setWarningMessage(java.lang.String warningMessage) {
	String oldValue = fieldWarningMessage;
	fieldWarningMessage = warningMessage;
	firePropertyChange("warningMessage", oldValue, warningMessage);
}


/**
 * Insert the method's description here.
 * Creation date: (6/5/00 10:13:05 PM)
 * @exception cbit.vcell.geometry.GeometryException The exception description.
 */
public void verifyCompleteSampling(VCImage argSampledImage) throws ImageException {
	
	boolean bHasError = false;
	String errorMessage = "";

	//
	// make sure that each sample was assigned to a SubVolume
	//
	int count = 0;
	byte samples[] = argSampledImage.getPixels();
	for (int i = 0; i < samples.length; i++){
		if (samples[i] == -1){
			count++;
		}
	}
	if (count>0){
		bHasError = true;
		errorMessage = "Invalid Geometry - "+count+" of "+samples.length+" samples of geometry domain didn't map to any SubVolume";
	}
	//
	// make sure that each subvolume is resolved in the geometry
	//
	Vector missingSubVolumeList = new Vector();
	SubVolume subVolumes[] = getSubVolumes();
	for (int i=0;i<subVolumes.length;i++){
		if (argSampledImage.getPixelClassFromPixelValue(subVolumes[i].getHandle())==null){
			missingSubVolumeList.add(subVolumes[i]);
		}
	}
	if (missingSubVolumeList.size()>0){
		if (bHasError){
			errorMessage += "\n";
		}else{
			errorMessage = "Invalid Geometry - ";
		}
		errorMessage += "Subdomain(s)";
		bHasError = true;
		for (int i = 0; i < missingSubVolumeList.size(); i++){
			errorMessage += " '" + ((SubVolume)missingSubVolumeList.elementAt(i)).getName()+"'";
		}
		errorMessage += " not resolved in geometry domain";
	}	

	if (bHasError){
		throw new ImageException(errorMessage);
	}
}


/**
 * Insert the method's description here.
 * Creation date: (6/3/00 9:58:08 AM)
 * @param event java.beans.PropertyChangeEvent
 */
public void vetoableChange(java.beans.PropertyChangeEvent event) throws PropertyVetoException {

	if (event.getSource() == this && event.getPropertyName().equals("image")){
		if (event.getNewValue() != null){
			VCImage newVCImage = (VCImage)event.getNewValue();
			if (newVCImage.getNumXYZ() > IMAGE_SIZE_LIMIT){
				//throw new PropertyVetoException("image size "+newVCImage.getNumXYZ()+" pixels exceeded limit of "+IMAGE_SIZE_LIMIT,event);
				System.out.println("WARNING: image size "+newVCImage.getNumXYZ()+" pixels exceeded limit of "+IMAGE_SIZE_LIMIT);				
			}
		}
	}
	
	if (event.getSource() == this && event.getPropertyName().equals("subVolumes")){
		SubVolume subVolumes[] = (SubVolume[])event.getNewValue();
		

		//
		// add subvolumes 
		// (handles must be unique and non-negative, and analytic subvolumes must be first in array)
		//
		boolean bFoundImageSubVolume = false;
		for (int i=0;i<subVolumes.length;i++){
			SubVolume sv = subVolumes[i];
			//
			// verify that handles are non-negative
			//
			if (sv.getHandle()<0){
				throw new PropertyVetoException("subdomain handle="+sv.getHandle()+" must be positive",event);
			}
			//
			// verify that handles and names are unique
			//
			for (int j=i+1;j<subVolumes.length;j++){
				if (subVolumes[j].getHandle() == subVolumes[i].getHandle()){
					throw new PropertyVetoException("subdomain handle="+sv.getHandle()+" has already been used in geometry",event);
				}
				if (subVolumes[j].getName().equals(subVolumes[i].getName())){
					throw new PropertyVetoException("subdomain name="+sv.getName()+" has already been used in geometry",event);
				}
			}
			//
			// verify that all analytic subVolumes come first in array
			//
			if (sv instanceof ImageSubVolume){
				bFoundImageSubVolume = true;
			}else if (sv instanceof AnalyticSubVolume){
				if (bFoundImageSubVolume){
					throw new PropertyVetoException("subdomains are out of order, all analytic subdomains must preceed all image subdomains",event);
				}
			}
		}
		
		//
		// check for applicability (regarding dimension)
		//

		//
		// check for applicability (regarding images)
		// image must be set first in constructor
		//
		for (int i=0;i<subVolumes.length;i++){
			if (subVolumes[i] instanceof ImageSubVolume){
				if (vcImage == null){
					throw new PropertyVetoException("adding image subdomain, an image must be set first",event);
				}
			}
		}
		//
		// check for uniqueness of name and handles 
		// check for handle values of (0..N-1)
		//
	}else if (event.getSource() == this && event.getPropertyName().equals("extent")){
		Extent newExtent = (Extent)event.getNewValue();
		if (newExtent==null){
			throw new PropertyVetoException("extent cannot be null",event);
		}
		if (newExtent.getX()<=0 || newExtent.getY()<=0.0 || newExtent.getZ()<=0){
			throw new PropertyVetoException("extent must be positive in X,Y,Z",event);
		}
	}else if (event.getSource() instanceof SubVolume && event.getPropertyName().equals("name")){
		String newName = (String)event.getNewValue();
		if (newName==null || newName.length()<1){
			throw new PropertyVetoException("subdomain name must be at least one character",event);
		}
		//
		// check if name already used
		//
		SubVolume sv = getSubVolume(newName);
		if (sv != null && sv != event.getSource()){
			throw new PropertyVetoException("subdomain name '"+newName+"' is already used",event);
		}
	}
}
	}