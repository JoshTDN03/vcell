package cbit.vcell.simdata;
import cbit.vcell.export.server.*;
import cbit.rmi.event.*;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import cbit.vcell.simdata.gui.SpatialSelection;
import cbit.vcell.simdata.gui.SpatialSelectionVolume;
import cbit.vcell.simdata.gui.SpatialSelectionContour;
import cbit.vcell.simdata.gui.SpatialSelectionMembrane;
import cbit.vcell.parser.*;
import cbit.vcell.geometry.*;
import cbit.vcell.math.*;
import cbit.plot.*;
import java.util.*;
import java.io.*;
import cbit.vcell.server.*;
import cbit.vcell.solvers.CartesianMesh;
/**
 * This interface was generated by a SmartGuide.
 * 
 */
public class DataSetControllerImpl implements SimDataConstants {
	//
	private SessionLog log = null;
	private File rootDirectory =  null;
	private Cachetable cacheTable = null;
	private Vector aDataJobListener = null;
	//
	public static class SpatialStatsInfo {
		public boolean bWeightsValid;
		public double[][] spaceWeight;
		public double[] totalSpace;
	};
	//
	private class MultiFunctionIndexes{
		private FunctionIndexes[] functionIndexesArr;
		private String[] allFuncVarNames = new String[0];
		private int[][] allFuncIndexes = new int[0][];
		private int blockSize;
		private double[][][] valuesOverTime = null;
		private double[][] valuesOverLine = null;
		private SimulationData simData = null;
		private double[] dataSetTimes = null;
		private boolean[] wantsTheseTimes = null;
		public MultiFunctionIndexes(VCDataIdentifier argVcdID, String argVarName, int[] argIndices,boolean[] argWantsTheseTimes)
									throws IOException,DataAccessException,ExpressionException,MathException{
										
			wantsTheseTimes = argWantsTheseTimes;
			dataSetTimes = DataSetControllerImpl.this.getDataSetTimes(argVcdID);
			simData = (SimulationData)getVCData(argVcdID);
			functionIndexesArr = findFunctionIndexes(argVcdID,simData.getFunction(argVarName),argIndices);
			//functionIndexesArr = new FunctionIndexes[argIndices.length];
			//for(int i=0;i<argIndices.length;i+= 1){
				//functionIndexesArr[i] = findFunctionIndexes(argVcdID,simData.getFunction(argVarName),argIndices[i]);
			//}
			blockSize = functionIndexesArr[0].getIndexes().length;
			for(int i=0;i<functionIndexesArr.length;i+= 1){
				FunctionIndexes fi = functionIndexesArr[i];
				String[] tempVN = new String[allFuncVarNames.length + fi.getSimFileVarNames().length];
				System.arraycopy(allFuncVarNames,0,tempVN,0,allFuncVarNames.length);
				System.arraycopy(fi.getSimFileVarNames(),0,tempVN,allFuncVarNames.length,fi.getSimFileVarNames().length);
				int[][] tempInd = new int[allFuncIndexes.length + fi.getIndexes().length][];
				for(int j=0;j<tempInd.length;j+= 1){
					if(j < allFuncIndexes.length){
						tempInd[j] = allFuncIndexes[j];
					}else{
						tempInd[j] = new int[] {fi.getIndexes()[j-allFuncIndexes.length]};
					}
				}
				allFuncIndexes = tempInd;
				allFuncVarNames = tempVN;
			}
		}
		public double evaluateTimeFunction(int timeIndex,int varNameIndex)
								throws ExpressionException,DataAccessException,IOException{
			if(valuesOverTime == null){
				valuesOverTime =
					simData.getSimDataTimeSeries(this.geExpandedSimFileVarNames(),this.getExpandedFunctionIndexes(),wantsTheseTimes);
			}
			double[] argsD = getArgBlock(valuesOverTime[timeIndex],varNameIndex);
			return functionIndexesArr[varNameIndex].evaluateFunction(dataSetTimes[timeIndex],argsD);
		}
		public double evaluateLineFunction(double time,int varNameIndex)
								throws ExpressionException,DataAccessException,IOException{
			if(valuesOverLine == null){
				valuesOverLine =
					simData.getSimDataLineScan(this.geExpandedSimFileVarNames(),this.getExpandedFunctionIndexes(),time);
			}
			double[] argsD = getArgBlock(valuesOverLine,varNameIndex);
			return functionIndexesArr[varNameIndex].evaluateFunction(time,argsD);
		}
		private String[] geExpandedSimFileVarNames(){
			return allFuncVarNames;
		}
		private int[][] getExpandedFunctionIndexes(){
			return allFuncIndexes;
		}
		private double[] getArgBlock(double[][] sourceValues,int index){
			double[] argsD = new double[blockSize];
			for(int k=0;k<blockSize;k+= 1){
				argsD[k] = sourceValues[(blockSize*index)+k][0];
			}
			return argsD;
		}
	};
	//
	private class FunctionIndexes{
		private AnnotatedFunction function;
		private Coordinate xyz;
		private String[] funcVarNames;
		private String[] simFileVarNames;
		private int[] funcIndexes;
		private double[] functionArgs;
		
		public String[] getSimFileVarNames(){
			return simFileVarNames;
		}
		public int[] getIndexes(){
			return funcIndexes;
		}
		public double evaluateFunction(double time,double[] argValues) throws ExpressionException{
			functionArgs[0] = time; // time
			functionArgs[1] = xyz.getX(); // x
			functionArgs[2] = xyz.getY(); // y
			functionArgs[3] = xyz.getZ(); // z
			for(int i=0;i<funcVarNames.length;i+= 1){
				functionArgs[i+4] = argValues[i];
			}
			return function.getSimplifiedExpression().evaluateVector(functionArgs);
		}
		public FunctionIndexes(AnnotatedFunction argAF,Coordinate argXYZ,String[] argVarNames,String[] argSimFileVarNames,int[] argIndexes){
			function = argAF;
			xyz = argXYZ;
			funcVarNames = argVarNames;
			funcIndexes = argIndexes;
			simFileVarNames = argSimFileVarNames;
			functionArgs = new double[argSimFileVarNames.length+4];
			
		}
	};

/**
 * This method was created by a SmartGuide.
 */
public DataSetControllerImpl (SessionLog sessionLog, Cachetable aCacheTable, File rootDir) throws FileNotFoundException {
	this.cacheTable = aCacheTable;
	this.rootDirectory = rootDir;
	if (rootDirectory == null){
		try {
			String usersDir = System.getProperty(PropertyLoader.serverSimDataDirProperty);
			if (!usersDir.endsWith(new String(File.separator))){
				usersDir += File.separator;
			}
			rootDirectory = new File(usersDir);
			if (!rootDirectory.exists() || !rootDirectory.isDirectory()){
				String msg = "DataSetControllerImpl(): users directory "+usersDir+" not found or is not a directory";
				sessionLog.alert(msg);
				throw new FileNotFoundException(msg);
			}
		}catch (Exception e){
			sessionLog.exception(e);
			throw new FileNotFoundException("required System property \""+PropertyLoader.serverSimDataDirProperty+"\" not defined");
		}		
	}
	this.log = sessionLog;
}


/**
 * Add a cbit.vcell.desktop.controls.ExportListener.
 */
public void addDataJobListener(cbit.rmi.event.DataJobListener newListener) {
	if (aDataJobListener == null) {
		aDataJobListener = new java.util.Vector();
	};
	aDataJobListener.addElement(newListener);
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public void addFunction(VCDataIdentifier vcdID, AnnotatedFunction function) throws DataAccessException, ExpressionException {
	try {
		VCData simData = getVCData(vcdID);
		simData.addFunction(function);
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public void addFunctions(VCDataIdentifier vcdID, AnnotatedFunction[] functions) throws DataAccessException, ExpressionException {
	try {
		VCData simData = getVCData(vcdID);
		for (int i=0;i<functions.length;i++){
			simData.addFunction(functions[i]);
		}
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * Insert the method's description here.
 * Creation date: (3/20/2006 3:37:39 PM)
 */
private SpatialStatsInfo calcSpatialStatsInfo(cbit.util.TimeSeriesJobSpec timeSeriesJobSpec,VCDataIdentifier vcdID) throws Exception{

	SpatialStatsInfo ssi = new SpatialStatsInfo();
	//Determine weights for indices of each variable if we are going to be calculating spatial statistics
	ssi.bWeightsValid = true;
    //if(timeSeriesJobSpec.isCalcSpaceStats()){
	    CartesianMesh myMesh = getMesh(vcdID);
	    DataIdentifier[] dataIDs = getDataIdentifiers(vcdID);
	    ssi.spaceWeight = new double[timeSeriesJobSpec.getVariableNames().length][];
	    ssi.totalSpace = new double[timeSeriesJobSpec.getVariableNames().length];
	    for(int i=0;i<timeSeriesJobSpec.getVariableNames().length;i+= 1){
		    ssi.spaceWeight[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    Boolean isVolume = null;
		    for(int j=0;j<dataIDs.length;j+= 1){
			    if(dataIDs[j].getName().equals(timeSeriesJobSpec.getVariableNames()[i])){
				    isVolume = new Boolean(dataIDs[j].getVariableType().equals(VariableType.VOLUME) || dataIDs[j].getVariableType().equals(VariableType.VOLUME_REGION));
				    break;
			    }
		    }
		    if(isVolume == null){
			    throw new RuntimeException("Couldn't find variable type for varname="+timeSeriesJobSpec.getVariableNames()[i]+" during TimeSeries calc spatial stats");
		    }else{
			    for(int j=0;j<timeSeriesJobSpec.getIndices()[i].length;j+= 1){
				    if(isVolume.booleanValue()){
					    ssi.spaceWeight[i][j] = myMesh.calculateMeshElementVolumeFromVolumeIndex(timeSeriesJobSpec.getIndices()[i][j]);
				    }else{//assume membrane
					    double area = myMesh.getMembraneElements()[timeSeriesJobSpec.getIndices()[i][j]].getArea();
					    if(area == cbit.vcell.solvers.MembraneElement.AREA_UNDEFINED){
					    	ssi.bWeightsValid = false;
					    	break;
					    }
					    ssi.spaceWeight[i][j] = area;
				    }
				    ssi.totalSpace[i]+= ssi.spaceWeight[i][j];
			    }
		    }
		    if(!ssi.bWeightsValid){
			    break;
		    }
	    }
    //}

    //if(ssi.bWeightsValid){
	    return ssi;
    //}else{
	    //return null;
    //}
}


/**
 * Insert the method's description here.
 * Creation date: (2/16/2006 12:28:29 PM)
 */
private cbit.util.TimeSeriesJobResults calculateStatisticsFromWhole(
	cbit.util.TimeSeriesJobSpec timeSeriesJobSpec,
    double[][][] timeSeriesFormatedValuesArr,
    double[] desiredTimeValues,
    SpatialStatsInfo spatialStatsInfo) throws Exception{

	//timeSeriesFormatedValuesArr[varnames][indices][times]
	//timeSeriesFormatedValuesArr[varnames][0][times] contains desired times NOT values (unnecessary duplication should be fixed)
	
    //if (!timeSeriesJobSpec.isCalcSpaceStats() && !timeSeriesJobSpec.isCalcTimeStats()) {
        //return new cbit.util.TSJobResultsNoStats(
            //timeSeriesJobSpec.getVariableNames(),
            //timeSeriesJobSpec.getIndices(),
            //desiredTimeValues,
            //timeSeriesFormatedValuesArr);
    //}






    


    
    if(timeSeriesJobSpec.isCalcTimeStats()){
	    double[][] timeMinArr = null;
	    double[][] timeMaxArr = null;
	    double[][] timeMeanArr = null;
	    timeMinArr = new double[timeSeriesJobSpec.getVariableNames().length][];
	    timeMaxArr = new double[timeSeriesJobSpec.getVariableNames().length][];
	    timeMeanArr = new double[timeSeriesJobSpec.getVariableNames().length][];
	    double val=0;
	    for(int i=0;i<timeSeriesFormatedValuesArr.length;i+= 1){
		    timeMinArr[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    timeMaxArr[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    timeMeanArr[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    for(int j=1;j<timeSeriesFormatedValuesArr[i].length;j+= 1){//skip index 0 (has times)
			    double min = Double.POSITIVE_INFINITY;
			    double max = Double.NEGATIVE_INFINITY;
			    double mean = 0;
			    for(int k=0;k<desiredTimeValues.length;k+= 1){
				    val = timeSeriesFormatedValuesArr[i][j][k];
				    if(val < min){min=val;}
				    if(val > max){max=val;}
				    mean+= val;
			    }
			    mean/= desiredTimeValues.length;
			    timeMinArr[i][j-1] = min;
			    timeMaxArr[i][j-1] = max;
			    timeMeanArr[i][j-1] = mean;
		    }
	    }
	    if(!timeSeriesJobSpec.isCalcSpaceStats()){//No space stats
	        return new cbit.util.TSJobResultsTimeStats(
	            timeSeriesJobSpec.getVariableNames(),
	            timeSeriesJobSpec.getIndices(),
	            desiredTimeValues,
	            timeMinArr,timeMaxArr,timeMeanArr);
	    }else {
		    double[] timeSpaceStatsMin = new double[timeSeriesFormatedValuesArr.length];
		    double[] timeSpaceStatsMax = new double[timeSeriesFormatedValuesArr.length];
		    double[] timeSpaceStatsUnweightedMean = new double[timeSeriesFormatedValuesArr.length];
		    double[] timeSpaceStatsWeightedMean = new double[timeSeriesFormatedValuesArr.length];
		    for(int i=0;i<timeSeriesFormatedValuesArr.length;i+= 1){
			    double min = Double.POSITIVE_INFINITY;
			    double max = Double.NEGATIVE_INFINITY;
			    double mean = 0;
			    double wmean = 0;
			    for(int j=0;j<timeSeriesJobSpec.getIndices()[i].length;j+= 1){
				    if(timeMinArr[i][j] < min){min=timeMinArr[i][j];}
				    if(timeMaxArr[i][j] > max){max=timeMaxArr[i][j];}
				    mean+= timeMeanArr[i][j];
				    if(spatialStatsInfo.bWeightsValid){wmean+= timeMeanArr[i][j]*spatialStatsInfo.spaceWeight[i][j];}
			    }
			    mean/= timeSeriesFormatedValuesArr[i].length;
			    if(spatialStatsInfo.bWeightsValid){wmean/= spatialStatsInfo.totalSpace[i];}
			    
			    timeSpaceStatsMin[i] = min;
			    timeSpaceStatsMax[i] = max;
			    timeSpaceStatsUnweightedMean[i] = mean;
			    timeSpaceStatsWeightedMean[i] = wmean;
		    }
	        return new cbit.util.TSJobResultsTimeStats(
	            timeSeriesJobSpec.getVariableNames(),
	            timeSeriesJobSpec.getIndices(),
	            desiredTimeValues,
	            timeSpaceStatsMin,timeSpaceStatsMax,timeSpaceStatsUnweightedMean,(spatialStatsInfo.bWeightsValid?timeSpaceStatsWeightedMean:null));
	    }
    }else if(timeSeriesJobSpec.isCalcSpaceStats()){
	    
	    double val=0;
		
	    double[][] spaceStatsMin = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsMax = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsUnweightedMean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsWeightedMean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    for(int k=0;k<desiredTimeValues.length;k+= 1){//times
		    for(int i=0;i<timeSeriesFormatedValuesArr.length;i+= 1){//Variable names
			    double min = Double.POSITIVE_INFINITY;
			    double max = Double.NEGATIVE_INFINITY;
			    double mean = 0;
			    double wmean = 0;
			    for(int j=1;j<timeSeriesFormatedValuesArr[i].length;j+= 1){//index
				    val = timeSeriesFormatedValuesArr[i][j][k];
				    if(val < min){min=val;}
				    if(val > max){max=val;}
				    mean+= val;
				    if(spatialStatsInfo.bWeightsValid){wmean+= val*spatialStatsInfo.spaceWeight[i][j-1];}
			    }
			    mean/= timeSeriesJobSpec.getIndices()[i].length;
			    if(spatialStatsInfo.bWeightsValid){wmean/= spatialStatsInfo.totalSpace[i];}

			    spaceStatsMin[i][k] = min;
			    spaceStatsMax[i][k] = max;
			    spaceStatsUnweightedMean[i][k] = mean;
			    spaceStatsWeightedMean[i][k] = wmean;
		    }
	    }
        return new cbit.util.TSJobResultsSpaceStats(
            timeSeriesJobSpec.getVariableNames(),
            timeSeriesJobSpec.getIndices(),
            desiredTimeValues,
            spaceStatsMin,spaceStatsMax,spaceStatsUnweightedMean,
            (spatialStatsInfo.bWeightsValid?spaceStatsWeightedMean:null),
            (spatialStatsInfo.bWeightsValid?spatialStatsInfo.totalSpace:null));
    }

    throw new IllegalArgumentException("Couldn't determine format of data to return");
}


/**
 * Insert the method's description here.
 * Creation date: (10/13/00 9:13:52 AM)
 * @return cbit.vcell.simdata.SimDataBlock
 * @param user cbit.vcell.server.User
 * @param simResults cbit.vcell.simdata.SimResults
 * @param function cbit.vcell.math.Function
 * @param time double
 */
private SimDataBlock evaluateFunction(
	VCDataIdentifier vcdID, 
	VCData simData, 
	AnnotatedFunction function, 
	double time)
	throws ExpressionException, DataAccessException, IOException, MathException {

	//
	// identify data dependencies
	//
	Expression exp = function.getSimplifiedExpression();
	String dependentIDs[] = exp.getSymbols();
	Vector dataSetList = new Vector();
	Vector dependencyList = new Vector();

	//
	//
	// get Dependent datasets
	//
	// variables are indexed by a number, t=0, x=1, y=2, z=3, a(i) = 4+i where a's are other variables
	// these variables
	//
	int varIndex = 4;
	int dataLength = 0;
	long lastModified = 0;
	VariableType variableType = null;
	for (int i = 0; dependentIDs!=null && i < dependentIDs.length; i++) {
		SymbolTableEntry ste = exp.getSymbolBinding(dependentIDs[i]);
		if (ste instanceof DataSetIdentifier) {
			DataSetIdentifier dsi = (DataSetIdentifier) ste;
			dependencyList.addElement(dsi);
			dsi.setIndex(varIndex++);
			if (dsi.getName().endsWith("_OUTSIDE") || dsi.getName().endsWith("_INSIDE")){
				String volVarName = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
				SimDataBlock simDataBlock = getSimDataBlock(vcdID, volVarName, time);
				lastModified = simDataBlock.getPDEDataInfo().getTimeStamp();
				//
				// if inside/outside volume element dependent, then can only be a membrane type 
				//
				if (simDataBlock.getVariableType().equals(VariableType.VOLUME)){
					variableType = VariableType.MEMBRANE;
					dataLength = getMesh(vcdID).getMembraneElements().length;
				//
				// if inside/outside volume element dependent, then can only be a membrane type 
				//
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION) && variableType==null){
					variableType = VariableType.MEMBRANE_REGION;
					dataLength = getMesh(vcdID).getNumMembraneRegions();
				}
				dataSetList.addElement(simDataBlock);
			}else{	
				SimDataBlock simDataBlock = getSimDataBlock(vcdID, dsi.getName(), time);
				if (variableType==null || simDataBlock.getVariableType().isExpansionOf(variableType)) {
					lastModified = simDataBlock.getPDEDataInfo().getTimeStamp();
					dataLength = simDataBlock.getData().length;
					variableType = simDataBlock.getVariableType();
				}
				dataSetList.addElement(simDataBlock);
			}
		} else if (ste instanceof ReservedVariable) {
			ReservedVariable rv = (ReservedVariable) ste;
			if (rv.isTIME()) {
				rv.setIndex(0);
			} else if (rv.isX()) {
				rv.setIndex(1);
			} else if (rv.isY()) {
				rv.setIndex(2);
			} else if (rv.isZ()) {
				rv.setIndex(3);
			}
		}
	}

	if (dataLength <= 0) {
		log.alert("dependencies for function '"+function+"' not found, assuming datalength of volume");
		try {
			dataLength = getMesh(vcdID).getDataLength(VariableType.VOLUME);
			variableType = VariableType.VOLUME;
		}catch (MathException e){
			log.exception(e);
			throw new RuntimeException("MathException, cannot determine domain for function '"+function+"'");
		}catch (FileNotFoundException e){
			log.exception(e);
			throw new RuntimeException("Mesh not found, cannot determine domain for function '"+function+"'");
		}
	}

	//
	// evaluate function on dependent dataset
	// store result 
	//
	double args[] = new double[varIndex];
	double data[] = new double[dataLength];
	args[0] = time; // time
	args[1] = 0.0; // x
	args[2] = 0.0; // y
	args[3] = 0.0; // z
	CartesianMesh mesh = getMesh(vcdID);
	for (int i = 0; i < dataLength; i++) {
		//
		// initialize argments to expression
		//
		if (variableType.equals(VariableType.VOLUME)){
			Coordinate coord = mesh.getCoordinateFromVolumeIndex(i);
			args[1] = coord.getX();
			args[2] = coord.getY();
			args[3] = coord.getZ();
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				SimDataBlock simDataBlock = (SimDataBlock)dataSetList.elementAt(j);
				if (simDataBlock.getVariableType().equals(VariableType.VOLUME)){
					args[4 + j] = simDataBlock.getData()[i];
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION)){
					int volumeIndex = mesh.getVolumeRegionIndex(i);
					args[4 + j] = simDataBlock.getData()[volumeIndex];
				}
			}
		}else if (variableType.equals(VariableType.VOLUME_REGION)){
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				SimDataBlock simDataBlock = (SimDataBlock)dataSetList.elementAt(j);
				if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION)){
					args[4 + j] = simDataBlock.getData()[i];
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE)){
			Coordinate coord = mesh.getCoordinateFromMembraneIndex(i);
			args[1] = coord.getX();
			args[2] = coord.getY();
			args[3] = coord.getZ();
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				SimDataBlock simDataBlock = (SimDataBlock)dataSetList.elementAt(j);
				if (simDataBlock.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_INSIDE")){
					int volInsideIndex = mesh.getMembraneElements()[i].getInsideVolumeIndex();
					args[4 + j] = simDataBlock.getData()[volInsideIndex];
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_OUTSIDE")){
					int volOutsideIndex = mesh.getMembraneElements()[i].getOutsideVolumeIndex();
					args[4 + j] = simDataBlock.getData()[volOutsideIndex];
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){
					int insideVolumeIndex = mesh.getMembraneElements()[i].getInsideVolumeIndex();
					int volRegionIndex = mesh.getVolumeRegionIndex(insideVolumeIndex);
					args[4 + j] = simDataBlock.getData()[volRegionIndex];
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){
					int outsideVolumeIndex = mesh.getMembraneElements()[i].getOutsideVolumeIndex();
					int volRegionIndex = mesh.getVolumeRegionIndex(outsideVolumeIndex);
					args[4 + j] = simDataBlock.getData()[volRegionIndex];
				}else if (simDataBlock.getVariableType().equals(VariableType.MEMBRANE)){
					args[4 + j] = simDataBlock.getData()[i];
				}else if (simDataBlock.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(i);
					args[4 + j] = simDataBlock.getData()[memRegionIndex];
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE_REGION)){
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				SimDataBlock simDataBlock = (SimDataBlock)dataSetList.elementAt(j);
				if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){
					//
					// find "inside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					int insideVolumeIndex = -1;
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==i){
							insideVolumeIndex = mesh.getMembraneElements()[k].getInsideVolumeIndex();
							break;
						}
					}
					int volRegionIndex = mesh.getVolumeRegionIndex(insideVolumeIndex);
					args[4 + j] = simDataBlock.getData()[volRegionIndex];
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){
					//
					// find "outside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					int outsideVolumeIndex = -1;
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==i){
							outsideVolumeIndex = mesh.getMembraneElements()[k].getOutsideVolumeIndex();
							break;
						}
					}
					int volRegionIndex = mesh.getVolumeRegionIndex(outsideVolumeIndex);
					args[4 + j] = simDataBlock.getData()[volRegionIndex];
				}else if (simDataBlock.getVariableType().equals(VariableType.MEMBRANE)){
					args[4 + j] = simDataBlock.getData()[i];
				}else if (simDataBlock.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(i);
					args[4 + j] = simDataBlock.getData()[memRegionIndex];
				}
			}
		}
		try {
			data[i] = function.getSimplifiedExpression().evaluateVector(args);
		}catch (DivideByZeroException e){
			System.out.println("DataSetControllerImpl.evaluateFunction(): DivideByZero "+e.getMessage());
			data[i] = Double.POSITIVE_INFINITY;
		}
	}
	DataSet dataSet = new DataSet();
	PDEDataInfo pdeDataInfo = new PDEDataInfo(vcdID.getOwner(), vcdID.getID(), function.getName(), time, lastModified);
	if (data != null) {
		return new SimDataBlock(pdeDataInfo, data, variableType);
	} else {
		return null;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (10/13/00 9:13:52 AM)
 * @return cbit.vcell.simdata.SimDataBlock
 * @param user cbit.vcell.server.User
 * @param simResults cbit.vcell.simdata.SimResults
 * @param function cbit.vcell.math.Function
 * @param time double
 */
private FunctionIndexes[] findFunctionIndexes(VCDataIdentifier vcdID,AnnotatedFunction function,int[] dataIndexes)
	throws ExpressionException, DataAccessException, IOException, MathException {

	//
	// identify data dependencies
	//
	VariableType variableType = function.getFunctionType();
	
	Expression exp = function.getSimplifiedExpression();
	String dependentIDs[] = exp.getSymbols();
	Vector dependencyList = new Vector();
	//
	// get Dependents
	// variables are indexed by a number, t=0, x=1, y=2, z=3, a(i) = 4+i where a's are other variables
	//
	int varIndex = 4;
	
	for (int i = 0; dependentIDs!=null && i < dependentIDs.length; i++) {
		SymbolTableEntry ste = exp.getSymbolBinding(dependentIDs[i]);
		if (ste instanceof DataSetIdentifier) {
			DataSetIdentifier dsi = (DataSetIdentifier) ste;
			dependencyList.addElement(dsi);
			dsi.setIndex(varIndex++);
		} else if (ste instanceof ReservedVariable) {
			ReservedVariable rv = (ReservedVariable) ste;
			if (rv.isTIME()) {
				rv.setIndex(0);
			} else if (rv.isX()) {
				rv.setIndex(1);
			} else if (rv.isY()) {
				rv.setIndex(2);
			} else if (rv.isZ()) {
				rv.setIndex(3);
			}
		}
	}
	//
	// get Indexes and simFileNames
	//
	Coordinate initCoord = new Coordinate(0,0,0);
	Coordinate[] coords = new Coordinate[dataIndexes.length];
	for(int i=0;i<coords.length;i+= 1){
		coords[i] = initCoord;
	}
	String[] varNames = new String[varIndex-4];
	String[] simFileVarNames = new String[varNames.length];
	int[][] varIndexes = new int[dataIndexes.length][varNames.length];
	
	CartesianMesh mesh = getMesh(vcdID);
	//
	// initialize argments to expression
	//
	for(int i=0;i<dataIndexes.length;i+= 1){
		coords[i] = mesh.getCoordinateFromVolumeIndex(dataIndexes[i]);

		if (variableType.equals(VariableType.VOLUME)){
			//coord = mesh.getCoordinateFromVolumeIndex(dataIndex);
			coords[i] = mesh.getCoordinateFromVolumeIndex(dataIndexes[i]);
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION)){
					int volumeIndex = mesh.getVolumeRegionIndex(dataIndexes[i]);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = volumeIndex;
				}
			}
		}else if (variableType.equals(VariableType.VOLUME_REGION)){
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME_REGION)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE)){
			//coord = mesh.getCoordinateFromMembraneIndex(dataIndex);
			coords[i] = mesh.getCoordinateFromMembraneIndex(dataIndexes[i]);
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_INSIDE")){
					int volInsideIndex = mesh.getMembraneElements()[dataIndexes[i]].getInsideVolumeIndex();
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volInsideIndex;
				}else if (dsi.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_OUTSIDE")){
					int volOutsideIndex = mesh.getMembraneElements()[dataIndexes[i]].getOutsideVolumeIndex();
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volOutsideIndex;
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){
					int insideVolumeIndex = mesh.getMembraneElements()[dataIndexes[i]].getInsideVolumeIndex();
					int volRegionIndex = mesh.getVolumeRegionIndex(insideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){
					int outsideVolumeIndex = mesh.getMembraneElements()[dataIndexes[i]].getOutsideVolumeIndex();
					int volRegionIndex = mesh.getVolumeRegionIndex(outsideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(dataIndexes[i]);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = memRegionIndex;
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE_REGION)){
			for (int j = 0; j < varIndex - 4; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){
					//
					// find "inside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					int insideVolumeIndex = -1;
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==dataIndexes[i]){
							insideVolumeIndex = mesh.getMembraneElements()[k].getInsideVolumeIndex();
							break;
						}
					}
					int volRegionIndex = mesh.getVolumeRegionIndex(insideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){
					//
					// find "outside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					int outsideVolumeIndex = -1;
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==dataIndexes[i]){
							outsideVolumeIndex = mesh.getMembraneElements()[k].getOutsideVolumeIndex();
							break;
						}
					}
					int volRegionIndex = mesh.getVolumeRegionIndex(outsideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(dataIndexes[i]);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = memRegionIndex;
				}
			}
		}
	}

	FunctionIndexes[] fiArr = new FunctionIndexes[dataIndexes.length];
	for(int i=0;i<dataIndexes.length;i+= 1){
		fiArr[i] = new FunctionIndexes(function,coords[i],varNames,simFileVarNames,varIndexes[i]);
	}
	return fiArr;
	//
}


/**
 * Method to support listener events.
 */
protected void fireDataJobMessage(cbit.rmi.event.DataJobEvent event) {
	if (aDataJobListener == null) {
		return;
	};
	int currentSize = aDataJobListener.size();
	cbit.rmi.event.DataJobListener tempListener = null;
	for (int index = 0; index < currentSize; index++){
		tempListener = (cbit.rmi.event.DataJobListener)aDataJobListener.elementAt(index);
		if (tempListener != null) {
			tempListener.dataJobMessage(event);
		};
	};
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String[]
 */
public DataIdentifier[] getDataIdentifiers(VCDataIdentifier vcdID) throws DataAccessException, IOException, FileNotFoundException {
	log.print("DataSetControllerImpl.getDataIdentifiers("+vcdID.getID()+")");

	VCData simData = getVCData(vcdID);
	//filter names with _INSIDE and _OUTSIDE
	DataIdentifier[] dataIdentifiersIncludingOutsideAndInside = simData.getVarAndFunctionDataIdentifiers();
	Vector v = new Vector();
	for (int i = 0; i < dataIdentifiersIncludingOutsideAndInside.length; i++){
		DataIdentifier di = dataIdentifiersIncludingOutsideAndInside[i];
		if (!di.getName().endsWith("_INSIDE") && !di.getName().endsWith("_OUTSIDE")) {
			v.addElement(di);
		}
	}
	DataIdentifier[] ids = new DataIdentifier[v.size()];
	v.copyInto(ids);
	return ids;
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public double[] getDataSetTimes(VCDataIdentifier vcdID) throws DataAccessException {
	try {
		VCData simData = getVCData(vcdID);
		double times[] = simData.getDataTimes();
		String timeString = "null";
		if (times!=null){
			timeString = String.valueOf(times[0]);
			if (times.length>1){
				timeString += "..."+times[times.length-1];
			}
		}
		log.print("DataSetControllerImpl.getDataSetTimes() returning ["+timeString+"]");
		return times;
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public AnnotatedFunction[] getFunctions(VCDataIdentifier vcdID) throws DataAccessException, ExpressionBindingException {
	try {
		VCData simData = getVCData(vcdID);
		return simData.getFunctions();
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 */
public boolean getIsODEData(VCDataIdentifier vcdID) throws DataAccessException, IOException, FileNotFoundException {

	VCData simData = getVCData(vcdID);
	return simData.getIsODEData();
	
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.plot.PlotData
 * @param varName java.lang.String
 * @param begin cbit.vcell.math.CoordinateIndex
 * @param end cbit.vcell.math.CoordinateIndex
 */
public PlotData getLineScan(VCDataIdentifier vcdID, String varName, double time, CoordinateIndex begin, CoordinateIndex end) throws DataAccessException, MathException {
	try {
		double dataTimes[] = getDataSetTimes(vcdID);
		if (dataTimes==null || dataTimes.length <= 0) {
			return null;
		}
		try {
			if (getIsODEData(vcdID)){
				throw new DataAccessException("cannot request a line-scan on a nonspatial result set");
			}
		}catch (IOException e){
			log.exception(e);
		}
		CartesianMesh mesh = getMesh(vcdID);
		int sizeX = mesh.getSizeX();
		int sizeY = mesh.getSizeY();
		int sizeZ = mesh.getSizeZ();

		SimDataBlock simDataBlock = getSimDataBlock(vcdID,varName,time);
		if (simDataBlock == null){
			return null;
		}

		double data[] = simDataBlock.getData();
		if (data == null) {
			return null;
		}

		//
		// get length of span (in elements)
		//
		double lengthScan = Math.sqrt((begin.x - end.x) * (begin.x - end.x) + (begin.y - end.y) * (begin.y - end.y) + (begin.z - end.z) * (begin.z - end.z));
		if (lengthScan <= 0) {
			return null;
		}

		//
		// get length of span (in microns)
		//
		Coordinate beginCoord = mesh.getCoordinate(begin);
		Coordinate endCoord = mesh.getCoordinate(end);
		double lengthScanMicrons = beginCoord.distanceTo(endCoord);
		
		int sizeScan = Math.min(200, 4 * ((int) lengthScan));
		double lineScan[] = new double[sizeScan];
		double line[] = new double[sizeScan];
		for (int i = 0; i < sizeScan; i++) {
			// operate on normalized length (parametric line)
			line[i] = ((double) i) / (sizeScan - 1);
			double coordX = begin.x + line[i] * (end.x - begin.x);
			double coordY = begin.y + line[i] * (end.y - begin.y);
			double coordZ = begin.z + line[i] * (end.z - begin.z);
			int pointX = (int) (coordX + 0.5);
			int pointY = (int) (coordY + 0.5);
			int pointZ = (int) (coordZ + 0.5);
			lineScan[i] = data[ (pointZ * sizeY + pointY) * sizeX + pointX];
			// restore scale to
			line[i] *= lengthScanMicrons;
		}
		return new PlotData(line, lineScan);
	} catch (DataAccessException e) {
		log.exception(e);
		throw e;
	} catch (IOException e) {
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.plot.PlotData
 * @param varName java.lang.String
 * @param begin cbit.vcell.math.CoordinateIndex
 * @param end cbit.vcell.math.CoordinateIndex
 */
public PlotData getLineScan(VCDataIdentifier vcdID, String varName, double time, SpatialSelection spatialSelection) throws DataAccessException, MathException {
	try {
		if (spatialSelection == null){
			throw new IllegalArgumentException("null spatialSelection");
		}
		if (spatialSelection.isPoint()){
			throw new RuntimeException("'Point' spatialSelection not expected");
		}
		double dataTimes[] = getDataSetTimes(vcdID);
		if (dataTimes==null || dataTimes.length <= 0) {
			return null;
		}
		try {
			if (getIsODEData(vcdID)){
				throw new DataAccessException("cannot request a line-scan on a nonspatial result set");
			}
		}catch (IOException e){
			log.exception(e);
		}
		CartesianMesh mesh = getMesh(vcdID);
		//mesh is transient and is null if we got here by a serialized path (e.g. rmi)
		spatialSelection.setMesh(mesh);
		
		SimDataBlock simDataBlock = getSimDataBlock(vcdID,varName,time);
		if (simDataBlock == null){
			return null;
		}
		DataIdentifier dataIdentifier = null;
		try {
			DataIdentifier dataIdentifiers[] = getDataIdentifiers(vcdID);
			for (int i = 0; i < dataIdentifiers.length; i++){
				if (dataIdentifiers[i].getName().equals(varName)){
					dataIdentifier = dataIdentifiers[i];
				}
			}
		}catch (IOException e){
			throw new DataAccessException(e.getMessage());
		}

		double data[] = simDataBlock.getData();
		if (data == null) {
			return null;
		}
		
		if (spatialSelection instanceof SpatialSelectionVolume){

			SpatialSelectionVolume ssVolume = (SpatialSelectionVolume)spatialSelection;
			SpatialSelection.SSHelper ssvHelper = ssVolume.getIndexSamples(0.0,1.0);
			if (dataIdentifier.getVariableType().equals(VariableType.VOLUME)){
				ssvHelper.initializeValues_VOLUME(data);
			}else if(dataIdentifier.getVariableType().equals(VariableType.VOLUME_REGION)){
				ssvHelper.initializeValues_VOLUMEREGION(data);
			}else{
				throw new RuntimeException(SpatialSelectionVolume.class.getName()+" does not support variableType="+dataIdentifier.getVariableType());
			}

			return new PlotData(ssvHelper.getWorldCoordinateLengths(),ssvHelper.getSampledValues());
			
		}else if (spatialSelection instanceof SpatialSelectionContour){
			//
			// get length of span (in microns)
			//
			double lengthMicrons = spatialSelection.getLengthInMicrons();
			if (lengthMicrons <= 0) {
				return null;
			}
			int sizeScan;

			int[] sampleIndexes = null;
			double[] lineScan = null;
			double[] distance = null;
			
			SpatialSelectionContour ssContour = (SpatialSelectionContour)spatialSelection;
			sampleIndexes = ssContour.getIndexSamples();
			sizeScan = sampleIndexes.length;
			//
			// if contour region, must translate from Contour indexes to ContourRegion indexes
			//
			if (dataIdentifier.getVariableType().equals(VariableType.CONTOUR_REGION)){
				for (int i = 0; i < sampleIndexes.length; i++){
					sampleIndexes[i] = mesh.getContourRegionIndex(sampleIndexes[i]);
				}
			}
			lineScan = new double[sizeScan];
			distance = new double[sizeScan];
			for (int i=0;i<sizeScan;i++){
				lineScan[i] = data[sampleIndexes[i]];
				distance[i] = (((double) i) / (sizeScan - 1)) * lengthMicrons;
			}
			
			return new PlotData(distance, lineScan);

			
		}else if (spatialSelection instanceof SpatialSelectionMembrane){
			SpatialSelectionMembrane ssMembrane = (SpatialSelectionMembrane)spatialSelection;

			SpatialSelection.SSHelper ssmHelper = ssMembrane.getIndexSamples();
			if (dataIdentifier.getVariableType().equals(VariableType.MEMBRANE)){
				ssmHelper.initializeValues_MEMBRANE(data);
			}else if(dataIdentifier.getVariableType().equals(VariableType.MEMBRANE_REGION)){
				ssmHelper.initializeValues_MEMBRANEREGION(data);
			}else{
				throw new RuntimeException(SpatialSelectionMembrane.class.getName()+" does not support variableType="+dataIdentifier.getVariableType());
			}

			return new PlotData(ssmHelper.getWorldCoordinateLengths(),ssmHelper.getSampledValues());
			
		}else{
			throw new RuntimeException("unexpected SpatialSelection type "+spatialSelection.getClass().toString());
		}

	} catch (DataAccessException e) {
		log.exception(e);
		throw e;
	} catch (IOException e) {
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created in VisualAge.
 * @return CartesianMesh
 */
public CartesianMesh getMesh(VCDataIdentifier vcdID) throws DataAccessException, IOException, MathException {

	log.print("DataSetControllerImpl.getMesh("+vcdID.getOwner().getName()+","+vcdID.getID()+")");
	
	VCData simData = null;
	try {
		simData = getVCData(vcdID);
	}catch (DataAccessException e){
	}
	
	if (simData==null){
		throw new DataAccessException("no simResults for user "+vcdID.getOwner().getName()+" with simID="+vcdID.getID());
	}

	try {
		if (getIsODEData(vcdID)){
			throw new DataAccessException("cannot request a mesh for a nonspatial result set");
		}
	}catch (IOException e){
		log.exception(e);
	}
	
	CartesianMesh mesh = simData.getMesh();
	
	if (mesh==null){
		log.alert("DataSetControllerImpl.getMesh(): creating dummy CartesianMesh");
		try {
			int size[] = simData.getVolumeSize();
			if (size==null){
				return null;
			}
			throw new RuntimeException("DataSetControllerImpl.getMesh(): size not null but couldn't read Mesh");
		}catch (Throwable e2){
			log.exception(e2);
			log.alert("DataSetControllerImpl.getMesh(): error creating dummy mesh: "+e2.getMessage());
			return null;
		}
	}else{
		return mesh;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (1/14/00 1:43:47 PM)
 * @return cbit.vcell.simdata.ODEDataBlock
 * @param user cbit.vcell.server.User
 * @param simID java.lang.String
 */
public ODEDataBlock getODEDataBlock(VCDataIdentifier vcdID) throws DataAccessException {
	
	log.print("DataSetControllerImpl.getODEDataBlock()");

	try {
		//
		// check if already cached
		//
		VCData simData = getVCData(vcdID);
		ODEDataInfo odeDataInfo = new ODEDataInfo(vcdID.getOwner(), vcdID.getID(), simData.getDataBlockTimeStamp(ODE_DATA, 0));
		ODEDataBlock odeDataBlock = cacheTable.get(odeDataInfo);
		if (odeDataBlock != null){
			return odeDataBlock;
		}else{
			if (simData.getIsODEData()) {
				odeDataBlock = simData.getODEDataBlock();
				if (odeDataBlock != null){
					cacheTable.put(odeDataInfo, odeDataBlock);
					return odeDataBlock;
				}else{
					String msg = "failure reading ODE data for " + vcdID.getOwner().getName() + "'s " + vcdID.getID();
					log.alert("DataSetControllerImpl.getODEDataBlock(): "+msg);
					throw new DataAccessException(msg);
				}
			} else {
				String msg = "Simulation data is not ODE data for " + vcdID.getOwner().getName() + "'s " + vcdID.getID();
				log.alert("DataSetControllerImpl.getODEDataBlock(): "+msg);
				throw new DataAccessException(msg);
			}
		}
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 * @param varName java.lang.String
 * @param time double
 */
public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws DataAccessException {
	log.print("DataSetControllerImpl.getParticleDataBlock(" + time + ")");

	try {
		//
		// check if already cached
		//
		VCData simData = getVCData(vcdID);
		ParticleDataInfo particleDataInfo = new ParticleDataInfo(vcdID.getOwner(), vcdID.getID(), time, simData.getDataBlockTimeStamp(PARTICLE_DATA, time));
		ParticleDataBlock particleDataBlock = cacheTable.get(particleDataInfo);
		if (particleDataBlock != null){
			return particleDataBlock;
		}else{
			particleDataBlock = simData.getParticleDataBlock(time);
			if (particleDataBlock != null){
				cacheTable.put(particleDataInfo, particleDataBlock);
				return particleDataBlock;
			}else{
				String msg = "failure reading at t = " + time + " for " + vcdID.getOwner().getName() + "'s " + vcdID.getID();
				log.alert("DataSetControllerImpl.getParticleDataBlock(): "+msg);
				throw new DataAccessException(msg);
			}
		}
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 */
public boolean getParticleDataExists(VCDataIdentifier vcdID) throws DataAccessException, IOException, FileNotFoundException {

	VCData simData = getVCData(vcdID);
	return simData.getParticleDataExists();
	
}


/**
 * This method was created in VisualAge.
 * @return java.io.File
 */
private File getRootDir() {
	return rootDirectory;
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 * @param varName java.lang.String
 * @param time double
 */
public SimDataBlock getSimDataBlock(VCDataIdentifier vcdID, String varName, double time) throws DataAccessException {
	log.print("DataSetControllerImpl.getSimDataBlock(" + varName + ", " + time + ")");

	try {
		if (getIsODEData(vcdID)){
			throw new DataAccessException("cannot request a SimDataBlock on a nonspatial result set");
		}
	}catch (IOException e){
		log.exception(e);
	}
	
	try {
		//
		// check if already cached for non-function variables
		//
		VCData simData = getVCData(vcdID);
		PDEDataInfo pdeDataInfo = new PDEDataInfo(vcdID.getOwner(),vcdID.getID(),varName,time,simData.getDataBlockTimeStamp(PDE_DATA, time));
		SimDataBlock simDataBlock = null;
		AnnotatedFunction function = simData.getFunction(varName);
		if (function == null){
			simDataBlock = cacheTable.get(pdeDataInfo);
			if (simDataBlock == null) {
				simDataBlock = simData.getSimDataBlock(varName,time);
				if (simDataBlock != null) {
					cacheTable.put(pdeDataInfo,simDataBlock);
				}
			}				
		}else{
			simDataBlock = evaluateFunction(vcdID,simData,function,time);
		}
		if (simDataBlock != null) {
			return simDataBlock;
		} else {
			String msg = "failure reading "+varName+" at t="+time+" for "+vcdID.getOwner().getName()+"'s "+vcdID.getID();
			log.alert("DataSetControllerImpl.getDataBlockValues(): "+msg);
			throw new DataAccessException(msg);			
		}
	}catch (MathException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}catch (ExpressionException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 * @param varName java.lang.String
 * @param x int
 * @param y int
 * @param z int
 */
public cbit.util.TimeSeriesJobResults getTimeSeriesValues(VCDataIdentifier vcdID,cbit.util.TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {

	
	double dataTimes[] = getDataSetTimes(vcdID);
	if (dataTimes.length<=0){
		return null;
	}	

	boolean[] wantsTheseTimes = new boolean[dataTimes.length];
	double[] desiredTimeValues = null;
	int desiredNumTimes = 0;
	
	//if(timeSeriesJobSpec.getStartTime() == dataTimes[0] && timeSeriesJobSpec.getStep() == 1){
		//Arrays.fill(wantsTheseTimes,true);
		//desiredTimeValues = dataTimes;
		//desiredNumTimes = dataTimes.length;
	//}else{
		Arrays.fill(wantsTheseTimes,false);
		double[] tempTimes = new double[dataTimes.length];
		
		int stepCounter = 0;
		for(int i=0;i<dataTimes.length;i+= 1){
			if(dataTimes[i] > timeSeriesJobSpec.getEndTime()){
				break;
			}
			if(dataTimes[i] == timeSeriesJobSpec.getStartTime()){
				tempTimes[desiredNumTimes] = dataTimes[i];
				desiredNumTimes+= 1;
				stepCounter = 0;
				wantsTheseTimes[i] = true;
				if(timeSeriesJobSpec.getStep() == 0){
					break;
				}
			}else if(desiredNumTimes > 0 && stepCounter%timeSeriesJobSpec.getStep() == 0){
				tempTimes[desiredNumTimes] = dataTimes[i];
				desiredNumTimes+= 1;
				wantsTheseTimes[i] = true;
			}
			stepCounter+= 1;
		}
		if(desiredNumTimes == 0){
			throw new IllegalArgumentException("Couldn't find startTime "+timeSeriesJobSpec.getStartTime());
		}
		desiredTimeValues = new double[desiredNumTimes];
		System.arraycopy(tempTimes,0,desiredTimeValues,0,desiredNumTimes);
	//}
	
	try{
		fireDataJobMessage(
			new DataJobEvent(
					new Object(),
					System.currentTimeMillis(),
					vcdID.getOwner(),
					vcdID,
					//(vcdID instanceof cbit.vcell.solver.VCSimulationDataIdentifier?((cbit.vcell.solver.VCSimulationDataIdentifier)vcdID).getVcSimID():((cbit.vcell.solver.VCSimulationDataIdentifierOldStyle)vcdID).getVcSimID()),
					MessageEvent.DATA_START,
					new Double(0),
					java.net.InetAddress.getLocalHost().getHostName()
				)
		);

		final int NUM_STATS = 4;//min,max,mean,wmean
		final int MIN_OFFSET = 0;
		final int MAX_OFFSET = 1;
		final int MEAN_OFFSET = 2;
		final int WMEAN_OFFSET = 3;
		SimulationData simData = (SimulationData)getVCData(vcdID);
		//
		//Determine Memory Usage for this job to protect server
		//
		final long MAX_MEM_USAGE = 20000000;//No TimeSeries jobs larger than this
		long memUsage = 0;
		boolean bHasFunctionVars = false;//efficient function stats are not yet implemented so check to adjust calculation
		for(int i=0;i<timeSeriesJobSpec.getVariableNames().length;i+= 1){
			bHasFunctionVars = bHasFunctionVars || (simData.getFunction(timeSeriesJobSpec.getVariableNames()[i]) != null);
		}
		for(int i=0;i<timeSeriesJobSpec.getIndices().length;i+= 1){
			memUsage+= (timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars ? NUM_STATS : timeSeriesJobSpec.getIndices()[i].length);
		}
		memUsage*= desiredNumTimes*8*2;
		System.out.println("DataSetControllerImpl.getTimeSeriesValues: job memory="+memUsage);
		if(memUsage > MAX_MEM_USAGE){
			throw new DataAccessException(
				"DataSetControllerImpl.getTimeSeriesValues: Job too large"+(bHasFunctionVars?"(has function vars)":"")+", requires approx. "+memUsage+
				" bytes of memory (only "+MAX_MEM_USAGE+" bytes allowed).  Choose fewer datapoints or times.");
		}
		//
		Vector valuesV = new Vector();
		SpatialStatsInfo spatialStatsInfo = null;
		if(timeSeriesJobSpec.isCalcSpaceStats()){
			spatialStatsInfo = calcSpatialStatsInfo(timeSeriesJobSpec,vcdID);
		}
		for(int k=0;k<timeSeriesJobSpec.getVariableNames().length;k+= 1){
			double[][] timeSeries = null;
			String varName = timeSeriesJobSpec.getVariableNames()[k];
			int[] indices = timeSeriesJobSpec.getIndices()[k];
			if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
				timeSeries = new double[NUM_STATS + 1][desiredNumTimes];
			}else{
				timeSeries = new double[indices.length + 1][desiredNumTimes];
			}
			timeSeries[0] = desiredTimeValues;
			if(simData.getFunction(varName) != null){
				MultiFunctionIndexes mfi = new MultiFunctionIndexes(vcdID,varName,indices,wantsTheseTimes);
				for (int i=0;i<desiredTimeValues.length;i++){
					for (int j = 0; j < indices.length; j++){
						timeSeries[j + 1][i] = mfi.evaluateTimeFunction(i,j);
					}
				}
			}else{
				double[][][] valuesOverTime = null;
				if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
					valuesOverTime = simData.getSimDataTimeSeries(new String[] {varName},new int[][]{indices},wantsTheseTimes,spatialStatsInfo);
				}else{
					valuesOverTime = simData.getSimDataTimeSeries(new String[] {varName},new int[][]{indices},wantsTheseTimes);
				}
				for (int i=0;i<desiredTimeValues.length;i++){
					if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
						timeSeries[MIN_OFFSET + 1][i] = valuesOverTime[i][0][MIN_OFFSET];// min
						timeSeries[MAX_OFFSET + 1][i] = valuesOverTime[i][0][MAX_OFFSET];// max
						timeSeries[MEAN_OFFSET + 1][i] = valuesOverTime[i][0][MEAN_OFFSET];// mean
						timeSeries[WMEAN_OFFSET + 1][i] = valuesOverTime[i][0][WMEAN_OFFSET];// wmean
					}else{
						for (int j = 0; j < indices.length; j++){
							timeSeries[j + 1][i] = valuesOverTime[i][0][j];
						}
					}
				}
			}
			
			valuesV.add(timeSeries);
		}

		if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
			double[][] min = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] max = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] mean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] wmean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			for(int i=0;i<valuesV.size();i+= 1){
				double[][] timeStat = (double[][])valuesV.elementAt(i);
				for(int j=0;j<desiredTimeValues.length;j+= 1){
					min[i][j] = timeStat[MIN_OFFSET+1][j];
					max[i][j] = timeStat[MAX_OFFSET+1][j];
					mean[i][j] = timeStat[MEAN_OFFSET+1][j];
					wmean[i][j] = timeStat[WMEAN_OFFSET+1][j];
				}
			}
			return new cbit.util.TSJobResultsSpaceStats(
					timeSeriesJobSpec.getVariableNames(),
					timeSeriesJobSpec.getIndices(),
					desiredTimeValues,
					min,max,mean,
					(spatialStatsInfo.bWeightsValid?wmean:null),
					(spatialStatsInfo.bWeightsValid?spatialStatsInfo.totalSpace:null)
				);
		}else if(timeSeriesJobSpec.isCalcSpaceStats() && bHasFunctionVars){
			double[][][] timeSeriesFormatedValuesArr = new double[valuesV.size()][][];
			valuesV.copyInto(timeSeriesFormatedValuesArr);
			return calculateStatisticsFromWhole(timeSeriesJobSpec,timeSeriesFormatedValuesArr,desiredTimeValues,spatialStatsInfo);
		}else{
			double[][][] timeSeriesFormatedValuesArr = new double[valuesV.size()][][];
			valuesV.copyInto(timeSeriesFormatedValuesArr);
			return new cbit.util.TSJobResultsNoStats(
	            timeSeriesJobSpec.getVariableNames(),
	            timeSeriesJobSpec.getIndices(),
	            desiredTimeValues,
	            timeSeriesFormatedValuesArr);
		}
		
	}catch (DataAccessException e){
		log.exception(e);
		throw e;
	}catch (Throwable e){
		log.exception(e);
		throw new DataAccessException("DataSetControllerImpl.getTimeSeriesValues: "+(e.getMessage() == null?e.getClass().getName():e.getMessage()));
	}
}


/**
 * This method was created in VisualAge.
 * @return java.io.File
 * @param user cbit.vcell.server.User
 */
private File getUserDir(User user) throws FileNotFoundException {
	File userDir = new File(getRootDir(),user.getName());
	if (userDir.exists()){
		if (userDir.isDirectory()){
			return userDir;
		}else{
			throw new FileNotFoundException("file "+userDir.getPath()+" is not a directory");
		}
	}else{
		if (userDir.mkdir()){
			return userDir;
		}else{
			throw new FileNotFoundException("cannot create directory "+userDir.getPath());
		}
	}
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.simdata.SimResults
 * @param user User
 * @param simID java.lang.String
 */
public VCData getVCData(VCDataIdentifier vcdID) throws DataAccessException, IOException {

	VCData vcData = (VCData)cacheTable.get(vcdID);
	//
	// check to see if cached version is compatible with current data
	//
	if (vcData==null){
		if (vcdID instanceof MergedDataInfo) {
			try {
				User user = vcdID.getOwner();
				VCDataIdentifier[] vcdIdentifiers = ((MergedDataInfo)vcdID).getDataIDs();
				vcData = new MergedData(user, getUserDir(vcdID.getOwner()), this, vcdIdentifiers);
			} catch (IOException e) {
				e.printStackTrace(System.out);
				throw new RuntimeException(e.getMessage());
			}
		} else {  // assume vcdID instanceof cbit.vcell.solver.SimulationInfo or a test adapter
			vcData = new SimulationData(vcdID,getUserDir(vcdID.getOwner()));
		}
		cacheTable.put(vcData.getResultsInfoObject(),vcData);
	}

	return vcData;
}


/**
 * Add a cbit.vcell.desktop.controls.ExportListener.
 */
public void removeDataJobListener(cbit.rmi.event.DataJobListener djListener) {
	if (aDataJobListener != null) {
		aDataJobListener.remove(djListener);
	};
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public void removeFunction(VCDataIdentifier vcdID, AnnotatedFunction function) throws DataAccessException, ExpressionBindingException {
	try {
		VCData simData = getVCData(vcdID);
		simData.removeFunction(function);
		cacheTable.removeVariable(vcdID,function.getName());
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}
}