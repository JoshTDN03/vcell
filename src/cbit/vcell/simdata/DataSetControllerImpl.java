package cbit.vcell.simdata;
import cbit.util.FileUtils;
import cbit.util.ISize;
import cbit.util.NumberUtils;
import cbit.util.TSJobResultsNoStats;
import cbit.util.TimeSeriesJobResults;
import cbit.util.TimeSeriesJobSpec;
import cbit.util.TokenMangler;
import cbit.util.VCDataJobID;
import cbit.vcell.field.FieldDataDBOperationDriver;
import cbit.vcell.field.FieldDataFileOperationResults;
import cbit.vcell.field.FieldDataFileOperationSpec;
import cbit.vcell.field.FieldDataIdentifierSpec;
import cbit.vcell.field.FieldDataParameterVariable;
import cbit.vcell.field.FieldFunctionArguments;
import cbit.vcell.field.SimResampleInfoProvider;
import cbit.rmi.event.*;
import cbit.sql.KeyValue;
import cbit.vcell.simdata.gui.SpatialSelection;
import cbit.vcell.simdata.gui.SpatialSelectionVolume;
import cbit.vcell.simdata.gui.SpatialSelectionContour;
import cbit.vcell.simdata.gui.SpatialSelectionMembrane;
import cbit.vcell.parser.*;
import cbit.vcell.geometry.*;
import cbit.vcell.math.*;
import cbit.plot.*;

import java.sql.Connection;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;
import java.io.*;

import cbit.vcell.server.*;
import cbit.vcell.solver.SolverException;
import cbit.vcell.solver.VCSimulationDataIdentifier;
import cbit.vcell.solver.VCSimulationDataIdentifierOldStyle;
import cbit.vcell.solver.VCSimulationIdentifier;
import cbit.vcell.solvers.CartesianMesh;
import cbit.vcell.solvers.FVSolver;
/**
 * This interface was generated by a SmartGuide.
 * 
 */
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/

public class DataSetControllerImpl implements SimDataConstants {
	
	private static final int TXYZ_OFFSET = 4;
	
	public interface ProgressListener{
		public void updateProgress(double progress);
	};
	
	private class TimeInfo {
		private boolean[] wantsTheseTimes;
		private double[] desiredTimeValues;
		public TimeInfo(VCDataIdentifier vcdID,double startTime,double step,double endTime) throws DataAccessException{
			double dataTimes[] = getDataSetTimes(vcdID);
			if (dataTimes.length<=0){
				throw new DataAccessException("No times found for "+vcdID.toString());
			}	

			wantsTheseTimes = new boolean[dataTimes.length];
			desiredTimeValues = null;
			int desiredNumTimes = 0;
			
			Arrays.fill(wantsTheseTimes,false);
			double[] tempTimes = new double[dataTimes.length];
			
			int stepCounter = 0;
			for(int i=0;i<dataTimes.length;i+= 1){
				if(dataTimes[i] > endTime){
					break;
				}
				if(dataTimes[i] == startTime){
					tempTimes[desiredNumTimes] = dataTimes[i];
					desiredNumTimes+= 1;
					stepCounter = 0;
					wantsTheseTimes[i] = true;
					if(step == 0){
						break;
					}
				}else if(desiredNumTimes > 0 && stepCounter%step == 0){
					tempTimes[desiredNumTimes] = dataTimes[i];
					desiredNumTimes+= 1;
					wantsTheseTimes[i] = true;
				}
				stepCounter+= 1;
			}
			if(desiredNumTimes == 0){
				throw new IllegalArgumentException("Couldn't find startTime "+startTime);
			}
			desiredTimeValues = new double[desiredNumTimes];
			System.arraycopy(tempTimes,0,desiredTimeValues,0,desiredNumTimes);
			
		}
		public boolean[] getWantsTheseTimes() {
			return wantsTheseTimes;
		}
		public double[] getDesiredTimeValues() {
			return desiredTimeValues;
		}
		
	};
	
	private static class VolumeIndexNearFar {
		public int volIndexNear;
		public int volIndexFar;
		public VolumeIndexNearFar(int indexNear,int indexFar){
			this.volIndexNear = indexNear;
			this.volIndexFar = indexFar;
		}
		public static double interpolate(double valNear,double valFar){
			return 1.5 * valNear-0.5 * valFar;

		}
	};
	
	private boolean dataCachingEnabled = true;
	
	private HashMap<User, Vector<ExternalDataIdentifier>>
	userExtDataIDH =
		new HashMap<User, Vector<ExternalDataIdentifier>>();
	
	private static final int NUM_STATS = 6;//min,max,mean,wmean
	private static final int MIN_OFFSET = 0;
	private static final int MAX_OFFSET = 1;
	private static final int MEAN_OFFSET = 2;
	private static final int WMEAN_OFFSET = 3;
	private static final int SUM_OFFSET = 4;
	private static final int WSUM_OFFSET = 5;
	//
	private SessionLog log = null;
	private File primaryRootDirectory =  null;
	private File secondaryRootDirectory =  null;
	private Cachetable cacheTable0 = null;
	private Vector<DataJobListener> aDataJobListener = null;
	//
	public static class SpatialStatsInfo {
		public boolean bWeightsValid;
		public double[][] spaceWeight;
		public double[] totalSpace;
	};
	//
	private class MultiFunctionIndexes{
		private FunctionIndexes[] functionIndexesArr;
		private String[] allFuncVarNames = new String[0];
		private int[][] allFuncIndexes = new int[0][];
		private int blockSize;
		private double[][][] valuesOverTime = null;
//		private double[][] valuesOverLine = null;
		private VCData simData = null;
		private double[] dataSetTimes = null;
		private boolean[] wantsTheseTimes = null;
		private DataSetControllerImpl.ProgressListener progressListener;
		
		public MultiFunctionIndexes(
				final VCDataIdentifier argVcdID, 
				AnnotatedFunction argFunc,
				int[] argIndices,
				boolean[] argWantsTheseTimes,
				DataSetControllerImpl.ProgressListener argProgressListener)
									throws IOException,DataAccessException,ExpressionException,MathException{
										
			wantsTheseTimes = argWantsTheseTimes;
			dataSetTimes = DataSetControllerImpl.this.getDataSetTimes(argVcdID);
			simData = getVCData(argVcdID);
			functionIndexesArr = findFunctionIndexes(argVcdID,argFunc,argIndices);
			if(!functionIndexesArr[0].hasNearFarInterpolation()){
				blockSize = functionIndexesArr[0].getIndexes().length;
				for(int i=0;i<functionIndexesArr.length;i+= 1){
					FunctionIndexes fi = functionIndexesArr[i];
					String[] tempVN = new String[allFuncVarNames.length + fi.getSimFileVarNames().length];
					System.arraycopy(allFuncVarNames,0,tempVN,0,allFuncVarNames.length);
					System.arraycopy(fi.getSimFileVarNames(),0,tempVN,allFuncVarNames.length,fi.getSimFileVarNames().length);
					int[][] tempInd = new int[allFuncIndexes.length + fi.getIndexes().length][];
					for(int j=0;j<tempInd.length;j+= 1){
						if(j < allFuncIndexes.length){
							tempInd[j] = allFuncIndexes[j];
						}else{
							tempInd[j] = new int[] {fi.getIndexes()[j-allFuncIndexes.length]};
						}
					}
					allFuncIndexes = tempInd;
					allFuncVarNames = tempVN;
				}
			}else{
				blockSize = functionIndexesArr[0].getIndexes().length*2;
				int varIndex = -1;
				for(int i=0;i<functionIndexesArr.length;i+= 1){
					FunctionIndexes fi = functionIndexesArr[i];
					String[] tempVN = new String[allFuncVarNames.length + fi.getSimFileVarNames().length*2];
					System.arraycopy(allFuncVarNames,0,tempVN,0,allFuncVarNames.length);
					System.arraycopy(fi.getSimFileVarNames(),0,tempVN,allFuncVarNames.length,fi.getSimFileVarNames().length);
					System.arraycopy(fi.getSimFileVarNames(),0,tempVN,allFuncVarNames.length+fi.getSimFileVarNames().length,fi.getSimFileVarNames().length);
					int[][] tempInd = new int[allFuncIndexes.length + fi.getIndexes().length*2][];
					for(int j=0;j<tempInd.length;j+= 1){
						if(j < allFuncIndexes.length){
							tempInd[j] = allFuncIndexes[j];
						}else if(j < allFuncIndexes.length + fi.getIndexes().length){
							tempInd[j] = new int[] {fi.getIndexes()[j-allFuncIndexes.length]};
						}else{
							varIndex = j-allFuncIndexes.length-fi.getIndexes().length;
							tempInd[j] = new int[] {fi.getIndexes()[varIndex]};
							tempInd[j][0] = fi.findFarIndex(varIndex, tempInd[j][0]);
						}
					}
					allFuncIndexes = tempInd;
					allFuncVarNames = tempVN;
				}				
			}
			
			progressListener = argProgressListener;
		}
		public double evaluateTimeFunction(int timeIndex,int dataIndex)
								throws ExpressionException,DataAccessException,IOException{
			if(valuesOverTime == null){
				valuesOverTime =
					simData.getSimDataTimeSeries(this.geExpandedSimFileVarNames(),this.getExpandedFunctionIndexes(),wantsTheseTimes,progressListener);
			}
			double[] argsD = getArgBlock(valuesOverTime[timeIndex],dataIndex);
			return functionIndexesArr[dataIndex].evaluateFunction(dataSetTimes[timeIndex],argsD);
		}
//		public double evaluateLineFunction(double time,int dataIndex)
//								throws ExpressionException,DataAccessException,IOException{
//			if(valuesOverLine == null){
//				valuesOverLine =
//					simData.getSimDataLineScan(this.geExpandedSimFileVarNames(),this.getExpandedFunctionIndexes(),time);
//			}
//			double[] argsD = getArgBlock(valuesOverLine,dataIndex);
//			return functionIndexesArr[dataIndex].evaluateFunction(time,argsD);
//		}
		private String[] geExpandedSimFileVarNames(){
			return allFuncVarNames;
		}
		private int[][] getExpandedFunctionIndexes(){
			return allFuncIndexes;
		}
		private double[] getArgBlock(double[][] sourceValues,int index){
			double[] argsD = new double[blockSize];
			for(int k=0;k<blockSize;k+= 1){
				argsD[k] = sourceValues[(blockSize*index)+k][0];
			}
			return argsD;
		}
	};
	//
	private class FunctionIndexes{
		private AnnotatedFunction function;
		private Coordinate xyz;
		private String[] funcVarNames;
		private String[] simFileVarNames;
		private int[] funcIndexes;
		private double[] functionArgs;
		private VolumeIndexNearFar[] inside_near_far_indexes;
		private VolumeIndexNearFar[] outside_near_far_indexes;

		public int findFarIndex(int varIndex,int origVal){
			if(inside_near_far_indexes[varIndex] != null && inside_near_far_indexes[varIndex].volIndexFar != -1){
				return inside_near_far_indexes[varIndex].volIndexFar;
			}else if(outside_near_far_indexes[varIndex] != null && outside_near_far_indexes[varIndex].volIndexFar != -1){
				return outside_near_far_indexes[varIndex].volIndexFar;			
			}
			return origVal;
		}
		public boolean hasNearFarInterpolation(){
			for (int i = 0; i < inside_near_far_indexes.length; i++) {
				if(inside_near_far_indexes[i] != null){
					return true;
				}
			}
			for (int i = 0; i < outside_near_far_indexes.length; i++) {
				if(outside_near_far_indexes[i] != null){
					return true;
				}
			}
			return false;
		}
		public String[] getSimFileVarNames(){
			return simFileVarNames;
		}
		public int[] getIndexes(){
			return funcIndexes;
		}
		public double evaluateFunction(double time,double[] argValues) throws ExpressionException{
			functionArgs[0] = time; // time
			functionArgs[1] = xyz.getX(); // x
			functionArgs[2] = xyz.getY(); // y
			functionArgs[3] = xyz.getZ(); // z
			for(int i=0;i<funcVarNames.length;i+= 1){
				functionArgs[i+TXYZ_OFFSET] = argValues[i];
				if(inside_near_far_indexes[i] != null && inside_near_far_indexes[i].volIndexFar != -1){
					functionArgs[i+TXYZ_OFFSET] = VolumeIndexNearFar.interpolate(argValues[i], argValues[funcVarNames.length+i]);
				}else if(outside_near_far_indexes[i] != null && outside_near_far_indexes[i].volIndexFar != -1){
					functionArgs[i+TXYZ_OFFSET] = VolumeIndexNearFar.interpolate(argValues[i], argValues[funcVarNames.length+i]);			
				}
			}
			return function.getExpression().evaluateVector(functionArgs);
		}
		public FunctionIndexes(AnnotatedFunction argAF,Coordinate argXYZ,
				String[] argVarNames,String[] argSimFileVarNames,int[] argIndexes,
				VolumeIndexNearFar[] arg_inside_near_far_indexes,
				VolumeIndexNearFar[] arg_outside_near_far_indexes){
			for(int i=0;i<argVarNames.length;i+= 1){
				if(
					(arg_inside_near_far_indexes[i] != null && arg_inside_near_far_indexes[i].volIndexNear != argIndexes[i])
					||
					(arg_outside_near_far_indexes[i] != null && arg_outside_near_far_indexes[i].volIndexNear != argIndexes[i]))
				{
					throw new RuntimeException("FunctionIndexes: 'near' indexes should always match argIndexes when they exist");
				}
			}
			function = argAF;
			xyz = argXYZ;
			funcVarNames = argVarNames;
			funcIndexes = argIndexes;
			simFileVarNames = argSimFileVarNames;
			functionArgs = new double[argSimFileVarNames.length+TXYZ_OFFSET];
			inside_near_far_indexes = arg_inside_near_far_indexes;
			outside_near_far_indexes = arg_outside_near_far_indexes;
		}
	};

/**
 * This method was created by a SmartGuide.
 */
public DataSetControllerImpl (SessionLog sessionLog, Cachetable aCacheTable, File primaryDir, File secondDir) throws FileNotFoundException {
	this.cacheTable0 = aCacheTable;
	this.primaryRootDirectory = primaryDir;
	this.secondaryRootDirectory = secondDir;
	this.log = sessionLog;
}


/**
 * Add a cbit.vcell.desktop.controls.ExportListener.
 */
public void addDataJobListener(cbit.rmi.event.DataJobListener newListener) {
	if (aDataJobListener == null) {
		aDataJobListener = new java.util.Vector<DataJobListener>();
	};
	aDataJobListener.addElement(newListener);
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public void addFunctions(VCDataIdentifier vcdID, AnnotatedFunction[] functions,boolean[] bReplaceArr) throws DataAccessException, ExpressionException {
	try {
		VCData simData = getVCData(vcdID);
		for (int i=0;i<functions.length;i++){
			if(functions[i].getName().toUpperCase().endsWith("_INSIDE") || 
				functions[i].getName().toUpperCase().endsWith("_OUTSIDE")){
				throw new DataAccessException("Function names cannot end with text '_INSIDE' or '_OUTSIDE'");
			}
			boolean isGrad = functions[i].getExpression().hasGradient();
			if(isGrad && !functions[i].getFunctionType().equals(VariableType.VOLUME)){
				throw new DataAccessException("Gradient function is not implemented for datatype "+functions[i].getFunctionType().getTypeName());
			}
//			if(vcdID instanceof VCSimulationDataIdentifier &&
//				functions[i].isUserDefined()){
//				FieldFunctionArguments[] fieldFuncArgumentsArr =
//					functions[i].getExpression().getFieldFunctionArguments();
//				//Check that this sim has extDataids for these fieldfuncargs
//				//This will throw an Exception is there are no matches
//				if(fieldFuncArgumentsArr != null && fieldFuncArgumentsArr.length>0)
//					getFieldDataIdentifierSpecs(
//							fieldFuncArgumentsArr,
//							(VCSimulationDataIdentifier)vcdID);
//			}
			simData.addFunction(functions[i],bReplaceArr[i]);
		}
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * Insert the method's description here.
 * Creation date: (3/20/2006 3:37:39 PM)
 */
private SpatialStatsInfo calcSpatialStatsInfo(TimeSeriesJobSpec timeSeriesJobSpec,VCDataIdentifier vcdID) throws Exception{

	SpatialStatsInfo ssi = new SpatialStatsInfo();
	//Determine weights for indices of each variable if we are going to be calculating spatial statistics
	ssi.bWeightsValid = true;
    //if(timeSeriesJobSpec.isCalcSpaceStats()){
	    CartesianMesh myMesh = getMesh(vcdID);
	    DataIdentifier[] dataIDs = getDataIdentifiers(vcdID);
	    ssi.spaceWeight = new double[timeSeriesJobSpec.getVariableNames().length][];
	    ssi.totalSpace = new double[timeSeriesJobSpec.getVariableNames().length];
	    for(int i=0;i<timeSeriesJobSpec.getVariableNames().length;i+= 1){
		    ssi.spaceWeight[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    Boolean isVolume = null;
		    for(int j=0;j<dataIDs.length;j+= 1){
			    if(dataIDs[j].getName().equals(timeSeriesJobSpec.getVariableNames()[i])){
				    isVolume = new Boolean(dataIDs[j].getVariableType().equals(VariableType.VOLUME) || dataIDs[j].getVariableType().equals(VariableType.VOLUME_REGION));
				    break;
			    }
		    }
		    if(isVolume == null){
			    throw new RuntimeException("Couldn't find variable type for varname="+timeSeriesJobSpec.getVariableNames()[i]+" during TimeSeries calc spatial stats");
		    }else{
			    for(int j=0;j<timeSeriesJobSpec.getIndices()[i].length;j+= 1){
				    if(isVolume.booleanValue()){
					    ssi.spaceWeight[i][j] = myMesh.calculateMeshElementVolumeFromVolumeIndex(timeSeriesJobSpec.getIndices()[i][j]);
				    }else{//assume membrane
					    double area = myMesh.getMembraneElements()[timeSeriesJobSpec.getIndices()[i][j]].getArea();
					    if(area == cbit.vcell.solvers.MembraneElement.AREA_UNDEFINED){
					    	ssi.bWeightsValid = false;
					    	break;
					    }
					    ssi.spaceWeight[i][j] = area;
				    }
				    ssi.totalSpace[i]+= ssi.spaceWeight[i][j];
			    }
		    }
		    if(!ssi.bWeightsValid){
			    break;
		    }
	    }
    //}

    //if(ssi.bWeightsValid){
	    return ssi;
    //}else{
	    //return null;
    //}
}


/**
 * Insert the method's description here.
 * Creation date: (2/16/2006 12:28:29 PM)
 */
private cbit.util.TimeSeriesJobResults calculateStatisticsFromWhole(
	TimeSeriesJobSpec timeSeriesJobSpec,
    double[][][] timeSeriesFormatedValuesArr,
    double[] desiredTimeValues,
    SpatialStatsInfo spatialStatsInfo) throws Exception{

    if(timeSeriesJobSpec.isCalcTimeStats()){
	    double[][] timeMinArr = null;
	    double[][] timeMaxArr = null;
	    double[][] timeMeanArr = null;
	    timeMinArr = new double[timeSeriesJobSpec.getVariableNames().length][];
	    timeMaxArr = new double[timeSeriesJobSpec.getVariableNames().length][];
	    timeMeanArr = new double[timeSeriesJobSpec.getVariableNames().length][];
	    double val=0;
	    for(int i=0;i<timeSeriesFormatedValuesArr.length;i+= 1){
		    timeMinArr[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    timeMaxArr[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    timeMeanArr[i] = new double[timeSeriesJobSpec.getIndices()[i].length];
		    for(int j=1;j<timeSeriesFormatedValuesArr[i].length;j+= 1){//skip index 0 (has times)
			    double min = Double.POSITIVE_INFINITY;
			    double max = Double.NEGATIVE_INFINITY;
			    double mean = 0;
			    for(int k=0;k<desiredTimeValues.length;k+= 1){
				    val = timeSeriesFormatedValuesArr[i][j][k];
				    if(val < min){min=val;}
				    if(val > max){max=val;}
				    mean+= val;
			    }
			    mean/= desiredTimeValues.length;
			    timeMinArr[i][j-1] = min;
			    timeMaxArr[i][j-1] = max;
			    timeMeanArr[i][j-1] = mean;
		    }
	    }
	    if(!timeSeriesJobSpec.isCalcSpaceStats()){//No space stats
	        return new cbit.util.TSJobResultsTimeStats(
	            timeSeriesJobSpec.getVariableNames(),
	            timeSeriesJobSpec.getIndices(),
	            desiredTimeValues,
	            timeMinArr,timeMaxArr,timeMeanArr);
	    }else {
		    double[] timeSpaceStatsMin = new double[timeSeriesFormatedValuesArr.length];
		    double[] timeSpaceStatsMax = new double[timeSeriesFormatedValuesArr.length];
		    double[] timeSpaceStatsUnweightedMean = new double[timeSeriesFormatedValuesArr.length];
		    double[] timeSpaceStatsWeightedMean = new double[timeSeriesFormatedValuesArr.length];
		    for(int i=0;i<timeSeriesFormatedValuesArr.length;i+= 1){
			    double min = Double.POSITIVE_INFINITY;
			    double max = Double.NEGATIVE_INFINITY;
			    double mean = 0;
			    double wmean = 0;
			    for(int j=0;j<timeSeriesJobSpec.getIndices()[i].length;j+= 1){
				    if(timeMinArr[i][j] < min){min=timeMinArr[i][j];}
				    if(timeMaxArr[i][j] > max){max=timeMaxArr[i][j];}
				    mean+= timeMeanArr[i][j];
				    if(spatialStatsInfo.bWeightsValid){wmean+= timeMeanArr[i][j]*spatialStatsInfo.spaceWeight[i][j];}
			    }
			    mean/= timeSeriesFormatedValuesArr[i].length;
			    if(spatialStatsInfo.bWeightsValid){wmean/= spatialStatsInfo.totalSpace[i];}
			    
			    timeSpaceStatsMin[i] = min;
			    timeSpaceStatsMax[i] = max;
			    timeSpaceStatsUnweightedMean[i] = mean;
			    timeSpaceStatsWeightedMean[i] = wmean;
		    }
	        return new cbit.util.TSJobResultsTimeStats(
	            timeSeriesJobSpec.getVariableNames(),
	            timeSeriesJobSpec.getIndices(),
	            desiredTimeValues,
	            timeSpaceStatsMin,timeSpaceStatsMax,timeSpaceStatsUnweightedMean,(spatialStatsInfo.bWeightsValid?timeSpaceStatsWeightedMean:null));
	    }
    }else if(timeSeriesJobSpec.isCalcSpaceStats()){
	    
	    double val=0;
		
	    double[][] spaceStatsMin = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsMax = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsUnweightedMean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsWeightedMean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsUnweightedSum = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    double[][] spaceStatsWeightedSum = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
	    for(int k=0;k<desiredTimeValues.length;k+= 1){//times
		    for(int i=0;i<timeSeriesFormatedValuesArr.length;i+= 1){//Variable names
			    double min = Double.POSITIVE_INFINITY;
			    double max = Double.NEGATIVE_INFINITY;
			    double mean = 0;
			    double wmean = 0;
			    double sum = 0;
			    double wsum = 0;
			    for(int j=1;j<timeSeriesFormatedValuesArr[i].length;j+= 1){//index
				    val = timeSeriesFormatedValuesArr[i][j][k];
				    if(val < min){min=val;}
				    if(val > max){max=val;}
				    sum+= val;
				    if(spatialStatsInfo.bWeightsValid){wsum+= val*spatialStatsInfo.spaceWeight[i][j-1];}
			    }
			    mean = sum/timeSeriesJobSpec.getIndices()[i].length;
			    if(spatialStatsInfo.bWeightsValid){wmean = wsum/spatialStatsInfo.totalSpace[i];}

			    spaceStatsMin[i][k] = min;
			    spaceStatsMax[i][k] = max;
			    spaceStatsUnweightedMean[i][k] = mean;
			    spaceStatsWeightedMean[i][k] = wmean;
			    spaceStatsUnweightedSum[i][k] = sum;
			    spaceStatsWeightedSum[i][k] = wsum;
		    }
	    }
        return new cbit.util.TSJobResultsSpaceStats(
            timeSeriesJobSpec.getVariableNames(),
            timeSeriesJobSpec.getIndices(),
            desiredTimeValues,
            spaceStatsMin,spaceStatsMax,
            spaceStatsUnweightedMean,
            (spatialStatsInfo.bWeightsValid?spaceStatsWeightedMean:null),
            spaceStatsUnweightedSum,
            (spatialStatsInfo.bWeightsValid?spaceStatsWeightedSum:null),
            (spatialStatsInfo.bWeightsValid?spatialStatsInfo.totalSpace:null));
    }

    throw new IllegalArgumentException("Couldn't determine format of data to return");
}




private double interpolateVolDataValToMemb(CartesianMesh mesh,int membraneIndex,SimDataHolder simDataHolder,boolean isInside,boolean IsRegion){
	
	VolumeIndexNearFar volIndexNearFar = interpolateFindNearFarIndex(mesh, membraneIndex, isInside,IsRegion);
	if(volIndexNearFar.volIndexFar == -1){
		return simDataHolder.getData()[volIndexNearFar.volIndexNear];
	}
	return VolumeIndexNearFar.interpolate(simDataHolder.getData()[volIndexNearFar.volIndexNear], simDataHolder.getData()[volIndexNearFar.volIndexFar]);
	
}
private VolumeIndexNearFar interpolateFindNearFarIndex(CartesianMesh mesh,int membraneIndex,boolean isInside,boolean isRegion){
	int volIndexNear = -1;
	int volIndexFar = -1;
	if(isInside){
		volIndexNear = mesh.getMembraneElements()[membraneIndex].getInsideVolumeIndex();
		volIndexFar = volIndexNear+(volIndexNear-mesh.getMembraneElements()[membraneIndex].getOutsideVolumeIndex());
	}else{
		volIndexNear = mesh.getMembraneElements()[membraneIndex].getOutsideVolumeIndex();
		volIndexFar = volIndexNear+(volIndexNear-mesh.getMembraneElements()[membraneIndex].getInsideVolumeIndex());
	}
	//Check if totally out of bounds
	if(volIndexFar < 0 || volIndexFar > mesh.getNumVolumeElements()){
		volIndexFar = -1;
	}else{
		//Check if index wrapped
		CoordinateIndex coordFar = mesh.getCoordinateIndexFromVolumeIndex(volIndexFar);
		CoordinateIndex coordNear = mesh.getCoordinateIndexFromVolumeIndex(volIndexNear);
		if( Math.abs(coordFar.x-coordNear.x) > 1 ||
			Math.abs(coordFar.y-coordNear.y) > 1 ||
			Math.abs(coordFar.z-coordNear.z) > 1
		){
			volIndexFar = -1;
		}else{
			//Check if in same region
			if(mesh.getVolumeRegionIndex(volIndexNear) != mesh.getVolumeRegionIndex(volIndexFar)){
				volIndexFar = -1;
			}			
		}
	}
	volIndexNear = (isRegion?mesh.getVolumeRegionIndex(volIndexNear):volIndexNear);
	volIndexFar = (volIndexFar == -1?-1:(isRegion?mesh.getVolumeRegionIndex(volIndexFar):volIndexFar));
	return new VolumeIndexNearFar(volIndexNear,volIndexFar);
}

/**
 * Insert the method's description here.
 * Creation date: (10/13/00 9:13:52 AM)
 * @return cbit.vcell.simdata.SimDataBlock
 * @param user cbit.vcell.server.User
 * @param simResults cbit.vcell.simdata.SimResults
 * @param function cbit.vcell.math.Function
 * @param time double
 */
private SimDataBlock evaluateFunction(
	final VCDataIdentifier vcdID, 
	VCData simData, 
	AnnotatedFunction function, 
	double time)
	throws ExpressionException, DataAccessException, IOException, MathException {

	Expression exp = fieldFunctionSubstitution(vcdID, function);
		
	//
	// get Dependent datasets
	//
	// variables are indexed by a number, t=0, x=1, y=2, z=3, a(i) = 4+i where a's are other variables
	// these variables
	//
	String[] dependentIDs = exp.getSymbols();
	Vector<SimDataHolder> dataSetList = new Vector<SimDataHolder>();
	Vector<DataSetIdentifier> dependencyList = new Vector<DataSetIdentifier>();
	int varIndex = TXYZ_OFFSET;
	int dataLength = 0;
	long lastModified = 0;
	VariableType variableType = null;
	for (int i = 0; dependentIDs!=null && i < dependentIDs.length; i++) {
		SymbolTableEntry ste = exp.getSymbolBinding(dependentIDs[i]);
		if (ste instanceof DataSetIdentifier) {
			DataSetIdentifier dsi = (DataSetIdentifier) ste;
			dependencyList.addElement(dsi);
			dsi.setIndex(varIndex++);
			if (dsi.getName().endsWith("_OUTSIDE") || dsi.getName().endsWith("_INSIDE")){
				String volVarName = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
				SimDataBlock simDataBlock = getSimDataBlock(vcdID, volVarName, time);
				lastModified = simDataBlock.getPDEDataInfo().getTimeStamp();
				//
				// if inside/outside volume element dependent, then can only be a membrane type 
				//
				if (simDataBlock.getVariableType().equals(VariableType.VOLUME)){
					variableType = VariableType.MEMBRANE;
					dataLength = getMesh(vcdID).getMembraneElements().length;
				//
				// if inside/outside volume element dependent, then can only be a membrane type 
				//
				}else if (simDataBlock.getVariableType().equals(VariableType.VOLUME_REGION) && variableType==null){
					variableType = VariableType.MEMBRANE_REGION;
					dataLength = getMesh(vcdID).getNumMembraneRegions();
				}
				dataSetList.addElement(simDataBlock);
			}else{	
				SimDataBlock simDataBlock = getSimDataBlock(vcdID, dsi.getName(), time);
				if (variableType==null || simDataBlock.getVariableType().isExpansionOf(variableType)) {
					lastModified = simDataBlock.getPDEDataInfo().getTimeStamp();
					dataLength = simDataBlock.getData().length;
					variableType = simDataBlock.getVariableType();
				}
				dataSetList.addElement(simDataBlock);
			}
		} else if (ste instanceof ReservedVariable) {
			ReservedVariable rv = (ReservedVariable) ste;
			if (rv.isTIME()) {
				rv.setIndex(0);
			} else if (rv.isX()) {
				rv.setIndex(1);
			} else if (rv.isY()) {
				rv.setIndex(2);
			} else if (rv.isZ()) {
				rv.setIndex(3);
			}
		}else if (ste instanceof FieldDataParameterVariable){
			//Field Data
			((FieldDataParameterVariable)ste).setIndex(varIndex++);
			final double[] steResampledFieldData =
				((FieldDataParameterVariable)ste).getResampledFieldData();
			final VariableType newVariableType =
				(steResampledFieldData.length == getMesh(vcdID).getNumVolumeElements()?
							VariableType.VOLUME:
								(steResampledFieldData.length == getMesh(vcdID).getNumMembraneElements()?
										VariableType.MEMBRANE:null)
				);
			if(newVariableType == null){
				throw new DataAccessException("Couldn't determine VariableType for FieldData");
			}
			if(variableType != null && !variableType.equals(newVariableType)){
				throw new DataAccessException("Incompatible VariableType for FieldData");
			}
			SimDataHolder newSimDataHolder =
				new SimDataHolder(){
					public double[] getData() {
						return steResampledFieldData;
					}
					public VariableType getVariableType() {
						return newVariableType;
					}
			};
			dataSetList.addElement(newSimDataHolder);
			dependencyList.add(new DataSetIdentifier(ste.getName(), newVariableType));
			if(variableType == null){
				variableType = newVariableType;
				dataLength = newSimDataHolder.getData().length;
			}
		}
	}	       
	       
	if (dataLength <= 0) {
		log.alert("dependencies for function '"+function+"' not found, assuming datalength of volume");
		try {
			dataLength = getMesh(vcdID).getDataLength(VariableType.VOLUME);
			variableType = VariableType.VOLUME;
		}catch (MathException e){
			log.exception(e);
			throw new RuntimeException("MathException, cannot determine domain for function '"+function+"'");
		}catch (FileNotFoundException e){
			log.exception(e);
			throw new RuntimeException("Mesh not found, cannot determine domain for function '"+function+"'");
		}
	}

	
	//
	//Gradient Info for special processing
	//
	boolean isGrad = exp.hasGradient();
	if(isGrad && !variableType.equals(VariableType.VOLUME)){
		throw new DataAccessException("Gradient function is not implemented for datatype "+variableType.getTypeName());
	}
	double args[] = new double[varIndex+(isGrad?12*varIndex:0)];
	double data[] = new double[dataLength];
	args[0] = time; // time
	args[1] = 0.0; // x
	args[2] = 0.0; // y
	args[3] = 0.0; // z
	CartesianMesh mesh = getMesh(vcdID);
	for (int i = 0; i < dataLength; i++) {
		//
		// initialize argments to expression
		//
		if (variableType.equals(VariableType.VOLUME)){
			Coordinate coord = mesh.getCoordinateFromVolumeIndex(i);
			args[1] = coord.getX();
			args[2] = coord.getY();
			args[3] = coord.getZ();
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				SimDataHolder simDataHolder = dataSetList.elementAt(j);
				if (simDataHolder.getVariableType().equals(VariableType.VOLUME)){
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[i];
				}else if (simDataHolder.getVariableType().equals(VariableType.VOLUME_REGION)){
					int volumeIndex = mesh.getVolumeRegionIndex(i);
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[volumeIndex];
				}
			}
			if(isGrad){
				getSpatialNeighborData(mesh,i,varIndex,time,dataSetList,args);
			}
		}else if (variableType.equals(VariableType.VOLUME_REGION)){
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				SimDataHolder simDataHolder = dataSetList.elementAt(j);
				if (simDataHolder.getVariableType().equals(VariableType.VOLUME_REGION)){
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[i];
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE)){
			Coordinate coord = mesh.getCoordinateFromMembraneIndex(i);
			args[1] = coord.getX();
			args[2] = coord.getY();
			args[3] = coord.getZ();
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				SimDataHolder simDataHolder = dataSetList.elementAt(j);
				if (simDataHolder.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_INSIDE")){
					args[TXYZ_OFFSET + j] = interpolateVolDataValToMemb(mesh,i,simDataHolder,true,false);//simDataHolder.getData()[volInsideIndex];
				}else if (simDataHolder.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_OUTSIDE")){
					args[TXYZ_OFFSET + j] = interpolateVolDataValToMemb(mesh,i,simDataHolder,false,false);//simDataHolder.getData()[volOutsideIndex];
				}else if (simDataHolder.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){
					args[TXYZ_OFFSET + j] = interpolateVolDataValToMemb(mesh,i,simDataHolder,true,true);//simDataHolder.getData()[volRegionIndex];
				}else if (simDataHolder.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){
					args[TXYZ_OFFSET + j] = interpolateVolDataValToMemb(mesh,i,simDataHolder,false,true);//simDataHolder.getData()[volRegionIndex];
				}else if (simDataHolder.getVariableType().equals(VariableType.MEMBRANE)){
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[i];
				}else if (simDataHolder.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(i);
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[memRegionIndex];
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE_REGION)){
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				SimDataHolder simDataHolder = dataSetList.elementAt(j);
				if (simDataHolder.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){
					//
					// find "inside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==i){
							args[TXYZ_OFFSET + j] = interpolateVolDataValToMemb(mesh,i,simDataHolder,true,true);
							break;
						}
					}
				}else if (simDataHolder.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){
					//
					// find "outside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==i){
							args[TXYZ_OFFSET + j] = interpolateVolDataValToMemb(mesh,i,simDataHolder,false,true);
							break;
						}
					}
				}else if (simDataHolder.getVariableType().equals(VariableType.MEMBRANE)){
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[i];
				}else if (simDataHolder.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(i);
					args[TXYZ_OFFSET + j] = simDataHolder.getData()[memRegionIndex];
				}
			}
		}
		try {
			data[i] = exp.evaluateVector(args);
		}catch (DivideByZeroException e){
			System.out.println("DataSetControllerImpl.evaluateFunction(): DivideByZero "+e.getMessage());
			data[i] = Double.POSITIVE_INFINITY;
		}
	}

	PDEDataInfo pdeDataInfo = new PDEDataInfo(vcdID.getOwner(), vcdID.getID(), function.getName(), time, lastModified);
	if (data != null) {
		return new SimDataBlock(pdeDataInfo, data, variableType);
	} else {
		return null;
	}
}



public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec)
	throws ObjectNotFoundException{

	if(fieldDataFileOperationSpec.opType == FieldDataFileOperationSpec.FDOS_COPYSIM){
		Vector<File> removeFilesIfErrorV = new Vector<File>();
		try{
			int simJobIndex = fieldDataFileOperationSpec.sourceSimParamScanJobIndex;
			//Determine style so file names can be constructed properly
			VCSimulationDataIdentifier sourceSimDataID =
				new VCSimulationDataIdentifier(
						new VCSimulationIdentifier(
								fieldDataFileOperationSpec.sourceSimDataKey,
								fieldDataFileOperationSpec.sourceOwner),
						simJobIndex);
			
			boolean isOldStyle =
				(getVCData(sourceSimDataID).getResultsInfoObject() instanceof VCSimulationDataIdentifierOldStyle);
			//
			//log,mesh,zip,func
			//
			KeyValue origSimKey = fieldDataFileOperationSpec.sourceSimDataKey;
			File sourceDir = new File(primaryRootDirectory,fieldDataFileOperationSpec.sourceOwner.getName());			
			File meshFile_orig = new File(sourceDir,ExternalDataIdentifier.createCanonicalMeshFileName(origSimKey,simJobIndex,isOldStyle));
			File funcFile_orig = new File(sourceDir,ExternalDataIdentifier.createCanonicalFunctionsFileName(origSimKey,simJobIndex,isOldStyle));
			File fdLogFile_orig = new File(sourceDir,ExternalDataIdentifier.createCanonicalSimLogFileName(origSimKey,simJobIndex,isOldStyle));
			File zipFile_orig = new File(sourceDir,ExternalDataIdentifier.createCanonicalSimZipFileName(origSimKey,0,simJobIndex,isOldStyle));
			if(!(meshFile_orig.exists() && funcFile_orig.exists() && fdLogFile_orig.exists() && zipFile_orig.exists())){
				throw new RuntimeException("Couldn't find all of the files required to copy sim");
			}
	
			File userDir = getPrimaryUserDir(fieldDataFileOperationSpec.owner, true);
			File meshFile_new = new File(userDir,ExternalDataIdentifier.createCanonicalMeshFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
			File funcFile_new = new File(userDir,ExternalDataIdentifier.createCanonicalFunctionsFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
			File fdLogFile_new = new File(userDir,ExternalDataIdentifier.createCanonicalSimLogFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
			File zipFile_new = new File(userDir,ExternalDataIdentifier.createCanonicalSimZipFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,0,false));
			if(meshFile_new.exists() || funcFile_new.exists() || fdLogFile_new.exists() || zipFile_new.exists()){
				throw new RuntimeException("File names required for new Field Data already exist on server");
			}

			removeFilesIfErrorV.add(funcFile_new);
			removeFilesIfErrorV.add(meshFile_new);
			removeFilesIfErrorV.add(fdLogFile_new);
			//Simple copy of mesh and funcfile because they do not have to be changed
			FileUtils.copyFile(meshFile_orig, meshFile_new, false, false, 8*1024);
			FileUtils.copyFile(funcFile_orig, funcFile_new, false, false, 8*1024);
			
			//Copy Log file and replace original simID with ExternalDataIdentifier id
	        BufferedReader reader = null;
	        BufferedWriter writer = null;
	        try{
		        StringBuffer fileData = new StringBuffer(1000);
		        reader = new BufferedReader(new FileReader(fdLogFile_orig));
		        char[] buf = new char[1024];
		        int numRead=0;
		        while((numRead=reader.read(buf)) != -1){
		            String readData = String.valueOf(buf, 0, numRead);
		            fileData.append(readData);
		            buf = new char[1024];
		        }
		        reader.close();
		        String origLog = fileData.toString();
		        String newLogStr;
	        	String replace_new =
	        		ExternalDataIdentifier.createSimIDWithJobIndex(
	        				fieldDataFileOperationSpec.specEDI.getKey(),
	        				FieldDataFileOperationSpec.JOBINDEX_DEFAULT, false);
		        if(isOldStyle){
		        	String replace_orig =
		        		ExternalDataIdentifier.createSimIDWithJobIndex(origSimKey, 0, true);
			        newLogStr = origLog.replaceAll(replace_orig, replace_new);	        	
		        }else{
		        	String replace_orig =
		        		ExternalDataIdentifier.createSimIDWithJobIndex(
		        				origSimKey,
		        				fieldDataFileOperationSpec.sourceSimParamScanJobIndex, false);
			        newLogStr= origLog.replaceAll(replace_orig, replace_new);	        	
		        }
		        writer = new BufferedWriter(new FileWriter(fdLogFile_new));
		        writer.write(newLogStr);
		        writer.close();
	        }finally{
	        	try{if(reader != null){reader.close();}}catch(Exception e){/*ignore*/};
		        try{if(writer != null){writer.close();}}catch(Exception e){/*ignore*/};
	        }
	        
	        //
	        //Copy zip file and rename entries
	        //
	        int zipIndex = 0;
	        while(true){//Loop because there might be more than 1 zip file for large datasets
				zipFile_orig = new File(sourceDir,ExternalDataIdentifier.createCanonicalSimZipFileName(origSimKey,zipIndex,simJobIndex,isOldStyle));
				if(!zipFile_orig.exists()){
					//done
					break;
				}
				zipFile_new = new File(userDir,ExternalDataIdentifier.createCanonicalSimZipFileName(fieldDataFileOperationSpec.specEDI.getKey(),zipIndex,0,false));
				if(zipFile_new.exists()){
					throw new DataAccessException("new zipfile name "+zipFile_new.getAbsolutePath()+" already exists");
				}
				removeFilesIfErrorV.add(zipFile_new);
				
				ZipFile inZipFile = null;
		        InputStream zis = null;
		        ZipOutputStream zos = null;
		        try{
		        	inZipFile = new ZipFile(zipFile_orig);;
			        zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFile_new)));
			        Enumeration<? extends ZipEntry> zipEntryEnum = inZipFile.entries();
			        while(zipEntryEnum.hasMoreElements()){
			        	ZipEntry zeIN = zipEntryEnum.nextElement();
			        	byte[] zdataIN = new byte[(int)zeIN.getSize()];
			        	int num = 0;
			        	int numTotal = 0;
			        	zis = inZipFile.getInputStream(zeIN);
//			    long startTime = System.currentTimeMillis();
			        	while((num = zis.read(zdataIN, numTotal, zdataIN.length-numTotal)) != -1 && numTotal != zdataIN.length){
			        		numTotal+= num;
			        	}
//			    System.out.println("zipread time="+((System.currentTimeMillis()-startTime)/1000.0));
			        	zis.close();
			        	String newName;
			        	String replace_new =
			        		ExternalDataIdentifier.createSimIDWithJobIndex(
			        				fieldDataFileOperationSpec.specEDI.getKey(),
			        				FieldDataFileOperationSpec.JOBINDEX_DEFAULT, false);
				        if(isOldStyle){
				        	String replace_orig =
				        		ExternalDataIdentifier.createSimIDWithJobIndex(origSimKey, 0, true);
				        	newName = zeIN.getName().replaceAll(replace_orig, replace_new);	        	
				        }else{
				        	String replace_orig =
				        		ExternalDataIdentifier.createSimIDWithJobIndex(
				        				origSimKey,
				        				fieldDataFileOperationSpec.sourceSimParamScanJobIndex, false);
				        	newName = zeIN.getName().replaceAll(replace_orig, replace_new);	        	
				        }
			        	ZipEntry zeOUT = new ZipEntry(newName);
			        	zeOUT.setComment(zeIN.getComment());
			        	zeOUT.setCompressedSize(zeIN.getCompressedSize());
			        	zeOUT.setCrc(zeIN.getCrc());
			        	zeOUT.setExtra(zeIN.getExtra());
			        	zeOUT.setMethod(zeIN.getMethod());
			        	zeOUT.setSize(zeIN.getSize());
			        	zeOUT.setTime(zeIN.getTime());
//			    startTime = System.currentTimeMillis();
			        	zos.putNextEntry(zeOUT);
			        	zos.write(zdataIN, 0, zdataIN.length);
//				System.out.println("zipwrite time="+((System.currentTimeMillis()-startTime)/1000.0)+"\n");
			        }
		        }finally{
		        	try{if(zis != null){zis.close();}}catch(Exception e){/*ignore*/};
			        try{if(zos != null){zos.close();}}catch(Exception e){/*ignore*/};
		        }
		        zipIndex+= 1;
	        }
	        //Now see if we can read what we just wrote
			return fieldDataFileOperation(
					FieldDataFileOperationSpec.
						createInfoFieldDataFileOperationSpec(
							fieldDataFileOperationSpec.specEDI.getKey(),
							fieldDataFileOperationSpec.owner,
							FieldDataFileOperationSpec.JOBINDEX_DEFAULT));
		}catch(Exception e){
			e.printStackTrace();
			try{
				for(int i=0;i<removeFilesIfErrorV.size();i+= 1){
					removeFilesIfErrorV.elementAt(i).delete();
				}
			}catch(Throwable e2){
				//ignore, we tried to cleanup
			}
			throw new RuntimeException("Error copying sim data to new Field Data\n"+e.getMessage());
		}

	}else if(fieldDataFileOperationSpec.opType == FieldDataFileOperationSpec.FDOS_ADD){
		if(fieldDataFileOperationSpec.cartesianMesh == null){
			throw new RuntimeException("Field Data Operation 'ADD' cartesianMesh cannot be null");
		}
		if(fieldDataFileOperationSpec.times == null || fieldDataFileOperationSpec.times.length == 0){
			throw new RuntimeException("Field Data Operation 'ADD' times cannot be null");
		}
		if(fieldDataFileOperationSpec.times[0] != 0){
			throw new RuntimeException("Field Data Operation 'ADD' first time must be 0.0");
		}
		if(fieldDataFileOperationSpec.varNames == null || fieldDataFileOperationSpec.varNames.length == 0){
			throw new RuntimeException("Field Data Operation 'ADD' variable names cannot be null");
		}
		if(fieldDataFileOperationSpec.shortSpecData == null ||
				fieldDataFileOperationSpec.shortSpecData.length != fieldDataFileOperationSpec.times.length ||
				fieldDataFileOperationSpec.shortSpecData[0].length != fieldDataFileOperationSpec.varNames.length
				){
			throw new RuntimeException(
					"Field Data Operation 'ADD' data dimension does not match\n"+
					"times and variable names array lengths");
		}
		if(fieldDataFileOperationSpec.variableTypes == null || fieldDataFileOperationSpec.variableTypes.length == 0){
			throw new RuntimeException("Field Data Operation 'ADD' variable types cannot be null");
		}
		if(fieldDataFileOperationSpec.variableTypes.length != fieldDataFileOperationSpec.varNames.length){
			throw new RuntimeException("Field Data Operation 'ADD' variable types count does not match variable names count");
		}

		//byte[][][] allData = fieldDataFileOperationSpec.specData;
		double[] times = fieldDataFileOperationSpec.times;
		ExternalDataIdentifier dataset = fieldDataFileOperationSpec.specEDI;
		String[] vars = fieldDataFileOperationSpec.varNames;
		VariableType[] varTypes = fieldDataFileOperationSpec.variableTypes;
		File userDir = null;
		try{
			userDir = getPrimaryUserDir(fieldDataFileOperationSpec.owner, true);
		}catch(FileNotFoundException e){
			throw new RuntimeException("Couldn't create new user directory on server");
		}
		
		//convert short to double
		double[][][] convertedData = new double[times.length][vars.length][];
		for(int i=0;i<times.length;i+= 1){
			for(int j=0;j<vars.length;j+= 1){
				if (fieldDataFileOperationSpec.shortSpecData!=null){
					convertedData[i][j] = new double[fieldDataFileOperationSpec.shortSpecData[i][j].length];
					for (int k = 0; k < fieldDataFileOperationSpec.shortSpecData[i][j].length; k += 1) {
						convertedData[i][j][k] = (double) (((int)fieldDataFileOperationSpec.shortSpecData[i][j][k]) & 0x0000FFFF);
//						convertedData[i][j][k] = fieldDataFileOperationSpec.shortSpecData[i][j][k];
					}
				}else{
					throw new RuntimeException("no pixel data found");
				}
			}
		}

		//Write Log file
		File fdLogFile =
			new File(userDir,
					ExternalDataIdentifier.createCanonicalSimLogFileName(
							dataset.getKey(),0,false));
		PrintStream ps = null;
		File zipFile =
			new File(userDir,
					ExternalDataIdentifier.createCanonicalSimZipFileName(
							dataset.getKey(),0,0,false));
		Vector<String> simFileNamesV = new Vector<String>();
		try{
			if(!fdLogFile.createNewFile()){
				throw new Exception("File.createNewFile() returned null");
			}
			ps = new PrintStream(fdLogFile);
			for(int i=0;i<times.length;i+= 1){
				String simFilename =
					ExternalDataIdentifier.createCanonicalSimFilePathName(
							dataset.getKey(), i,0,false);
				simFileNamesV.add(simFilename);
				ps.println(i+"\t"+simFilename+"\t"+zipFile.getAbsolutePath()+"\t"+times[i]+"");
			}
			ps.flush();
		}catch(Exception e){
			throw new RuntimeException("Couldn't create log file "+fdLogFile.getAbsolutePath()+"\n"+e.getMessage());
		}finally{
			if(ps != null){ps.close();}
		}

		//Write zipFile
		java.util.zip.ZipOutputStream zipOut = null;
		try{
			java.io.BufferedOutputStream bout = new java.io.BufferedOutputStream(new java.io.FileOutputStream(zipFile));
			zipOut = new java.util.zip.ZipOutputStream(bout);
		    for(int t=0;t<times.length;t+= 1){
				java.io.File temp = java.io.File.createTempFile("temp",null);
				cbit.vcell.simdata.DataSet.writeNew(
					temp,vars,varTypes,fieldDataFileOperationSpec.isize,convertedData[t]);
				java.util.zip.ZipEntry zipEntry =
					new java.util.zip.ZipEntry(simFileNamesV.get(t));
				zipOut.putNextEntry(zipEntry);
				//----------------------------
				java.io.BufferedInputStream in = new java.io.BufferedInputStream(new java.io.FileInputStream(temp));
				byte[] bytes = new byte[65536];
				try {
					int b = in.read(bytes);
					while (b != -1) {
						zipOut.write(bytes, 0, b);
						b = in.read(bytes);
					}
				}catch(IOException e){
					throw new Exception("Error writing zip file bytes");
				}finally {
					//cleanup
					in.close();
					temp.delete();
				}
				//----------------------------
		    }
		}catch(Exception e){
			throw new RuntimeException("Couldn't create zip file "+zipFile.getAbsolutePath()+"\n"+e.getMessage());
		}finally{
			try{
				zipOut.close();
			}catch(IOException e){
				e.printStackTrace();
				//ignore
			}
		}
		//Write Mesh file
		FileOutputStream fos = null;
		File meshFile = null;
		try {
			CartesianMesh mesh = fieldDataFileOperationSpec.cartesianMesh;
			 meshFile = new File(userDir,ExternalDataIdentifier.createCanonicalMeshFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
			fos = new FileOutputStream(meshFile);
			mesh.write(new PrintStream(fos));
		} catch (IOException e) {
			e.printStackTrace();
			throw new RuntimeException("Error writing mesh file "+meshFile.getAbsolutePath()+"\n"+e.getMessage());
		}finally{
			try {
				if(fos != null){
					fos.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
				//ignore
			}
		}
		
		//Write Functionfile file
		PrintStream ps2 = null;
		File funcFile = null;
		try {
			funcFile = new File(userDir,ExternalDataIdentifier.createCanonicalFunctionsFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
			FileOutputStream fos2 = new FileOutputStream(funcFile);
			ps2 =new PrintStream(fos2);
			ps2.println(
					"##---------------------------------------------"+"\n"+
					"##  "+funcFile.getAbsolutePath()+"\n"+
					"##---------------------------------------------"+"\n"
					);
			ps2.flush();
			ps2.close();
		} catch (IOException e) {
			e.printStackTrace();
			throw new RuntimeException("Error writing function file "+funcFile.getAbsolutePath()+"\n"+e.getMessage());
		}finally{
			if(ps2 != null){
				ps2.close();
			}
		}
		
		try{
			//return Info
			return fieldDataFileOperation(
					FieldDataFileOperationSpec.
						createInfoFieldDataFileOperationSpec(
							fieldDataFileOperationSpec.specEDI.getKey(),
							fieldDataFileOperationSpec.owner,
							FieldDataFileOperationSpec.JOBINDEX_DEFAULT));
		}catch(Exception e){
			e.printStackTrace();
			//ignore
		}
		
	}else if(fieldDataFileOperationSpec.opType == FieldDataFileOperationSpec.FDOS_DELETE){

		File userDir = null;
		try{
			userDir = getPrimaryUserDir(fieldDataFileOperationSpec.specEDI.getOwner(), true);
		}catch(FileNotFoundException e){
			throw new RuntimeException("Couldn't create new user directory on server");
		}
		File fdLogFile =
			new File(userDir,
					ExternalDataIdentifier.createCanonicalSimLogFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
		File fdMeshFile =
			new File(userDir,
					ExternalDataIdentifier.createCanonicalMeshFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
		File fdFunctionFile =
			new File(userDir,
					ExternalDataIdentifier.createCanonicalFunctionsFileName(fieldDataFileOperationSpec.specEDI.getKey(),0,false));
		if(!fdLogFile.delete()){
			System.out.println("Couldn't delete log file "+fdLogFile.getAbsolutePath());
		}
		if(!fdMeshFile.delete()){
			System.out.println("Couldn't delete Mesh file "+fdMeshFile.getAbsolutePath());
		}
		if(!fdFunctionFile.delete()){
			System.out.println("Couldn't delete Functions file "+fdFunctionFile.getAbsolutePath());
		}
		int index = 0;
		while(true){
			File fdZipFile =
				new File(userDir,
						ExternalDataIdentifier.createCanonicalSimZipFileName(fieldDataFileOperationSpec.specEDI.getKey(), index,0,false));
			if(index != 0 && !fdZipFile.exists()){
				break;
			}
			if(!fdZipFile.delete()){
				System.out.println("Couldn't delete zip file "+fdZipFile.getAbsolutePath());
			}
			index+= 1;
		}
		return null;
	}else if(fieldDataFileOperationSpec.opType == FieldDataFileOperationSpec.FDOS_INFO){
		try{
			FieldDataFileOperationResults fdor = new FieldDataFileOperationResults();
			VCDataIdentifier sourceSimDataID =
				new VCSimulationDataIdentifier(
					new VCSimulationIdentifier(
							fieldDataFileOperationSpec.sourceSimDataKey,
							fieldDataFileOperationSpec.sourceOwner),
				fieldDataFileOperationSpec.sourceSimParamScanJobIndex);
			if(sourceSimDataID == null){
				throw new Exception("Field Data Op 'INFO' has no data identifier");
			}
			fdor.dataIdentifierArr =
				getDataIdentifiers(sourceSimDataID);
			CartesianMesh mesh = getMesh(sourceSimDataID);
			fdor.extent = mesh.getExtent();
			fdor.origin = mesh.getOrigin();
			fdor.iSize = new ISize(mesh.getSizeX(),mesh.getSizeY(),mesh.getSizeZ());
			fdor.times = getDataSetTimes(sourceSimDataID);
			return fdor;
		}catch(FileNotFoundException e){
			throw new ObjectNotFoundException("Error FieldDataOp get INFO",e);
		}catch(Exception e){
			throw new RuntimeException("Error FieldDataFileOperationSpec INFO Operation\n"+e.getMessage());
		}
	}
	
	throw new RuntimeException("Field data operation "+fieldDataFileOperationSpec.opType+" unknown.");
}

private Vector<DataSetIdentifier> identifyDataDependencies(AnnotatedFunction function){
	//
	// identify data dependencies
	//
	
	Expression exp = function.getExpression();
	String dependentIDs[] = exp.getSymbols();
	Vector<DataSetIdentifier> dependencyList = new Vector<DataSetIdentifier>();
	//
	// get Dependents
	// variables are indexed by a number, t=0, x=1, y=2, z=3, a(i) = 4+i where a's are other variables
	//
	int varIndex = TXYZ_OFFSET;
	
	for (int i = 0; dependentIDs!=null && i < dependentIDs.length; i++) {
		SymbolTableEntry ste = exp.getSymbolBinding(dependentIDs[i]);
		if (ste instanceof DataSetIdentifier) {
			DataSetIdentifier dsi = (DataSetIdentifier) ste;
			dependencyList.addElement(dsi);
			dsi.setIndex(varIndex++);
		} else if (ste instanceof ReservedVariable) {
			ReservedVariable rv = (ReservedVariable) ste;
			if (rv.isTIME()) {
				rv.setIndex(0);
			} else if (rv.isX()) {
				rv.setIndex(1);
			} else if (rv.isY()) {
				rv.setIndex(2);
			} else if (rv.isZ()) {
				rv.setIndex(3);
			}
		}
	}
	
	return dependencyList;
}
/**
 * Insert the method's description here.
 * Creation date: (10/13/00 9:13:52 AM)
 * @return cbit.vcell.simdata.SimDataBlock
 * @param user cbit.vcell.server.User
 * @param simResults cbit.vcell.simdata.SimResults
 * @param function cbit.vcell.math.Function
 * @param time double
 */
private FunctionIndexes[] findFunctionIndexes(VCDataIdentifier vcdID,AnnotatedFunction function,int[] dataIndexes)
	throws ExpressionException, DataAccessException, IOException, MathException {

	VariableType variableType = function.getFunctionType();
	Vector<DataSetIdentifier> dependencyList = identifyDataDependencies(function);
	int varIndex = TXYZ_OFFSET+dependencyList.size();
	//
	// get Indexes and simFileNames
	//
	Coordinate initCoord = new Coordinate(0,0,0);
	Coordinate[] coords = new Coordinate[dataIndexes.length];
	for(int i=0;i<coords.length;i+= 1){
		coords[i] = initCoord;
	}
	String[] varNames = new String[varIndex-TXYZ_OFFSET];
	String[] simFileVarNames = new String[varNames.length];
	int[][] varIndexes = new int[dataIndexes.length][varNames.length];
	//New data needed for INSIDE-OUTSIDE interpolation
	VolumeIndexNearFar[][] inside_near_far_indexes = new VolumeIndexNearFar[dataIndexes.length][varNames.length];
	VolumeIndexNearFar[][] outside_near_far_indexes = new VolumeIndexNearFar[dataIndexes.length][varNames.length];
	
	CartesianMesh mesh = getMesh(vcdID);
	//
	// initialize argments to expression
	//
	for(int i=0;i<dataIndexes.length;i+= 1){
		coords[i] = mesh.getCoordinateFromVolumeIndex(dataIndexes[i]);

		if (variableType.equals(VariableType.VOLUME)){
			//coord = mesh.getCoordinateFromVolumeIndex(dataIndex);
			coords[i] = mesh.getCoordinateFromVolumeIndex(dataIndexes[i]);
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION)){
					int volumeIndex = mesh.getVolumeRegionIndex(dataIndexes[i]);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = volumeIndex;
				}
			}
		}else if (variableType.equals(VariableType.VOLUME_REGION)){
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME_REGION)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE)){
			//coord = mesh.getCoordinateFromMembraneIndex(dataIndex);
			coords[i] = mesh.getCoordinateFromMembraneIndex(dataIndexes[i]);
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_INSIDE")){		
					int volInsideIndex = mesh.getMembraneElements()[dataIndexes[i]].getInsideVolumeIndex();
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volInsideIndex;
					inside_near_far_indexes[i][j] = interpolateFindNearFarIndex(mesh, dataIndexes[i], true, false);
				}else if (dsi.getVariableType().equals(VariableType.VOLUME) && dsi.getName().endsWith("_OUTSIDE")){					
					int volOutsideIndex = mesh.getMembraneElements()[dataIndexes[i]].getOutsideVolumeIndex();
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volOutsideIndex;
					outside_near_far_indexes[i][j] = interpolateFindNearFarIndex(mesh, dataIndexes[i], false, false);
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){					
					int insideVolumeIndex = mesh.getMembraneElements()[dataIndexes[i]].getInsideVolumeIndex();
					int volRegionIndex = mesh.getVolumeRegionIndex(insideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
					inside_near_far_indexes[i][j] = interpolateFindNearFarIndex(mesh, dataIndexes[i], true, true);
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){					
					int outsideVolumeIndex = mesh.getMembraneElements()[dataIndexes[i]].getOutsideVolumeIndex();
					int volRegionIndex = mesh.getVolumeRegionIndex(outsideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
					outside_near_far_indexes[i][j] = interpolateFindNearFarIndex(mesh, dataIndexes[i], false, true);
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(dataIndexes[i]);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = memRegionIndex;
				}
			}
		}else if (variableType.equals(VariableType.MEMBRANE_REGION)){
			for (int j = 0; j < varIndex - TXYZ_OFFSET; j++) {
				DataSetIdentifier dsi = (DataSetIdentifier)dependencyList.elementAt(j);
				if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_INSIDE")){					
					//
					// find "inside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					int insideVolumeIndex = -1;
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==dataIndexes[i]){
							insideVolumeIndex = mesh.getMembraneElements()[k].getInsideVolumeIndex();
							break;
						}
					}
					int volRegionIndex = mesh.getVolumeRegionIndex(insideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
					inside_near_far_indexes[i][j] = interpolateFindNearFarIndex(mesh, dataIndexes[i], true, true);;
				}else if (dsi.getVariableType().equals(VariableType.VOLUME_REGION) && dsi.getName().endsWith("_OUTSIDE")){					
					//
					// find "outside" volume element index for first membrane element in MembraneRegion 'i'.
					//
					int outsideVolumeIndex = -1;
					for (int k = 0; k < mesh.getMembraneElements().length; k++){
						if (mesh.getMembraneRegionIndex(k)==dataIndexes[i]){
							outsideVolumeIndex = mesh.getMembraneElements()[k].getOutsideVolumeIndex();
							break;
						}
					}
					int volRegionIndex = mesh.getVolumeRegionIndex(outsideVolumeIndex);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName().substring(0,dsi.getName().lastIndexOf("_"));
					varIndexes[i][j] = volRegionIndex;
					outside_near_far_indexes[i][j] = interpolateFindNearFarIndex(mesh, dataIndexes[i], false, true);
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE)){
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = dataIndexes[i];
				}else if (dsi.getVariableType().equals(VariableType.MEMBRANE_REGION)){
					int memRegionIndex = mesh.getMembraneRegionIndex(dataIndexes[i]);
					varNames[j]=dsi.getName();
					simFileVarNames[j] = dsi.getName();
					varIndexes[i][j] = memRegionIndex;
				}
			}
		}
	}

	FunctionIndexes[] fiArr = new FunctionIndexes[dataIndexes.length];
	for(int i=0;i<dataIndexes.length;i+= 1){
		fiArr[i] = new FunctionIndexes(function,coords[i],varNames,simFileVarNames,varIndexes[i],inside_near_far_indexes[i],outside_near_far_indexes[i]/*,insideArgIndex,outsideArgIndex*/);
	}
	return fiArr;
	//
}


private Expression fieldFunctionSubstitution(final VCDataIdentifier vcdID,AnnotatedFunction function)
	throws ExpressionException, DataAccessException, IOException, MathException{
	
	SimResampleInfoProvider simResampleInfoProvider = null;
	
	if(vcdID instanceof VCSimulationDataIdentifier){
		simResampleInfoProvider = ((VCSimulationDataIdentifier)vcdID);
	}else if(vcdID instanceof VCSimulationDataIdentifierOldStyle){
		simResampleInfoProvider = ((VCSimulationDataIdentifierOldStyle)vcdID);
	}else if(vcdID instanceof ExternalDataIdentifier){
		simResampleInfoProvider =
			new SimResampleInfoProvider() {
				public int getJobIndex() {
					return 0;
				}
				public KeyValue getSimulationKey() {
					return ((ExternalDataIdentifier)vcdID).getKey();
				}
				public boolean isParameterScanType() {
					return true;
				}
				public String getID() {
					return ((ExternalDataIdentifier)vcdID).getID();
				}
				public User getOwner() {
					return ((ExternalDataIdentifier)vcdID).getOwner();
				}
		};
	}else{
		return function.getExpression();
	}

	
	
	
	Expression origExpression = function.getExpression();
	FieldFunctionArguments[] fieldfuncArgumentsArr =
		origExpression.getFieldFunctionArguments();
	if(fieldfuncArgumentsArr == null || fieldfuncArgumentsArr.length == 0){
		return origExpression;
	}
	
	String[] origSymbols = origExpression.getSymbols();
	Vector<SymbolTableEntry> originalSymbolTablEntrryV = new Vector<SymbolTableEntry>();
	for (int i = 0; origSymbols!=null && i < origSymbols.length; i++) {
		if(!originalSymbolTablEntrryV.contains(origExpression.getSymbolBinding(origSymbols[i]))){
			originalSymbolTablEntrryV.add(origExpression.getSymbolBinding(origSymbols[i]));
		}
	}
	
	Expression exp = new Expression(origExpression);
	
	//
	//Handle Field Data Function field(...)
	//
	double[][] resampledFieldDatas = null;
	HashMap<String, Integer> substSymbolIndexH =
		new HashMap<String, Integer>();
//	if(fieldfuncArgumentsArr != null && fieldfuncArgumentsArr.length > 0){
		FieldDataIdentifierSpec[] fieldDataIdentifierSpecArr =
			getFieldDataIdentifierSpecs(fieldfuncArgumentsArr,simResampleInfoProvider);
		//Substitute Field Data Functions for simple symbols for lookup-------
		for(int i=0;i<fieldfuncArgumentsArr.length;i+= 1){
			for (int j = 0; j < fieldDataIdentifierSpecArr.length; j++) {
				if(fieldfuncArgumentsArr[i].equals(fieldDataIdentifierSpecArr[j].getFieldFuncArgs())){
					String substFieldName =
						fieldfuncArgumentsArr[i].getFieldName()+"_"+
						fieldfuncArgumentsArr[i].getVariableName()+"_"+
						fieldfuncArgumentsArr[i].getTime().evaluateConstant();
					substFieldName = TokenMangler.fixTokenStrict(substFieldName);
					if(exp.hasSymbol(substFieldName)){
						throw new DataAccessException("Substitute Field data name is not unique");
					}
					String fieldFuncString =
						ExternalDataIdentifier.createCanonicalFieldFunctionSyntax(
							(ExternalDataIdentifier)fieldDataIdentifierSpecArr[j].getExternalDataIdentifier(),
							fieldfuncArgumentsArr[i].getVariableName(),
							fieldfuncArgumentsArr[i].getTime().evaluateConstant(),
							fieldfuncArgumentsArr[i].getTime().evaluateConstant());
					exp.substituteInPlace(new Expression(fieldFuncString), new Expression(substFieldName));
					substSymbolIndexH.put(substFieldName,i);
					break;
				}
			}
		}
		//----------------------------------------------------------------------

		try{
		FVSolver.resampleFieldData(
				fieldDataIdentifierSpecArr,
				getPrimaryUserDir(simResampleInfoProvider.getOwner(), true),
				getMesh(simResampleInfoProvider),
				simResampleInfoProvider,
				getMesh(simResampleInfoProvider).getNumMembraneElements(),
				FVSolver.HESM_KEEP_AND_CONTINUE);
		}catch(SolverException e){
			throw new DataAccessException("Error while resampling Field Data \n" + e.getMessage());
		}
		resampledFieldDatas = new double[fieldfuncArgumentsArr.length][];
		for(int i=0;i<fieldfuncArgumentsArr.length;i+= 1){
//			File resampledFile =
//				new File(getUserDir(vcsdID.getOwner()),
//					vcsdID.getID()+
//					FieldDataIdentifierSpec.getDefaultFieldDataFileNameForSimulation(fieldfuncArgumentsArr[i])
//				);
			File resampledFile =
			new File(
				getPrimaryUserDir(simResampleInfoProvider.getOwner(), true),
				ExternalDataIdentifier.createCanonicalResampleFileName(
					simResampleInfoProvider,
					fieldfuncArgumentsArr[i])
			);
			resampledFieldDatas[i] =
				DataSet.fetchSimData(
					fieldfuncArgumentsArr[i].getVariableName(),
					resampledFile);
		}
//	}
	
	//Rebind all the symbols
	String[] dependentIDs = exp.getSymbols();
	VariableSymbolTable varSymbolTable = new VariableSymbolTable();
	for (int i = 0; dependentIDs!=null && i < dependentIDs.length; i++) {
		SymbolTableEntry newSymbolTableEntry = null;
		for (int j = 0; j < originalSymbolTablEntrryV.size(); j++) {
			if(originalSymbolTablEntrryV.elementAt(j).getName().equals(dependentIDs[i])){
				newSymbolTableEntry = originalSymbolTablEntrryV.elementAt(j);
				break;
			}
		}
		if(newSymbolTableEntry == null ){
			if(substSymbolIndexH.containsKey(dependentIDs[i])){
				int resampledDataIndex = substSymbolIndexH.get(dependentIDs[i]).intValue();
				FieldDataParameterVariable fieldDataParameterVariable =
					new FieldDataParameterVariable(
							dependentIDs[i],
							resampledFieldDatas[resampledDataIndex]);
				newSymbolTableEntry = fieldDataParameterVariable;
			}
		}
		if(newSymbolTableEntry == null){
			throw new DataAccessException("Field Data Couldn't find substituted expression while evaluating function");
		}
		varSymbolTable.addVar(newSymbolTableEntry);
	}
	exp.bindExpression(varSymbolTable);
	
	return exp;
}

private void fireDataJobEventIfNecessary(
		VCDataJobID vcDataJobID,
		int argEventType,
		VCDataIdentifier argVCDataID,
		Double argProgress,
		TimeSeriesJobResults argTSJR,
		Exception argFailedJobExc){
	
	if(vcDataJobID == null || !vcDataJobID.isBackgroundTask()){
		return;
	}
	fireDataJobMessage_private(
		new DataJobEvent(
			vcDataJobID,
			argEventType,
			argVCDataID,
			argProgress,
			argTSJR,argFailedJobExc
		));
			
}
/**
 * Method to support listener events.
 */
private void fireDataJobMessage_private(cbit.rmi.event.DataJobEvent event) {
	if (aDataJobListener == null) {
		return;
	};
	int currentSize = aDataJobListener.size();
	cbit.rmi.event.DataJobListener tempListener = null;
	for (int index = 0; index < currentSize; index++){
		tempListener = (cbit.rmi.event.DataJobListener)aDataJobListener.elementAt(index);
		if (tempListener != null) {
			tempListener.dataJobMessage(event);
		};
	};
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String[]
 */
public DataIdentifier[] getDataIdentifiers(VCDataIdentifier vcdID) throws DataAccessException, IOException, FileNotFoundException {
	log.print("DataSetControllerImpl.getDataIdentifiers("+vcdID.getID()+")");

	VCData simData = getVCData(vcdID);
	//filter names with _INSIDE and _OUTSIDE
	DataIdentifier[] dataIdentifiersIncludingOutsideAndInside = simData.getVarAndFunctionDataIdentifiers();
	Vector<DataIdentifier> v = new Vector<DataIdentifier>();
	for (int i = 0; i < dataIdentifiersIncludingOutsideAndInside.length; i++){
		DataIdentifier di = dataIdentifiersIncludingOutsideAndInside[i];
		if (!di.getName().endsWith("_INSIDE") && !di.getName().endsWith("_OUTSIDE")) {
			v.addElement(di);
		}
	}
	DataIdentifier[] ids = new DataIdentifier[v.size()];
	v.copyInto(ids);
	return ids;
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public double[] getDataSetTimes(VCDataIdentifier vcdID) throws DataAccessException {
	try {
		VCData simData = getVCData(vcdID);
		double times[] = simData.getDataTimes();
		String timeString = "null";
		if (times!=null){
			timeString = String.valueOf(times[0]);
			if (times.length>1){
				timeString += "..."+times[times.length-1];
			}
		}
		log.print("DataSetControllerImpl.getDataSetTimes() returning ["+timeString+"]");
		return times;
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}

private FieldDataIdentifierSpec[] getFieldDataIdentifierSpecs(
		FieldFunctionArguments[] fieldFuncArgumentsArr,VCDataIdentifier vcdID) throws DataAccessException{

	FieldDataIdentifierSpec[] fieldDataIdentifierSpecs = null;
	try{//Try without refreshing from the database
		fieldDataIdentifierSpecs =
			getFieldDataIdentifierSpecs_private(fieldFuncArgumentsArr,vcdID);
	}catch(ObjectNotFoundException onfe){
		//Refresh from database and try once more
		refreshExternalDataIdentifiers();
		fieldDataIdentifierSpecs =
			getFieldDataIdentifierSpecs_private(fieldFuncArgumentsArr,vcdID);
	}
	return fieldDataIdentifierSpecs;
}

private FieldDataIdentifierSpec[] getFieldDataIdentifierSpecs_private(
FieldFunctionArguments[] fieldFuncArgumentsArr,VCDataIdentifier vcdID) throws DataAccessException{

	Vector<ExternalDataIdentifier> userExtDataIdentifiersV = userExtDataIDH.get(vcdID.getOwner());
	if(userExtDataIdentifiersV == null  || userExtDataIdentifiersV.size() < fieldFuncArgumentsArr.length){
		//must refresh
		refreshExternalDataIdentifiers();
		userExtDataIdentifiersV = userExtDataIDH.get(vcdID.getOwner());
	}
	FieldDataIdentifierSpec[] fieldDataIdentifierSpecs =
	new FieldDataIdentifierSpec[fieldFuncArgumentsArr.length];
	Arrays.fill(fieldDataIdentifierSpecs, null);
	for (int i = 0; i < fieldFuncArgumentsArr.length; i++) {
		for (int j = 0; userExtDataIdentifiersV != null && j < userExtDataIdentifiersV.size(); j++) {
			if(fieldFuncArgumentsArr[i].getFieldName().equals(userExtDataIdentifiersV.elementAt(j).getName())){
				fieldDataIdentifierSpecs[i] =
					new FieldDataIdentifierSpec(fieldFuncArgumentsArr[i],userExtDataIdentifiersV.elementAt(j));
				break;
			}
		}
		if(fieldDataIdentifierSpecs[i] == null){
			throw new ObjectNotFoundException(
				"The data locator for Field Function '"+fieldFuncArgumentsArr[i].getFieldName()+"' could not be found.");
		}
	}
	return fieldDataIdentifierSpecs;
}



//private FieldDataIdentifierSpec[] getFieldDataIdentifierSpecs_private(
//		FieldFunctionArguments[] fieldFuncArgumentsArr,VCSimulationDataIdentifier vcsdID) throws DataAccessException{
//	
//	HashMap<ExternalDataIdentifier, Vector<KeyValue>> ExtDataIDAndSimRefsH =
//		userExtDataIDAndsimRefsH.get(vcsdID.getOwner());
//	if(ExtDataIDAndSimRefsH == null  || ExtDataIDAndSimRefsH.size() < fieldFuncArgumentsArr.length){
//		ExtDataIDAndSimRefsH = getExternalDataIdentifiers(vcsdID.getOwner());
//		if(ExtDataIDAndSimRefsH == null || ExtDataIDAndSimRefsH.size() == 0){
//			ExtDataIDAndSimRefsH = null;
//			userExtDataIDAndsimRefsH.remove(vcsdID.getOwner());
//		}else{
//			userExtDataIDAndsimRefsH.put(vcsdID.getOwner(), ExtDataIDAndSimRefsH);
//		}
//	}
//	FieldDataIdentifierSpec[] fieldDataIdentifierSpecs =
//		new FieldDataIdentifierSpec[fieldFuncArgumentsArr.length];
//	Arrays.fill(fieldDataIdentifierSpecs, null);
//	ExternalDataIdentifier[] userExtDataIDArr =
//		ExtDataIDAndSimRefsH.keySet().toArray(new ExternalDataIdentifier[0]);
//	for (int i = 0; i < fieldFuncArgumentsArr.length; i++) {
//		for (int j = 0; j < userExtDataIDArr.length; j++) {
//			if(fieldFuncArgumentsArr[i].getFieldName().equals(userExtDataIDArr[j].getName())){
//				fieldDataIdentifierSpecs[i] =
//					new FieldDataIdentifierSpec(fieldFuncArgumentsArr[i],userExtDataIDArr[j]);
//				break;
//			}
//		}
//		if(fieldDataIdentifierSpecs[i] == null){
//			throw new ObjectNotFoundException("No ExternalDataIdentifier found for Field Function");
//		}
//		Vector<KeyValue> simRefV =
//			ExtDataIDAndSimRefsH.get(fieldDataIdentifierSpecs[i].getExternalDataIdentifier());
//		boolean bFound = false;
//		for(int j=0;j<simRefV.size();j+= 1){
//			if(simRefV.elementAt(j).compareEqual(vcsdID.getSimulationKey())){
//				bFound = true;
//				break;
//			}
//		}
//		if(!bFound){
//			throw new DependencyException(
//					"Field Function '"+fieldFuncArgumentsArr[i].getFieldName()+"' is not allowed in a user-defined\n"+
//					"function for this dataset because the originating simulation has no reference for the function.");
//		}
//	}
//	return fieldDataIdentifierSpecs;
//}

private void refreshExternalDataIdentifiers() throws DataAccessException{

	String dbDriverName = PropertyLoader.getProperty(PropertyLoader.dbDriverName, null);
	String dbConnectURL = PropertyLoader.getProperty(PropertyLoader.dbConnectURL, null);
	String dbSchemaUser = PropertyLoader.getProperty(PropertyLoader.dbUserid, null);
	String dbPassword = PropertyLoader.getProperty(PropertyLoader.dbPassword, null);

	Connection con = null;
	try{
		Class.forName(dbDriverName);
		con = java.sql.DriverManager.getConnection(dbConnectURL,dbSchemaUser,dbPassword);
		con.setReadOnly(true);
		userExtDataIDH =
			FieldDataDBOperationDriver.getAllExternalDataIdentifiers(con);
	}catch(Exception e){
		e.printStackTrace();
		throw new DataAccessException(
				this.getClass().getName()+": Couldn't refresh ExternalDataIdentifiers from database\n"+e.getMessage());
	}finally{
		try{con.close();}catch(Exception e){e.printStackTrace();}
	}
}

//private HashMap<ExternalDataIdentifier, Vector<KeyValue>> getExternalDataIdentifiers(User owner) throws DataAccessException{
//
//	String dbDriverName = PropertyLoader.getProperty(PropertyLoader.dbDriverName, null);
//	String dbConnectURL = PropertyLoader.getProperty(PropertyLoader.dbConnectURL, null);
//	String dbSchemaUser = PropertyLoader.getProperty(PropertyLoader.dbUserid, null);
//	String dbPassword = PropertyLoader.getProperty(PropertyLoader.dbPassword, null);
//
//	Connection con = null;
//	try{
//		Class.forName(dbDriverName);
//		con = java.sql.DriverManager.getConnection(dbConnectURL,dbSchemaUser,dbPassword);
//		return FieldDataDBOperationDriver.getExtDataIDsAndSimRefs(con, owner);
//	}catch(Exception e){
//		throw new DataAccessException(
//				"couldn't get FieldDataIdentifierSpecs from database\n"+e.getMessage());
//	}finally{
//		try{con.close();}catch(Exception e){e.printStackTrace();}
//	}
//}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public AnnotatedFunction[] getFunctions(VCDataIdentifier vcdID) throws DataAccessException, ExpressionBindingException {
	try {
		VCData simData = getVCData(vcdID);
		return simData.getFunctions();
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 */
public boolean getIsODEData(VCDataIdentifier vcdID) throws DataAccessException, IOException, FileNotFoundException {

	VCData simData = getVCData(vcdID);
	return simData.getIsODEData();
	
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.plot.PlotData
 * @param varName java.lang.String
 * @param begin cbit.vcell.math.CoordinateIndex
 * @param end cbit.vcell.math.CoordinateIndex
 * @deprecated
 */
public PlotData getLineScan(VCDataIdentifier vcdID, String varName, double time, CoordinateIndex begin, CoordinateIndex end) throws DataAccessException, MathException {
	throw new RuntimeException("Method deprecated. no longer in use.");
//	try {
//		double dataTimes[] = getDataSetTimes(vcdID);
//		if (dataTimes==null || dataTimes.length <= 0) {
//			return null;
//		}
//		try {
//			if (getIsODEData(vcdID)){
//				throw new DataAccessException("cannot request a line-scan on a nonspatial result set");
//			}
//		}catch (IOException e){
//			log.exception(e);
//		}
//		CartesianMesh mesh = getMesh(vcdID);
//		int sizeX = mesh.getSizeX();
//		int sizeY = mesh.getSizeY();
//
//		SimDataBlock simDataBlock = getSimDataBlock(vcdID,varName,time);
//		if (simDataBlock == null){
//			return null;
//		}
//
//		double data[] = simDataBlock.getData();
//		if (data == null) {
//			return null;
//		}
//
//		//
//		// get length of span (in elements)
//		//
//		double lengthScan = Math.sqrt((begin.x - end.x) * (begin.x - end.x) + (begin.y - end.y) * (begin.y - end.y) + (begin.z - end.z) * (begin.z - end.z));
//		if (lengthScan <= 0) {
//			return null;
//		}
//
//		//
//		// get length of span (in microns)
//		//
//		Coordinate beginCoord = mesh.getCoordinate(begin);
//		Coordinate endCoord = mesh.getCoordinate(end);
//		double lengthScanMicrons = beginCoord.distanceTo(endCoord);
//		
//		int sizeScan = Math.min(200, 4 * ((int) lengthScan));
//		double lineScan[] = new double[sizeScan];
//		double line[] = new double[sizeScan];
//		for (int i = 0; i < sizeScan; i++) {
//			// operate on normalized length (parametric line)
//			line[i] = ((double) i) / (sizeScan - 1);
//			double coordX = begin.x + line[i] * (end.x - begin.x);
//			double coordY = begin.y + line[i] * (end.y - begin.y);
//			double coordZ = begin.z + line[i] * (end.z - begin.z);
//			int pointX = (int) (coordX + 0.5);
//			int pointY = (int) (coordY + 0.5);
//			int pointZ = (int) (coordZ + 0.5);
//			lineScan[i] = data[ (pointZ * sizeY + pointY) * sizeX + pointX];
//			// restore scale to
//			line[i] *= lengthScanMicrons;
//		}
//		return new PlotData(line, lineScan);
//	} catch (DataAccessException e) {
//		log.exception(e);
//		throw e;
//	} catch (IOException e) {
//		log.exception(e);
//		throw new DataAccessException(e.getMessage());
//	}
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.plot.PlotData
 * @param varName java.lang.String
 * @param begin cbit.vcell.math.CoordinateIndex
 * @param end cbit.vcell.math.CoordinateIndex
 */
public PlotData getLineScan(VCDataIdentifier vcdID, String varName, double time, SpatialSelection spatialSelection) throws DataAccessException, MathException {
	try {
		if (spatialSelection == null){
			throw new IllegalArgumentException("null spatialSelection");
		}
		if (spatialSelection.isPoint()){
			throw new RuntimeException("'Point' spatialSelection not expected");
		}
		double dataTimes[] = getDataSetTimes(vcdID);
		if (dataTimes==null || dataTimes.length <= 0) {
			return null;
		}
		try {
			if (getIsODEData(vcdID)){
				throw new DataAccessException("cannot request a line-scan on a nonspatial result set");
			}
		}catch (IOException e){
			log.exception(e);
		}
		CartesianMesh mesh = getMesh(vcdID);
		//mesh is transient and is null if we got here by a serialized path (e.g. rmi)
		spatialSelection.setMesh(mesh);
		
		SimDataBlock simDataBlock = getSimDataBlock(vcdID,varName,time);
		if (simDataBlock == null){
			return null;
		}
		DataIdentifier dataIdentifier = null;
		try {
			DataIdentifier dataIdentifiers[] = getDataIdentifiers(vcdID);
			for (int i = 0; i < dataIdentifiers.length; i++){
				if (dataIdentifiers[i].getName().equals(varName)){
					dataIdentifier = dataIdentifiers[i];
				}
			}
		}catch (IOException e){
			throw new DataAccessException(e.getMessage());
		}

		double data[] = simDataBlock.getData();
		if (data == null) {
			return null;
		}
		
		if (spatialSelection instanceof SpatialSelectionVolume){

			SpatialSelectionVolume ssVolume = (SpatialSelectionVolume)spatialSelection;
			SpatialSelection.SSHelper ssvHelper = ssVolume.getIndexSamples(0.0,1.0);
			if (dataIdentifier.getVariableType().equals(VariableType.VOLUME)){
				ssvHelper.initializeValues_VOLUME(data);
			}else if(dataIdentifier.getVariableType().equals(VariableType.VOLUME_REGION)){
				ssvHelper.initializeValues_VOLUMEREGION(data);
			}else{
				throw new RuntimeException(SpatialSelectionVolume.class.getName()+" does not support variableType="+dataIdentifier.getVariableType());
			}
			try {
				if(ssvHelper.getMembraneIndexesInOut() != null && ssvHelper.getMembraneIndexesInOut().length > 0){
					adjustMembraneAdjacentVolumeValues(
						new double[][] {ssvHelper.getSampledValues()},false,simDataBlock,
						ssvHelper.getSampledIndexes(),
						ssvHelper.getMembraneIndexesInOut(),
						vcdID,
						varName,
						mesh,
						new TimeInfo(vcdID,time,1,time));
				}
			} catch (Exception e) {
				throw new DataAccessException("Error getLineScan adjustingMembraneValues\n"+e.getMessage(),e);
			}

			return new PlotData(ssvHelper.getWorldCoordinateLengths(),ssvHelper.getSampledValues());
			
		}else if (spatialSelection instanceof SpatialSelectionContour){
			//
			// get length of span (in microns)
			//
			double lengthMicrons = spatialSelection.getLengthInMicrons();
			if (lengthMicrons <= 0) {
				return null;
			}
			int sizeScan;

			int[] sampleIndexes = null;
			double[] lineScan = null;
			double[] distance = null;
			
			SpatialSelectionContour ssContour = (SpatialSelectionContour)spatialSelection;
			sampleIndexes = ssContour.getIndexSamples();
			sizeScan = sampleIndexes.length;
			//
			// if contour region, must translate from Contour indexes to ContourRegion indexes
			//
			if (dataIdentifier.getVariableType().equals(VariableType.CONTOUR_REGION)){
				for (int i = 0; i < sampleIndexes.length; i++){
					sampleIndexes[i] = mesh.getContourRegionIndex(sampleIndexes[i]);
				}
			}
			lineScan = new double[sizeScan];
			distance = new double[sizeScan];
			for (int i=0;i<sizeScan;i++){
				lineScan[i] = data[sampleIndexes[i]];
				distance[i] = (((double) i) / (sizeScan - 1)) * lengthMicrons;
			}
			
			return new PlotData(distance, lineScan);

			
		}else if (spatialSelection instanceof SpatialSelectionMembrane){
			SpatialSelectionMembrane ssMembrane = (SpatialSelectionMembrane)spatialSelection;

			SpatialSelection.SSHelper ssmHelper = ssMembrane.getIndexSamples();
			if (dataIdentifier.getVariableType().equals(VariableType.MEMBRANE)){
				ssmHelper.initializeValues_MEMBRANE(data);
			}else if(dataIdentifier.getVariableType().equals(VariableType.MEMBRANE_REGION)){
				ssmHelper.initializeValues_MEMBRANEREGION(data);
			}else{
				throw new RuntimeException(SpatialSelectionMembrane.class.getName()+" does not support variableType="+dataIdentifier.getVariableType());
			}

			return new PlotData(ssmHelper.getWorldCoordinateLengths(),ssmHelper.getSampledValues());
			
		}else{
			throw new RuntimeException("unexpected SpatialSelection type "+spatialSelection.getClass().toString());
		}

	} catch (DataAccessException e) {
		log.exception(e);
		throw e;
	} catch (IOException e) {
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created in VisualAge.
 * @return CartesianMesh
 */
public CartesianMesh getMesh(VCDataIdentifier vcdID) throws DataAccessException, IOException, MathException {

	log.print("DataSetControllerImpl.getMesh("+vcdID.getOwner().getName()+","+vcdID.getID()+")");
	
	VCData simData = null;
	try {
		simData = getVCData(vcdID);
	}catch (DataAccessException e){
	}
	
	if (simData==null){
		throw new DataAccessException("no simResults for user "+vcdID.getOwner().getName()+" with simID="+vcdID.getID());
	}

	try {
		if (getIsODEData(vcdID)){
			throw new DataAccessException("cannot request a mesh for a nonspatial result set");
		}
	}catch (IOException e){
		log.exception(e);
	}
	
	CartesianMesh mesh = simData.getMesh();
	
	if (mesh==null){
		log.alert("DataSetControllerImpl.getMesh(): creating dummy CartesianMesh");
		try {
			int size[] = simData.getVolumeSize();
			if (size==null){
				return null;
			}
			throw new RuntimeException("DataSetControllerImpl.getMesh(): size not null but couldn't read Mesh");
		}catch (Throwable e2){
			log.exception(e2);
			log.alert("DataSetControllerImpl.getMesh(): error creating dummy mesh: "+e2.getMessage());
			return null;
		}
	}else{
		return mesh;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (1/14/00 1:43:47 PM)
 * @return cbit.vcell.simdata.ODEDataBlock
 * @param user cbit.vcell.server.User
 * @param simID java.lang.String
 */
public ODEDataBlock getODEDataBlock(VCDataIdentifier vcdID) throws DataAccessException {
	
	log.print("DataSetControllerImpl.getODEDataBlock()");

	try {
		//
		// check if already cached
		//
		VCData simData = getVCData(vcdID);
		ODEDataInfo odeDataInfo = new ODEDataInfo(vcdID.getOwner(), vcdID.getID(), simData.getDataBlockTimeStamp(ODE_DATA, 0));
		ODEDataBlock odeDataBlock = (cacheTable0 != null?cacheTable0.get(odeDataInfo):null);
		if (odeDataBlock != null){
			return odeDataBlock;
		}else{
			if (simData.getIsODEData()) {
				odeDataBlock = simData.getODEDataBlock();
				if (odeDataBlock != null){
//					cacheTable.put(odeDataInfo, odeDataBlock);
					if(cacheTable0 != null){
						cacheTable0.put(odeDataInfo, odeDataBlock);
					}
					return odeDataBlock;
				}else{
					String msg = "failure reading ODE data for " + vcdID.getOwner().getName() + "'s " + vcdID.getID();
					log.alert("DataSetControllerImpl.getODEDataBlock(): "+msg);
					throw new DataAccessException(msg);
				}
			} else {
				String msg = "Simulation data is not ODE data for " + vcdID.getOwner().getName() + "'s " + vcdID.getID();
				log.alert("DataSetControllerImpl.getODEDataBlock(): "+msg);
				throw new DataAccessException(msg);
			}
		}
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 * @param varName java.lang.String
 * @param time double
 */
public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws DataAccessException {
	log.print("DataSetControllerImpl.getParticleDataBlock(" + time + ")");

	try {
		//
		// check if already cached
		//
		VCData simData = getVCData(vcdID);
		ParticleDataInfo particleDataInfo = new ParticleDataInfo(vcdID.getOwner(), vcdID.getID(), time, simData.getDataBlockTimeStamp(PARTICLE_DATA, time));
		ParticleDataBlock particleDataBlock = (cacheTable0 != null?cacheTable0.get(particleDataInfo):null);
		if (particleDataBlock != null){
			return particleDataBlock;
		}else{
			particleDataBlock = simData.getParticleDataBlock(time);
			if (particleDataBlock != null){
//				cacheTable.put(particleDataInfo, particleDataBlock);
				if(cacheTable0 != null){
					cacheTable0.put(particleDataInfo, particleDataBlock);
				}
				return particleDataBlock;
			}else{
				String msg = "failure reading at t = " + time + " for " + vcdID.getOwner().getName() + "'s " + vcdID.getID();
				log.alert("DataSetControllerImpl.getParticleDataBlock(): "+msg);
				throw new DataAccessException(msg);
			}
		}
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @return boolean
 */
public boolean getParticleDataExists(VCDataIdentifier vcdID) throws DataAccessException, IOException, FileNotFoundException {

	VCData simData = getVCData(vcdID);
	return simData.getParticleDataExists();
	
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 * @param varName java.lang.String
 * @param time double
 */
public SimDataBlock getSimDataBlock(VCDataIdentifier vcdID, String varName, double time) throws DataAccessException {
	log.print("DataSetControllerImpl.getSimDataBlock(" + varName + ", " + time + ")");

	try {
		if (getIsODEData(vcdID)){
			throw new DataAccessException("cannot request a SimDataBlock on a nonspatial result set");
		}
	}catch (IOException e){
		log.exception(e);
	}
	
	try {
		//
		// check if already cached for non-function variables
		//
		VCData simData = getVCData(vcdID);
		PDEDataInfo pdeDataInfo = new PDEDataInfo(vcdID.getOwner(),vcdID.getID(),varName,time,simData.getDataBlockTimeStamp(PDE_DATA, time));
		SimDataBlock simDataBlock = null;
		AnnotatedFunction function = simData.getFunction(varName);
		if (function == null){
			simDataBlock = (cacheTable0 != null?cacheTable0.get(pdeDataInfo):null);
			if (simDataBlock == null) {
				simDataBlock = simData.getSimDataBlock(varName,time);
				if (simDataBlock != null && dataCachingEnabled) {
//					cacheTable.put(pdeDataInfo,simDataBlock);
					if(cacheTable0 != null){
						cacheTable0.put(pdeDataInfo,simDataBlock);
					}
				}
			}				
		}else{
			simDataBlock = evaluateFunction(vcdID,simData,function,time);
		}
		if (simDataBlock != null) {
			return simDataBlock;
		} else {
			String msg = "failure reading "+varName+" at t="+time+" for "+vcdID.getOwner().getName()+"'s "+vcdID.getID();
			log.alert("DataSetControllerImpl.getDataBlockValues(): "+msg);
			throw new DataAccessException(msg);			
		}
	}catch (MathException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}catch (IOException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}catch (ExpressionException e){
		log.exception(e);
		throw new DataAccessException(e.getMessage());
	}
}


/**
 * Insert the method's description here.
 * Creation date: (2/10/2007 1:37:32 PM)
 * @return double[]
 */
private double[] getSpatialNeighborData(CartesianMesh mesh,int volumeIndex,int numArgs,double time,Vector<SimDataHolder> dataSetList,double[] args) {
	
	int regionIndex = mesh.getVolumeRegionIndex(volumeIndex);
	double[] spatialNeighborData = args;
	int argCount = numArgs;
	for(int i=0;i<12;i+= 1){
		int x = (i==0?-1:0)+(i==1?1:0)+(i==6?-2:0)+(i==7?2:0);
		int y = (i==2?-1:0)+(i==3?1:0)+(i==8?-2:0)+(i==9?2:0);
		int z = (i==4?-1:0)+(i==5?1:0)+(i==10?-2:0)+(i==11?2:0);
	//for(int z=-1;z<=1;z+=2){
		//for(int y=-1;y<=1;y+=2){
			//for(int x=-1;x<=1;x+=2){
				spatialNeighborData[argCount] = time;
				argCount+= 1;
				//
				CoordinateIndex ci = mesh.getCoordinateIndexFromVolumeIndex(volumeIndex);
				ci.x+= x;
				ci.y+= y;
				ci.z+= z;
				if( ci.x >= 0 && ci.x < mesh.getSizeX() &&
					ci.y >= 0 && ci.y < mesh.getSizeY() &&
					ci.z >= 0 && ci.z < mesh.getSizeZ()){//Inside boundary of data
					Coordinate coord = mesh.getCoordinate(ci);
					int neighborVolumeIndex = mesh.getVolumeIndex(ci);
					int neighborRegionIndex = mesh.getVolumeRegionIndex(neighborVolumeIndex);
					if(neighborRegionIndex == regionIndex){
						spatialNeighborData[argCount] = coord.getX();
						argCount+= 1;
						spatialNeighborData[argCount] = coord.getY();
						argCount+= 1;
						spatialNeighborData[argCount] = coord.getZ();
						argCount+= 1;
						for (int j = 0; j < numArgs - TXYZ_OFFSET; j++) {
							SimDataHolder simDataHolder = dataSetList.elementAt(j);
							if (simDataHolder.getVariableType().equals(VariableType.VOLUME)){
								spatialNeighborData[argCount] = simDataHolder.getData()[neighborVolumeIndex];
								argCount+= 1;
							}else{
								throw new RuntimeException("only VOLUME variables allowed in grad functions");
							}
						}
						continue;
					}
					//else{//Outside the current region, mark neighbor as undefined
						//for(int j=0;j<(numArgs-4);j+= 1){//four less because time and coordinate are inserted already
							//spatialNeighborData[argCount] = Double.NaN;
							//argCount+= 1;
						//}
					//}
				}
				//else{
				//Outside boundary of data, mark neighbor as undefined
				for(int j=0;j<(numArgs-1);j+= 1){//one less because time is inserted already
					spatialNeighborData[argCount] = Double.NaN;
					argCount+= 1;
				}
				//}
			//}
		//}
		//}
	}
	return spatialNeighborData;
}

private TimeSeriesJobResults getSpecialTimeSeriesValues(VCDataIdentifier vcdID,
		TimeSeriesJobSpec timeSeriesJobSpec,TimeInfo timeInfo) throws Exception{
	
	String[] variableNames = timeSeriesJobSpec.getVariableNames();
	boolean bIsSpecial = false;
	CartesianMesh mesh = getMesh(vcdID);
	VCData simData = getVCData(vcdID);
	//
	//Gradient and FieldData functions are special.
	//They have to be evaluated using the 'full data' method using evaluateFunction(...).
	//They cannot be evaluated using the fast findFunctionIndexes(...) method.
	//Also if the 'roi' is a significant fraction of the whole dataset then
	//the 'full data' method of evaluation is more efficient
	final double SIGNIFICANT_ROI_FRACTION = .2;//a guess for best efficiency
	final int ABSOLUTE_SIZE_LIMIT = 10000;
	for(int i=0;i<variableNames.length;i+= 1){
		DataSetIdentifier dsi = (DataSetIdentifier)simData.getEntry(variableNames[i]);
		if(dsi.getVariableType().equals(VariableType.VOLUME)){
			if(timeSeriesJobSpec.getIndices()[i].length >
			mesh.getNumVolumeElements()*SIGNIFICANT_ROI_FRACTION){
				bIsSpecial = true;
				break;
			}
		}else if(dsi.getVariableType().equals(VariableType.MEMBRANE)){
			if(timeSeriesJobSpec.getIndices()[i].length >
			mesh.getNumMembraneElements()*SIGNIFICANT_ROI_FRACTION){
				bIsSpecial = true;
				break;
			}
		}
		AnnotatedFunction functionFromVarName = simData.getFunction(variableNames[i]);
		if(functionFromVarName != null){
			FieldFunctionArguments[] fieldFunctionArgumentsArr =
				functionFromVarName.getExpression().getFieldFunctionArguments();
			if(functionFromVarName.getExpression().hasGradient() ||
				(fieldFunctionArgumentsArr != null && fieldFunctionArgumentsArr.length > 0)){
				bIsSpecial = true;
				break;
			}
			//check function absolute size limit
			Expression exp = functionFromVarName.getExpression();
			String[] funcSymbols = exp.getSymbols();
			int varCount = 0;
			if(funcSymbols != null){
				for (int j = 0; j < funcSymbols.length; j++) {
					SymbolTableEntry ste = exp.getSymbolBinding(funcSymbols[j]);
					if (ste instanceof DataSetIdentifier) {
						varCount+= 1;
					}
				}
			}
			varCount = Math.max(varCount, 1);
			if(varCount*timeSeriesJobSpec.getIndices()[i].length > ABSOLUTE_SIZE_LIMIT){
				bIsSpecial = true;
				break;
			}
		}else if(timeSeriesJobSpec.getIndices()[i].length > ABSOLUTE_SIZE_LIMIT){
			bIsSpecial = true;
			break;
		}
	}

	if(!bIsSpecial){
		return null;
	}
	
	if(timeSeriesJobSpec.isCalcTimeStats()){
		throw new RuntimeException("Time Stats Not yet implemented for 'special' data");
	}
	
	double[][][] varIndicesTimesArr = new double[variableNames.length][][];
	for(int varNameIndex =0;varNameIndex<variableNames.length;varNameIndex+= 1){
		int[] dataIndices = timeSeriesJobSpec.getIndices()[varNameIndex];
		varIndicesTimesArr[varNameIndex] = new double[dataIndices.length + 1][timeInfo.desiredTimeValues.length];
		varIndicesTimesArr[varNameIndex][0] = timeInfo.desiredTimeValues;
		for(int timeIndex=0;timeIndex<timeInfo.desiredTimeValues.length;timeIndex+= 1){
			int num = varNameIndex*timeInfo.desiredTimeValues.length+timeIndex;
			int denom = variableNames.length*timeInfo.desiredTimeValues.length;
			double progressTime = 100.0 * (double)num / (double)denom;
			fireDataJobEventIfNecessary(
							timeSeriesJobSpec.getVcDataJobID(),
							MessageEvent.DATA_PROGRESS,
							vcdID,
							new Double(progressTime),
							null,null
						);
			SimDataBlock simDatablock = getSimDataBlock(vcdID, variableNames[varNameIndex], timeInfo.desiredTimeValues[timeIndex]);
			double[] data = simDatablock.getData();
			for(int dataIndex=0;dataIndex<dataIndices.length;dataIndex+= 1){
				varIndicesTimesArr[varNameIndex][dataIndex+1][timeIndex] = data[dataIndices[dataIndex]];
			}
			if(timeSeriesJobSpec.getCrossingMembraneIndices() != null && timeSeriesJobSpec.getCrossingMembraneIndices().length > 0){
				adjustMembraneAdjacentVolumeValues(
					varIndicesTimesArr[varNameIndex],true,simDatablock,
					timeSeriesJobSpec.getIndices()[varNameIndex],
					timeSeriesJobSpec.getCrossingMembraneIndices()[varNameIndex],
					vcdID,
					variableNames[varNameIndex],
					mesh,
					timeInfo);
			}
		}
	}
	
	TimeSeriesJobResults tsjr = null;
	if(timeSeriesJobSpec.isCalcSpaceStats()){
		SpatialStatsInfo ssi = calcSpatialStatsInfo(timeSeriesJobSpec, vcdID);
		tsjr = calculateStatisticsFromWhole(timeSeriesJobSpec, varIndicesTimesArr, timeInfo.desiredTimeValues, ssi);
	}else if(timeSeriesJobSpec.isCalcTimeStats()){
		throw new RuntimeException("Time Stats Not yet implemented for 'special' data");		
	}else{
		tsjr = new TSJobResultsNoStats(
				timeSeriesJobSpec.getVariableNames(),
				timeSeriesJobSpec.getIndices(),
				timeInfo.desiredTimeValues,
				varIndicesTimesArr
				);
	}
	
	return tsjr;
}




private cbit.util.TimeSeriesJobResults getTimeSeriesValues_private(final VCDataIdentifier vcdID,final TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {

	TimeInfo timeInfo =
		new TimeInfo(vcdID,timeSeriesJobSpec.getStartTime(),timeSeriesJobSpec.getStep(),timeSeriesJobSpec.getEndTime());
//	boolean[] wantsTheseTimes = timeInfo.getWantsTheseTimes();
//	double[] desiredTimeValues = timeInfo.getDesiredTimeValues();
//	int desiredNumTimes = desiredTimeValues.length;
	
	double dataTimes[] = getDataSetTimes(vcdID);
	if (dataTimes.length<=0){
		return null;
	}	

	boolean[] wantsTheseTimes = new boolean[dataTimes.length];
	double[] desiredTimeValues = null;
	int desiredNumTimes = 0;
	
	Arrays.fill(wantsTheseTimes,false);
	double[] tempTimes = new double[dataTimes.length];
	
	int stepCounter = 0;
	for(int i=0;i<dataTimes.length;i+= 1){
		if(dataTimes[i] > timeSeriesJobSpec.getEndTime()){
			break;
		}
		if(dataTimes[i] == timeSeriesJobSpec.getStartTime()){
			tempTimes[desiredNumTimes] = dataTimes[i];
			desiredNumTimes+= 1;
			stepCounter = 0;
			wantsTheseTimes[i] = true;
			if(timeSeriesJobSpec.getStep() == 0){
				break;
			}
		}else if(desiredNumTimes > 0 && stepCounter%timeSeriesJobSpec.getStep() == 0){
			tempTimes[desiredNumTimes] = dataTimes[i];
			desiredNumTimes+= 1;
			wantsTheseTimes[i] = true;
		}
		stepCounter+= 1;
	}
	if(desiredNumTimes == 0){
		throw new IllegalArgumentException("Couldn't find startTime "+timeSeriesJobSpec.getStartTime());
	}
	desiredTimeValues = new double[desiredNumTimes];
	System.arraycopy(tempTimes,0,desiredTimeValues,0,desiredNumTimes);
	
	//Check timeInfo
	if(desiredTimeValues.length != timeInfo.getDesiredTimeValues().length){
		throw new DataAccessException("timeInfo check failed");
	}
	for (int i = 0; i < desiredTimeValues.length; i++) {
		if(desiredTimeValues[i] != timeInfo.getDesiredTimeValues()[i]){
				throw new DataAccessException("timeInfo check failed");
		}
	}
	for (int i = 0; i < wantsTheseTimes.length; i++) {
		if(wantsTheseTimes[i] != timeInfo.getWantsTheseTimes()[i]){
				throw new DataAccessException("timeInfo check failed");
		}
	}
	
	try{

		timeSeriesJobSpec.initIndices(getMesh(vcdID));

		//See if we need special processing
		TimeSeriesJobResults specialTSJR = getSpecialTimeSeriesValues(vcdID,timeSeriesJobSpec,timeInfo);
		if(specialTSJR != null){
			return specialTSJR;
		}
		//
		VCData vcData = getVCData(vcdID);
		//
		//Determine Memory Usage for this job to protect server
		//
		final long MAX_MEM_USAGE = 20000000;//No TimeSeries jobs larger than this
		long memUsage = 0;
		boolean bHasFunctionVars = false;//efficient function stats are not yet implemented so check to adjust calculation
		for(int i=0;i<timeSeriesJobSpec.getVariableNames().length;i+= 1){
			bHasFunctionVars = bHasFunctionVars || (vcData.getFunction(timeSeriesJobSpec.getVariableNames()[i]) != null);
		}
		for(int i=0;i<timeSeriesJobSpec.getIndices().length;i+= 1){
			memUsage+= (timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars ? NUM_STATS : timeSeriesJobSpec.getIndices()[i].length);
		}
		memUsage*= desiredNumTimes*8*2;
		System.out.println("DataSetControllerImpl.getTimeSeriesValues: job memory="+memUsage);
		if(memUsage > MAX_MEM_USAGE){
			throw new DataAccessException(
				"DataSetControllerImpl.getTimeSeriesValues: Job too large"+(bHasFunctionVars?"(has function vars)":"")+", requires approx. "+memUsage+
				" bytes of memory (only "+MAX_MEM_USAGE+" bytes allowed).  Choose fewer datapoints or times.");
		}
		//
		Vector<double[][]> valuesV = new Vector<double[][]>();
		SpatialStatsInfo spatialStatsInfo = null;
		if(timeSeriesJobSpec.isCalcSpaceStats()){
			spatialStatsInfo = calcSpatialStatsInfo(timeSeriesJobSpec,vcdID);
		}
		for(int k=0;k<timeSeriesJobSpec.getVariableNames().length;k+= 1){
			double[][] timeSeries = null;
			String varName = timeSeriesJobSpec.getVariableNames()[k];
			int[] indices = timeSeriesJobSpec.getIndices()[k];
			if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
				timeSeries = new double[NUM_STATS + 1][desiredNumTimes];
			}else{
				timeSeries = new double[indices.length + 1][desiredNumTimes];
			}
			timeSeries[0] = desiredTimeValues;
			ProgressListener progressListener = new ProgressListener(){
				public void updateProgress(double progress) {
					fireDataJobEventIfNecessary(
							timeSeriesJobSpec.getVcDataJobID(),
							MessageEvent.DATA_PROGRESS,
							vcdID,
							new Double(progress),
							null,null
						);
				}
			};
			if(vcData.getFunction(varName) != null){
				AnnotatedFunction function = vcData.getFunction(varName);
				MultiFunctionIndexes mfi = new MultiFunctionIndexes(vcdID,function,indices,wantsTheseTimes, progressListener);
				for (int i=0;i<desiredTimeValues.length;i++){
					fireDataJobEventIfNecessary(
							timeSeriesJobSpec.getVcDataJobID(),
							MessageEvent.DATA_PROGRESS,
							vcdID,
							new Double(NumberUtils.formatNumber(
								100.0*(double)(k*desiredTimeValues.length+i)/
								(double)(timeSeriesJobSpec.getVariableNames().length*desiredTimeValues.length),3)),
							null,null
						);
					for (int j = 0; j < indices.length; j++){
						timeSeries[j + 1][i] = mfi.evaluateTimeFunction(i,j);
					}
				}
			}else{
				double[][][] valuesOverTime = null;
				if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
					valuesOverTime = vcData.getSimDataTimeSeries(new String[] {varName},new int[][]{indices},wantsTheseTimes,spatialStatsInfo,progressListener);
				}else{
					valuesOverTime = vcData.getSimDataTimeSeries(new String[] {varName},new int[][]{indices},wantsTheseTimes,progressListener);
				}
				for (int i=0;i<desiredTimeValues.length;i++){
					fireDataJobEventIfNecessary(
							timeSeriesJobSpec.getVcDataJobID(),
							MessageEvent.DATA_PROGRESS,
							vcdID,
							new Double(NumberUtils.formatNumber(
								100.0*(double)(k*desiredTimeValues.length+i)/
								(double)(timeSeriesJobSpec.getVariableNames().length*desiredTimeValues.length),3)),
							null,null
						);
					if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
						timeSeries[MIN_OFFSET + 1][i] = valuesOverTime[i][0][MIN_OFFSET];// min
						timeSeries[MAX_OFFSET + 1][i] = valuesOverTime[i][0][MAX_OFFSET];// max
						timeSeries[MEAN_OFFSET + 1][i] = valuesOverTime[i][0][MEAN_OFFSET];// mean
						timeSeries[WMEAN_OFFSET + 1][i] = valuesOverTime[i][0][WMEAN_OFFSET];// wmean
						timeSeries[SUM_OFFSET + 1][i] = valuesOverTime[i][0][SUM_OFFSET];// sum
						timeSeries[WSUM_OFFSET + 1][i] = valuesOverTime[i][0][WSUM_OFFSET];// wsum
					}else{
						for (int j = 0; j < indices.length; j++){
							timeSeries[j + 1][i] = valuesOverTime[i][0][j];
						}
					}
				}
			}
			
			valuesV.add(timeSeries);
		}

		if(timeSeriesJobSpec.isCalcSpaceStats() && !bHasFunctionVars){
			double[][] min = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] max = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] mean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] wmean = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] sum = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			double[][] wsum = new double[timeSeriesJobSpec.getVariableNames().length][desiredTimeValues.length];
			for(int i=0;i<valuesV.size();i+= 1){
				double[][] timeStat = (double[][])valuesV.elementAt(i);
				for(int j=0;j<desiredTimeValues.length;j+= 1){
					min[i][j] = timeStat[MIN_OFFSET+1][j];
					max[i][j] = timeStat[MAX_OFFSET+1][j];
					mean[i][j] = timeStat[MEAN_OFFSET+1][j];
					wmean[i][j] = timeStat[WMEAN_OFFSET+1][j];
					sum[i][j] = timeStat[SUM_OFFSET+1][j];
					wsum[i][j] = timeStat[WSUM_OFFSET+1][j];
				}
			}
			return new cbit.util.TSJobResultsSpaceStats(
					timeSeriesJobSpec.getVariableNames(),
					timeSeriesJobSpec.getIndices(),
					desiredTimeValues,
					min,max,
					mean,
					(spatialStatsInfo.bWeightsValid?wmean:null),
					sum,
					(spatialStatsInfo.bWeightsValid?wsum:null),
					(spatialStatsInfo.bWeightsValid?spatialStatsInfo.totalSpace:null)
				);
		}else if(timeSeriesJobSpec.isCalcSpaceStats() && bHasFunctionVars){
			double[][][] timeSeriesFormatedValuesArr = new double[valuesV.size()][][];
			valuesV.copyInto(timeSeriesFormatedValuesArr);
			return calculateStatisticsFromWhole(timeSeriesJobSpec,timeSeriesFormatedValuesArr,desiredTimeValues,spatialStatsInfo);
		}else{
			double[][][] timeSeriesFormatedValuesArr = new double[valuesV.size()][][];
			valuesV.copyInto(timeSeriesFormatedValuesArr);
			TSJobResultsNoStats tsJobResultsNoStats =  new cbit.util.TSJobResultsNoStats(
	            timeSeriesJobSpec.getVariableNames(),
	            timeSeriesJobSpec.getIndices(),
	            desiredTimeValues,
	            timeSeriesFormatedValuesArr);
			if(timeSeriesJobSpec.getCrossingMembraneIndices() != null && timeSeriesJobSpec.getCrossingMembraneIndices().length > 0){
				adjustMembraneAdjacentVolumeValues(
						tsJobResultsNoStats.getTimesAndValuesForVariable(timeSeriesJobSpec.getVariableNames()[0]),
						true,null,
						timeSeriesJobSpec.getIndices()[0],
						timeSeriesJobSpec.getCrossingMembraneIndices()[0],
						vcdID,
						timeSeriesJobSpec.getVariableNames()[0],
						getMesh(vcdID),
						timeInfo
					);
			}
			return tsJobResultsNoStats;
		}
		
	}catch (DataAccessException e){
		log.exception(e);
		throw e;
	}catch (Throwable e){
		log.exception(e);
		throw new DataAccessException("DataSetControllerImpl.getTimeSeriesValues: "+(e.getMessage() == null?e.getClass().getName():e.getMessage()));
	}
}


public cbit.util.TimeSeriesJobResults getTimeSeriesValues(final VCDataIdentifier vcdID,final TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {

	fireDataJobEventIfNecessary(
			timeSeriesJobSpec.getVcDataJobID(),
			MessageEvent.DATA_START,
			vcdID,
			new Double(0),
			null,null
		);

	dataCachingEnabled = false;
	Exception failException = null;
	try{
		TimeSeriesJobResults timeSeriesJobResults =
			getTimeSeriesValues_private(vcdID,timeSeriesJobSpec);
		fireDataJobEventIfNecessary(
				timeSeriesJobSpec.getVcDataJobID(),
						MessageEvent.DATA_COMPLETE,
						vcdID,
						new Double(100),
						timeSeriesJobResults,null
					);
		
		return timeSeriesJobResults;
		
	}catch (Exception e) {
		failException = e;
		e.printStackTrace();
		if(e instanceof DataAccessException){
			throw (DataAccessException)e;
		}else{
			throw new DataAccessException(e.getClass().getName()+"\n"+e.getMessage());
		}
	}finally{
		dataCachingEnabled = true;
		if(failException != null){
			fireDataJobEventIfNecessary(
					timeSeriesJobSpec.getVcDataJobID(),
							MessageEvent.DATA_FAILURE,
							vcdID,
							new Double(0),
							null,failException
						);			
		}
	}
}

/**
 * This method was created in VisualAge.
 * @return java.io.File
 * @param user cbit.vcell.server.User
 */
private File getPrimaryUserDir(User user, boolean bVerify) throws FileNotFoundException {
	File userDir = new File(primaryRootDirectory, user.getName());
	if (userDir.exists()){
		if (userDir.isDirectory()){
			return userDir;
		} else {
			throw new FileNotFoundException("file " + userDir.getPath() + " is not a directory");
		}
	}else{
		if (userDir.mkdir()){
			return userDir;
		} else if (bVerify) {
			throw new FileNotFoundException("cannot create directory "+userDir.getPath());
		}
	}
	return null;
}

private File getSecondaryUserDir(User user) throws FileNotFoundException {
	File userDir = new File(secondaryRootDirectory, user.getName());
	if (userDir.exists()){
		if (userDir.isDirectory()){
			return userDir;
		}else{
			throw new FileNotFoundException("file " + userDir.getPath() + " is not a directory");
		}
	}else{
		return null;
	}
}

/**
 * This method was created in VisualAge.
 * @return cbit.vcell.simdata.SimResults
 * @param user User
 * @param simID java.lang.String
 */
public VCData getVCData(VCDataIdentifier vcdID) throws DataAccessException, IOException {

	VCData vcData = (cacheTable0 != null?cacheTable0.get(vcdID):null);
	//
	// check to see if cached version is compatible with current data
	//
	if (vcData==null){
		if (vcdID instanceof MergedDataInfo) {
			try {
				User user = vcdID.getOwner();
				VCDataIdentifier[] vcdIdentifiers = ((MergedDataInfo)vcdID).getDataIDs();
				vcData = new MergedData(user, getPrimaryUserDir(vcdID.getOwner(), false), getSecondaryUserDir(vcdID.getOwner()), this, vcdIdentifiers);
			} catch (IOException e) {
				e.printStackTrace(System.out);
				throw new RuntimeException(e.getMessage());
			}
		} else {  // assume vcdID instanceof cbit.vcell.solver.SimulationInfo or a test adapter
			vcData = new SimulationData(vcdID, getPrimaryUserDir(vcdID.getOwner(), false), getSecondaryUserDir(vcdID.getOwner()));
		}
//		cacheTable.put(vcdID,vcData);
		if(cacheTable0 != null){
			cacheTable0.put(vcdID,vcData);
		}
	}

	return vcData;
}

private void adjustMembraneAdjacentVolumeValues(
		double[][] dataToAdjust,boolean bTimeFormat,SimDataBlock fullDataValueSource,
		int[] volumeDataIndexes,
		int[] membraneIndexesInOut,
		VCDataIdentifier vcdID,
		String varName,
		CartesianMesh mesh,
		TimeInfo timeInfo) throws Exception{
	
	if(membraneIndexesInOut == null || membraneIndexesInOut.length == 0){
		return;
	}
	if(bTimeFormat){
		if(dataToAdjust.length != volumeDataIndexes.length+1 || dataToAdjust[0].length != timeInfo.desiredTimeValues.length){
			throw new IllegalArgumentException(this.getClass().getName()+".adjustMembraneAdjacentVolumeValues array format wrong for time flag="+bTimeFormat);
		}
	}else{
		if(dataToAdjust.length != timeInfo.desiredTimeValues.length || dataToAdjust[0].length != volumeDataIndexes.length){
			throw new IllegalArgumentException(this.getClass().getName()+".adjustMembraneAdjacentVolumeValues array format wrong for time flag="+bTimeFormat);
		}
	}
	boolean bIsSpecial = false;
	AnnotatedFunction insideFunction = null;
	AnnotatedFunction outsideFunction = null;
	DataIdentifier[] myDataIdentifers = getDataIdentifiers(vcdID);
	for (int i = 0; i < myDataIdentifers.length; i++) {
		if(myDataIdentifers[i].getName().equals(varName)){
			if(myDataIdentifers[i].getVariableType().equals(VariableType.MEMBRANE)){
				throw new IllegalArgumentException(this.getClass().getName()+".adjustMembraneAdjacentVolumeValues Not for Membrane Variables");
			}
			Expression insideExp = null;
			Expression outsideExp = null;
			if(myDataIdentifers[i].isFunction()){
				AnnotatedFunction sourceFunction = null;
				AnnotatedFunction[] functionsArr = getFunctions(vcdID);
				for (int j = 0; j < functionsArr.length; j++) {
					if(functionsArr[j].getName().equals(varName)){
						sourceFunction = functionsArr[j];
						break;
					}
				}
				Vector<DataSetIdentifier> dependencyList = identifyDataDependencies(sourceFunction);
				insideExp = new Expression(sourceFunction.getExpression());
				outsideExp = new Expression(sourceFunction.getExpression());
				for (int j = 0; j < dependencyList.size(); j++) {
					insideExp.substituteInPlace(
							new Expression(dependencyList.elementAt(j).getName()),
							new Expression(dependencyList.elementAt(j).getName()+"_INSIDE"));
					outsideExp.substituteInPlace(
							new Expression(dependencyList.elementAt(j).getName()),
							new Expression(dependencyList.elementAt(j).getName()+"_OUTSIDE"));
				}

			}else{
				insideExp = new Expression(varName+"_INSIDE");
				outsideExp = new Expression(varName+"_OUTSIDE");
			}
			if(insideExp != null && outsideExp != null){
				insideExp.bindExpression((SimulationData)getVCData(vcdID));
				outsideExp.bindExpression((SimulationData)getVCData(vcdID));
				insideFunction = new AnnotatedFunction("",insideExp,"",VariableType.MEMBRANE,true);
				outsideFunction = new AnnotatedFunction("",outsideExp,"",VariableType.MEMBRANE,true);
				insideFunction.setExpression(insideExp.flatten());
				outsideFunction.setExpression(outsideExp.flatten());				
				bIsSpecial =
					insideExp.hasGradient() || outsideExp.hasGradient() ||
					(insideExp.getFieldFunctionArguments() != null && insideExp.getFieldFunctionArguments().length > 0) ||
					(outsideExp.getFieldFunctionArguments() != null && outsideExp.getFieldFunctionArguments().length > 0);
				if(bIsSpecial && fullDataValueSource == null){
					throw new IllegalArgumentException(this.getClass().getName()+".adjustMembraneAdjacentVolumeValues: special values need SimDataBlock");
				}
			}
			break;
		}
	}
	int crossingCount = 0;
	for (int j = 0; j < membraneIndexesInOut.length; j++) {
		if(membraneIndexesInOut[j] != -1){
			crossingCount+= 1;
		}
	}
	if(crossingCount > 0){
		int[] crossingCondensedIndexes = new int[crossingCount];
		int[] crossingCondensedOrigLocation = new int[crossingCount];
		crossingCount = 0;
		for (int j = 0; j < membraneIndexesInOut.length; j++) {
			if(membraneIndexesInOut[j] != -1){
				crossingCondensedOrigLocation[crossingCount] = j;
				crossingCondensedIndexes[crossingCount] = membraneIndexesInOut[j];
				crossingCount+= 1;
			}
		}
		MultiFunctionIndexes mfi_inside = null;
		MultiFunctionIndexes mfi_outside = null;
		for (int j = 0; j < crossingCount; j++) {
			double specialInsideVal = (bIsSpecial?interpolateVolDataValToMemb(mesh, crossingCondensedIndexes[j], fullDataValueSource, true, false):0);
			double specialOutsideVal = (bIsSpecial?interpolateVolDataValToMemb(mesh, crossingCondensedIndexes[j], fullDataValueSource, false, false):0);
			VolumeIndexNearFar vinf_inside =
				interpolateFindNearFarIndex(mesh, crossingCondensedIndexes[j], true, false);
			VolumeIndexNearFar vinf_outside =
				interpolateFindNearFarIndex(mesh, crossingCondensedIndexes[j], false, false);
			if(vinf_inside.volIndexNear == volumeDataIndexes[crossingCondensedOrigLocation[j]]){
				if(!bIsSpecial && mfi_inside == null){
					mfi_inside =
						new MultiFunctionIndexes(vcdID,insideFunction,crossingCondensedIndexes,timeInfo.wantsTheseTimes,null);
				}
				for (int k = 0; k < timeInfo.desiredTimeValues.length; k++) {
					if(bTimeFormat){
						dataToAdjust[crossingCondensedOrigLocation[j]+1][k] = (bIsSpecial?specialInsideVal:mfi_inside.evaluateTimeFunction(k,j));
					}else{
						dataToAdjust[k][crossingCondensedOrigLocation[j]] = (bIsSpecial?specialInsideVal:mfi_inside.evaluateTimeFunction(k,j));
					}
				}
			}else if(vinf_outside.volIndexNear == volumeDataIndexes[crossingCondensedOrigLocation[j]]){
				if(!bIsSpecial && mfi_outside == null){
					mfi_outside =
						new MultiFunctionIndexes(vcdID,outsideFunction,crossingCondensedIndexes,timeInfo.wantsTheseTimes,null);
				}
				for (int k = 0; k < timeInfo.desiredTimeValues.length; k++) {
					if(bTimeFormat){
						dataToAdjust[crossingCondensedOrigLocation[j]+1][k] = (bIsSpecial?specialOutsideVal:mfi_outside.evaluateTimeFunction(k,j));
					}else{
						dataToAdjust[k][crossingCondensedOrigLocation[j]] = (bIsSpecial?specialOutsideVal:mfi_outside.evaluateTimeFunction(k,j));
					}
				}
			}else{
				throw new Exception("couldn't match 'near' indexes");
			}
		}
	}else{
		throw new IllegalArgumentException("No non-null membrane crossing indexes found");
	}

}

/**
 * Add a cbit.vcell.desktop.controls.ExportListener.
 */
public void removeDataJobListener(cbit.rmi.event.DataJobListener djListener) {
	if (aDataJobListener != null) {
		aDataJobListener.remove(djListener);
	};
}


/**
 * This method was created by a SmartGuide.
 * @return double[]
 */
public void removeFunction(VCDataIdentifier vcdID, AnnotatedFunction function) throws DataAccessException {
	try {
		if(!function.isUserDefined()){
			throw new Exception("Non User-Defined functions cannot be deleted");
		}
		VCData simData = getVCData(vcdID);
		simData.removeFunction(function);
//		cacheTable.removeVariable(vcdID,function.getName());
		if(cacheTable0 != null){
			cacheTable0.removeVariable(vcdID,function.getName());
		}
	}catch (Exception e){
		log.exception(e);
		if(e instanceof DataAccessException){
			throw (DataAccessException)e;
		}
		throw new DataAccessException(e.getMessage());
	}
}
}