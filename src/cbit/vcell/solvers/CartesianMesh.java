package cbit.vcell.solvers;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.util.*;
import java.io.*;

//import org.apache.commons.httpclient.methods.GetMethod;

import cbit.util.*;
import cbit.vcell.geometry.*;
import cbit.vcell.math.CommentStringTokenizer;
import cbit.vcell.math.VCML;
import cbit.vcell.math.MathException;
import cbit.vcell.math.MathFormatException;
import cbit.vcell.solvers.MeshRegionInfo.VolumeRegionMapSubvolume;
import cbit.vcell.math.CoordinateIndex;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class CartesianMesh implements Serializable, Matchable {

	//
	private static class MembraneMeshMetrics {
		public short[] regionIndexes;
		public float[] areas;
		public float[][] normals;
		public float[][] centroids;
	}
	//
	private byte[] compressedBytes = null;
		
	private transient MembraneElement membraneElements[] = null;
	private transient ContourElement contourElements[] = null;
	private transient MeshRegionInfo meshRegionInfo = null;
	private transient ISize size = null;
	private transient Origin origin = new Origin(0,0,0);
	private transient Extent extent = new Extent(10,10,10);
	private transient String version = VERSION_1_0;

	public final static String VERSION_1_0 = "1.0";		// origin, extent, sizeXYZ, 
														// membrane (membraneIndex, insideVolumeIndex, outsideVolumeIndex)
														
	public final static String VERSION_1_1 = "1.1";		// added: membrane connectivity 8/30/2000
	public final static String VERSION_1_2 = "1.2";		// added: Regions 07/02/2001
	

/**
 * This method was created by a SmartGuide.
 */
private CartesianMesh () {
}

/**
 * Insert the method's description here.
 * Creation date: (2/23/2006 12:52:44 PM)
 */
public double calculateMeshElementVolumeFromVolumeIndex(int volumeIndex) {

	CoordinateIndex ci = getCoordinateIndexFromVolumeIndex(volumeIndex);
    double fxMESize = (ci.x == 0 || ci.x == (getSizeX()-1)?.5:1);
    double fyMESize = (getGeometryDimension() >= 2 ?(ci.y == 0 || ci.y == (getSizeY()-1)?.5:1):0);
    double fzMESize = (getGeometryDimension() == 3 ?(ci.z == 0 || ci.z == (getSizeZ()-1)?.5:1):0);
    
    return (fxMESize != 0?fxMESize*(getExtent().getX()/(getSizeX()-1)):1)*
    		(fyMESize != 0?fyMESize*(getExtent().getY()/(getSizeY()-1)):1)*
    		(fzMESize != 0?fzMESize*(getExtent().getZ()/(getSizeZ()-1)):1);
	
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param object java.lang.Object
 */
public boolean compareEqual(Matchable object) {
	if(this == object){
		return true;
	}
	if (object == null){
		return false;
	}
	CartesianMesh mesh = null;
	if (!(object instanceof CartesianMesh)){
		return false;
	}else{
		mesh = (CartesianMesh)object;
	}

	if (!Compare.isEqualOrNullStrict(membraneElements,mesh.membraneElements)){
		return false;
	}
	if (!Compare.isEqualOrNullStrict(contourElements,mesh.contourElements)){
		return false;
	}
	if (!size.compareEqual(mesh.size)) {
		return false;
	}
	/*
	if (sizeX!=mesh.sizeX || sizeY!=mesh.sizeY || sizeZ!=mesh.sizeZ){
		return false;
	}
	*/
	if (!origin.compareEqual(mesh.origin)){
		return false;
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (8/4/2005 8:25:37 AM)
 */
public static boolean compareMesh(CartesianMesh mesh1, CartesianMesh mesh2, PrintWriter pw) {
	try {		
		int dimension = mesh1.getGeometryDimension();
		
		if (dimension != mesh2.getGeometryDimension()) {
			return false;
		}

		// Size
		if (mesh1.getSizeX() != mesh2.getSizeX() || dimension > 1 && mesh1.getSizeY() != mesh2.getSizeY()
			|| dimension > 2 && mesh1.getSizeZ() != mesh2.getSizeZ()) {
			pw.println("Size is differnt!");
			System.out.println("Size is differnt!");
			return false;
		}

		// Extent
		if (mesh1.getExtent().getX() != mesh2.getExtent().getX() || dimension > 1 && mesh1.getExtent().getY() != mesh2.getExtent().getY()
			|| dimension > 2 && mesh1.getExtent().getZ() != mesh2.getExtent().getZ()) {
			pw.println("Extent is differnt!");
			System.out.println("Extent is differnt!");
			return false;
		}

		// Origin
		if (mesh1.getOrigin().getX() != mesh2.getOrigin().getX() || dimension > 1 && mesh1.getOrigin().getY() != mesh2.getOrigin().getY()
			|| dimension > 2 && mesh1.getOrigin().getZ() != mesh2.getOrigin().getZ()) {
			pw.println("Origin is different!");
			System.out.println("Origin is different!");
			return false;
		}
		
		if (!Compare.isEqualOrNullStrict(mesh1.getContourElements(),mesh2.getContourElements())){
			pw.println("ContourElemment is different!");
			System.out.println("ContourElemment is different!");
			return false;
		}

		MeshRegionInfo meshRegionInfo1 = mesh1.getMeshRegionInfo();
		MeshRegionInfo meshRegionInfo2 = mesh2.getMeshRegionInfo();


		// Compare VolumeRegionMapSubVolume
		if (meshRegionInfo1.getNumVolumeRegions() != meshRegionInfo2.getNumVolumeRegions()) {
			pw.println("# of volume regions is different!");
			return false;
		}
		Vector vrmsv1 = meshRegionInfo1.getVolumeRegionMapSubvolume();
		Vector vrmsv2 = meshRegionInfo2.getVolumeRegionMapSubvolume();
		
		double precision = 1.1e-15;
		double MAX_REL_ERROR = 1.1e-15;		
		
		for (int i = 0; i < meshRegionInfo1.getNumVolumeRegions(); i ++) {
			MeshRegionInfo.VolumeRegionMapSubvolume region1 = (MeshRegionInfo.VolumeRegionMapSubvolume)vrmsv1.elementAt(i);
			MeshRegionInfo.VolumeRegionMapSubvolume region2 = (MeshRegionInfo.VolumeRegionMapSubvolume)vrmsv2.elementAt(i);
			double region1Volume = region1.volumeRegionVolume;
			double region2Volume = region2.volumeRegionVolume;			
			
			if (region1.volumeRegionID != region2.volumeRegionID 
				|| region1.subvolumeID != region2.subvolumeID
				|| (Math.abs(region1Volume - region2Volume) > precision && Math.abs(region1Volume - region2Volume)/region1Volume > MAX_REL_ERROR)) {
				System.out.println("VolumeRegionMapSubVolume is different!");
				pw.println("VolumeRegionMapSubVolume is different!");
				return false;
			}
		}

		// Compare MembraneRegionsMapVolumeRegion
		if (meshRegionInfo1.getNumMembraneRegions() != meshRegionInfo2.getNumMembraneRegions()) {
			System.out.println("# of MembraneRegions is different");
			pw.println("# of MembraneRegions is different");
			return false;
		}

		Vector mrmsv1 = meshRegionInfo1.getMembraneRegionMapVolumeRegion();
		Vector mrmsv2 = meshRegionInfo2.getMembraneRegionMapVolumeRegion();

		for (int i = 0; i < meshRegionInfo2.getNumMembraneRegions(); i ++) {	
			MeshRegionInfo.MembraneRegionMapVolumeRegion region1 = (MeshRegionInfo.MembraneRegionMapVolumeRegion)mrmsv1.elementAt(i);
			MeshRegionInfo.MembraneRegionMapVolumeRegion region2 = (MeshRegionInfo.MembraneRegionMapVolumeRegion)mrmsv2.elementAt(i);

			double region1Surface = region1.membraneRegionSurface;
			double region2Surface = region2.membraneRegionSurface;
			
			// compare surface area, ignoring the index
			if (Math.abs(region1Surface - region2Surface)/region1Surface > MAX_REL_ERROR && Math.abs(region1Surface - region2Surface) > precision) {
				System.out.println("MembraneRegionsMapVolumeRegion is different!");
				pw.println("MembraneRegionsMapVolumeRegion is different!");
				return false;
			}
		}
		
		// Compare VolumeElementsMapVolumeRegion
		if (mesh1.getNumVolumeElements() != mesh2.getNumVolumeElements()) {
			return false;
		}
		for (int i = 0; i < mesh1.getNumVolumeElements(); i ++) {
			if (mesh1.getVolumeRegionIndex(i) != mesh2.getVolumeRegionIndex(i)) {
				System.out.println("VolumeElementsMapVolumeRegion is different at " + i);
				pw.println("VolumeElementsMapVolumeRegion is different at " + i);
				return false;
			}
		}

		// Compare Membrane Elements
		if (mesh1.getNumMembraneElements() != mesh2.getNumMembraneElements()){
			return false;
		}
		if (mesh1.getNumMembraneElements()==0){
			return true;
		}
		MembraneElement[] memElements1 = mesh1.getMembraneElements();
		MembraneElement[] memElements2 = mesh2.getMembraneElements();

		for (int i = 0; i < mesh1.getNumMembraneElements(); i++){
		
			// index
			if (memElements1[i].getMembraneIndex() != memElements2[i].getMembraneIndex()){
				return false;
			}			

			// Inside
			if (memElements1[i].getInsideVolumeIndex() != memElements2[i].getInsideVolumeIndex()){
				return false;
			}

			// Outside
			if (memElements1[i].getOutsideVolumeIndex() != memElements2[i].getOutsideVolumeIndex()){
				return false;
			}
			
			// Neighbors	
			int[] neighborIndexes1 = memElements1[i].getMembraneNeighborIndexes();
			int[] neighborIndexes2 = memElements2[i].getMembraneNeighborIndexes();
			if ((neighborIndexes1!=null && neighborIndexes2==null) ||
				(neighborIndexes1==null && neighborIndexes2!=null)){
				return false;
			}
			if (neighborIndexes1!=null && neighborIndexes2!=null){
				if (neighborIndexes1.length!=neighborIndexes2.length){
					return false;
				}
				for (int k=0;k<neighborIndexes1.length;k++){
					if (neighborIndexes1[k] != neighborIndexes2[k]){
						return false;
					}
				}
			}
			// Membrane Region ID
			if (mesh1.getMembraneRegionIndex(i) != mesh2.getMembraneRegionIndex(i)) {
				return false;
			}
			
			// X, Y, Z
			if (memElements1[i].centroidX != memElements2[i].centroidX 
				|| memElements1[i].centroidY != memElements2[i].centroidY
				|| memElements1[i].centroidZ != memElements2[i].centroidZ) {
				return false;				
			}
			// area
			if (Math.abs(memElements1[i].area - memElements2[i].area) > precision) {
				return false;
			}
			// normal
			if (Math.abs(memElements1[i].normalX - memElements2[i].normalX) > precision 
					|| Math.abs(memElements1[i].normalY - memElements2[i].normalY) > precision
					|| Math.abs(memElements1[i].normalZ - memElements2[i].normalZ) > precision) {
				return false;
			}
		}
			
	} catch (Exception ex) {
		ex.printStackTrace();
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (8/12/2005 1:06:21 PM)
 * @return cbit.vcell.geometry.Coordinate
 * @param orig cbit.util.Origin
 * @param ext cbit.util.Extent
 * @param dimensionFlag int
 */
public static double coordComponentFromSinglePlanePolicy(Origin argOrigin, Extent argExtent, int argAxisFlag) {
	
	if(argAxisFlag == Coordinate.X_AXIS){
		return argExtent.getX()/2.0 + argOrigin.getX();
	}else if(argAxisFlag == Coordinate.Y_AXIS){
		return argExtent.getY()/2.0 + argOrigin.getY();
	}else if(argAxisFlag == Coordinate.Z_AXIS){
		return argExtent.getZ()/2.0 + argOrigin.getZ();
	}

	throw new IllegalArgumentException("Unknown Axis Flag="+argAxisFlag);
}


/**
 * This method was created by a SmartGuide.
 */
public static CartesianMesh createSimpleCartesianMesh(Origin orig, Extent extent, ISize size, RegionImage regionImage) throws IOException{
	CartesianMesh mesh = new CartesianMesh();
	mesh.setOrigin(orig);
	mesh.setExtent(extent);
	mesh.setSize(size.getX(), size.getY(), size.getZ());
	
	mesh.meshRegionInfo = new MeshRegionInfo();	
	byte[] compressRegionBytes = BeanUtils.compress(regionImage.getShortEncodedRegionIndexImage());
	mesh.meshRegionInfo.setCompressedVolumeElementMapVolumeRegion(compressRegionBytes, mesh.getNumVolumeElements());
	
	return mesh;
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public static CartesianMesh fromTokens(cbit.vcell.math.CommentStringTokenizer meshTokens,cbit.vcell.math.CommentStringTokenizer membraneMeshMetricsTokens) throws MathException {
	CartesianMesh mesh = new CartesianMesh();

	MembraneMeshMetrics membraneMeshMetrics = null;
	if(membraneMeshMetricsTokens != null){
		membraneMeshMetrics = mesh.readMembraneMeshMetrics(membraneMeshMetricsTokens);
	}
	mesh.read(meshTokens,membraneMeshMetrics);
	return mesh;
}


/**
 * Insert the method's description here.
 * Creation date: (7/10/01 4:05:48 PM)
 * @return cbit.vcell.solvers.ContourElement[]
 */
public ContourElement[] getContourElements() {
	if (contourElements == null) {
		inflate();
	}
	return contourElements;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getContourRegionIndex(int contourIndex) {	
	throw new RuntimeException("CartesianMesh.getContourRegionIndex() not yet implemented");
	//ContourElement contourElement = getContourElements()[contourIndex];
	//return contourElement.getRegionIndex();
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinate(cbit.vcell.math.CoordinateIndex coordIndex) {
	//
	//
	// calculate coordinates based on element coordinates 
	//     
	//     1--------2--------3-------4--------N
	//
	// so spacing is divided into (N-1) regions.
	//
	//
	// if N is 1, then take middle of that dimension
	//
	//
	double x = coordComponentFromSinglePlanePolicy(origin,extent,Coordinate.X_AXIS);//extent.getX()/2.0 + origin.getX();
	if (getSizeX()>1){
		x = (((double)coordIndex.x)/(getSizeX()-1))*extent.getX()+origin.getX();
	}
	double y = coordComponentFromSinglePlanePolicy(origin,extent,Coordinate.Y_AXIS);//extent.getY()/2.0 + origin.getY();
	if (getSizeY()>1){
		y = (((double)coordIndex.y)/(getSizeY()-1))*extent.getY()+origin.getY();
	}
	double z = coordComponentFromSinglePlanePolicy(origin,extent,Coordinate.Z_AXIS);//extent.getZ()/2.0 + origin.getZ();
	if (getSizeZ()>1){
		z = (((double)coordIndex.z)/(getSizeZ()-1))*extent.getZ()+origin.getZ();
	}
	return (new Coordinate(x, y, z));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinateFromContourIndex(int contourIndex) {
    ContourElement ce = getContourElements()[contourIndex];
    Coordinate begCoord = ce.getBeginCoordinate();
    Coordinate endCoord = ce.getEndCoordinate();
    return (new Coordinate(
		0.5*(begCoord.getX() + endCoord.getX()),
		0.5*(begCoord.getY() + endCoord.getY()),
		0.5*(begCoord.getZ() + endCoord.getZ())));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinateFromMembraneIndex(int membraneIndex) {
    MembraneElement me = getMembraneElements()[membraneIndex];
    Coordinate inCoord = getCoordinateFromVolumeIndex(me.getInsideVolumeIndex());
    Coordinate outCoord = getCoordinateFromVolumeIndex(me.getOutsideVolumeIndex());
    return (new Coordinate(
		0.5*(inCoord.getX() + outCoord.getX()),
		0.5*(inCoord.getY() + outCoord.getY()),
		0.5*(inCoord.getZ() + outCoord.getZ())));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinateFromVolumeIndex(int volumeIndex) {
	return getCoordinate(getCoordinateIndexFromVolumeIndex(volumeIndex));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public CoordinateIndex getCoordinateIndexFromFractionalIndex(Coordinate fractionalIndex) {
	return new CoordinateIndex(	(int)Math.round(fractionalIndex.getX()),
								(int)Math.round(fractionalIndex.getY()),
								(int)Math.round(fractionalIndex.getZ()));
}


/**
 * Insert the method's description here.
 * Creation date: (8/29/00 10:51:55 AM)
 * @return cbit.vcell.math.CoordinateIndex
 * @param volIndex int
 */
public CoordinateIndex getCoordinateIndexFromVolumeIndex(int volIndex) {
	int volZ = volIndex / (getSizeX() * getSizeY());
	volIndex -= volZ * (getSizeX() * getSizeY());
	int volY = volIndex / getSizeX();
	volIndex -= volY * getSizeX();
	int volX = volIndex;
	return new CoordinateIndex(volX, volY, volZ);
}


/**
 * This method was created in VisualAge.
 * @return int
 */
public int getDataLength(cbit.vcell.simdata.VariableType pdeVariableType) {
	int num = 0;
	if (pdeVariableType.equals(cbit.vcell.simdata.VariableType.VOLUME)) {
		num = getSizeX() * getSizeY() * getSizeZ();
	} else if (pdeVariableType.equals(cbit.vcell.simdata.VariableType.MEMBRANE)) {
		num = (membraneElements == null ? 0 : membraneElements.length);
	} else if (pdeVariableType.equals(cbit.vcell.simdata.VariableType.CONTOUR)) {
		throw new RuntimeException("CartesianMesh.getDataLength("+pdeVariableType+") not yet implemented");
	} else if (pdeVariableType.equals(cbit.vcell.simdata.VariableType.VOLUME_REGION)) {
		num = getNumVolumeRegions();
	} else if (pdeVariableType.equals(cbit.vcell.simdata.VariableType.MEMBRANE_REGION)) {
		num = getNumMembraneRegions();
	} else if (pdeVariableType.equals(cbit.vcell.simdata.VariableType.CONTOUR_REGION)) {
		throw new RuntimeException("CartesianMesh.getDataLength("+pdeVariableType+") not yet implemented");
	}
	return num;
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 */
public Extent getExtent() {
	if (extent == null) {
		inflate();
	}
	return extent;
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getFractionalCoordinateIndex(Coordinate worldCoord) {
	//
	//
	// calculate coordinates based on element coordinates 
	//     
	//     1--------2--------3-------4--------N
	//
	// so spacing is divided into (N-1) regions.
	//
	//
	// if N is 1, then take middle of that dimension
	//
	//
	double fractX;
	double fractY;
	double fractZ;
	
	if (getSizeX()>1){
		fractX = (worldCoord.getX()-origin.getX())/extent.getX()*(getSizeX()-1);
	}else{
		fractX = 0;
	}
	
	if (getSizeY()>1){
		fractY = (worldCoord.getY()-origin.getY())/extent.getY()*(getSizeY()-1);
	}else{
		fractY = 0;
	}
	
	if (getSizeZ()>1){
		fractZ = (worldCoord.getZ()-origin.getZ())/extent.getZ()*(getSizeZ()-1);
	}else{
		fractZ = 0;
	}

	return new Coordinate(fractX,fractY,fractZ);
}


/**
 * Insert the method's description here.
 * Creation date: (2/4/2004 5:18:45 PM)
 * @return int
 * @param mesh cbit.vcell.solvers.CartesianMesh
 */
public int getGeometryDimension() {
	// Get dimension of geometry using mesh variables to use appropriate resampling algorithm.
	int dimension = 0;
	
	if ( (getSizeX() > 1) && (getSizeY() > 1) && (getSizeZ() > 1) ) {
		dimension = 3;
	} else if ( ( (getSizeX() > 1) && (getSizeY() > 1) && (getSizeZ() == 1) ) ||
				( (getSizeX() > 1) && (getSizeY() == 1) && (getSizeZ() > 1) ) ||
				( (getSizeX() == 1) && (getSizeY() > 1) && (getSizeZ() > 1) )  ) {
		dimension = 2;
	} else if ( ( (getSizeX() > 1) && (getSizeY() == 1) && (getSizeZ() == 1) ) ||
				( (getSizeX() == 1) && (getSizeY() > 1) && (getSizeZ() == 1) ) ||
				( (getSizeX() == 1) && (getSizeY() == 1) && (getSizeZ() > 1) )  ) {
		dimension = 1;
	}
				
	return dimension;
}


/**
 * Insert the method's description here.
 * Creation date: (7/10/01 4:05:48 PM)
 * @return cbit.vcell.solvers.MembraneElement[]
 */
public MembraneElement[] getMembraneElements() {
	if (membraneElements == null) {
		inflate();
	}
	return membraneElements;
}


/**
 * Insert the method's description here.
 * Creation date: (5/2/2005 10:20:34 AM)
 * @return int[]
 * @param referenceMesh cbit.vcell.solvers.CartesianMesh
 */
public int[] getMembraneIndexMapping(CartesianMesh referenceMesh) {
	//
	// this method gets a mapping between the membrane element indexes of this mesh and the reference mesh.
	// the assumption is that the volume indices don't require any mappings, but the surfaces may have their normals flipped.
	// 
	//
	//   e.g.  this allows comparing membrane values as follows: 
	//
	//       int[] mapping = this.getMembraneIndexMapping(refMesh);
	//       double difference = refData[i] - data[mapping[i]];
	//
	if (getNumMembraneElements()!=referenceMesh.getNumMembraneElements()){
		throw new RuntimeException("this mesh and reference mesh have different number of membrane elements '"+getNumMembraneElements()+" and "+referenceMesh.getNumMembraneElements());
	}
	if (getNumMembraneElements()==0){
		return null;
	}
	MembraneElement[] memElements = getMembraneElements();
	MembraneElement[] refMemElements = referenceMesh.getMembraneElements();
	int[] mapping = new int[refMemElements.length];
	for (int i = 0; i < refMemElements.length; i++){
		int refInsideIndex = refMemElements[i].getInsideVolumeIndex();
		int refOutsideIndex = refMemElements[i].getOutsideVolumeIndex();
		int correspondingMemIndex = -1;
		for (int j = 0; j < memElements.length; j++){
			int insideIndex = memElements[j].getInsideVolumeIndex();
			int outsideIndex = memElements[j].getOutsideVolumeIndex();
			//
			// just in case inside/outside are flipped we will check both ways.
			//
			if ((insideIndex==refInsideIndex && outsideIndex==refOutsideIndex) || (insideIndex==refOutsideIndex && outsideIndex==refInsideIndex)){
				correspondingMemIndex = j;
				break;
			}
		}
		if (correspondingMemIndex==-1){
			throw new RuntimeException("couldn't find corresponding membrane element in reference mesh for index = "+i);
		}
		mapping[i] = correspondingMemIndex;
	}
	
	return mapping;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getMembraneRegionIndex(int membraneIndex) {
	return getMeshRegionInfo().getMembraneRegionForMembraneElement(membraneIndex);
}


/**
 * Insert the method's description here.
 * Creation date: (7/9/2001 12:29:36 PM)
 * @return cbit.vcell.solvers.MeshRegionInfo
 */
private MeshRegionInfo getMeshRegionInfo() {
	//
	// mesh region info is a very low-level object, it should be encapsulated.
	//
	if (meshRegionInfo == null) {
		inflate();
	}
	return meshRegionInfo;
}


/**
 * Insert the method's description here.
 * Creation date: (5/2/2005 10:52:06 AM)
 * @return int
 */
public int getNumMembraneElements() {
	MembraneElement memElement[] = getMembraneElements();
	if (memElement!=null){
		return memElement.length;
	}else{
		return 0;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (3/3/2002 11:20:04 PM)
 * @return int
 */
public int getNumMembraneRegions() {
	MeshRegionInfo mri = getMeshRegionInfo();
	if (mri == null){
		return 0;
	}
	return mri.getNumMembraneRegions();
}


/**
 * Insert the method's description here.
 * Creation date: (5/2/2005 10:52:06 AM)
 * @return int
 */
public int getNumVolumeElements() {
	return size.getX()*size.getY()*size.getZ();
}


/**
 * Insert the method's description here.
 * Creation date: (3/3/2002 11:20:04 PM)
 * @return int
 */
public int getNumVolumeRegions() {
	MeshRegionInfo mri = getMeshRegionInfo();
	if (mri == null){
		return 0;
	}
	return mri.getNumVolumeRegions();
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 */
public Origin getOrigin() {
	if (origin == null) {
		inflate();
	}	
	return origin;
}


/**
 * Insert the method's description here.
 * Creation date: (9/20/2005 5:05:53 PM)
 * @return double
 */
public double getRegionMembraneSurfaceAreaFromMembraneIndex(int membraneIndex) {
	return getMeshRegionInfo().getRegionMembraneSurfaceAreaFromMembraneIndex(membraneIndex);
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getSizeX() {
	if (size == null) {
		inflate();
	}	
	return size.getX();
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getSizeY() {
	if (size == null) {
		inflate();
	}	
	return size.getY();
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getSizeZ() {
	if (size == null) {
		inflate();
	}

	return size.getZ();
}


/**
 * Insert the method's description here.
 * Creation date: (8/20/2003 1:46:44 PM)
 * @return int
 * @param volIndex int
 */
public int getSubVolumeFromVolumeIndex(int volIndex) {
	int regionIndex = getVolumeRegionIndex(volIndex);
	return meshRegionInfo.getSubVolumeIDfromVolRegion(regionIndex);
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
private int getVolumeIndex(int coordX,int coordY,int coordZ) {
	return coordX + getSizeX()*(coordY + getSizeY()*coordZ);
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getVolumeIndex(CoordinateIndex coordIndex) {
	return getVolumeIndex(coordIndex.x,coordIndex.y,coordIndex.z);
	//return coordIndex.x + getSizeX()*(coordIndex.y + getSizeY()*coordIndex.z);
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getVolumeRegionIndex(int volumeIndex) {
	return getMeshRegionInfo().getVolumeElementMapVolumeRegion(volumeIndex);
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getVolumeRegionIndex(CoordinateIndex coordIndex) {
	int volumeIndex = getVolumeIndex(coordIndex);
	return getMeshRegionInfo().getVolumeElementMapVolumeRegion(volumeIndex);
}


/**
 * This method was created in VisualAge.
 * @return java.lang.String
 * @param variable java.lang.String
 * @param time double
 */
public int[] getVolumeSliceIndices(int normalAxis, int sliceNumber) {

	Coordinate normalAxisDimension = Coordinate.convertAxisFromStandardXYZToNormal(getSizeX(),getSizeY(),getSizeZ(),normalAxis);
	int indices[] = new int[(int)normalAxisDimension.getX()*(int)normalAxisDimension.getY()];
	int counter = 0;
	CoordinateIndex coordIndex = new CoordinateIndex();
	for (int y = 0;y < normalAxisDimension.getY();y+= 1){
		for (int x = 0;x < normalAxisDimension.getX();x+= 1){
			//
			// indexing through "normal" slice, converting each X,Y pair into equivalent
			// (X,Y,Z) in mesh coordinates.
			//
			coordIndex.x = x;
			coordIndex.y = y;
			coordIndex.z = sliceNumber;
			Coordinate.convertCoordinateIndexFromNormalToStandardXYZ(coordIndex,normalAxis);
			//
			// store mesh coordinates in "normal" slice sample array. 
			//
			indices[counter] = getVolumeIndex(coordIndex.x,coordIndex.y,coordIndex.z);
			counter+= 1;
		}
	}
	return indices;
}

/**
 * Insert the method's description here.
 * Creation date: (7/10/01 4:15:09 PM)
 * @return boolean
 */
public boolean hasRegionInfo() {
	return (meshRegionInfo!=null);
}


/**
 * Insert the method's description here.
 * Creation date: (9/13/2004 9:33:11 AM)
 * @param out java.io.ObjectOutputStream
 * @exception java.io.IOException The exception description.
 */
private void inflate() {
	if (compressedBytes == null) {
		return;
	}

	try {
		//Object objArray[] =  { version, size, origin, extent, meshRegionInfo, membraneElements, contourElements};
		Object objArray[] = (Object[])cbit.util.BeanUtils.fromCompressedSerialized(compressedBytes);
		version = (String)objArray[0];
		size = (ISize)objArray[1];
		origin = (Origin)objArray[2];
		extent = (Extent)objArray[3];
		meshRegionInfo = (MeshRegionInfo)objArray[4];
		membraneElements = (MembraneElement[])objArray[5];
		contourElements = (ContourElement[])objArray[6];

		compressedBytes = null;
		
	} catch (Exception ex) {
		ex.printStackTrace(System.out);
		throw new RuntimeException(ex.getMessage());
	}
}


/**
 * Insert the method's description here.
 * Creation date: (6/14/2001 4:54:52 PM)
 * @return boolean
 * @param from cbit.vcell.solvers.MembraneElement
 * @param to cbit.vcell.solvers.MembraneElement
 */
private boolean isFriendshipMutual(MembraneElement neighbor1,MembraneElement neighbor2) {
	//
	if(!isInList(neighbor1.getMembraneIndex(),neighbor2.getMembraneNeighborIndexes())){
		return false;
	}
	if(!isInList(neighbor2.getMembraneIndex(),neighbor1.getMembraneNeighborIndexes())){
		return false;
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (6/14/2001 5:14:36 PM)
 * @return boolean
 * @param checkMe int
 * @param checkList int[]
 */
private boolean isInList(int checkMe, int[] checkList) {
	boolean bInList = false;
    for (int i = 0; i < checkList.length; i += 1) {
        if (checkMe == checkList[i]) {
	        bInList = true;
            break;
        }
    }
    return bInList;
}


/**
 * Insert the method's description here.
 * Creation date: (6/14/2001 4:26:36 PM)
 * @return boolean
 */
public boolean isMembraneConnectivityOK() {
    for (int c = 0; c < membraneElements.length; c += 1) {
        //Get the next membraneElement in the list
        MembraneElement currentMembraneElement = membraneElements[c];
        int[] membraneNeighborIndexes =
            currentMembraneElement.getMembraneNeighborIndexes();
        //Search the neighbors the the currentMembraneElement
        for (int mnic = 0; mnic < membraneNeighborIndexes.length; mnic += 1) {
            //Get the connectivity neighbors the of the next neighbor in the list
            if (!isFriendshipMutual(currentMembraneElement,membraneElements[membraneNeighborIndexes[mnic]])) {
                return false;
            }
        }
    }
    return true;
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
private void read(cbit.vcell.math.CommentStringTokenizer tokens,MembraneMeshMetrics membraneMeshMetrics) throws MathException {
	//
	// clear previous contents
	//
	membraneElements = null;

	//
	// read new stuff
	//
	String token = null;
	token = tokens.nextToken();
	if (token.equalsIgnoreCase(VCML.Version)){
		//
		// read version number 
		//
		token = tokens.nextToken(); 
		this.version = token;
		token = tokens.nextToken();
	}
	if (token.equalsIgnoreCase(VCML.CartesianMesh)){
		token = tokens.nextToken();
	}else{
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.CartesianMesh);
	}
	//
	// only Version 1.1 and later supports membrane connectivity  (as of 8/30/2000)
	//
	boolean bConnectivity = false;
	if (version.equals(VERSION_1_1) || version.equals(VERSION_1_2)){
		bConnectivity = true;
	}
	//
	// only Version 1.2 and later supports Regions
	//
	boolean bRegions = false;
	if (version.equals(VERSION_1_2)){
		bRegions = true;
		meshRegionInfo = new MeshRegionInfo();
	}
	
	if (!token.equalsIgnoreCase(VCML.BeginBlock)){
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
	}			
	while (tokens.hasMoreTokens()){
		token = tokens.nextToken();
		if (token.equalsIgnoreCase(VCML.EndBlock)){
			break;
		}			
		if (token.equalsIgnoreCase(VCML.Size)){
			int sx, sy, sz;
			try {
				token = tokens.nextToken();
				sx = Integer.valueOf(token).intValue();
				token = tokens.nextToken();
				sy = Integer.valueOf(token).intValue();
				token = tokens.nextToken();
				sz = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("expected:  "+VCML.Size+" # # #");
			}
			setSize(sx,sy,sz);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.Extent)){
			double ex, ey, ez;
			try {
				token = tokens.nextToken();
				ex = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				ey = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				ez = Double.valueOf(token).doubleValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("expected:  "+VCML.Extent+" # # #");
			}
			setExtent(new Extent(ex,ey,ez));
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.Origin)){
			double ox, oy, oz;
			try {
				token = tokens.nextToken();
				ox = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				oy = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				oz = Double.valueOf(token).doubleValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("expected:  "+VCML.Origin+" # # #");
			}
			setOrigin(new Origin(ox,oy,oz));
			continue;
		}
		//
		//
		//
		if (token.equalsIgnoreCase(VCML.VolumeRegionsMapSubvolume)){
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numVolumeRegions = 0;
			try {
				numVolumeRegions = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the VolumeRegionsMapSubvolume list length");
			}
			int checkCount = 0;
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				try{
					int volRegionID = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int subvolumeID = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					double volume = Double.valueOf(token).doubleValue();
					meshRegionInfo.mapVolumeRegionToSubvolume(volRegionID,subvolumeID,volume);
				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  # # #");
				}
				checkCount+= 1;
			}
			if(checkCount != numVolumeRegions){
				throw new MathFormatException("CartesianMesh.read->VolumeRegionsMapSubvolume: read "+checkCount+" VolRegions but was expecting "+numVolumeRegions);
			}
			continue;
		}	
		if (token.equalsIgnoreCase(VCML.MembraneRegionsMapVolumeRegion)){
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numMembraneRegions = 0;
			try {
				numMembraneRegions = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the MembraneRegionsMapVolumeRegion list length");
			}
			int checkCount = 0;
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				try{
					int memRegionID = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int volRegionIn = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int volRegionOut = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					double surface = Double.valueOf(token).doubleValue();
					meshRegionInfo.mapMembraneRegionToVolumeRegion(memRegionID,volRegionIn,volRegionOut,surface);
				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  # # #");
				}
				checkCount+= 1;
			}
			if(checkCount != numMembraneRegions){
				throw new MathFormatException("CartesianMesh.read->MembraneRegionsMapVolumeRegion: read "+checkCount+" MembraneRegions but was expecting "+numMembraneRegions);
			}
			continue;
		}	
		if (token.equalsIgnoreCase(VCML.VolumeElementsMapVolumeRegion)){
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numVolumeElements = 0;
			try {
				numVolumeElements = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the VolumeElementsMapVolumeRegion list length");
			}
			token  = tokens.nextToken();
			boolean bCompressed = token.equalsIgnoreCase("Compressed");
			if(!bCompressed){
				if(!token.equalsIgnoreCase("UnCompressed")){
					throw new MathFormatException("unexpected token "+token+" expecting Compress or UnCompress");
				}
			}
			byte[] volumeElementMap = new byte[numVolumeElements];
			int checkCount = 0;
			if(bCompressed){
				//Get HEX encoded bytes of the compressed VolumeElements-RegionID Map
				StringBuffer hexOfCompressed = new StringBuffer();
				while (tokens.hasMoreTokens()){
					token = tokens.nextToken();
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}
					hexOfCompressed.append(token);
				}
				//Un-HEX the compressed data
				byte[] compressedData = Hex.toBytes(hexOfCompressed.toString());
				try{
					meshRegionInfo.setCompressedVolumeElementMapVolumeRegion(compressedData, numVolumeElements);
				}catch(IOException e){
					throw new MathFormatException("CartesianMesh.read->VolumeElementsMapVolumeRegion "+e.toString());
				}
				checkCount = meshRegionInfo.getUncompressedVolumeElementMapVolumeRegionLength();
			}else{
				while (tokens.hasMoreTokens()){
					token = tokens.nextToken();
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}
					try{
						int volumeRegionID = Integer.valueOf(token).intValue();
						volumeElementMap[checkCount] = (byte)volumeRegionID;
					}catch (NumberFormatException e){
						throw new MathFormatException("expected:  # # #");
					}
					checkCount+= 1;
				}
			}
			if(checkCount != numVolumeElements && checkCount != 2 * numVolumeElements){
				throw new MathFormatException("CartesianMesh.read->VolumeElementsMapVolumeRegion: read "+checkCount+" VolumeElements but was expecting "+numVolumeElements);
			}
			continue;
		}
		//
		//
		//	
		if (token.equalsIgnoreCase(VCML.MembraneElements)){
			//
			// read '{'
			//
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numMemElements = 0;
			try {
				numMemElements = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the membraneElement list length");
			}
			//
			// read list of the following format:
			//
			//		memIndex insideVolIndex outsideVolIndex
			//
			membraneElements = new MembraneElement[numMemElements];
			int index = 0;
			int[] membraneElementMapMembraneRegion = null;
			if(bRegions){
				membraneElementMapMembraneRegion = new int[numMemElements];
				meshRegionInfo.mapMembraneElementsToMembraneRegions(membraneElementMapMembraneRegion);
			}
			//
			// loop until read a "}"
			//
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				int memIndex = -1;
				int insideIndex = -1;
				int outsideIndex = -1;
				try {
					//
					// read first three tokens of a membrane element
					//
					//     membraneIndex   insideIndex    outsideIndex
					//
					memIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					insideIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					outsideIndex = Integer.valueOf(token).intValue();

				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  # # #");
				}
				
				MembraneElement me = null;
				//
				// grab connectivity if enabled (additional four tokens)
				//
				//     memNeighbor1  memNeighbor2  memNeighbor3  memNeighbor4
				//
				//	where memNeighborX = -1 for missing connections.   
				//
				if (bConnectivity){
					try {
						token = tokens.nextToken();
						int neighbor1 = Integer.valueOf(token).intValue();
						token = tokens.nextToken();
						int neighbor2 = Integer.valueOf(token).intValue();
						token = tokens.nextToken();
						int neighbor3 = Integer.valueOf(token).intValue();
						token = tokens.nextToken();
						int neighbor4 = Integer.valueOf(token).intValue();
						//
						if(bRegions){
							token = tokens.nextToken();
							int regionID = Integer.valueOf(token).intValue();
							membraneElementMapMembraneRegion[memIndex] = regionID;
						}
						if(membraneMeshMetrics == null){
							me = new MembraneElement(	memIndex,insideIndex,outsideIndex,
													neighbor1,neighbor2,neighbor3,neighbor4,MembraneElement.AREA_UNDEFINED,0,0,0,0,0,0);
						}else{
							me = new MembraneElement(	memIndex,insideIndex,outsideIndex,
													neighbor1,neighbor2,neighbor3,neighbor4,
													membraneMeshMetrics.areas[memIndex],
													membraneMeshMetrics.normals[memIndex][0],
													membraneMeshMetrics.normals[memIndex][1],
													membraneMeshMetrics.normals[memIndex][2],
													membraneMeshMetrics.centroids[memIndex][0],
													membraneMeshMetrics.centroids[memIndex][1],
													membraneMeshMetrics.centroids[memIndex][2]);
						}
					}catch (NumberFormatException e){
						throw new MathFormatException("expected:  # # # # # # #");
					}
				}else{
					me = new MembraneElement(memIndex,insideIndex,outsideIndex);
				}
				
				membraneElements[index] = me;
				index++;
			}
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.ContourElements)){
			//
			// read '{'
			//
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numContourElements = 0;
			try {
				numContourElements = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the contourElement list length");
			}
			//
			// read list of the following format:
			//
			//		contourIndex volumeIndex beginCoord endCoord prevIndex nextIndex
			//
			contourElements = new ContourElement[numContourElements];
			int index = 0;
			//
			// loop until read a "}"
			//
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				ContourElement ce = null;
				try {
					//
					// read first two tokens of a contour element
					//
					//     contourIndex volumeIndex
					//
					int contourIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int volumeIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();

					//
					// read beginCoord endCoord
					//
					double beginX = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double beginY = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double beginZ = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();

					double endX = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double endY = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double endZ = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();

					Coordinate begin = new Coordinate(beginX,beginY,beginZ);
					Coordinate end = new Coordinate(endX,endY,endZ);

					//
					// read last two tokens of a contour element
					//
					//     prevContourIndex nextContourIndex
					//
					int prevContourIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int nextContourIndex = Integer.valueOf(token).intValue();

					ce = new ContourElement(contourIndex, volumeIndex, begin, end, prevContourIndex, nextContourIndex);

				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  %d %d   %f %f %f    %f %f %f   %d %d");
				}
				
				contourElements[index] = ce;
				
				index++;
			}
			continue;
		}
		throw new MathFormatException("unexpected identifier "+token);
	}
	switch (getGeometryDimension()) {
		case 1 : {
			if (extent.getY() != 1 || extent.getZ() != 1) {
				System.out.println("Extent "+extent.toString()+" for a 1-D mesh truncated to 1 for y and z");
				setExtent(new Extent(extent.getX(), 1.0, 1.0));
			}
			break;
		}
		case 2 : {
			if (extent.getZ() != 1) {
				System.out.println("Extent "+extent.toString()+" for a 2-D mesh truncated to 1 for z");
				setExtent(new Extent(extent.getX(), extent.getY(), 1.0));
			}
			break;			
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (2/15/2006 2:06:21 PM)
 */
public MembraneMeshMetrics readMembraneMeshMetrics(cbit.vcell.math.CommentStringTokenizer tokens) throws MathException{

	MembraneMeshMetrics membraneMeshMetrics = new MembraneMeshMetrics();
	
	String token = null;
	token = tokens.nextToken();
	if (token.equalsIgnoreCase(VCML.MembraneElements)){
		token = tokens.nextToken();
	}else{
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.CartesianMesh);
	}
	if (!token.equalsIgnoreCase(VCML.BeginBlock)){
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
	}
	
	token = tokens.nextToken();
	int numMembraneElements = 0;
	try{
		numMembraneElements = Integer.valueOf(token).intValue();
	}catch(NumberFormatException e){
		throw new MathFormatException("unexpected token "+token+" expecting MembraneElement count");
	}
	
	short[] regionIndex = new short[numMembraneElements];
	float[] areas = new float[numMembraneElements];
	float[][] normals = new float[numMembraneElements][3];
	float[][] centroids = new float[numMembraneElements][3];

	if(
		!(token = tokens.nextToken()).equals("Index") ||
		!(token = tokens.nextToken()).equals("RegionIndex") ||
		!(token = tokens.nextToken()).equals("X") ||
		!(token = tokens.nextToken()).equals("Y") ||
		!(token = tokens.nextToken()).equals("Z") ||
		!(token = tokens.nextToken()).equals("Area") ||
		!(token = tokens.nextToken()).equals("Nx") ||
		!(token = tokens.nextToken()).equals("Ny") ||
		!(token = tokens.nextToken()).equals("Nz")
	){
		throw new MathFormatException("unexpected MeshMetrics column description = "+token);
	}
	int counter = 0;
	while (tokens.hasMoreTokens()){
		token = tokens.nextToken();
		if (token.equalsIgnoreCase(VCML.EndBlock)){
			break;
		}			
		if(counter >= numMembraneElements){
			throw new MathFormatException("Error parsing MembraneMeshMetrics values index="+counter+".  Expecting only "+numMembraneElements+" MembraneElements");
		}
		try {
			int index = Integer.valueOf(token).intValue();
			if(index != counter){
				throw new MathFormatException("unexpected token "+token+" expecting "+counter);
			}
			regionIndex[counter] = Short.parseShort(tokens.nextToken());
			//centroids
			centroids[counter][0] = Float.parseFloat(tokens.nextToken());
			centroids[counter][1] = Float.parseFloat(tokens.nextToken());
			centroids[counter][2] = Float.parseFloat(tokens.nextToken());
			//area
			areas[counter] = Float.parseFloat(tokens.nextToken());
			//normals
			normals[counter][0] = Float.parseFloat(tokens.nextToken());
			normals[counter][1] = Float.parseFloat(tokens.nextToken());
			normals[counter][2] = Float.parseFloat(tokens.nextToken());
			
		}catch (NumberFormatException e){
			throw new MathFormatException("Error parsing MembraneMeshMetrics values index="+counter+"  "+e.getMessage());
		}
		counter+= 1;
	}

	membraneMeshMetrics.regionIndexes = regionIndex;
	membraneMeshMetrics.areas = areas;
	membraneMeshMetrics.normals = normals;
	membraneMeshMetrics.centroids = centroids;
	
	return membraneMeshMetrics;	
}


/**
 * Insert the method's description here.
 * Creation date: (9/13/2004 9:33:11 AM)
 * @param out java.io.ObjectOutputStream
 * @exception java.io.IOException The exception description.
 */
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
	int compressedSize = s.readInt();
	compressedBytes = new byte[compressedSize];
	s.readFully(compressedBytes, 0, compressedSize);
}


/**
 * This method was created in VisualAge.
 * @param extent cbit.util.Extent
 */
private void setExtent(cbit.util.Extent argExtent) {
	this.extent = argExtent;
}


/**
 * This method was created in VisualAge.
 * @param extent cbit.util.Extent
 */
private void setOrigin(cbit.util.Origin origin) {
	this.origin = origin;
}


/**
 * This method was created in VisualAge.
 * @param x int
 * @param y int
 * @param z int
 */
private void setSize(int x, int y, int z) {
	size = new ISize(x, y, z);
}


/**
 * Insert the method's description here.
 * Creation date: (9/13/2004 9:33:11 AM)
 * @param out java.io.ObjectOutputStream
 * @exception java.io.IOException The exception description.
 */
private void writeObject(ObjectOutputStream s) throws IOException {
	Object objArray[] =  { version, size, origin, extent, meshRegionInfo, membraneElements, contourElements};

	if (compressedBytes == null) {
		compressedBytes = cbit.util.BeanUtils.toCompressedSerialized(objArray);
	}
	s.writeInt(compressedBytes.length);
	s.write(compressedBytes);
}

public void write(PrintStream out)
{
	//
	// 'Version 1.1' added membrane connectivity
	// 'Version 1.2' added regions
	//
	out.println("Version 1.2\n");
	out.println("CartesianMesh {\n");//Begin CartesianMesh
	//
	writeCartesianMeshHeader(out);
	out.println("\n");
	writeVolumeRegionsMapSubvolume(out);
	out.println("\n");
	writeMembraneRegionMapVolumeRegion(out);
	out.println("\n");
	writeVolumeElementsMapVolumeRegion(out);
	out.println("\n");
	writeMembraneElements_Connectivity_Region(out);
	out.println("\n");
//	writeContourElements(out);
	//
	out.println("}\n");//End CartesianMesh
}

private void writeVolumeRegionsMapSubvolume(PrintStream out)
{
	int numVolumeRegions = getMeshRegionInfo().getNumVolumeRegions();	
	out.println("\tVolumeRegionsMapSubvolume {\n");
	out.println("\t"+numVolumeRegions+"\n");
	out.println("// VolRegID   SubvolID     Volume");
	for(int c = 0;c < numVolumeRegions;c+= 1){
		VolumeRegionMapSubvolume volRegionMapSubvolume = getMeshRegionInfo().getVolumeRegionMapSubvolume().get(c);
		out.println("\t"+volRegionMapSubvolume.volumeRegionID+" "+
				volRegionMapSubvolume.subvolumeID+" "+
				volRegionMapSubvolume.volumeRegionVolume);
	}
	out.println("\t}\n");
}
private void writeVolumeElementsMapVolumeRegion(PrintStream out)
{
	int numVolumeElements = getNumVolumeElements();
	byte[] compressedBytes = meshRegionInfo.getCompressedVolumeElementMapVolumeRegion();
	out.println("\tVolumeElementsMapVolumeRegion {");
	out.println("\t"+numVolumeElements+" Compressed");
	byte[] tempBuffer = new byte[1];
	for(int c = 0;c < compressedBytes.length;c+= 1){
		if(c%40 == 0){
			out.println("\n\t");
		}
		tempBuffer[0] = compressedBytes[c];
		out.print(Hex.toString(tempBuffer));
	}
	out.println("\n\t}\n");
}

private void writeMembraneRegionMapVolumeRegion(PrintStream out)
{
	int numMembraneRegions = getNumMembraneRegions();
	out.println("\tMembraneRegionsMapVolumeRegion {\n");
	out.println("\t"+numMembraneRegions);
	out.println("\t//MemRegID  VolRegIn  VolRegOut  Surface\n");
	if (numMembraneRegions>0){
		throw new RuntimeException("membrane regions not supported for write()");
	}
//	for(int c = 0;c < numMembraneRegions;c+= 1){
//		MembraneRegion *membraneRegion = getMembraneRegion(c);
//		VolumeRegion *vrInside = membraneRegion->getRegionInside();
//		VolumeRegion *vrOutside= membraneRegion->getRegionOutside();
//		out.println("\t%10ld %10ld %10ld %10.17lg",
//					membraneRegion->getId(),
//					vrInside->getId(),
//					vrOutside->getId(),
//					membraneRegion->getSurface());
//	}
	out.println("\t}");
}

private void writeCartesianMeshHeader(PrintStream out)
{
	out.println("\t//     X       Y       Z");
	out.println("\tSize   "+getSizeX()+"   "+getSizeY()+"    "+getSizeZ());
	out.println("\tExtent "+getExtent().getX()+"   "+getExtent().getY()+"   "+getExtent().getZ());
	out.println("\tOrigin "+getOrigin().getX()+"   "+getOrigin().getY()+"   "+getOrigin().getZ());
}

//boolean CartesianMesh::writeMeshMetrics(OutputStream out)
//{
//	out.println("MembraneElements {\n");
//	out.println("%d\n",(int)getNumMembraneElements());
//	out.println("%5s %11s %17s %25s %25s %25s %25s %25s %25s\n","Index","RegionIndex","X","Y","Z","Area","Nx","Ny","Nz");
//	for (int i=0;i<getNumMembraneElements();i++){
//		MembraneElement *memEl = pMembraneElement + i;
//		WorldCoord wc = getMembraneWorldCoord(i);
//		out.println("%-5ld %11ld %25.17lg %25.17lg %25.17lg %25.17lg %25.17lg %25.17lg %25.17lg\n",
//			memEl->index,
//			memEl->region->getId(),
//			wc.x,
//			wc.y,
//			wc.z,
//			memEl->area,
//			memEl->unitNormal.x,
//			memEl->unitNormal.y,
//			memEl->unitNormal.z);
//	}
//	out.println("}");
//	return TRUE;
//}

private void writeMembraneElements_Connectivity_Region(PrintStream out)
{
	out.println("\tMembraneElements {\n");
	out.println("\t"+getNumMembraneElements());
	out.println("\t//Indx  VIn  VOut  Conn0  Conn1  Conn2  Conn3  MemRegID");
	MembraneElement[] memEl = getMembraneElements();
	for (int i=0;membraneElements != null && i<membraneElements.length;i++){
		out.println("\t"+i+" "+memEl[i].getInsideVolumeIndex()+" "+memEl[i].getOutsideVolumeIndex()+" "+
				memEl[i].getMembraneNeighborIndexes()[0]+" "+
				memEl[i].getMembraneNeighborIndexes()[1]+" "+
				memEl[i].getMembraneNeighborIndexes()[2]+" "+
				memEl[i].getMembraneNeighborIndexes()[3]+" "+
				meshRegionInfo.getMembraneRegionForMembraneElement(i));
	}
	out.println("    }\n");
}

//private void writeContourElements(OutputStream out)
//{
//	int i;
//	//
//	// write out contour elements (if present)
//	//
//	if (getNumContourElements()>0){
//		out.println("    ContourElements {\n");
//		out.println("           %d\n",(int)getNumContourElements());
//		//
//		// index volumeIndex begin.x begin.y begin.z  end.x, end.y end.z neighbor(prev) neighbor(next)
//		//
//		for (i=0;i<getNumContourElements();i++){
//			ContourElement *cEl = getContourElement(i);
//			int neighborPrev = -1;
//			int neighborNext = -1;
//			if (cEl->getBorder() == CONTOUR_BEGIN){
//				neighborPrev = -1;
//				neighborNext = i+1;
//			}else if (cEl->getBorder() == CONTOUR_END){
//				neighborPrev = i-1;
//				neighborNext = -1;
//			}else if (cEl->getBorder() == CONTOUR_INTERIOR){
//				neighborPrev = i-1;
//				neighborNext = i+1;
//			}else{
//				throw new Exception("Error writing contour mesh, contour element(%ld) has an illegal ContourBorder type = %d\n",i,cEl->getBorder());
//			}
//			out.println("           %ld %ld %lg %lg %lg %lg %lg %lg %ld %ld\n",cEl->getElementIndex(),cEl->getVolumeIndex(),
//						cEl->getBegin().x,cEl->getBegin().y,cEl->getBegin().z,
//						cEl->getEnd().x,  cEl->getEnd().y,  cEl->getEnd().z,
//						neighborPrev, neighborNext);
//		}
//		out.println("    }\n");  // end ContourElements
//	}
//}

	public static void test() {
		try {
			cbit.vcell.solvers.CartesianMesh mesh = null;
	
			File meshFile = new File("\\\\san1\\RAID\\vcell\\users\\frm\\SimID_20587997_0_.mesh");
			File membraneMeshMetricsFile = new File("\\\\san1\\RAID\\vcell\\users\\frm\\SimID_20587997_0_.meshmetrics");
			// read meshFile,MembraneMeshMetrics and parse into 'mesh' object
			//
			InputStreamReader reader = null;
			try {
				FileInputStream is = new FileInputStream(meshFile);
				reader = new InputStreamReader(is);
				char buffer[] = new char[(int)meshFile.length()];
				int length = reader.read(buffer,0,buffer.length);
				String meshString = new String(buffer,0,length);
System.out.println("-------------------- original file ----------------");
System.out.println(meshString);
				reader.close();
				CommentStringTokenizer meshST = new CommentStringTokenizer(meshString);

				CommentStringTokenizer membraneMeshMetricsST = null;
				if(membraneMeshMetricsFile != null){
					is = new FileInputStream(membraneMeshMetricsFile);
					reader = new InputStreamReader(is);
					buffer = new char[(int)membraneMeshMetricsFile.length()];
					length = reader.read(buffer,0,buffer.length);
					String mmmString = new String(buffer,0,length);
					reader.close();
					membraneMeshMetricsST = new CommentStringTokenizer(mmmString);
				}

				mesh = CartesianMesh.fromTokens(meshST,membraneMeshMetricsST);
			} finally {
				if (reader != null) {
					reader.close();
				}
			}
			System.out.println("-------------------- generated file ----------------");
			mesh.write(System.out);
		}catch (Exception e){
			e.printStackTrace(System.out);
		}
	}

}