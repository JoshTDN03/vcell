package cbit.vcell.model;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.beans.*;
import cbit.vcell.parser.*;
import cbit.vcell.parser.Expression;
import cbit.vcell.units.VCUnitDefinition;

import java.util.*;
import java.io.Serializable;
import cbit.util.*;
import net.sourceforge.interval.ia_math.RealInterval;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public abstract class Kinetics implements Matchable, PropertyChangeListener, VetoableChangeListener, java.io.Serializable {
	private String name;
	private ReactionStep reactionStep = null;
	protected transient java.beans.PropertyChangeSupport propertyChange;
	protected transient java.beans.VetoableChangeSupport vetoPropertyChange;
	private cbit.vcell.model.Kinetics.KineticsParameter[] fieldKineticsParameters = new KineticsParameter[0];
	private cbit.vcell.model.Kinetics.UnresolvedParameter[] fieldUnresolvedParameters = new UnresolvedParameter[0];
	private transient boolean bReading = false;
	private transient boolean bResolvingUnits = false;
	public transient boolean bRefreshingUnits = false;
	
	// !! HACK ALERT!!
	// For older models that did have GeneralTotalKinetics: need this to bring the params into GeneralLumpedKinetics 
	public static String GTK_TotalRate_oldname = "total rate";
	public static String GTK_AssumedCompartmentSize_oldname = "assumed compartment size";
	public static String GTK_ReactionRate_oldname = "reaction rate";
	public static String GTK_CurrentDensity_oldname = "inward current density";


	public static final String ISSUECATEGORY_KineticsApplicability = "KineticsApplicablity";
	public static final String ISSUECATEGORY_ParameterLoop = "ParameterLoop";

	private static final String PREDEFINED_MANGLED_PREFIX = "PREDEFINED_MANGLED_PREFIX";

	public static final int ROLE_UserDefined	= 0;
	public static final int ROLE_ReactionRate	= 1;
	public static final int ROLE_CurrentDensity	= 2;
	public static final int ROLE_KForward		= 3;
	public static final int ROLE_KReverse		= 4;
	public static final int ROLE_Km				= 5;
	public static final int ROLE_Vmax			= 6;
	public static final int ROLE_KmFwd			= 7;
	public static final int ROLE_VmaxFwd		= 8;
	public static final int ROLE_KmRev			= 9;
	public static final int ROLE_VmaxRev		= 10;
	public static final int ROLE_Permeability	= 11;
	public static final int ROLE_Conductivity	= 12;
	public static final int ROLE_LumpedReactionRate = 13;
	public static final int ROLE_LumpedCurrent	= 14;

	public static final int NUM_ROLES			= 15;

	
	private static final String RoleDescs[] = {
		"user defined",
		"reaction rate",
		"inward current density",
		"forward rate constant",
		"reverse rate constant",
		"Km (1/2 max)",
		"max reaction rate",
		"Km forward",
		"max forward rate",
		"Km reverese",
		"max reverse rate",
		"permeability",
		"conductivity",
		"lumped reaction rate",
		"lumped current",
	};


	private static final String RoleTags[] = {
		"no tag",
		VCMODL.ReactionRate,
		VCMODL.CurrentDensity,
		VCMODL.ForwardRate,
		VCMODL.ReverseRate,
		VCMODL.Km,
		VCMODL.Vmax,
		VCMODL.KmFwd,
		VCMODL.VmaxFwd,
		VCMODL.KmRev,
		VCMODL.VmaxRev,
		VCMODL.Permeability,
		VCMODL.Conductivity,
		VCMODL.LumpedReactionRate,
		VCMODL.LumpedCurrent,
	};

	private static final String DefaultNames[] = {
		null,
		"J",
		"I",
		"Kf",
		"Kr",
		"Km",
		"Vmax",
		"KmFwd",
		"VmaxFwd",
		"KmRev",
		"VmaxRev",
		"P",
		"C",
		"LumpedJ",
		"LumpedI",
	};

	private static final RealInterval[] bounds = {
		null, // user defined
		null, // reaction rate
		null, // current density
		new RealInterval(0,Double.POSITIVE_INFINITY), // Kf
		new RealInterval(0,Double.POSITIVE_INFINITY), // Kr
		new RealInterval(0,Double.POSITIVE_INFINITY), // Km
		new RealInterval(0,Double.POSITIVE_INFINITY), // Vmax
		new RealInterval(0,Double.POSITIVE_INFINITY), // KmFwd
		new RealInterval(0,Double.POSITIVE_INFINITY), // VmaxFwd
		new RealInterval(0,Double.POSITIVE_INFINITY), // KmRev
		new RealInterval(0,Double.POSITIVE_INFINITY), // VmaxRev
		new RealInterval(0,Double.POSITIVE_INFINITY), // Permeability
		new RealInterval(0,Double.POSITIVE_INFINITY), // Conductivity
		null,   // lumped rate
		null	// lumped current
	};


	public class KineticsParameter extends Parameter implements ExpressionContainer {
		
		private String fieldParameterName = null;
		private cbit.vcell.parser.Expression fieldParameterExpression = null;
		private int fieldParameterRole = ROLE_UserDefined;
		private cbit.vcell.units.VCUnitDefinition fieldUnitDefinition = null;

		protected KineticsParameter(String argName, Expression expression, int argRole, cbit.vcell.units.VCUnitDefinition unitDefinition) {
			if (argName == null){
				throw new IllegalArgumentException("parameter name is null");
			}
			if (argName.length()<1){
				throw new IllegalArgumentException("parameter name is zero length");
			}
			this.fieldParameterName = argName;
			this.fieldParameterExpression = expression;
			if (argRole >= 0 && argRole < NUM_ROLES){
				this.fieldParameterRole = argRole;
				setDescription(Kinetics.RoleDescs[argRole]);
			}else{
				throw new IllegalArgumentException("parameter 'role' = "+argRole+" is out of range");
			}
			this.fieldUnitDefinition = unitDefinition;
		}


		public boolean compareEqual(Matchable obj) {
			if (!(obj instanceof KineticsParameter)){
				return false;
			}
			KineticsParameter kp = (KineticsParameter)obj;
			if (!super.compareEqual0(kp)){
				return false;
			}
			if (fieldParameterRole != kp.fieldParameterRole){
				return false;
			}
			
			return true;
		}

		public boolean isExpressionEditable(){
			//
			// don't allow direct editing of rates and currents if they are generated
			//
			if (getRole() == ROLE_ReactionRate){
				// only allow editing "ReactionRate" for GeneralKinetics
				if (Kinetics.this instanceof cbit.vcell.model.GeneralKinetics){
					return true;
				}else{
					return false;
				}
			}
			if (getRole() == ROLE_LumpedReactionRate){
				// only allow editing "LumpedReactionRate" for GeneralLumpedKinetics
				if (Kinetics.this instanceof cbit.vcell.model.GeneralLumpedKinetics){
					return true;
				}else{
					return false;
				}
			}
			if (getRole() == ROLE_CurrentDensity){
				// only allow editing "CurrentDensity" for GeneralCurrentKinetics
				if (Kinetics.this instanceof cbit.vcell.model.GeneralCurrentKinetics){
					return true;
				}else{
					return false;
				}
			}
			if (getRole() == ROLE_LumpedCurrent){
				// only allow editing "Current" for GeneralCurrentLumpedKinetics
				if (Kinetics.this instanceof cbit.vcell.model.GeneralCurrentLumpedKinetics){
					return true;
				}else{
					return false;
				}
			}
			return true;
		}
		
		public boolean isUnitEditable(){
			//
			// don't allow direct editing of rates and currents if they are generated
			//
			if (getRole() == ROLE_UserDefined){
				return true;
			}else{
				return false;
			}
		}

		public boolean isNameEditable(){
			return true;
		}

		public double getConstantValue() throws ExpressionException {
			return this.fieldParameterExpression.evaluateConstant();
		}      


		public Expression getExpression() {
			return this.fieldParameterExpression;
		}


		public int getIndex() {
			return -1;
		}


		public String getName(){ 
			return this.fieldParameterName; 
		}   

		public NameScope getNameScope() {
			if (Kinetics.this.reactionStep!=null){
				return Kinetics.this.reactionStep.getNameScope();
			}else{
				return null;
			}
		}

		public Kinetics getKinetics() {
			return Kinetics.this;
		}

		public int getRole() {
			return this.fieldParameterRole;
		}

		public cbit.vcell.units.VCUnitDefinition getUnitDefinition() {
			return fieldUnitDefinition;
		}

		public void setUnitDefinition(cbit.vcell.units.VCUnitDefinition unitDefinition) {
			cbit.vcell.units.VCUnitDefinition oldValue = fieldUnitDefinition;
			fieldUnitDefinition = unitDefinition;
			if (oldValue==unitDefinition){
				return;
			}
			if (unitDefinition!=null && unitDefinition.compareEqual(oldValue)){
				return;
			}
			super.firePropertyChange("unitDefinition", oldValue, unitDefinition);
		}
		
		public void setExpression(cbit.vcell.parser.Expression expression) throws java.beans.PropertyVetoException {
			Expression oldValue = fieldParameterExpression;
			super.fireVetoableChange("expression", oldValue, expression);
			fieldParameterExpression = expression;
			super.firePropertyChange("expression", oldValue, expression);
		}
		public void setName(java.lang.String name) throws java.beans.PropertyVetoException {
			String oldValue = fieldParameterName;
			super.fireVetoableChange("name", oldValue, name);
			fieldParameterName = name;
			super.firePropertyChange("name", oldValue, name);
		}

	}

	public class UnresolvedParameter extends Parameter {
		
		private String fieldParameterName = null;

		protected UnresolvedParameter(String argName) {
			if (argName == null){
				throw new IllegalArgumentException("parameter name is null");
			}
			if (argName.length()<1){
				throw new IllegalArgumentException("parameter name is zero length");
			}
			this.fieldParameterName = argName;
			setDescription("unresolved");
		}

		public boolean compareEqual(Matchable obj) {
			if (!(obj instanceof UnresolvedParameter)){
				return false;
			}
			UnresolvedParameter up = (UnresolvedParameter)obj;
			if (!super.compareEqual0(up)){
				return false;
			}			
			return true;
		}

		public double getConstantValue() throws ExpressionException {
			throw new ExpressionException("no expression defined for UnresolvedParameter '"+fieldParameterName+"'");
		}      

		public Expression getExpression() {
			return null;
		}

		public boolean isExpressionEditable(){
			return false;
		}

		public boolean isNameEditable(){
			return false;
		}

		public boolean isUnitEditable(){
			return false;
		}

		public int getIndex() {
			return -1;
		}

		public String getName(){ 
			return this.fieldParameterName; 
		}

		public cbit.vcell.units.VCUnitDefinition getUnitDefinition() {
			return cbit.vcell.units.VCUnitDefinition.UNIT_TBD;
		}

		public NameScope getNameScope() {
			if (Kinetics.this.reactionStep!=null){
				return Kinetics.this.reactionStep.getNameScope();
			}else{
				return null;
			}
		}

		public void setName(java.lang.String name) throws java.beans.PropertyVetoException {
			String oldValue = fieldParameterName;
			super.fireVetoableChange("name", oldValue, name);
			fieldParameterName = name;
			super.firePropertyChange("name", oldValue, name);
		}

	}	

/**
 * Kinetics constructor comment.
 * @param name java.lang.String
 */
protected Kinetics(String name, ReactionStep reactionStep) {
	this.name = name;
	this.reactionStep = reactionStep;
	addVetoableChangeListener(this);
	addPropertyChangeListener(this);
	reactionStep.addPropertyChangeListener(this);
	reactionStep.setKinetics(this);
	reactionStep.getChargeCarrierValence().addPropertyChangeListener(this);
	ReactionParticipant reactionParticipants[] = reactionStep.getReactionParticipants();
	for (int i = 0; i < reactionParticipants.length; i++){
		reactionParticipants[i].addPropertyChangeListener(this);
	}
}


/**
 * This method was created by a SmartGuide.
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
protected void addKineticsParameter(KineticsParameter newParameter) throws PropertyVetoException {
	//
	// make copy of old array, and add to end
	//
	int oldLength = 0;
	if (fieldKineticsParameters!=null){
		oldLength = getKineticsParameters().length;
	}
	KineticsParameter newKineticsParameters[] = new KineticsParameter[oldLength+1];
	if (fieldKineticsParameters!=null){
		System.arraycopy(fieldKineticsParameters,0,newKineticsParameters,0,oldLength);
	}
	newKineticsParameters[oldLength] = newParameter;

	//
	// set new value of indexed property (kineticsParameters)
	//
	setKineticsParameters(newKineticsParameters);
}


/**
 * This method will add the parameters in the array without overwriting the already existant parameters.
 * Creation date: (3/7/2003 5:19:12 PM)
 * @param parameters cbit.vcell.model.KineticsParameter[]
 */
public void addKineticsParameters(KineticsParameter[] newparameters) throws PropertyVetoException {
	ArrayList newArrayList  = new ArrayList();

	//check the new parameters are not repeated
	for (int i = 0; i < newparameters.length; i++){
		KineticsParameter oldParam = this.getKineticsParameter(newparameters[i].getName());
		
		if ( oldParam ==null ) {
			//if it is brand new just add it
			newArrayList.add(newparameters[i]);
		} else {
			//if it already exists, reuse it but update the content
			oldParam.setExpression(newparameters[i].getExpression());
			newArrayList.add(oldParam);
		}
	}

	//Check that there are no left parameters...
	KineticsParameter[] oldArray = this.getKineticsParameters();

	for (int i = 0; i < oldArray.length ; i++){
		if ( !newArrayList.contains(oldArray[i]) ) {
			newArrayList.add(oldArray[i]);
		}
	}

	//put it back into an array
	KineticsParameter[] allNewParameters = new KineticsParameter[newArrayList.size()];
	allNewParameters = (KineticsParameter[])newArrayList.toArray(allNewParameters);	;
	//save the whole new array into this kinetics
	this.setKineticsParameters(allNewParameters);
}


/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().addPropertyChangeListener(listener);
}


/**
 * Insert the method's description here.
 * Creation date: (9/22/2003 9:51:49 AM)
 * @param parameterName java.lang.String
 */
public void addUnresolvedParameter(String parameterName) {
	if (getParameter(parameterName)!=null){
		throw new RuntimeException("parameter '"+parameterName+"' already exists");
	}
	UnresolvedParameter newUnresolvedParameters[] = (UnresolvedParameter[])BeanUtils.addElement(fieldUnresolvedParameters,new UnresolvedParameter(parameterName));
	setUnresolvedParameters(newUnresolvedParameters);
}


/**
 * Insert the method's description here.
 * Creation date: (9/22/2003 9:51:49 AM)
 * @param parameterName java.lang.String
 */
public KineticsParameter addUserDefinedKineticsParameter(String parameterName, Expression expression, cbit.vcell.units.VCUnitDefinition unit) throws PropertyVetoException {
	if (getParameter(parameterName)!=null){
		throw new RuntimeException("parameter '"+parameterName+"' already exists");
	}
	KineticsParameter newKineticsParameter = new KineticsParameter(parameterName,expression,ROLE_UserDefined, unit);
	KineticsParameter newKineticsParameters[] = (KineticsParameter[])BeanUtils.addElement(fieldKineticsParameters,newKineticsParameter);
	setKineticsParameters(newKineticsParameters);
	return newKineticsParameter;
}


/**
 * The addVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void addVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().addVetoableChangeListener(listener);
}


/**
 * This method was created by a SmartGuide.
 * @param symbolTable cbit.vcell.parser.SymbolTable
 */
public void bind(cbit.vcell.parser.SymbolTable symbolTable) throws cbit.vcell.parser.ExpressionBindingException {
	for (int i = 0; i < getKineticsParameters().length; i++){
		getKineticsParameters()[i].getExpression().bindExpression(symbolTable);
	}
	try {
		cleanupParameters();
		//resolveUndefinedUnits();
	}catch (PropertyVetoException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}catch (ModelException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}catch (ExpressionBindingException e){
		e.printStackTrace(System.out);
		throw e;
	}catch (ExpressionException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());	
	}
}


/**
 * This method was created in VisualAge.
 */
private final void cleanupParameters() throws ModelException, ExpressionException, PropertyVetoException {
	if (bReading){
		return;
	}
	//
	// for each parameter, see if it is used, if not delete it
	//
	if (fieldKineticsParameters != null){
		for (int i=0;i<fieldKineticsParameters.length;i++){
			if (fieldKineticsParameters[i].getRole()==ROLE_UserDefined && !isReferenced(fieldKineticsParameters[i],0)){
				removeKineticsParameter(fieldKineticsParameters[i]);
				i--;
			}
		}
	}
	if (fieldUnresolvedParameters != null){
		for (int i=0;i<fieldUnresolvedParameters.length;i++){
			if (!isReferenced(fieldUnresolvedParameters[i],0)){
				removeUnresolvedParameter(fieldUnresolvedParameters[i]);
				i--;
			}
		}
	}

	for (int i = 0;fieldKineticsParameters!=null && i < fieldKineticsParameters.length; i++){
		Expression exp = fieldKineticsParameters[i].getExpression();
		if (exp!=null){
			try {
				exp.bindExpression(reactionStep);
			}catch (ExpressionBindingException e){
				System.out.println("error binding expression '"+exp.infix()+"': "+e.getMessage());
			}
		}
	}
//	resolveUndefinedUnits();
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param kinetics cbit.vcell.model.Kinetics
 */
protected boolean compareEqual0(Kinetics kinetics) {

	if (!Compare.isEqual(name,kinetics.name)){
		return false;
	}
	if (!Compare.isEqualOrNull(fieldKineticsParameters,kinetics.fieldKineticsParameters)){
		return false;
	}
	
	return true;
}


/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}


/**
 * The fireVetoableChange method was generated to support the vetoPropertyChange field.
 */
public void fireVetoableChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) throws java.beans.PropertyVetoException {
	getVetoPropertyChange().fireVetoableChange(propertyName, oldValue, newValue);
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public final void fromTokens(cbit.vcell.math.CommentStringTokenizer tokens) throws ExpressionException, PropertyVetoException {
	//
	//  old format (version 1) (still supported for reading)
	//
	//	Kinetics GeneralCurrentKinetics {
	//      Parameter a 10;
	//      Parameter b 3;
	//      Parameter c d/2;
	//      Parameter d 5;
	//      CurrentDensity a+b/c;
	//  }
	//
	//
	//  new format (version 2) (deprecated, incompatable with Version 1, still supported for reading)
	//
	//	Kinetics GeneralCurrentKinetics {
	//      CurrentDensity 'currentDensity'
	//		Parameter currentDensity a+b/c;
	//      Parameter a 10;
	//      Parameter b 3;
	//      Parameter c d/2;
	//      Parameter d 5;
	//  }
	//
	//  latest format (version 3), which is backward compatable with version 1
	//  ParameterVCMLTokens (such as "CurrentDensity") have simple expressions 
	//  that always consist of only the requiredIdentifier (e.g.  currentDensity; )
	//
	//	Kinetics GeneralCurrentKinetics {
	//		Parameter currentDensity a+b/c;
	//      Parameter a 10;
	//      Parameter b 3;
	//      Parameter c d/2;
	//      Parameter d 5;
	//      CurrentDensity currentDensity;
	//  }
	//
	//


	// protect predefined parameters
	Kinetics.KineticsParameter[] predefParams = getKineticsParameters();
	for (int i = 0; i < predefParams.length; i++){
		if (predefParams[i].getRole() == ROLE_UserDefined) {
			BeanUtils.removeElement(predefParams, predefParams[i]);
			i--;
		} else {
			renameParameter(predefParams[i].getName(), PREDEFINED_MANGLED_PREFIX + predefParams[i].getName());
		}
	}
		
	try {
		
		// now read in, and check predefined ones at the end 
		reading(true);
		
		ReactionStep reactionStep = getReactionStep();
			
		String token = null;
		tokens.nextToken(); // read "{"

		while (tokens.hasMoreTokens()){
			token = tokens.nextToken();
			if (token.equalsIgnoreCase(VCMODL.EndBlock)){
				break;
			}
			if (token.equalsIgnoreCase(VCMODL.Fast)){
				//setFast(true);
				continue;
			}
			if (token.equalsIgnoreCase(VCMODL.Parameter)){
				token = tokens.nextToken();
				Expression exp = new Expression(tokens);
				String symbols[] = exp.getSymbols();
				for (int j = 0;symbols!=null && j < symbols.length; j++){
					if (getReactionStep().getLocalEntry(symbols[j])==null){
						addUnresolvedParameter(symbols[j]);
					}
				}
				exp.bindExpression(reactionStep);
				Parameter parm = getParameter(token);
				String unitsString = tokens.nextToken();
				cbit.vcell.units.VCUnitDefinition unitDef = cbit.vcell.units.VCUnitDefinition.UNIT_TBD;
				if (unitsString.startsWith("[")){
					while (!unitsString.endsWith("]")){
						String tempToken = tokens.nextToken();
						unitsString = unitsString + " " + tempToken;
					}
					//
					// now string starts with '[' and ends with ']'
					//
					unitDef = cbit.vcell.units.VCUnitDefinition.getInstance(unitsString.substring(1,unitsString.length()-1));
				}else{
					tokens.pushToken(unitsString);
				}
				if (parm == null){
					addKineticsParameter(new KineticsParameter(token,exp,ROLE_UserDefined,unitDef));
				}else if (parm instanceof UnresolvedParameter){
					removeUnresolvedParameter((UnresolvedParameter)parm);
					addKineticsParameter(new KineticsParameter(token,exp,ROLE_UserDefined,unitDef));
				}else if (parm instanceof KineticsParameter){
					((KineticsParameter)parm).setExpression(exp);
				}else{
					throw new RuntimeException("unexpected parameter type '"+parm.getClass().getName()+"'");
				}
				continue;
			}
			//
			// not written as a parameter, try a requiredIdentifier
			//
			if (this instanceof GeneralLumpedKinetics) {
				if (token.equals(VCMODL.ReactionRate) || token.equals(VCMODL.CurrentDensity) || token.equals(VCMODL.AssumedCompartmentSize_oldname)){
					token = tokens.nextToken();
					continue;
				} else if (token.equals(VCMODL.TotalRate_oldname)) {
					token = VCMODL.LumpedReactionRate;
				}
			}
			boolean bTokenFound = false;
			for (int i = 0; i < RoleTags.length; i++){
				if (token.equalsIgnoreCase(RoleTags[i])){
					int role = i;
					bTokenFound = true;
					token = tokens.nextToken();
					String parmName = null;
					if (token.endsWith("'") && token.startsWith("'")){
						//
						// if requiredIdentifier name is present (delimited by single quotes)
						// use it as the user-supplied name for that required parameter
						//
						//     e.g. CurrentDensity 'currentDensity'
						//
						parmName = token.substring(1,token.length()-1);
						KineticsParameter parm = getKineticsParameterFromRole(role);
						parm.setName(parmName);
					}else{
						//
						// else if a non-trivial expression, then use the default name for the requiredParameter.
						//      if a single identifier expression, then use that identifier as the requiredParameter name.
						//
						
						// first token (already popped) must be part of the expression (need to push it back).
						//
						//     e.g. CurrentDensity a+b/c;
						//
						tokens.pushToken(token);
						Expression exp = new Expression(tokens);
						
						String[] symbols = exp.getSymbols();
						boolean bIsSingleId = false;
						if (symbols != null && symbols.length==1){
							if (exp.compareEqual(new Expression(symbols[0]))){
								bIsSingleId = true;
							}
						}
						String unitsString = tokens.nextToken();
						cbit.vcell.units.VCUnitDefinition unitDef = cbit.vcell.units.VCUnitDefinition.UNIT_TBD;
						if (unitsString.startsWith("[")){
							while (!unitsString.endsWith("]")){
								String tempToken = tokens.nextToken();
								unitsString = unitsString + " " + tempToken;
							}
							//
							// now string starts with '[' and ends with ']'
							//
							unitDef = cbit.vcell.units.VCUnitDefinition.getInstance(unitsString.substring(1,unitsString.length()-1));
						}else{
							tokens.pushToken(unitsString);
						}
						Parameter parm = null;
						if (!bIsSingleId){
							//
							// normal expression (not just a single identifier), resolve symbols and bind
							//
							for (int j = 0;symbols!=null && j < symbols.length; j++){
								if (getReactionStep().getLocalEntry(symbols[j])==null){
									addUnresolvedParameter(symbols[j]);
								}
							}
							exp.bindExpression(reactionStep);
							
							//
							// use "requiredIdentifier" name
							//
							parm = getKineticsParameterFromRole(role);
							if (parm==null){
								addKineticsParameter(new KineticsParameter(getDefaultParameterName(role),exp,role,unitDef));
							}else if (parm instanceof UnresolvedParameter){
								removeUnresolvedParameter((UnresolvedParameter)parm);
								addKineticsParameter(new KineticsParameter(getDefaultParameterName(role),exp,role,unitDef));							
							}else if (parm instanceof KineticsParameter){
								((KineticsParameter)parm).setExpression(exp);
							}else{
								throw new RuntimeException("unexpected parameter type '"+parm.getClass().getName()+"'");
							}
						}else{
							//
							// must be a single identifier expression (e.g. Kf_012;) ... use this as the parameter's name, and continue parsing...
							// later, this parameter will be defined, and the expression will be set.
							//
							parmName = symbols[0];
							//
							// if already using the default name, don't change anything
							//
							KineticsParameter parmFromRole = getKineticsParameterFromRole(role);
							Parameter parmFromName = getParameter(parmName);
							if (parmFromRole == null){
								throw new RuntimeException("parameter for role '"+this.RoleTags+"' not defined");
								////
								//// "special" parameter not yet instantiated
								////
								//Expression newExp = new Expression(0.0);
								//if (parmFromName instanceof UnresolvedParameter){
									//removeUnresolvedParameter((UnresolvedParameter)parmFromName);
								//}else if (parmFromName instanceof KineticsParameter){
									//removeKineticsParameter((KineticsParameter)parmFromName);
									//newExp = parmFromName.getExpression();
								//}else if (parmFromName != null){
									//throw new RuntimeException("unexpected parameter '"+parmFromName+"'");
								//}
								//addKineticsParameter(new KineticsParameter(parmName,newExp,role,unitDef));
							}else{
								//
								// "special" parameter already exists
								//
								if (parmFromName == null){
									parmFromRole.setName(parmName);
								}else if (parmFromName == parmFromRole){
									//
									// do nothing, already has the correct name and role
									//
								}else if (parmFromName instanceof KineticsParameter){
									if (((KineticsParameter)parmFromName).getRole() == ROLE_UserDefined) {
										//
										// sometimes models have user defined parameters with the default name of a parameter with a non-user role.
										// (e.g.  user defined parameter of "J" and actual rate parameter of "J_channel")
										// in this case a swap of roles are required.  But since roles are immutable, swap name
										// in this case, don't remove those parameters
										//
										// swap name and expression between parmFromName and parmFromRole
										// ... usually, parmFromName will later be discarded by cleanupParameters().
										// 
										String tempName = parmFromRole.getName();
										Expression tempExp = parmFromRole.getExpression();
										parmFromRole.setName(parmName);
										parmFromRole.setExpression(new Expression(parmFromName.getExpression()));
										((Kinetics.KineticsParameter)parmFromName).setName(tempName);
										((Kinetics.KineticsParameter)parmFromName).setExpression(new Expression(tempExp));
										//removeKineticsParameter((KineticsParameter)parmFromName);
									} else {
										parmFromRole.setExpression(new Expression(parmFromName.getName()));
										if (!unitDef.isTBD()){
											parmFromRole.setUnitDefinition(unitDef);
										}
									}
								}else if (parmFromName instanceof UnresolvedParameter){
									parmFromRole.setName(parmName);
									removeUnresolvedParameter((UnresolvedParameter)parmFromName);
								}
							}
						}
					}
					break;
				}
			}
			if (bTokenFound){
				continue;
			}
			throw new RuntimeException("KineticsTemplate.fromTokens(), unexpected token "+token);
		}
		
		
	}finally{
		reading(false);
		// now check on our protected predefined params
		predefParams = getKineticsParameters();
		for (int i = 0; i < predefParams.length; i++){
			if (predefParams[i].getName().startsWith(PREDEFINED_MANGLED_PREFIX)) {
				String defaultName = Kinetics.DefaultNames[predefParams[i].getRole()];
				if (defaultName == null) {
					// was replaced during read in
				} else {
					// was renamed during read in; make it nice again, *but* must avoid conflicts
					while (getKineticsParameter(defaultName) != null) {
						defaultName = TokenMangler.getNextEnumeratedToken(defaultName);
					}
					renameParameter(predefParams[i].getName(), defaultName);
				}
			} else {
				// it has been renamed by stored user-defined name
			}
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (5/12/2004 2:53:13 PM)
 */
public void gatherIssues(Vector<Issue> issueList) {
	//
	// for each user unresolved parameter, make an issue
	//
	for (int i = 0; fieldUnresolvedParameters!=null && i < fieldUnresolvedParameters.length; i++){
		issueList.add(new Issue(fieldUnresolvedParameters[i],"Unresolved Parameter","Unresolved parameter '"+fieldUnresolvedParameters[i].getName()+"' in reaction '"+reactionStep.getName()+"'",Issue.SEVERITY_ERROR));
	}
	//
	// for each user defined parameter, see if it is used, if not make an issue
	//
	for (int i=0;fieldKineticsParameters!=null && i<fieldKineticsParameters.length;i++){
		if (fieldKineticsParameters[i].getRole()==ROLE_UserDefined){
			try {
				if (!isReferenced(fieldKineticsParameters[i],0)){
					issueList.add(new Issue(fieldKineticsParameters[i],"Unreferenced Kinetic Parameter","Unreferenced Kinetic Parameter '"+fieldKineticsParameters[i].getName()+"' in reaction '"+reactionStep.getName()+"'",Issue.SEVERITY_WARNING));
				}
			}catch (ExpressionException e){
				issueList.add(new Issue(fieldKineticsParameters[i],"Error resolving parameter","error resolving expression for parameter '"+fieldKineticsParameters[i].getName()+"': "+e.getMessage(),Issue.SEVERITY_WARNING));
			}catch (ModelException e){
				issueList.add(new Issue(this,ISSUECATEGORY_ParameterLoop,"there is a loop in the parameter definitions for parameter '"+fieldKineticsParameters[i].getName()+"'",Issue.SEVERITY_ERROR));
			}
		}
	}

	//
	// check for use of symbol bindings that are species contexts that are not reaction participants
	//
	for (int i = 0; fieldKineticsParameters!=null && i < fieldKineticsParameters.length; i++){
		if (fieldKineticsParameters[i].getExpression()==null){
			issueList.add(new Issue(fieldKineticsParameters[i],"Expression","expression for parameter '"+fieldKineticsParameters[i].getName()+"' is missing",Issue.SEVERITY_INFO));
		}else{
			Expression exp = fieldKineticsParameters[i].getExpression();
			String symbols[] = exp.getSymbols();
			for (int j = 0; symbols!=null && j < symbols.length; j++){
				SymbolTableEntry ste = exp.getSymbolBinding(symbols[j]);
				if (ste instanceof SpeciesContext && reactionStep.getReactionParticipants((SpeciesContext)ste).length == 0){
					issueList.add(new Issue(fieldKineticsParameters[i],"Expression","parameter '"+fieldKineticsParameters[i].getName()+"' references species context '"+ste.getName()+"', but it is not a reactant/product/catalyst of this reaction",Issue.SEVERITY_WARNING));
				}else if (ste == null){
					issueList.add(new Issue(fieldKineticsParameters[i],"Expression","parameter '"+fieldKineticsParameters[i].getName()+"' references undefined symbol '"+symbols[j]+"'",Issue.SEVERITY_ERROR));
				}
			}
		}
	}

	try {
		//
		// determine unit consistency for each expression
		//
		for (int i = 0; i < fieldKineticsParameters.length; i++){
			String parmName = reactionStep.getNameScope().getName()+"."+fieldKineticsParameters[i].getName();
			try {
				cbit.vcell.units.VCUnitDefinition paramUnitDef = fieldKineticsParameters[i].getUnitDefinition();
				cbit.vcell.units.VCUnitDefinition expUnitDef = VCUnitEvaluator.getUnitDefinition(fieldKineticsParameters[i].getExpression());
				if (paramUnitDef == null){
					issueList.add(new Issue(fieldKineticsParameters[i], "Units","parameter "+parmName+": defined unit is null",Issue.SEVERITY_WARNING));
				}else if (paramUnitDef.isTBD()){
					issueList.add(new Issue(fieldKineticsParameters[i], "Units","parameter "+parmName+": has undefined unit [tbd]",Issue.SEVERITY_WARNING));
				}else if (expUnitDef == null){
					issueList.add(new Issue(fieldKineticsParameters[i], "Units","parameter "+parmName+": computed unit is null",Issue.SEVERITY_WARNING));
				}else if (paramUnitDef.isTBD() || (!paramUnitDef.compareEqual(expUnitDef) && !expUnitDef.isTBD())){
					issueList.add(new Issue(fieldKineticsParameters[i], "Units","parameter "+parmName+": defined=["+fieldKineticsParameters[i].getUnitDefinition().getSymbol()+"], computed=["+expUnitDef.getSymbol()+"]",Issue.SEVERITY_WARNING));
				}
			}catch (cbit.vcell.units.VCUnitException e){
				issueList.add(new Issue(fieldKineticsParameters[i],"Units","parameter "+parmName+": "+e.getMessage(),Issue.SEVERITY_WARNING));
			}catch (ExpressionException e){
				issueList.add(new Issue(fieldKineticsParameters[i],"Units","parameter "+parmName+": "+e.getMessage(),Issue.SEVERITY_WARNING));
			}
		}
	}catch (Throwable e){
		issueList.add(new Issue(this,"Units","unexpected exception: "+e.getMessage(),Issue.SEVERITY_INFO));
	}

	//
	// add constraints (simpleBounds) for predefined parameters
	//
	for (int i = 0; i < fieldKineticsParameters.length; i++){
		RealInterval simpleBounds = bounds[fieldKineticsParameters[i].getRole()];
		if (simpleBounds!=null){
			String parmName = reactionStep.getNameScope().getName()+"."+fieldKineticsParameters[i].getName();
			issueList.add(new SimpleBoundsIssue(fieldKineticsParameters[i], simpleBounds, "parameter "+parmName+": must be within "+simpleBounds.toString()));
		}
	}
	
}


/**
 * Insert the method's description here.
 * Creation date: (10/16/2003 7:22:36 AM)
 * @return java.lang.String
 * @param role int
 */
public String getDefaultParameterDesc(int role) {
	if (role < 0 || role >= NUM_ROLES){
		throw new IllegalArgumentException("role out of range, "+role);
	}
//	return DefaultNames[role]+"_"+TokenMangler.fixTokenStrict(getReactionStep().getName());
	return RoleDescs[role];
}


/**
 * Insert the method's description here.
 * Creation date: (10/16/2003 7:22:36 AM)
 * @return java.lang.String
 * @param role int
 */
String getDefaultParameterName(int role) {
	if (role < 0 || role >= NUM_ROLES){
		throw new IllegalArgumentException("role out of range, "+role);
	}
//	return DefaultNames[role]+"_"+TokenMangler.fixTokenStrict(getReactionStep().getName());
	return DefaultNames[role];
}


/**
 * Insert the method's description here.
 * Creation date: (8/5/2002 5:51:50 PM)
 * @return cbit.vcell.model.KineticsDescription
 */
public abstract KineticsDescription getKineticsDescription();


public KineticsParameter getKineticsParameter(String pName){
	if (fieldKineticsParameters == null){
		return null;
	}
	for (int i=0;i<fieldKineticsParameters.length;i++){
		KineticsParameter parm = fieldKineticsParameters[i];
		if (pName.equals(parm.getName())){
			return parm;
		}
	}
	return null;
}   


/**
 * Gets the kineticsParameters index property (cbit.vcell.model.KineticsParameter) value.
 * @return The kineticsParameters property value.
 * @param index The index value into the property array.
 * @see #setKineticsParameters
 */
public KineticsParameter getKineticsParameterFromRole(int role) {
	for (int i = 0; i < fieldKineticsParameters.length; i++){
		if (fieldKineticsParameters[i].getRole() == role){
			return fieldKineticsParameters[i];
		}
	}
	return null;
}


/**
 * Gets the kineticsParameters property (cbit.vcell.model.KineticsParameter[]) value.
 * @return The kineticsParameters property value.
 * @see #setKineticsParameters
 */
public KineticsParameter[] getKineticsParameters() {
	return fieldKineticsParameters;
}


/**
 * Gets the kineticsParameters index property (cbit.vcell.model.KineticsParameter) value.
 * @return The kineticsParameters property value.
 * @param index The index value into the property array.
 * @see #setKineticsParameters
 */
public KineticsParameter getKineticsParameters(int index) {
	return getKineticsParameters()[index];
}


   public final String getName() 
   { 
	  return name; 
   }   


public Parameter getParameter(String pName){
	KineticsParameter kineticsParameter = getKineticsParameter(pName);
	UnresolvedParameter unresolvedParameter = getUnresolvedParameter(pName);
	if (kineticsParameter==null && unresolvedParameter==null){
		return null;
	}else if (kineticsParameter!=null && unresolvedParameter!=null){
		throw new RuntimeException("parameter '"+pName+"' exists both as kineticsParameter and unresolvedParameter");
	}else if (kineticsParameter!=null){
		return kineticsParameter;
	}else{
		return unresolvedParameter;
	}
}   


	public static int getParamRoleFromDesc(String paramDesc) {

		int paramRole = -1;
		
		if (paramDesc == null || paramDesc.length() == 0) {
			throw new IllegalArgumentException("Invalid value for parameter description: " + paramDesc); 
		}
		for (int i = 0; i < RoleDescs.length; i++) {
			if (RoleDescs[i].equals(paramDesc)) {
				paramRole = i;
			}	
		}

		if (paramDesc.equals(Kinetics.GTK_TotalRate_oldname)) {
			paramRole = ROLE_LumpedReactionRate;
		} 
		if (paramDesc.equals(Kinetics.GTK_AssumedCompartmentSize_oldname)) {
			paramRole = ROLE_UserDefined;
		} 
		if (paramRole == -1) {
			throw new IllegalArgumentException("Parameter description: " + paramDesc + " is not valid.");
		}

		return paramRole;
	}


/**
 * Accessor for the propertyChange field.
 */
protected java.beans.PropertyChangeSupport getPropertyChange() {
	if (propertyChange == null) {
		propertyChange = new java.beans.PropertyChangeSupport(this);
	};
	return propertyChange;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.model.ReactionStep
 */
public ReactionStep getReactionStep() {
	return reactionStep;
}


public UnresolvedParameter getUnresolvedParameter(String pName){
	if (fieldUnresolvedParameters == null){
		return null;
	}
	for (int i=0;i<fieldUnresolvedParameters.length;i++){
		UnresolvedParameter parm = fieldUnresolvedParameters[i];
		if (pName.equals(parm.getName())){
			return parm;
		}
	}
	return null;
}   


/**
 * Gets the unresolvedParameters property (cbit.vcell.model.UnresolvedParameter[]) value.
 * @return The unresolvedParameters property value.
 * @see #setUnresolvedParameters
 */
public UnresolvedParameter[] getUnresolvedParameters() {
	return fieldUnresolvedParameters;
}


/**
 * Gets the unresolvedParameters index property (cbit.vcell.model.UnresolvedParameter) value.
 * @return The unresolvedParameters property value.
 * @param index The index value into the property array.
 * @see #setUnresolvedParameters
 */
public UnresolvedParameter getUnresolvedParameters(int index) {
	return getUnresolvedParameters()[index];
}


/**
 * This method was created in VisualAge.
 * @return java.lang.String
 */
public String getVCML() {
	java.io.StringWriter stringWriter = new java.io.StringWriter();
	java.io.PrintWriter pw = new java.io.PrintWriter(stringWriter);
	writeTokens(pw);
	pw.flush();
	pw.close();
	return stringWriter.getBuffer().toString();
}


/**
 * Accessor for the vetoPropertyChange field.
 */
protected java.beans.VetoableChangeSupport getVetoPropertyChange() {
	if (vetoPropertyChange == null) {
		vetoPropertyChange = new java.beans.VetoableChangeSupport(this);
	};
	return vetoPropertyChange;
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param parm cbit.vcell.model.Parameter
 */
private boolean isReferenced(Parameter parm, int level) throws ModelException, ExpressionException {
	//
	// check for unbounded recursion (level > 10)
	//
	if (level >= 10){
		throw new ModelException("there is a loop in the parameter definitions");
	}

	//
	// if reactionStep is null (building from database), then it is OK
	//
	if (reactionStep==null){
		return true;
	}
	
	//
	// if this parameter is same as a reaction participant, then it should be removed
	//
	if (reactionStep.getReactionParticipantFromSymbol(parm.getName())!=null){
		return false;
	}

	//
	// if this unresolved parameter is same as another parameter, then it should be removed
	// note: that external identifiers have precedence over UndefinedParameters in ReactionStep.getEntry()
	//       so getEntry() will only return a UnresolvedParameter if there is no alternative.
	//
	if ((parm instanceof Kinetics.UnresolvedParameter) && parm != reactionStep.getEntry(parm.getName())){
		return false;
	}

	////
	//// if parameter is referenced in rate expression, then it is OK
	////
	//String symbols[] = getRequiredIdentifiers();
	//if (symbols != null){
		//for (int j=0;j<symbols.length;j++){
			//if (symbols[j].equals(parm.getName())){
				//return true;
			//}
		//}
	//}
	if (parm instanceof KineticsParameter && ((KineticsParameter)parm).getRole() != ROLE_UserDefined){
		return true;
	}

	//
	// else, if parameter is referenced in another parameter's expression, continue with that expression
	//
	boolean bReferenced = false;
	if (fieldKineticsParameters != null){
		for (int i=0;i<fieldKineticsParameters.length;i++){
			Parameter parentParm = fieldKineticsParameters[i];
			Expression exp = parentParm.getExpression();
			String[] symbols = exp.getSymbols();
			if (symbols!=null){
				for (int j=0;j<symbols.length;j++){
					if (AbstractNameScope.getStrippedIdentifier(symbols[j]).equals(parm.getName())){
						bReferenced = true;
						if (isReferenced(parentParm,level+1)){
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}


/**
 * Insert the method's description here.
 * Creation date: (2/15/01 1:56:56 PM)
 * @param event java.beans.PropertyChangeEvent
 */
public void propertyChange(PropertyChangeEvent event) {
	try {
		if (event.getSource() instanceof ReactionStep && event.getPropertyName().equals("physicsOptions")){
			updateGeneratedExpressions();
			refreshUnits();
			cleanupParameters();
		}
		if (event.getSource() instanceof ChargeCarrierValence && event.getPropertyName().equals("expression")){
			updateGeneratedExpressions();
			refreshUnits();
			cleanupParameters();
		}
		if (event.getSource() instanceof ReactionStep && event.getPropertyName().equals("structure")){
			updateGeneratedExpressions();
			refreshUnits();
			cleanupParameters();
		}
		if (event.getSource() instanceof ReactionStep && event.getPropertyName().equals("reactionParticipants")){
			ReactionParticipant oldValues[] = (ReactionParticipant[])event.getOldValue();
			for (int i = 0; oldValues!=null && i < oldValues.length; i++){
				oldValues[i].removePropertyChangeListener(this);
			}
			ReactionParticipant newValues[] = (ReactionParticipant[])event.getNewValue();
			for (int i = 0; newValues != null && i < newValues.length; i++){
				newValues[i].addPropertyChangeListener(this);
			}
			updateGeneratedExpressions();
			refreshUnits();
			cleanupParameters();
		}
		if (event.getSource() == this && event.getPropertyName().equals("kineticsParameters")){
			KineticsParameter oldValues[] = (KineticsParameter[])event.getOldValue();
			for (int i = 0; oldValues!=null && i < oldValues.length; i++){
				oldValues[i].removePropertyChangeListener(this);
			}
			KineticsParameter newValues[] = (KineticsParameter[])event.getNewValue();
			for (int i = 0; newValues != null && i < newValues.length; i++){
				newValues[i].addPropertyChangeListener(this);
			}
			refreshUnits();
			cleanupParameters();
		}
		if (event.getSource() instanceof ReactionParticipant){
			updateGeneratedExpressions();
			if (event.getPropertyName().equals("name")){
				String oldName = (String)event.getOldValue();
				String newName = (String)event.getNewValue();
				renameParameterExpressions(oldName,newName);
			}
			refreshUnits();
			cleanupParameters();
		}
		if (event.getSource() instanceof KineticsParameter){
			refreshUnits();
			cleanupParameters();
		}
	}catch (Throwable e){
		e.printStackTrace(System.out);
	}
}


/**
 * Insert the method's description here.
 * Creation date: (5/11/2004 6:19:00 PM)
 * @param bReading boolean
 */
public void reading(boolean argReading) {
	if (argReading == bReading){
		throw new RuntimeException("flag conflict");
	}
	this.bReading = argReading;
	if (!bReading){
		resolveUndefinedUnits();
	}
}


/**
 * Insert the method's description here.
 * Creation date: (5/24/01 4:05:36 PM)
 */
public void refreshDependencies() {
	removePropertyChangeListener(this);
	removeVetoableChangeListener(this);
	addPropertyChangeListener(this);
	addVetoableChangeListener(this);
	reactionStep.removePropertyChangeListener(this);
	reactionStep.addPropertyChangeListener(this);
	reactionStep.getChargeCarrierValence().removePropertyChangeListener(this);
	reactionStep.getChargeCarrierValence().addPropertyChangeListener(this);
	ReactionParticipant reactionParticipants[] = reactionStep.getReactionParticipants();
	for (int i = 0; i < reactionParticipants.length; i++){
		reactionParticipants[i].removePropertyChangeListener(this);
		reactionParticipants[i].addPropertyChangeListener(this);
	}
	for (int i = 0; i < fieldKineticsParameters.length; i++){
		fieldKineticsParameters[i].removePropertyChangeListener(this);
		fieldKineticsParameters[i].addPropertyChangeListener(this);
	}
	try {
		updateGeneratedExpressions();
	}catch (ExpressionException e){
	}catch (PropertyVetoException e){
	}
	refreshUnits();
	resolveUndefinedUnits();
}


/**
 * Insert the method's description here.
 * Creation date: (3/31/2004 3:55:44 PM)
 */
protected abstract void refreshUnits();


/**
 * Insert the method's description here.
 * Creation date: (9/22/2003 9:51:49 AM)
 * @param parameterName java.lang.String
 */
void removeAllUnresolvedParameters() {
	setUnresolvedParameters(new UnresolvedParameter[0]);
}


/**
 * This method was created by a SmartGuide.
 * @param name java.lang.String
 * @exception java.lang.Exception The exception description.
 */
protected void removeKineticsParameter(KineticsParameter parameter) throws PropertyVetoException {
	KineticsParameter newKineticsParameters[] = (KineticsParameter[])BeanUtils.removeElement(fieldKineticsParameters,parameter);
	setKineticsParameters(newKineticsParameters);
}


/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().removePropertyChangeListener(listener);
}


/**
 * Insert the method's description here.
 * Creation date: (9/22/2003 9:51:49 AM)
 * @param parameterName java.lang.String
 */
protected void removeUnresolvedParameter(UnresolvedParameter parameter) {
	for (int i = 0; i < fieldUnresolvedParameters.length; i++){
		if (fieldUnresolvedParameters[i] == parameter){
			UnresolvedParameter newUnresolvedParameters[] = (UnresolvedParameter[])BeanUtils.removeElement(fieldUnresolvedParameters,parameter);
			setUnresolvedParameters(newUnresolvedParameters);
			return;
		}
	}
	throw new RuntimeException("UnresolvedParameter '"+parameter.getName()+"' not found");
}


/**
 * Insert the method's description here.
 * Creation date: (9/22/2003 9:51:49 AM)
 * @param parameterName java.lang.String
 */
void removeUnresolvedParameters(SymbolTable symbolTable) {
	Kinetics.UnresolvedParameter unresolvedParms[] = (Kinetics.UnresolvedParameter[])fieldUnresolvedParameters.clone();
	for (int i = 0; i < unresolvedParms.length; i++){
		try {
			SymbolTableEntry ste = symbolTable.getEntry(unresolvedParms[i].getName());
			if (ste != unresolvedParms[i]){
				unresolvedParms = (Kinetics.UnresolvedParameter[])BeanUtils.removeElement(unresolvedParms,unresolvedParms[i]);
				i--;
			}
		}catch (ExpressionBindingException e){
			e.printStackTrace(System.out);
			throw new RuntimeException("unexpected exception while removing Unresolved Parameters: "+e.getMessage());
		}
	}
	setUnresolvedParameters(unresolvedParms);
}


/**
 * The removeVetoableChangeListener method was generated to support the vetoPropertyChange field.
 */
public synchronized void removeVetoableChangeListener(java.beans.VetoableChangeListener listener) {
	getVetoPropertyChange().removeVetoableChangeListener(listener);
}


/**
 * Insert the method's description here.
 * Creation date: (5/24/01 4:05:36 PM)
 */
public void renameParameter(String oldName, String newName) throws ExpressionException, java.beans.PropertyVetoException{
	if (oldName==null || newName==null){
		throw new RuntimeException("renameParameter from '"+oldName+"' to '"+newName+"', nulls are not allowed");
	}
	NameScope nameScope = getReactionStep().getNameScope();
	String prefix = AbstractNameScope.getPrefix(newName);
	String strippedName = AbstractNameScope.getStrippedIdentifier(newName);
	if (prefix!=null){
		NameScope prefixNameScope = nameScope.getNameScopeFromPrefix(prefix);
		if (prefixNameScope != nameScope){ // from different namescope, then strip any prefix.
			throw new ExpressionException("reaction parameter cannot be renamed to '"+newName+"', name is scoped to '"+prefixNameScope.getName()+"'");
		}
	}
	newName = strippedName;
	if (oldName.equals(newName)){
		throw new RuntimeException("renameParameter from '"+oldName+"' to '"+newName+"', same name not allowed");
	}
	KineticsParameter parameter = getKineticsParameter(oldName);
	if (parameter!=null){
		//
		// must change name in KineticsParameter directly
		// then change all references to this name in the other parameter's expressions.
		//
		KineticsParameter newParameters[] = (KineticsParameter[])getKineticsParameters().clone();
		//
		// replaces parameter with name 'oldName' with new parameter with name 'newName' and original expression.
		//
		for (int i = 0; i < newParameters.length; i++){
			if (newParameters[i] == parameter){
				newParameters[i] = new KineticsParameter(newName,parameter.getExpression(),parameter.getRole(),parameter.getUnitDefinition());
			}
		}
		//
		// go through all parameters' expressions and replace references to 'oldName' with 'newName'
		//
		for (int i = 0; i < newParameters.length; i++){ 
			Expression newExp = new Expression(getKineticsParameters()[i].getExpression());
			newExp.substituteInPlace(new Expression(oldName),new Expression(newName));
			//
			// if expression changed, create a new KineticsParameter
			//
//			if (!getKineticsParameters()[i].getExpression().compareEqual(newExp)){
				newParameters[i] = new KineticsParameter(newParameters[i].getName(),newExp,newParameters[i].getRole(),newParameters[i].getUnitDefinition());
//			}
		}
		setKineticsParameters(newParameters);

		// 
		// rebind all expressions
		//
		for (int i = 0; i < newParameters.length; i++){
			newParameters[i].getExpression().bindExpression(getReactionStep());
		}
		////
		//// then, if this parameter was a "requiredIdentifier", must also alter that indexed property (identifier array)
		////
		//String requiredIdentifiers[] = getRequiredIdentifiers();
		//String newRequiredIdentifiers[] = null;
		//for (int i = 0; i < requiredIdentifiers.length; i++){
			//if (parameter.getName().equals(requiredIdentifiers[i])){
				//newRequiredIdentifiers = (String[])requiredIdentifiers.clone();
				//newRequiredIdentifiers[i] = newName;
				//break;
			//}
		//}
		//if (newRequiredIdentifiers!=null){
			//setRequiredIdentifiers(newRequiredIdentifiers);
		//}

		//
		// clean up dangling parameters (those not reachable from the 'required' parameters).
		//
		try {
			cleanupParameters();
		}catch (ModelException e){
			e.printStackTrace(System.out);
			throw new RuntimeException(e.getMessage());
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (5/24/01 4:08:07 PM)
 */
private void renameParameterExpressions(java.lang.String oldName, java.lang.String newName) throws ExpressionException, PropertyVetoException {
	KineticsParameter newParameters[] = (KineticsParameter[])fieldKineticsParameters.clone();
	for (int i = 0; i < newParameters.length; i++){
		Expression newExp = new Expression(newParameters[i].getExpression());
		newExp.substituteInPlace(new Expression(oldName),new Expression(newName));
		newExp.bindExpression(reactionStep);
		newParameters[i].setExpression(newExp);
	}
	setKineticsParameters(newParameters);

	//
	// could possibly rename a SpeciesContext over a parameter name
	//
	//  for example:   a = b + c
	//                 b = 2
	//                 c = 1
	//
	//   now rename "Calcium" to c
	//
	//                 a = b + c
	//                 b = 2
	//
	// so "c" is no longer a parameter and must be cleaned up.
	//
	try {
		cleanupParameters();
	}catch (ModelException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}catch (PropertyVetoException e){
		e.printStackTrace(System.out);
		throw new RuntimeException(e.getMessage());
	}
}


/**
 * Insert the method's description here.
 * Creation date: (11/29/2006 3:33:33 PM)
 */
public void resolveCurrentWithStructure(Structure structure) throws PropertyVetoException{
	
	
	if(structure instanceof Feature && this.getKineticsParameterFromRole(Kinetics.ROLE_CurrentDensity) != null){
		this.removeKineticsParameter(this.getKineticsParameterFromRole(Kinetics.ROLE_CurrentDensity));
		
	}else if(structure instanceof Feature && this.getKineticsParameterFromRole(Kinetics.ROLE_LumpedCurrent) != null){
		this.removeKineticsParameter(this.getKineticsParameterFromRole(Kinetics.ROLE_LumpedCurrent));
		
	}else if(structure instanceof Membrane && this.getKineticsParameterFromRole(Kinetics.ROLE_CurrentDensity) == null){
		String pname = this.getDefaultParameterName(Kinetics.ROLE_CurrentDensity);
		Kinetics.KineticsParameter currentParm = new Kinetics.KineticsParameter(pname,new Expression(0.0),Kinetics.ROLE_CurrentDensity,VCUnitDefinition.UNIT_pA_per_um2);
		addKineticsParameter(currentParm);
		
	}else if(structure instanceof Membrane && this.getKineticsParameterFromRole(Kinetics.ROLE_LumpedCurrent) == null){
		String pname = this.getDefaultParameterName(Kinetics.ROLE_LumpedCurrent);
		Kinetics.KineticsParameter currentParm = new Kinetics.KineticsParameter(pname,new Expression(0.0),Kinetics.ROLE_LumpedCurrent,VCUnitDefinition.UNIT_pA);
		addKineticsParameter(currentParm);
	}
	
	
}


/**
 * Insert the method's description here.
 * Creation date: (4/13/2004 3:09:21 PM)
 */
public void resolveUndefinedUnits() {
	//
	// try to fix units for UserDefined parameters
	//
	if (!bResolvingUnits){
		try {
			bResolvingUnits = true;
			boolean bAnyTBDUnits = false;
			for (int i=0;i<fieldKineticsParameters.length;i++){
				if (fieldKineticsParameters[i].getUnitDefinition()==null){
					return; // not ready to resolve units yet
				}else if (fieldKineticsParameters[i].getUnitDefinition().compareEqual(cbit.vcell.units.VCUnitDefinition.UNIT_TBD)){
					bAnyTBDUnits = true;
				}
			}
			//
			// try to resolve TBD units (will fail if units are inconsistent) ... but these errors are collected in Kinetics.getIssues().
			//
			if (bAnyTBDUnits){
				cbit.vcell.units.VCUnitDefinition vcUnitDefinitions[] = VCUnitEvaluator.suggestUnitDefinitions(fieldKineticsParameters);
				for (int i = 0; i < fieldKineticsParameters.length; i++){
					if (!fieldKineticsParameters[i].getUnitDefinition().compareEqual(vcUnitDefinitions[i])){
						fieldKineticsParameters[i].setUnitDefinition(vcUnitDefinitions[i]);
					}
				}
				//System.out.println("successfully completed Kinetics.resolveUndefinedUnits() for ReactionStep '"+getReactionStep()+"'");
			}
		}catch (ExpressionBindingException e){
			System.out.println("Kinetics.resolveUndefinedUnits(): EXCEPTION: "+e.getMessage());
		}catch (Exception e){
			System.out.println("Kinetics.resolveUndefinedUnits(): EXCEPTION: "+e.getMessage());
		}finally{
			bResolvingUnits = false;
		}
	}
}


/**
 * Sets the kineticsParameters property (cbit.vcell.model.KineticsParameter[]) value.
 * @param kineticsParameters The new value for the property.
 * @exception java.beans.PropertyVetoException The exception description.
 * @see #getKineticsParameters
 */
void setKineticsParameters(KineticsParameter[] kineticsParameters) throws java.beans.PropertyVetoException {
	KineticsParameter[] oldValue = fieldKineticsParameters;
	fireVetoableChange("kineticsParameters", oldValue, kineticsParameters);
	fieldKineticsParameters = kineticsParameters;
	firePropertyChange("kineticsParameters", oldValue, kineticsParameters);
}


/**
 * Sets the kineticsParameters index property (cbit.vcell.model.KineticsParameter[]) value.
 * @param index The index value into the property array.
 * @param kineticsParameters The new value for the property.
 * @see #getKineticsParameters
 */
void setKineticsParameters(int index, KineticsParameter kineticsParameters) {
	KineticsParameter oldValue = fieldKineticsParameters[index];
	fieldKineticsParameters[index] = kineticsParameters;
	if (oldValue != null && !oldValue.equals(kineticsParameters)) {
		firePropertyChange("kineticsParameters", null, fieldKineticsParameters);
	};
}


/**
 * This method was created by a SmartGuide.
 * @param name java.lang.String
 */
void setName(String name) {
	this.name = name;
}


/**
 * This method was created by a SmartGuide.
 * @param expressionString java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public void setParameterValue(KineticsParameter parm, Expression exp) throws ExpressionException, PropertyVetoException {
	Parameter p = getKineticsParameter(parm.getName());
	if (p != parm){
		throw new RuntimeException("parameter "+parm.getName()+" not found");
	}
	Expression oldExpression = parm.getExpression();
	boolean bBound = false;
	try {
		KineticsParameter newKineticsParameters[] = (KineticsParameter[])fieldKineticsParameters.clone();
		String symbols[] = exp.getSymbols(getReactionStep().getNameScope());
		Vector symbolsToAdd = new Vector();
		for (int i = 0; symbols!=null && i < symbols.length; i++){
			if (reactionStep.getEntry(symbols[i])==null){
				symbolsToAdd.add(symbols[i]);
			}
		}
		for (int i = 0; i < symbolsToAdd.size(); i++){
			newKineticsParameters = (KineticsParameter[])BeanUtils.addElement(newKineticsParameters,new KineticsParameter((String)symbolsToAdd.elementAt(i),new Expression(0.0),ROLE_UserDefined,cbit.vcell.units.VCUnitDefinition.UNIT_TBD));
		}
		parm.setExpression(exp);
		setKineticsParameters(newKineticsParameters);
		exp.bindExpression(reactionStep);
		bBound = true;
	}finally{
		try {
			if (!bBound){
				parm.setExpression(oldExpression);
			}
			cleanupParameters();
		}catch (ModelException e){
			e.printStackTrace(System.out);
			throw new RuntimeException(e.getMessage());
		}catch (PropertyVetoException e){
			e.printStackTrace(System.out);
			throw new RuntimeException(e.getMessage());
		}
	}
}


/**
 * This method was created by a SmartGuide.
 * @param expressionString java.lang.String
 * @exception java.lang.Exception The exception description.
 */
public void setParameterValue(String parmName, String expressionString) throws ExpressionException, PropertyVetoException {
	KineticsParameter parm = getKineticsParameter(parmName);
	if (parm == null){
		throw new RuntimeException("parameter "+parmName+" not found");
	}
	Expression exp = new Expression(expressionString);
	setParameterValue(parm,exp);
}


/**
 * Sets the unresolvedParameters property (cbit.vcell.model.UnresolvedParameter[]) value.
 * @param unresolvedParameters The new value for the property.
 * @see #getUnresolvedParameters
 */
private void setUnresolvedParameters(UnresolvedParameter[] unresolvedParameters) {
	UnresolvedParameter[] oldValue = fieldUnresolvedParameters;
	fieldUnresolvedParameters = unresolvedParameters;
	firePropertyChange("unresolvedParameters", oldValue, unresolvedParameters);
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}


/**
 * Insert the method's description here.
 * Creation date: (10/19/2003 12:04:36 AM)
 * @exception cbit.vcell.parser.ExpressionException The exception description.
 */
protected abstract void updateGeneratedExpressions() throws cbit.vcell.parser.ExpressionException, PropertyVetoException;


/**
 * Insert the method's description here.
 * Creation date: (5/23/00 10:41:22 PM)
 * @param e java.beans.PropertyChangeEvent
 */
public void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException {
}


/**
 * This method was created by a SmartGuide.
 * @param ps java.io.PrintStream
 * @exception java.lang.Exception The exception description.
 */
public final void writeTokens(java.io.PrintWriter pw) {
	//
	//  old format (version 1) (still supported for reading)
	//
	//	Kinetics GeneralCurrentKinetics {
	//      Parameter a 10;
	//      Parameter b 3;
	//      Parameter c d/2;
	//      Parameter d 5;
	//      CurrentDensity a+b/c;
	//  }
	//
	//
	//  new format (version 2) (deprecated, incompatable with Version 1, still supported for reading)
	//
	//	Kinetics GeneralCurrentKinetics {
	//      CurrentDensity 'currentDensity'
	//		Parameter currentDensity a+b/c;
	//      Parameter a 10;
	//      Parameter b 3;
	//      Parameter c d/2;
	//      Parameter d 5;
	//  }
	//
	//  latest format (version 3), which is backward compatable with version 1
	//  ParameterVCMLTokens (such as "CurrentDensity") have simple expressions 
	//  that always consist of only the requiredIdentifier (e.g.  currentDensity; )
	//
	//	Kinetics GeneralCurrentKinetics {
	//		Parameter currentDensity a+b/c;
	//      Parameter a 10;
	//      Parameter b 3;
	//      Parameter c d/2;
	//      Parameter d 5;
	//      CurrentDensity currentDensity;
	//  }
	//
	//

	pw.println("\t\t"+VCMODL.Kinetics+" "+getKineticsDescription().getVCMLKineticsName()+" "+VCMODL.BeginBlock+" ");

	KineticsParameter parameters[] = getKineticsParameters();
	if (parameters!=null){
		for (int i=0;i<parameters.length;i++){
			KineticsParameter parm = parameters[i];
			cbit.vcell.units.VCUnitDefinition unit = parm.getUnitDefinition();
			if (unit == null) {
				pw.println("\t\t\t"+VCMODL.Parameter+" "+parm.getName()+" "+parm.getExpression().infix() + ";" );
			} else {
				pw.println("\t\t\t"+VCMODL.Parameter+" "+parm.getName()+" "+parm.getExpression().infix() + ";" +
					       " [" +  unit.getSymbol() + "]");
			}
		}
	}

	//
	// write primary tokens as simple expressions (e.g. parmName; )
	//
	for (int i = 0; i < parameters.length; i++){
		KineticsParameter parm = parameters[i];
		if (parm.getRole() != ROLE_UserDefined){
			pw.println("\t\t\t"+RoleTags[parm.getRole()]+" "+parm.getName()+";");
		}
	}
	
	
	pw.println("\t\t"+VCMODL.EndBlock+" ");
}

public abstract KineticsParameter getAuthoritativeParameter();

}