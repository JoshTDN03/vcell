package cbit.vcell.constraints.gui;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import cbit.gui.graph.CartoonTool;
import cbit.gui.graph.RubberBandRectShape;
import cbit.gui.graph.RubberBandEdgeShape;
import cbit.gui.graph.ContainerShape;
import cbit.gui.graph.ElipseShape;
import cbit.gui.graph.GraphModel;
import cbit.gui.graph.Shape;
import cbit.gui.graph.EdgeShape;
import cbit.gui.graph.SimpleContainerShape;
import java.awt.event.*;
import java.awt.*;
import cbit.gui.*;
import javax.swing.*;
import javax.swing.event.InternalFrameEvent;

/**
 * This class was generated by a SmartGuide.
 * 
 */
public class ConstraintGraphCartoonTool extends CartoonTool {
	private ConstraintsGraphModel graphModel = null;

	public static final String ANNEALER = "Annealer";
	public static final String CIRCULARIZER = "Circularizer";
	public static final String CYCLEIZER = "Cycleizer";
	public static final String FORCEDIRECT = "ForceDirect";
	public static final String LEVELLER = "Leveller";
	public static final String RANDOMIZER = "Randomizer";
	public static final String RELAXER = "Relaxer";
	public static final String STABILIZER = "Stabilizer";

	//
	// for dragging speciesContext's around
	//
	private boolean bMoving = false;
	private Shape movingShape = null;
	private Point movingPointWorld = null;
	private Point movingOffsetWorld = null;

	//
	// for dragging rectangle around
	//
	private boolean bRectStretch = false;
	private RubberBandRectShape rectShape = null;

	//
	// for dragging line around
	//
	private boolean bLineStretch = false;
	private Point endPointWorld = null;
	private RubberBandEdgeShape edgeShape = null;
	private int mode = -1;

	protected transient java.beans.PropertyChangeSupport propertyChange;
	private cbit.vcell.constraints.ConstraintSolver fieldConstraintSolver = null;

/**
 * This method was created by a SmartGuide.
 * @param canvas cbit.vcell.graph.CartoonCanvas
 */
public ConstraintGraphCartoonTool () {
	super();
}


/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().addPropertyChangeListener(listener);
}


/**
 * The addPropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void addPropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {
	getPropertyChange().addPropertyChangeListener(propertyName, listener);
}


/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.beans.PropertyChangeEvent evt) {
	getPropertyChange().firePropertyChange(evt);
}


/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.lang.String propertyName, int oldValue, int newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}


/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.lang.String propertyName, java.lang.Object oldValue, java.lang.Object newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}


/**
 * The firePropertyChange method was generated to support the propertyChange field.
 */
public void firePropertyChange(java.lang.String propertyName, boolean oldValue, boolean newValue) {
	getPropertyChange().firePropertyChange(propertyName, oldValue, newValue);
}


/**
 * Insert the method's description here.
 * Creation date: (9/9/2002 10:25:37 AM)
 * @return cbit.vcell.graph.GraphModel
 */
public ConstraintsGraphModel getConstraintsGraphModel() {
	return graphModel;
}


/**
 * Gets the constraintSolver property (cbit.vcell.constraints.ConstraintSolver) value.
 * @return The constraintSolver property value.
 * @see #setConstraintSolver
 */
public cbit.vcell.constraints.ConstraintSolver getConstraintSolver() {
	return fieldConstraintSolver;
}


/**
 * Insert the method's description here.
 * Creation date: (9/9/2002 10:25:37 AM)
 * @return cbit.vcell.graph.GraphModel
 */
public GraphModel getGraphModel() {
	return graphModel;
}


/**
 * Accessor for the propertyChange field.
 */
protected java.beans.PropertyChangeSupport getPropertyChange() {
	if (propertyChange == null) {
		propertyChange = new java.beans.PropertyChangeSupport(this);
	};
	return propertyChange;
}


/**
 * The hasListeners method was generated to support the propertyChange field.
 */
public synchronized boolean hasListeners(java.lang.String propertyName) {
	return getPropertyChange().hasListeners(propertyName);
}


/**
 * This method was created in VisualAge.
 */
public void layout(String layoutName) throws Exception {

	edu.rpi.graphdrawing.Blackboard bb = new edu.rpi.graphdrawing.Blackboard();
	java.util.HashMap nodeShapeMap = new java.util.HashMap();
	//
	// add nodes
	//
	java.util.Enumeration shapeEnum = getGraphModel().getShapes();
	while (shapeEnum.hasMoreElements()){
		Shape shape = (Shape)shapeEnum.nextElement();
		edu.rpi.graphdrawing.Node newNode = null;
		if (shape instanceof ElipseShape){
			newNode = bb.addNode(shape.getLabel());
		}
		//
		// initialize node location to current absolute position
		//
		if (newNode!=null){
			newNode.XY(shape.getAbsLocation().x,shape.getAbsLocation().y);
			nodeShapeMap.put(newNode.label(),shape);
		}
	}

	//
	// add edges
	//
	shapeEnum = getConstraintsGraphModel().getShapes();
	while (shapeEnum.hasMoreElements()){
		Shape shape = (Shape)shapeEnum.nextElement();
		edu.rpi.graphdrawing.Edge newEdge = null;
		if (shape instanceof ConstraintDependencyEdgeShape){
			ConstraintDependencyEdgeShape eShape = (ConstraintDependencyEdgeShape)shape;
			ElipseShape node1Shape = eShape.getConstraintShape();
			ElipseShape node2Shape = eShape.getVarShape();
			newEdge = bb.addEdge(node1Shape.getLabel(),node2Shape.getLabel());
		}
	}

	bb.setArea(0,0,getGraphPane().getWidth(),getGraphPane().getHeight());
	bb.globals.D(20);
	
	bb.addEmbedder(ANNEALER,new edu.rpi.graphdrawing.Annealer(bb));
	bb.addEmbedder(CIRCULARIZER,new edu.rpi.graphdrawing.Circularizer(bb));
	bb.addEmbedder(CYCLEIZER,new edu.rpi.graphdrawing.Cycleizer(bb));
	bb.addEmbedder(FORCEDIRECT,new edu.rpi.graphdrawing.ForceDirect(bb));
	bb.addEmbedder(LEVELLER,new edu.rpi.graphdrawing.Leveller(bb));
	bb.addEmbedder(RANDOMIZER,new edu.rpi.graphdrawing.Randomizer(bb));
	bb.addEmbedder(RELAXER,new edu.rpi.graphdrawing.Relaxer(bb));
	bb.addEmbedder(STABILIZER,new edu.rpi.graphdrawing.Stabilizer(bb));

	bb.setEmbedding(layoutName);

java.util.Vector nodeList = bb.nodes();
for (int i = 0; i < nodeList.size(); i++){
	edu.rpi.graphdrawing.Node node = (edu.rpi.graphdrawing.Node)nodeList.elementAt(i);
System.out.println("Node "+node.label()+" @ ("+node.x()+","+node.y()+")");
}
	bb.PreprocessNodes();
	
	edu.rpi.graphdrawing.Embedder embedder = bb.embedder();
	embedder.Init();
	for (int i = 0; i < 1000; i++){
		embedder.Embed();
	}

	bb.removeDummies();
	nodeList = bb.nodes();
	//
	// calculate offset and scaling so that resulting graph fits on canvas
	//
	double lowX = 100000;
	double highX = -100000;
	double lowY = 100000;
	double highY = -100000;
	for (int i = 0; i < nodeList.size(); i++){
		edu.rpi.graphdrawing.Node node = (edu.rpi.graphdrawing.Node)nodeList.elementAt(i);
		lowX = Math.min(lowX,node.x());
		highX = Math.max(highX,node.x());
		lowY = Math.min(lowY,node.y());
		highY = Math.max(highY,node.y());
	}
	double scaleX = getGraphPane().getWidth()/(1.5*(highX-lowX));
	double scaleY = getGraphPane().getHeight()/(1.5*(highY-lowY));
	int offsetX = getGraphPane().getWidth()/6;
	int offsetY = getGraphPane().getHeight()/6;
	for (int i = 0; i < nodeList.size(); i++){
		edu.rpi.graphdrawing.Node node = (edu.rpi.graphdrawing.Node)nodeList.elementAt(i);
		Shape shape = (Shape)nodeShapeMap.get(node.label());
		Point parentLoc = shape.getParent().getAbsLocation();
		shape.setLocation(new Point((int)(scaleX*(node.x()-lowX))+offsetX+parentLoc.x,(int)((scaleY*(node.y()-lowY))+offsetY+parentLoc.y)));
System.out.println("Shape "+shape.getLabel()+" @ "+shape.getAbsLocation());
	}

	getGraphPane().repaint();
}


/**
 * This method calls the glg layout library.
 * Creation date: (8/28/2002 3:44:20 PM)
 */
public void layoutGlg() {
	//
	//Create graph object
	//
	com.genlogic.GraphLayout.GlgGraphLayout graph = new com.genlogic.GraphLayout.GlgGraphLayout();
	graph.SetUntangle(true); //true
	//specify dimensions for the graph! 400x400
	//System.out.println("H:"+getGraphPane().getHeight()+" W"+getGraphPane().getWidth());
	com.genlogic.GraphLayout.GlgCube graphDim = new com.genlogic.GraphLayout.GlgCube();
	com.genlogic.GraphLayout.GlgPoint newPoint = new com.genlogic.GraphLayout.GlgPoint(0,0,0);
	graphDim.p1 = newPoint;
	//newPoint = new com.genlogic.GlgPoint(getGraphPane().getWidth()-20, getGraphPane().getHeight()-10, 0);//400,400,0
	newPoint = new com.genlogic.GraphLayout.GlgPoint(1600,1600, 0);
	graphDim.p2 = newPoint;
	graph.dimensions = graphDim;

	//
	//Add nodes (Vertex) to the graph
	//
	java.util.Enumeration shapeEnum = getConstraintsGraphModel().getShapes();
	com.genlogic.GraphLayout.GlgGraphNode graphNode;
	java.util.HashMap nodeMap = new java.util.HashMap(); 
	
	while (shapeEnum.hasMoreElements()) {
		Shape shape = (Shape)shapeEnum.nextElement();

		//add to the graph			
		if (shape instanceof ElipseShape) {
			graphNode = graph.AddNode(null, 0, null);
		} else {
			continue;
		}
		
		//add to the hashmap
		nodeMap.put(shape,graphNode);
	}
	//
	//Add edges
	//
	shapeEnum = getConstraintsGraphModel().getShapes();
	
	while (shapeEnum.hasMoreElements()) {
		Shape shape = (Shape)shapeEnum.nextElement();
		
		if (shape instanceof ConstraintDependencyEdgeShape) {
			ConstraintDependencyEdgeShape eShape = (ConstraintDependencyEdgeShape)shape;
			graph.AddEdge((com.genlogic.GraphLayout.GlgGraphNode)nodeMap.get(eShape.getConstraintShape()),(com.genlogic.GraphLayout.GlgGraphNode)nodeMap.get(eShape.getVarShape()),null, 0 ,null);
		}
	}

	//
	//call layout algorithm
	//
	while (!graph.SpringIterate()) {
		;
	}
	graph.Update();

	//
	//resize and scale the graph
	//
	//com.genlogic.GlgObject edgeArray = graph.edge_array;
	java.util.Vector edgeVector = graph.edge_array;
	double distance, minDistance = Double.MAX_VALUE;
	
	for (int i = 0; i < edgeVector.size(); i++){
		com.genlogic.GraphLayout.GlgGraphEdge edge = (com.genlogic.GraphLayout.GlgGraphEdge)edgeVector.elementAt(i);
		distance = java.awt.geom.Point2D.distance(edge.start_node.display_position.x, edge.start_node.display_position.y, edge.end_node.display_position.x, edge.end_node.display_position.y);
		minDistance = distance<minDistance?distance:minDistance;
	}
	double ratio = 1.0;
	if (minDistance > 40) {
		ratio = 40.0/minDistance;
	}
	
	//
	//Update positions
	//
	shapeEnum = getConstraintsGraphModel().getShapes();
	Point place;
	com.genlogic.GraphLayout.GlgPoint glgPoint;
	while (shapeEnum.hasMoreElements()) {
		Shape shape= (Shape)shapeEnum.nextElement();
		//test if it is contained in the nodeMap
		graphNode = (com.genlogic.GraphLayout.GlgGraphNode)nodeMap.get(shape);
		
		if (graphNode!= null) {
			glgPoint = graph.GetNodePosition(graphNode);
			//glgPoint = graphNode.display_position;
			place = new Point();
			place.setLocation(glgPoint.x*ratio, glgPoint.y*ratio+30);
			shape.setLocation(place);		
		}
	}	
	
	
	Dimension graphSize = new Dimension((int)(1600*ratio)+50,(int)(1600*ratio)+50);
	getGraphPane().setSize(graphSize);
	getGraphPane().setPreferredSize(graphSize);

	//update the window
	getGraphPane().invalidate();
	((JViewport)getGraphPane().getParent()).revalidate();	
}


/**
 * Insert the method's description here.
 * Creation date: (9/17/2002 3:56:54 PM)
 * @param shape cbit.vcell.graph.Shape
 * @param menuAction java.lang.String
 */
protected void menuAction(Shape shape, String menuAction) {
	try {
	
		if(shape == null){return;}

		// if multiselect, then get them all
		ConstraintsGraphModel constraintsGraphModel = (ConstraintsGraphModel)getGraphModel();
		Shape shapes[] = constraintsGraphModel.getAllSelectedShapes();
		//	
		if (menuAction.equals(RESET_MENU_ACTION)){
			getConstraintSolver().resetIntervals();
		}
		if (menuAction.equals(SOLVE_MENU_ACTION)){
			getConstraintSolver().narrow();
		}
		if (menuAction.equals(ENABLE_MENU_ACTION)){
			for (int i = 0; i < shapes.length; i++){
				if (shapes[i] instanceof BoundsNode || shapes[i] instanceof GeneralConstraintNode){
					cbit.vcell.constraints.AbstractConstraint constraint = (cbit.vcell.constraints.AbstractConstraint)shapes[i].getModelObject();
					getConstraintsGraphModel().getConstraintContainerImpl().setActive(constraint,true);
				}
			}
		}
		if (menuAction.equals(DISABLE_MENU_ACTION)){
			for (int i = 0; i < shapes.length; i++){
				if (shapes[i] instanceof BoundsNode || shapes[i] instanceof GeneralConstraintNode){
					cbit.vcell.constraints.AbstractConstraint constraint = (cbit.vcell.constraints.AbstractConstraint)shapes[i].getModelObject();
					getConstraintsGraphModel().getConstraintContainerImpl().setActive(constraint,false);
				}
			}
		}
		if (menuAction.equals(DELETE_MENU_ACTION)){
			java.util.Vector boundsToDelete = new java.util.Vector();
			java.util.Vector genConstraintsToDelete = new java.util.Vector();
			for (int i = 0; i < shapes.length; i++){
				if (shapes[i] instanceof BoundsNode){
					boundsToDelete.add(shapes[i].getModelObject());
				}else if (shapes[i] instanceof GeneralConstraintNode){
					genConstraintsToDelete.add(shapes[i].getModelObject());
				}
			}
			if (boundsToDelete.size()>0){
				cbit.vcell.constraints.SimpleBounds bounds[] = constraintsGraphModel.getConstraintContainerImpl().getSimpleBounds();
				for (int i = 0; i < boundsToDelete.size(); i++){
					bounds = (cbit.vcell.constraints.SimpleBounds[])cbit.util.BeanUtils.removeElement(bounds,boundsToDelete.elementAt(i));
				}
				constraintsGraphModel.getConstraintContainerImpl().setSimpleBounds(bounds);
			}
			if (genConstraintsToDelete.size()>0){
				cbit.vcell.constraints.GeneralConstraint genConstraints[] = constraintsGraphModel.getConstraintContainerImpl().getGeneralConstraints();
				for (int i = 0; i < genConstraintsToDelete.size(); i++){
					genConstraints = (cbit.vcell.constraints.GeneralConstraint[])cbit.util.BeanUtils.removeElement(genConstraints,genConstraintsToDelete.elementAt(i));
				}
				constraintsGraphModel.getConstraintContainerImpl().setGeneralConstraints(genConstraints);
			}
		}
	}catch (Throwable e){
		DialogUtils.showErrorDialog(e.getMessage());
	}
}


/**
 * This method was created by a SmartGuide.
 * @param event java.awt.event.MouseEvent
 */
public void mouseClicked(java.awt.event.MouseEvent event) {
	
	java.awt.Point screenPoint = new java.awt.Point(event.getX(),event.getY());
	java.awt.Point worldPoint = screenToWorld(screenPoint);

	try {
		//
		// if right mouse button, then do popup menu
		//
		if ((event.getModifiers() & (MouseEvent.BUTTON2_MASK | MouseEvent.BUTTON3_MASK)) != 0){
			return;
		}
		switch (mode) {
			case SELECT_MODE: {
				if (event.getClickCount()==2){
					Shape selectedShape = getConstraintsGraphModel().getSelectedShape();
					if (selectedShape != null){
						menuAction(selectedShape,PROPERTIES_MENU_ACTION);
					}
				}
				break;		
			}	
			default:
				break;
		}	
	}catch (Exception e){
		System.out.println("CartoonTool.mouseClicked: uncaught exception");
		e.printStackTrace(System.out);
		Point canvasLoc = getGraphPane().getLocationOnScreen();
		canvasLoc.x += screenPoint.x;
		canvasLoc.y += screenPoint.y;
		DialogUtils.showErrorDialog(e.getMessage());
	}				
}


/**
 * This method was created by a SmartGuide.
 * @param event java.awt.event.MouseEvent
 */
public void mouseDragged(java.awt.event.MouseEvent event) {
	
	if ((event.getModifiers() & (MouseEvent.BUTTON2_MASK | MouseEvent.BUTTON3_MASK)) != 0){
		return;
	}
	boolean bShift = (event.getModifiers() & InputEvent.SHIFT_MASK) == InputEvent.SHIFT_MASK;
	boolean bCntrl = (event.getModifiers() & InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK;
	//
	try {
		switch (mode){
			case SELECT_MODE: {
				java.awt.Point worldPoint = screenToWorld(event.getX(),event.getY());
				if (bMoving){
					Shape selectedShapes[] = getConstraintsGraphModel().getAllSelectedShapes();
					//
					// constrain to stay within the corresponding parent for the "movingShape" as well as all other selected (hence moving) shapes.
					//
					Point movingParentLoc = movingShape.getParent().getAbsLocation();
					Dimension movingParentSize = movingShape.getParent().getSize();
					worldPoint.x = Math.max(movingOffsetWorld.x+movingParentLoc.x,Math.min(movingOffsetWorld.x+movingParentLoc.x+movingParentSize.width-movingShape.getSize().width, worldPoint.x));
					worldPoint.y = Math.max(movingOffsetWorld.y+movingParentLoc.y,Math.min(movingOffsetWorld.x+movingParentLoc.y+movingParentSize.height-movingShape.getSize().height, worldPoint.y));
					for (int i = 0; selectedShapes!=null && i < selectedShapes.length; i++){
						if (selectedShapes[i]!=movingShape){
							Point selectedParentLoc = selectedShapes[i].getParent().getAbsLocation();
							Dimension selectedParentSize = selectedShapes[i].getParent().getSize();
							int selectedMovingOffsetX = movingOffsetWorld.x + (movingShape.getAbsLocation().x-selectedShapes[i].getAbsLocation().x);
							int selectedMovingOffsetY = movingOffsetWorld.y + (movingShape.getAbsLocation().y-selectedShapes[i].getAbsLocation().y);
							worldPoint.x = Math.max(selectedMovingOffsetX+selectedParentLoc.x,Math.min(selectedMovingOffsetX+selectedParentLoc.x+selectedParentSize.width-selectedShapes[i].getSize().width, worldPoint.x));
							worldPoint.y = Math.max(selectedMovingOffsetY+selectedParentLoc.y,Math.min(selectedMovingOffsetY+selectedParentLoc.y+selectedParentSize.height-selectedShapes[i].getSize().height, worldPoint.y));
						}
					}

					getGraphPane().setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
					Point newMovingPoint = new Point(worldPoint.x-movingOffsetWorld.x,worldPoint.y-movingOffsetWorld.y);
					int deltaX = newMovingPoint.x - movingPointWorld.x;
					int deltaY = newMovingPoint.y - movingPointWorld.y;
					movingPointWorld = newMovingPoint;
					movingShape.setLocation(new Point(movingPointWorld.x-movingParentLoc.x,movingPointWorld.y-movingParentLoc.y));
					//
					// for any other "movable" shapes that are selected, move them also
					//
					for (int i = 0; selectedShapes!=null && i < selectedShapes.length; i++){
						if (selectedShapes[i]!=movingShape){
							selectedShapes[i].setLocation(new Point(selectedShapes[i].getLocation().x + deltaX, selectedShapes[i].getLocation().y + deltaY));
						}
					}
					getGraphPane().invalidate();
					((JViewport)getGraphPane().getParent()).revalidate();
					getGraphPane().repaint();
				}else if (bRectStretch){
					//
					// constain to stay within parent
					//
					Point parentLoc = rectShape.getParent().getAbsLocation();
					Dimension parentSize = rectShape.getParent().getSize();
					worldPoint.x = Math.max(1,Math.min(parentSize.width-1,worldPoint.x-parentLoc.x)) + parentLoc.x;
					worldPoint.y = Math.max(1,Math.min(parentSize.height-1,worldPoint.y-parentLoc.y)) + parentLoc.y;
					getGraphPane().setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
					//getGraphPane().repaint();
					Graphics2D g = (Graphics2D)getGraphPane().getGraphics();
					java.awt.geom.AffineTransform oldTransform = g.getTransform();
					g.scale(0.01*getConstraintsGraphModel().getZoomPercent(),0.01*getConstraintsGraphModel().getZoomPercent());
					g.setXORMode(Color.white);
					rectShape.setEnd(endPointWorld);
					rectShape.paint(g,0,0);
					endPointWorld = worldPoint;
					rectShape.setEnd(endPointWorld);
					rectShape.paint(g,0,0);
					g.setTransform(oldTransform);
				}else{
					Shape shape = (getGraphModel().getSelectedShape() != null?getGraphModel().getSelectedShape():getConstraintsGraphModel().pickWorld(worldPoint));
					if (!bCntrl && !bShift && (shape instanceof ElipseShape)){
						bMoving=true;
						movingShape = shape;
						movingPointWorld = shape.getAbsLocation();
						movingOffsetWorld = new Point(worldPoint.x-movingPointWorld.x,worldPoint.y-movingPointWorld.y);
					}else if (shape instanceof ContainerShape || bShift || bCntrl){
						bRectStretch = true;
						endPointWorld = new Point(worldPoint.x+1,worldPoint.y+1);
				 		rectShape = new RubberBandRectShape(worldPoint,endPointWorld,getConstraintsGraphModel());
						rectShape.setEnd(endPointWorld);
						if(!(shape instanceof ContainerShape)){
							shape.getParent().addChildShape(rectShape);
						}else{
							shape.addChildShape(rectShape);
						}
						Graphics2D g = (Graphics2D)getGraphPane().getGraphics();
						java.awt.geom.AffineTransform oldTransform = g.getTransform();
						g.scale(0.01*getConstraintsGraphModel().getZoomPercent(),0.01*getConstraintsGraphModel().getZoomPercent());
						g.setXORMode(Color.white);
						rectShape.paint(g,0,0);
						g.setTransform(oldTransform);
					}		
				}		
				break;
			}
			default: {
				break;
			}
		}		
	}catch (Exception e){
		System.out.println("CartoonTool.mouseDragged: uncaught exception");
		e.printStackTrace(System.out);
	}			
}


/**
 * This method was created by a SmartGuide.
 * @param event java.awt.event.MouseEvent
 */
public void mousePressed(java.awt.event.MouseEvent event) {
	//
	if(getConstraintsGraphModel() == null){return;}
	try {
		//
		int eventX = event.getX();
		int eventY = event.getY();
		java.awt.Point screenPoint = new java.awt.Point(eventX,eventY);
		java.awt.Point worldPoint = new java.awt.Point((int)(eventX*100.0/getConstraintsGraphModel().getZoomPercent()),(int)(eventY*100.0/getConstraintsGraphModel().getZoomPercent()));
		//
		//Always select with MousePress
		//
		boolean bShift = (event.getModifiers() & InputEvent.SHIFT_MASK) == InputEvent.SHIFT_MASK;
		boolean bCntrl = (event.getModifiers() & InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK;
		if(mode == SELECT_MODE || (event.getModifiers() & MouseEvent.BUTTON1_MASK) != 0){
			selectEventFromWorld(worldPoint,bShift,bCntrl);
		}
		//
		// if mouse popupMenu event, popup menu
		if (event.isPopupTrigger() && mode == SELECT_MODE){
			popupMenu(getConstraintsGraphModel().getSelectedShape(),eventX,eventY);
			return;
		}
	}catch (Exception e){
		System.out.println("CartoonTool.mousePressed: uncaught exception");
		e.printStackTrace(System.out);
	}				
}


/**
 * This method was created by a SmartGuide.
 * @param event java.awt.event.MouseEvent
 */
public void mouseReleased(java.awt.event.MouseEvent event) {
	//
	if(getConstraintsGraphModel() == null){return;}
	//
	try {
		//Pick shape
		int eventX = event.getX();
		int eventY = event.getY();
		java.awt.Point screenPoint = new java.awt.Point(eventX,eventY);
		java.awt.Point worldPoint = new java.awt.Point((int)(eventX*100.0/getConstraintsGraphModel().getZoomPercent()),(int)(eventY*100.0/getConstraintsGraphModel().getZoomPercent()));
		Shape pickedShape = getConstraintsGraphModel().pickWorld(worldPoint);
		//
		// if mouse popupMenu event, popup menu
		//
		if (event.isPopupTrigger() && mode == SELECT_MODE){
			//boolean bShift = (event.getModifiers() & InputEvent.SHIFT_MASK) == InputEvent.SHIFT_MASK;
			//boolean bCntrl = (event.getModifiers() & InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK;
			//selectEventFromWorld(worldPoint,bShift,bCntrl);
			if(pickedShape.isSelected()){ // == getConstraintsGraphModel().getSelectedShape()){
				popupMenu(pickedShape,event.getX(),event.getY());
			}
			//popupMenu(pickedShape,event.getX(),event.getY());
			return;
		}
		//
		if ((event.getModifiers() & (MouseEvent.BUTTON2_MASK | MouseEvent.BUTTON3_MASK)) != 0){
			return;
		}
		//
		// else do select and move
		//
		switch (mode){
			case SELECT_MODE:{
				getGraphPane().setCursor(Cursor.getDefaultCursor());
				//int x = event.getX();
				//int y = event.getY();
				if (bMoving){
					getGraphPane().invalidate();
					((JViewport)getGraphPane().getParent()).revalidate();
					getGraphPane().repaint();
				}else if (bRectStretch){
					Point absLoc = rectShape.getLocation();
					Dimension size = rectShape.getSize();
					//
					// remove temporary rectangle
					//
					getConstraintsGraphModel().removeShape(rectShape);
					rectShape = null;
					Rectangle rect = new Rectangle(absLoc.x,absLoc.y,size.width,size.height);
					boolean bShift = (event.getModifiers() & InputEvent.SHIFT_MASK) == InputEvent.SHIFT_MASK;
					boolean bCntrl = (event.getModifiers() & InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK;
					selectEventFromWorld(rect,bShift,bCntrl);
					getGraphPane().repaint();
				}
				bMoving=false;
				movingShape=null;
				bRectStretch=false;
				rectShape=null;
				break;
			}
			default:{
				break;
			}
		}
	}catch (Exception e){
		System.out.println("CartoonTool.mouseReleased: uncaught exception");
		e.printStackTrace(System.out);
	}			
		
}


/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.beans.PropertyChangeListener listener) {
	getPropertyChange().removePropertyChangeListener(listener);
}


/**
 * The removePropertyChangeListener method was generated to support the propertyChange field.
 */
public synchronized void removePropertyChangeListener(java.lang.String propertyName, java.beans.PropertyChangeListener listener) {
	getPropertyChange().removePropertyChangeListener(propertyName, listener);
}


/**
 * This method was created by a SmartGuide.
 * @param x int
 * @param y int
 */
private void selectEventFromWorld(Point worldPoint, boolean bShift, boolean bCntrl) {
	//
	if(getConstraintsGraphModel() == null){return;}
	//
	if (!bShift && !bCntrl){
		//
		Shape pickedShape = getConstraintsGraphModel().pickWorld(worldPoint);
		//
		if (pickedShape == null || !pickedShape.isSelected()){
			getConstraintsGraphModel().clearSelection();
		}
		if (pickedShape != null && pickedShape.isSelected()){
			return;
		}
		if (pickedShape instanceof ContainerShape){
			if (pickedShape.isSelected()){
				getConstraintsGraphModel().clearSelection();
				return;
			}
		}
		if(pickedShape != null){
			getConstraintsGraphModel().select(pickedShape);
		}

	}else if (bShift){
		Shape pickedShape = getConstraintsGraphModel().pickWorld(worldPoint);
		if (pickedShape==null){
			return;
		}
		if (pickedShape instanceof ContainerShape){
			return;
		}
		if(getConstraintsGraphModel().getSelectedShape() instanceof ContainerShape){
			getConstraintsGraphModel().clearSelection();
		}
		getConstraintsGraphModel().select(pickedShape);
	}else if (bCntrl){
		Shape pickedShape = getConstraintsGraphModel().pickWorld(worldPoint);
		if (pickedShape==null){
			return;
		}
		if (pickedShape instanceof ContainerShape){
			return;
		}
		if (pickedShape.isSelected()){
			getConstraintsGraphModel().deselect(pickedShape);
		}else{
			getConstraintsGraphModel().select(pickedShape);
		}
	}
}


/**
 * This method was created in VisualAge.
 * @param rect java.awt.Rectangle
 * @param bShift boolean
 * @param bCntrl boolean
 */
private void selectEventFromWorld(Rectangle rect, boolean bShift, boolean bCntrl) {
	if (!bShift && !bCntrl){
		getConstraintsGraphModel().clearSelection();
		Shape shapes[] = getConstraintsGraphModel().pickWorld(rect);
		for (int i = 0; i < shapes.length; i++){
			if (shapes[i] instanceof ElipseShape){
				getConstraintsGraphModel().select(shapes[i]);
			}
		}
	}else if (bShift){
		if(getConstraintsGraphModel().getSelectedShape() instanceof ContainerShape){
			getConstraintsGraphModel().clearSelection();
		}
		Shape shapes[] = getConstraintsGraphModel().pickWorld(rect);
		for (int i = 0; i < shapes.length; i++){
			if (shapes[i] instanceof ElipseShape){
				getConstraintsGraphModel().select(shapes[i]);
			}
		}
	}else if (bCntrl){
		if(getConstraintsGraphModel().getSelectedShape() instanceof ContainerShape){
			getConstraintsGraphModel().clearSelection();
		}
		Shape shapes[] = getConstraintsGraphModel().pickWorld(rect);
		for (int i = 0; i < shapes.length; i++){
			if (shapes[i] instanceof ElipseShape){
				if (shapes[i].isSelected()){
					getConstraintsGraphModel().deselect(shapes[i]);
				}else{
					getConstraintsGraphModel().select(shapes[i]);
				}
			}
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (5/14/2003 10:51:54 AM)
 * @param newReactionCartoon cbit.vcell.graph.ReactionCartoon
 */
public void setConstraintsGraphModel(ConstraintsGraphModel constraintsGraphModel) {
	this.graphModel = constraintsGraphModel;
}


/**
 * Sets the constraintSolver property (cbit.vcell.constraints.ConstraintSolver) value.
 * @param constraintSolver The new value for the property.
 * @see #getConstraintSolver
 */
public void setConstraintSolver(cbit.vcell.constraints.ConstraintSolver constraintSolver) {
	cbit.vcell.constraints.ConstraintSolver oldValue = fieldConstraintSolver;
	fieldConstraintSolver = constraintSolver;
	firePropertyChange("constraintSolver", oldValue, constraintSolver);
}


/**
 * Insert the method's description here.
 * Creation date: (9/17/2002 3:47:34 PM)
 * @return boolean
 * @param shape cbit.vcell.graph.Shape
 * @param actionString java.lang.String
 */
protected boolean shapeHasMenuAction(Shape shape, String menuAction) {
	if (shape == null){
		return false;
	}
	
	if (menuAction.equals(RESET_MENU_ACTION)){
		if (shape instanceof SimpleContainerShape && shape.getModelObject() == ((ConstraintsGraphModel)getGraphModel()).getConstraintContainerImpl()){
			return true;
		}
	}
	if (menuAction.equals(SOLVE_MENU_ACTION)){
		if (shape instanceof SimpleContainerShape && shape.getModelObject() == ((ConstraintsGraphModel)getGraphModel()).getConstraintContainerImpl()){
			return true;
		}
	}
	if (menuAction.equals(ENABLE_MENU_ACTION)){
		if (shape instanceof GeneralConstraintNode ||
			shape instanceof BoundsNode){
			return true;
		}
	}
	if (menuAction.equals(DISABLE_MENU_ACTION)){
		if (shape instanceof GeneralConstraintNode ||
			shape instanceof BoundsNode){
			return true;
		}
	}
	if (menuAction.equals(DELETE_MENU_ACTION)){
		if (shape instanceof GeneralConstraintNode ||
			shape instanceof BoundsNode){
			return true;
		}
	}
	return false;
}


/**
 * Insert the method's description here.
 * Creation date: (5/9/2003 9:11:06 AM)
 * @return boolean
 * @param actionString java.lang.String
 */
protected boolean shapeHasMenuActionEnabled(Shape shape, java.lang.String menuAction) {
	if (shape == null){
		return false;
	}
	
	if (menuAction.equals(RESET_MENU_ACTION)){
		if (shape instanceof SimpleContainerShape && shape.getModelObject() == ((ConstraintsGraphModel)getGraphModel()).getConstraintContainerImpl()){
			return true;
		}
	}
	if (menuAction.equals(SOLVE_MENU_ACTION)){
		if (shape instanceof SimpleContainerShape && shape.getModelObject() == ((ConstraintsGraphModel)getGraphModel()).getConstraintContainerImpl()){
			return true;
		}
	}
	if (menuAction.equals(ENABLE_MENU_ACTION)){
		//
		// enable if any selected shapes can be enabled
		//
		Shape shapes[] = getGraphModel().getAllSelectedShapes();
		for (int i = 0; i < shapes.length; i++){
			if ((shapes[i] instanceof GeneralConstraintNode || shapes[i] instanceof BoundsNode)){
				cbit.vcell.constraints.AbstractConstraint constraint = (cbit.vcell.constraints.AbstractConstraint)shapes[i].getModelObject();
				if (getConstraintsGraphModel().getConstraintContainerImpl().getActive(constraint)==false){
					return true;
				}
			}
		}
	}
	if (menuAction.equals(DISABLE_MENU_ACTION)){
		//
		// disable if any selected shapes can be disabled
		//
		Shape shapes[] = getGraphModel().getAllSelectedShapes();
		for (int i = 0; i < shapes.length; i++){
			if ((shapes[i] instanceof GeneralConstraintNode || shapes[i] instanceof BoundsNode)){
				cbit.vcell.constraints.AbstractConstraint constraint = (cbit.vcell.constraints.AbstractConstraint)shapes[i].getModelObject();
				if (getConstraintsGraphModel().getConstraintContainerImpl().getActive(constraint)==true){
					return true;
				}
			}
		}
	}
	if (menuAction.equals(DELETE_MENU_ACTION)){
		//
		// delete if any selected shapes can be deleted
		//
		Shape shapes[] = getGraphModel().getAllSelectedShapes();
		for (int i = 0; i < shapes.length; i++){
			if ((shapes[i] instanceof GeneralConstraintNode || shapes[i] instanceof BoundsNode)){
				return true;
			}
		}
	}
	return false;
}


/**
 * This method was created in VisualAge.
 * @param mode int
 */
public void updateMode(int newMode) {
	if (newMode==mode){
		return;
	}

	bMoving = false;
	movingShape = null;

	bRectStretch = false;
	rectShape = null;

	bLineStretch = false;
	edgeShape = null;
	endPointWorld = null;
	if(getConstraintsGraphModel() != null){
		getConstraintsGraphModel().clearSelection();
	}

	this.mode = newMode;
	if(getGraphPane() != null){
		switch (mode){
			case SELECT_MODE:{
				getGraphPane().setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
				break;
			}
			default:{
				System.out.println("ERROR: mode " + newMode + "not defined");
				break;
			}
		}
	}
	return;
}
}