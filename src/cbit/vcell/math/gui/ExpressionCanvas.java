package cbit.vcell.math.gui;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.awt.*;
import cbit.vcell.parser.Expression;
import java.util.*;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class ExpressionCanvas extends javax.swing.JPanel implements javax.swing.Scrollable {
	private java.awt.Image offScreenImage = null;
	private java.awt.Dimension offScreenImageSize = null;
	private boolean bImageDirty = true;
	private cbit.vcell.parser.Expression[] fieldExpressions = null;
	private String fieldSuffixLabels[] = null;
	private String fieldPrefixLabels[] = null;
	private cbit.vcell.parser.NameScope fieldNameScope = null;


/**
 * Constructor
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
public ExpressionCanvas() {
	super();
	initialize();
}


	//used by the publish package.
	public static void getExpressionAsImage (Expression expArray [], java.awt.image.BufferedImage image, int scale) {    

		if (expArray == null || image == null) {
			throw new IllegalArgumentException("One or more invalid arguments for refreshGraphics()");
		}
		try {
			int width = image.getWidth();
			int height = image.getHeight();
			java.awt.Graphics2D g = (Graphics2D)image.getGraphics();
			g.setClip(0,0,width,height);
			g.setBackground(Color.white);
		  	g.fillRect(0,0,width,height);	
			g.setFont(new Font("SansSerif", Font.ITALIC, 11));
			//g.scale(scale,scale);
			//java.awt.geom.Rectangle2D sizeHelloBeforeScale = g.getFontMetrics().getStringBounds("hello",g);
			//System.out.println("size of 'hello' before scale is ["+sizeHelloBeforeScale.getWidth()+","+sizeHelloBeforeScale.getHeight()+"]");
			//g.getTransform().scale(scale*10, scale*10);
			//System.out.println("newScaleX = "+g.getTransform().getScaleX());
			//java.awt.geom.Rectangle2D sizeHelloAfterScale = g.getFontMetrics().getStringBounds("hello",g);
			//System.out.println("size of 'hello' after scale is ["+sizeHelloAfterScale.getWidth()+","+sizeHelloAfterScale.getHeight()+"]");
			if (expArray != null){
				g.setColor(Color.black);
				java.awt.Rectangle rect = g.getClipBounds();
				int posY = Math.max(10,(rect.height - height)/2);
				int posX = Math.max(10,(rect.width - width)/2);
				for (int i=0;i<expArray.length;i++){
					int prefixWidth = 0;
					cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(expArray[i]);
					java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
					g.setClip(posX+prefixWidth,posY,expressionDim.width,expressionDim.height);
					expPrintFormatter.paint(g);
					posY += expressionDim.height+20;
				}
			}
		} catch (Exception e) {
			System.out.println("exception in ExpressionCanvas.refreshGraphics()");
			e.printStackTrace(System.out);
		}
	}


	public static Dimension getExpressionImageSize(Expression expArray [], Graphics2D g) throws cbit.vcell.parser.ExpressionException {

		g.setFont(new Font("SansSerif", Font.ITALIC, 25));
		Dimension minSize = new java.awt.Dimension(10,10);
		for (int i=0;i<expArray.length;i++){
			cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(expArray[i]);
			java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
			int labelWidth = 0;
			minSize.width = Math.max(minSize.width, expressionDim.width + 20 + labelWidth);
			minSize.height += expressionDim.height+20;
		}

		return minSize;
	}


/**
 * Gets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @return The expressions property value.
 * @see #setExpressions
 */
public cbit.vcell.parser.Expression[] getExpressions() {
	return fieldExpressions;
}


/**
 * Gets the expressions index property (cbit.vcell.parser.Expression) value.
 * @return The expressions property value.
 * @param index The index value into the property array.
 * @see #setExpressions
 */
public cbit.vcell.parser.Expression getExpressions(int index) {
	return getExpressions()[index];
}


/**
 * Insert the method's description here.
 * Creation date: (3/28/01 5:38:58 PM)
 * @return javax.swing.JScrollPane
 */
private javax.swing.JScrollPane getJScrollPaneParent() {
	if (getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent();
	}else if (getParent() instanceof javax.swing.JViewport && getParent().getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent().getParent();
	}else{
		return null;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (11/19/2002 11:26:26 AM)
 * @return java.awt.Dimension
 */
public Dimension getMinimumSize() {
	Graphics2D g = (Graphics2D)getGraphics();
	if (g != null){
		g.setClip(0,0,getSize().width,getSize().height);
		g.setFont(new Font("SansSerif", Font.ITALIC, 11));
		try {
			Dimension minSize = new java.awt.Dimension(10,10);
			for (int i=0;i<fieldExpressions.length;i++){
				cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(fieldExpressions[i],getNameScope());
				java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
				int labelWidth = 0;
				if (fieldPrefixLabels!=null){
					labelWidth += g.getFontMetrics().stringWidth(fieldPrefixLabels[i]) + 20;
				}
				if (fieldSuffixLabels!=null){
					labelWidth += g.getFontMetrics().stringWidth(fieldSuffixLabels[i]) + 20;
				}
				minSize.width = Math.max(minSize.width, expressionDim.width + 20 + labelWidth);
				minSize.height += expressionDim.height+20;
			}
			return minSize;
		}catch (cbit.vcell.parser.ExpressionException e){
			e.printStackTrace(System.out);
			return super.getMinimumSize();
		}
	}else{
		return super.getMinimumSize();
	}
}


/**
 * Gets the nameScope property (cbit.vcell.parser.NameScope) value.
 * @return The nameScope property value.
 * @see #setNameScope
 */
public cbit.vcell.parser.NameScope getNameScope() {
	return fieldNameScope;
}


	/**
	 * Returns the preferred size of the viewport for a view component.
	 * For example the preferredSize of a JList component is the size
	 * required to acommodate all of the cells in its list however the
	 * value of preferredScrollableViewportSize is the size required for
	 * JList.getVisibleRowCount() rows.   A component without any properties
	 * that would effect the viewport size should just return 
	 * getPreferredSize() here.
	 * 
	 * @return The preferredSize of a JViewport whose view is this Scrollable.
	 * @see JViewport#getPreferredSize
	 */
public java.awt.Dimension getPreferredScrollableViewportSize() {
	return getPreferredSize();
}


/**
 * Insert the method's description here.
 * Creation date: (9/6/2002 12:17:16 PM)
 * @return java.awt.Dimension
 */
public Dimension getPreferredSize() {
	if (fieldExpressions!=null){
		Dimension prefSize = getMinimumSize();
		if (getJScrollPaneParent()!=null){
			java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
			prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
		}
		return prefSize;
	}else{
		return super.getPreferredSize();
	}
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one block
	 * of rows or columns, depending on the value of orientation. 
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a block scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "block" increment for scrolling in the specified direction.
	 * @see JScrollBar#setBlockIncrement
	 */
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	if (javax.swing.SwingConstants.VERTICAL == orientation){
		return visibleRect.height/4;
	}else{
		return visibleRect.width/4;
	}
}


	/**
	 * Return true if a viewport should always force the height of this 
	 * Scrollable to match the height of the viewport.  For example a 
	 * columnar text view that flowed text in left to right columns 
	 * could effectively disable vertical scrolling by returning
	 * true here.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables height to match its own.
	 */
public boolean getScrollableTracksViewportHeight() {
	return false;
}


	/**
	 * Return true if a viewport should always force the width of this 
	 * Scrollable to match the width of the viewport.  For example a noraml 
	 * text view that supported line wrapping would return true here, since it
	 * would be undesirable for wrapped lines to disappear beyond the right
	 * edge of the viewport.  Note that returning true for a Scrollable
	 * whose ancestor is a JScrollPane effectively disables horizontal
	 * scrolling.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables width to match its own.
	 */
public boolean getScrollableTracksViewportWidth() {
	return false;
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one new row
	 * or column, depending on the value of orientation.  Ideally, 
	 * components should handle a partially exposed row or column by 
	 * returning the distance required to completely expose the item.
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a unit scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "unit" increment for scrolling in the specified direction
	 * @see JScrollBar#setUnitIncrement
	 */
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	return 1;
}


/**
 * Called whenever the part throws an exception.
 * @param exception java.lang.Throwable
 */
private void handleException(java.lang.Throwable exception) {

	/* Uncomment the following lines to print uncaught exceptions to stdout */
	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
	// exception.printStackTrace(System.out);
}


/**
 * Initialize the class.
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private void initialize() {
	try {
		// user code begin {1}
		// user code end
		setName("ExpressionCanvas");
		setLayout(null);
		setSize(160, 120);
	} catch (java.lang.Throwable ivjExc) {
		handleException(ivjExc);
	}
	// user code begin {2}
	// user code end
}


/**
 * main entrypoint - starts the part when it is run as an application
 * @param args java.lang.String[]
 */
public static void main(java.lang.String[] args) {
	try {
		javax.swing.JFrame frame = new javax.swing.JFrame();
		ExpressionCanvas aExpressionCanvas;
		aExpressionCanvas = new ExpressionCanvas();
		frame.setContentPane(aExpressionCanvas);
		frame.setSize(aExpressionCanvas.getSize());
		frame.addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent e) {
				System.exit(0);
			};
		});
		frame.show();
		java.awt.Insets insets = frame.getInsets();
		frame.setSize(frame.getWidth() + insets.left + insets.right, frame.getHeight() + insets.top + insets.bottom);
		frame.setVisible(true);
	} catch (Throwable exception) {
		System.err.println("Exception occurred in main() of javax.swing.JPanel");
		exception.printStackTrace(System.out);
	}
}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void paintComponent(java.awt.Graphics g) {
	super.paintComponent(g);
	if (bImageDirty){
		refreshGraphics();
	}
	if (offScreenImage != null){
		g.drawImage(offScreenImage,-1,-1,this);
	}	
	return;
}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
private void refreshGraphics () {

	try {
		offScreenImageSize = new java.awt.Dimension(getSize().width,getSize().height);
		offScreenImage = createImage(offScreenImageSize.width,offScreenImageSize.height);
		if (offScreenImage==null){
			return;
		}	

		java.awt.Graphics2D g = (Graphics2D)offScreenImage.getGraphics();
//		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
		g.setClip(0,0,getSize().width,getSize().height);
		g.setFont(new Font("SansSerif", Font.ITALIC, 11));
		g.setColor(getBackground());
	  	g.fillRect(0,0,getSize().width,getSize().height);
  	
		if (fieldExpressions!=null){
			g.setColor(getForeground());
			java.awt.Rectangle rect = g.getClipBounds();
			int posY = Math.max(10,(rect.height - getSize().height)/2);
			int posX = Math.max(10,(rect.width - getSize().width)/2);
			for (int i=0;i<fieldExpressions.length;i++){
				int prefixWidth = 0;
				cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(fieldExpressions[i], getNameScope());
				java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
				if (fieldPrefixLabels!=null && fieldPrefixLabels[i]!=null){
					prefixWidth = g.getFontMetrics().stringWidth(fieldPrefixLabels[i]) + 10;
					g.setClip(posX,posY,getSize().width,getSize().height);
					g.setColor(Color.blue);
					g.drawString(fieldPrefixLabels[i],posX,posY+expressionDim.height/2+g.getFontMetrics().getDescent());
				}
				g.setColor(getForeground());
				g.setClip(posX+prefixWidth,posY,expressionDim.width,expressionDim.height);
				expPrintFormatter.paint(g);
				if (fieldSuffixLabels!=null && fieldSuffixLabels[i]!=null){
					g.setColor(Color.blue);
					g.setClip(posX,posY,getSize().width,getSize().height);
					g.drawString(fieldSuffixLabels[i],posX+expressionDim.width+prefixWidth+20,posY+expressionDim.height/2+g.getFontMetrics().getDescent());
				}
				posY += expressionDim.height+20;
			}
		}		
	}catch (Exception e){
		offScreenImage = null;
		System.out.println("exception in ExpressionCanvas.refreshGraphics()");
		e.printStackTrace(System.out);
	}

	bImageDirty = false;
	return;
}


/**
 * Insert the method's description here.
 * Creation date: (11/19/2002 12:25:45 PM)
 * @param x int
 * @param y int
 * @param w int
 * @param h int
 */
public void reshape(int x, int y, int w, int h) {
	if (w!=getSize().width || h!=getHeight()){
		bImageDirty = true;
	}
	super.reshape(x,y,w,h);
}


/**
 * This method was created by a SmartGuide.
 * @param expression cbit.vcell.parser.Expression
 */
public void setExpression(Expression expression) {
	Expression expList[] = null;
	if (expression != null){
		expList = new Expression[1];
		expList[0] = expression;
	}		
	setExpressions(expList,null,null);
}


/**
 * Sets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @param expressions The new value for the property.
 * @see #getExpressions
 */
public void setExpressions(cbit.vcell.parser.Expression[] expressions) {
	setExpressions(expressions,null,null);
}


/**
 * Sets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @param expressions The new value for the property.
 * @see #getExpressions
 */
public void setExpressions(cbit.vcell.parser.Expression[] expressions, String prefixLabels[], String suffixLabels[]) {
	fieldExpressions = expressions;
	fieldPrefixLabels = prefixLabels;
	fieldSuffixLabels = suffixLabels;
	bImageDirty = true;
	updateAll();
}


/**
 * Sets the nameScope property (cbit.vcell.parser.NameScope) value.
 * @param nameScope The new value for the property.
 * @see #getNameScope
 */
public void setNameScope(cbit.vcell.parser.NameScope nameScope) {
	cbit.vcell.parser.NameScope oldValue = fieldNameScope;
	fieldNameScope = nameScope;
	firePropertyChange("nameScope", oldValue, nameScope);
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void updateAll() {
	try {
		if (fieldExpressions!=null){
			if (getJScrollPaneParent()!=null){
				invalidate();
				getJScrollPaneParent().revalidate();
			}
			setSize(getPreferredSize());
			repaint();
		}
	}catch (Exception e){
		handleException(e);
	}			
}


/**
 * 
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private static void getBuilderData() {
/*V1.1
**start of data**
	D0CB838494G88G88GD5FBB0B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135D7FFECD4C59E670F1E512449F1B97470BFE23C33F72986358422E742DD0CA1A766CEECAFC82AE26CF94620292139A8C7626C5BDD5A2AE0292890EB8ED02414325D7E1042DEB5ADEDE3AB3D13C8258B5DC45E6ECE5BA7EF773DFB6FED3B5B16763E5F19B7EFDF6BAED492B679E45EFCE766BB5F797E784CAC59772FD5FE0F340F900F1F583FCE8FA12B5EA3E44748C79F885929231BEA096BF78830177C
	F24A876DG0CD5333EB5728E34FBG17C106EDB134F524F0E43FADAF3065829E09903591675CB352E04BAAE1CE8D483A81430D59795C001F05CE597D48AF0AC8551F8CE9B76AF16994A83157EE365B03E407E759B15C6BAF4CCEDCD3877D81G9E5ECB9E161A206DBAF7E57C4BD8D4318213B12A2A0104ECCD8446D3CAA8541F568DEA1A0A166C15131332C948CE26EFFF38062DA764D1685F5A043251886E518D5FE1008E6076FFF1344B36AFBC33161436A5FC6F6631FFE393373B2AA9EB7FB6759969G7375D3
	E974E970B87888B081A8849483B682BE0231774816A9BCCFCF546A559289AD59236BE75438719FADCED5788E05E04416FDCBE31A91A70447712FA34DB96C3996783A0A1F3C0E7B2428DD4434785B7BC87903F7C855B9FCD2DEB4A3D59C673E58F9BC6B933E774761FCFBB7B4AF4C3905FB0F90775E4DCF17F97DB9769EF82C4C9B347574B5E777361AB156FFE6310E4337474E83AEFF1A49573964BC7FE4A6477E8698EBBEA1F2A33CC758B2643B0B54357EAA279FD67E31D0DAFE025BD0F4A2EB8B4F0B72E92C23
	D210D782EA821BEA8F823A8191009E903971C93AE50939F1CEB62CB3A9C50DD303703565E9A4861A368CF9B0E9DAF2B2C6AF4806A2C7D58AB541677CAD0D36C7972CFB1965EC8C76780AA629A1DBD0C920DDCED00B9AA61F33BD3D976798140D8EAB898A9BA4F4A2747EB38D54C4D459343E536332C533B37838B7033E1C14AF00C6D0G5F5CAF3533687365F07EA240BA478FF39954F7169AC92A06C2C31AF6A5258F63C9C8CD8B462A035576C618DF81603A7CD7D1B68463719621E7CD265E2527CF0921793211
	9135D196C12ECC3708D83F9A96316E5BFDAFE9AE3BBDE72CFF8FF937224566521645B97F9C5309F6717EF8A43C041ACB37642E0725557832A56D613D817DFB1CD819F3982BD2303392E39094BE2E4C9C64B9FBC6B6294852EF8CC8B09A4FFA1C4FFDF19AF915CE522455C7F51A0C4307E96748AB5335597C9D531C5C5A4E64BA64FBAFA41869485F18461C14AD4BD022A90B1E271625A44733631E995C4BCCC575EC29083DEAE610CF34A948F7E77E6E19FAD68749A4E5C6BBCB6C71F7D92ED215A64068DEAD1534
	387C7DD90C77951A31EB65406CAE166BEA8A6B0E5FE12B6537718C0612GD7E06912F4907378ECD85C4108C61061DDBC846D6520484929CFC4CEFEBA7DDB327EFBDD4A4505ABFF7DF3E9FD1067D0E9B01B135C26372E66363D0E550CADB7392DB5076A20DDFC2B729CA81EC7BDD5203F2695B82CD564C06155832EBA33035F2B29AAF72563634C9C6AB6697FD29468898B7A2C6337E5F3750B46AE58BE6463374E218FD59797F0FB379FC39F3277418F72241C8E18D3108721505767E430063F8556B03E407927DA
	45DB20E8944F22E39F302AD5787B495D62AD3062CA912959D26A4D7716D9574A7DDC5E1A75F7499DD3DE6E2BFF905C33218D6E12B661A76F3C1B57FACCD30BA90CD26DB3BEB06F0E87172D1DFF8B5AB145B02DC1A818347047A373E8AFF22EAD363960219F5D395DEDD9EE99EE7BB14F70FB31015DFF93ED7CDE74B872A3CCEE39647C3E3CEFD43C571641D8C51B6061F68963B1508EBC8C18852CG14GCA5B059F7AC9BB394EBDB718046BA7A92B6797943038EF9817C14D597DB7D9ECD94DC14B6F08A7D94CAB
	E1CFDF8764AB13FDF889E50D506F6E907CFCB8C29C5F9DF7FD170CAE05D3EF94FC0FA7EE6A9E5CB7DDD2FE4E6D15F2F36E20141BF33F1176F2B968F03FC0447808F4EDCE7EDE4A4549DEB676D2F8974B670C1632608D560171FA536147B874E7BBF86E2E6E6077BE2F7F7B27109746604182DB1D57E90C5C7DB92E8DDC92EB6B207FA9208F908794GF88E9F3DA8F2F89B4EB9A9F40E9FBEC244FF8EAD91D02209C0EAB2911023D6004695AB947AEFCAD507ECD3896713B85395819D96207024601374E702CF0AFF
	F39759D9161BCF368EDF156EBE494F3761E416CFC8629909F35883ACF7F11D2FF3D3EDD7A74A36DE5A675201FEFC8D90C05B59F87D28FB9CE3F3EC41F85F02F1343747639E1FDCB06EF72D67E7FB7C08B85B4E47D793F5CDC15E7FFD851D765B58EE17D75C6951DF1C7672BAB8F171467E5B7C7BA72F631C361945EAEB67E22EFB1E4937F5AE663A9F1CBCF99D46A22784579D72E10E2D07FEB9208A704EE960FB4040E941F5D5D210DC076B06B5FD888AD4F51594BF5F5ACBB7765F6D8F55A2AEA58F7D0E2C3B25
	CFFABBCFDCA227F9BCE66D367105BBBD587273157871FC45B03681308D608BED2A5D8F880644793A3C4D7CFC7DD099BD16A547A6586DA58EF7C121D3D9B196A8BF5B33970993473F3B3E750BB71FF7EF3B29FBF03FB4797273EE2BAFB76FF67AF2736E973EEB73EA3FAF7FDBF74867FE6B72386E5805F55D87B13C8CA8G2C8494BBB15D62BB4CE31AA31E7D71F15A2B31FF181673967167BF6B237E6B7FAFFD420FEF1C28E6D9DA82758B79D3FE0C172569CC48E51B7D68A3C3991F3078D4DB7E2C9F79D125E3CC
	4CE5D2F5FE3BEA2B2FEFD7FDB5FB0F013E610CEE6B7C309A6FA9EDEC4C244E799B2A6B9C5920F9CEB395FC547D9FD0CB878828F6607C5487GG4893GGD0CB818294G94G88G88GD5FBB0B628F6607C5487GG4893GG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGG8E88GGGG
**end of data**/
}
}