/*
 * Copyright (C) 1999-2011 University of Connecticut Health Center
 *
 * Licensed under the MIT License (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *  http://www.opensource.org/licenses/mit-license.php
 */

package cbit.vcell.math.gui;
import java.awt.*;
import cbit.vcell.parser.Expression;
import java.util.*;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class ExpressionCanvas extends javax.swing.JPanel implements javax.swing.Scrollable {
	private java.awt.Image offScreenImage = null;
	private java.awt.Dimension offScreenImageSize = null;
	private boolean bImageDirty = true;
	private cbit.vcell.parser.Expression[] fieldExpressions = null;
	private String fieldSuffixLabels[] = null;
	private String fieldPrefixLabels[] = null;
	private cbit.vcell.parser.NameScope fieldNameScope = null;
	private java.lang.String[] fieldStrings = null; //created Oct.2nd, 2006 for printing stochastic variables, actions, probabilities.

/**
 * Constructor
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
public ExpressionCanvas() {
	super();
	initialize();
}


	//used by the publish package.
	public static void getExpressionAsImage (Expression expArray [], java.awt.image.BufferedImage image, int scale) {    

		if (expArray == null || image == null) {
			throw new IllegalArgumentException("One or more invalid arguments for refreshGraphics()");
		}
		try {
			int width = image.getWidth();
			int height = image.getHeight();
			java.awt.Graphics2D g = (Graphics2D)image.getGraphics();
			g.setClip(0,0,width,height);
			g.setBackground(Color.white);
		  	g.fillRect(0,0,width,height);	
			g.setFont(new Font("SansSerif", Font.ITALIC, 11));
			//g.scale(scale,scale);
			//java.awt.geom.Rectangle2D sizeHelloBeforeScale = g.getFontMetrics().getStringBounds("hello",g);
			//System.out.println("size of 'hello' before scale is ["+sizeHelloBeforeScale.getWidth()+","+sizeHelloBeforeScale.getHeight()+"]");
			//g.getTransform().scale(scale*10, scale*10);
			//System.out.println("newScaleX = "+g.getTransform().getScaleX());
			//java.awt.geom.Rectangle2D sizeHelloAfterScale = g.getFontMetrics().getStringBounds("hello",g);
			//System.out.println("size of 'hello' after scale is ["+sizeHelloAfterScale.getWidth()+","+sizeHelloAfterScale.getHeight()+"]");
			if (expArray != null){
				g.setColor(Color.black);
				java.awt.Rectangle rect = g.getClipBounds();
				int posY = Math.max(10,(rect.height - height)/2);
				int posX = Math.max(10,(rect.width - width)/2);
				for (int i=0;i<expArray.length;i++){
					int prefixWidth = 0;
					cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(expArray[i]);
					java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
					g.setClip(posX+prefixWidth,posY,expressionDim.width,expressionDim.height);
					expPrintFormatter.paint(g);
					posY += expressionDim.height+20;
				}
			}
		} catch (Exception e) {
			System.out.println("exception in ExpressionCanvas.refreshGraphics()");
			e.printStackTrace(System.out);
		}
	}


	public static Dimension getExpressionImageSize(Expression expArray [], Graphics2D g) throws cbit.vcell.parser.ExpressionException {

		g.setFont(new Font("SansSerif", Font.ITALIC, 25));
		Dimension minSize = new java.awt.Dimension(10,10);
		for (int i=0;i<expArray.length;i++){
			cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(expArray[i]);
			java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
			int labelWidth = 0;
			minSize.width = Math.max(minSize.width, expressionDim.width + 20 + labelWidth);
			minSize.height += expressionDim.height+20;
		}

		return minSize;
	}


/**
 * Gets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @return The expressions property value.
 * @see #setExpressions
 */
public cbit.vcell.parser.Expression[] getExpressions() {
	return fieldExpressions;
}


/**
 * Gets the expressions index property (cbit.vcell.parser.Expression) value.
 * @return The expressions property value.
 * @param index The index value into the property array.
 * @see #setExpressions
 */
public cbit.vcell.parser.Expression getExpressions(int index) {
	return getExpressions()[index];
}


/**
 * Insert the method's description here.
 * Creation date: (3/28/01 5:38:58 PM)
 * @return javax.swing.JScrollPane
 */
private javax.swing.JScrollPane getJScrollPaneParent() {
	if (getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent();
	}else if (getParent() instanceof javax.swing.JViewport && getParent().getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent().getParent();
	}else{
		return null;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (11/19/2002 11:26:26 AM)
 * @return java.awt.Dimension
 */
public Dimension getMinimumSize() {
	Graphics2D g = (Graphics2D)getGraphics();
	if (g != null){
		g.setClip(0,0,getSize().width,getSize().height);
		g.setFont(new Font("SansSerif", Font.ITALIC, 11));
		try {
			Dimension minSize = new java.awt.Dimension(10,10);
			if (fieldExpressions != null)
			{
				for (int i=0;i<fieldExpressions.length;i++){
					cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(fieldExpressions[i]);
					java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
					int labelWidth = 0;
					if (fieldPrefixLabels!=null){
						labelWidth += g.getFontMetrics().stringWidth(fieldPrefixLabels[i]) + 20;
					}
					if (fieldSuffixLabels!=null){
						labelWidth += g.getFontMetrics().stringWidth(fieldSuffixLabels[i]) + 20;
					}
					minSize.width = Math.max(minSize.width, expressionDim.width + 20 + labelWidth);
					minSize.height += expressionDim.height+20;
				}
			}else{
				minSize.width = 200;
				minSize.height = 200;
			}
		
			return minSize;
		}catch (cbit.vcell.parser.ExpressionException e){
			e.printStackTrace(System.out);
			return super.getMinimumSize();
		}
	}else{
		return super.getMinimumSize();
	}
}


/**
 * Gets the nameScope property (cbit.vcell.parser.NameScope) value.
 * @return The nameScope property value.
 * @see #setNameScope
 */
public cbit.vcell.parser.NameScope getNameScope() {
	return fieldNameScope;
}


	/**
	 * Returns the preferred size of the viewport for a view component.
	 * For example the preferredSize of a JList component is the size
	 * required to acommodate all of the cells in its list however the
	 * value of preferredScrollableViewportSize is the size required for
	 * JList.getVisibleRowCount() rows.   A component without any properties
	 * that would effect the viewport size should just return 
	 * getPreferredSize() here.
	 * 
	 * @return The preferredSize of a JViewport whose view is this Scrollable.
	 * @see JViewport#getPreferredSize
	 */
public java.awt.Dimension getPreferredScrollableViewportSize() {
	return getPreferredSize();
}


/**
 * Insert the method's description here.
 * Creation date: (9/6/2002 12:17:16 PM)
 * @return java.awt.Dimension
 */
public Dimension getPreferredSize() {
	if ((fieldExpressions!=null) || (fieldStrings!=null)){
		Dimension prefSize = getMinimumSize();
		if (getJScrollPaneParent()!=null){
			java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
			prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
		}
		return prefSize;
	}else{
		return super.getPreferredSize();
	}
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one block
	 * of rows or columns, depending on the value of orientation. 
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a block scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "block" increment for scrolling in the specified direction.
	 * @see JScrollBar#setBlockIncrement
	 */
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	if (javax.swing.SwingConstants.VERTICAL == orientation){
		return visibleRect.height/4;
	}else{
		return visibleRect.width/4;
	}
}


	/**
	 * Return true if a viewport should always force the height of this 
	 * Scrollable to match the height of the viewport.  For example a 
	 * columnar text view that flowed text in left to right columns 
	 * could effectively disable vertical scrolling by returning
	 * true here.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables height to match its own.
	 */
public boolean getScrollableTracksViewportHeight() {
	return false;
}


	/**
	 * Return true if a viewport should always force the width of this 
	 * Scrollable to match the width of the viewport.  For example a noraml 
	 * text view that supported line wrapping would return true here, since it
	 * would be undesirable for wrapped lines to disappear beyond the right
	 * edge of the viewport.  Note that returning true for a Scrollable
	 * whose ancestor is a JScrollPane effectively disables horizontal
	 * scrolling.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables width to match its own.
	 */
public boolean getScrollableTracksViewportWidth() {
	return false;
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one new row
	 * or column, depending on the value of orientation.  Ideally, 
	 * components should handle a partially exposed row or column by 
	 * returning the distance required to completely expose the item.
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a unit scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "unit" increment for scrolling in the specified direction
	 * @see JScrollBar#setUnitIncrement
	 */
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	return 1;
}


/**
 * Insert the method's description here.
 * Creation date: (10/2/2006 11:51:09 AM)
 * @return java.lang.String[]
 */
public java.lang.String[] getStrings() {
	return fieldStrings;
}


/**
 * Called whenever the part throws an exception.
 * @param exception java.lang.Throwable
 */
private void handleException(java.lang.Throwable exception) {

	/* Uncomment the following lines to print uncaught exceptions to stdout */
	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
	// exception.printStackTrace(System.out);
}


/**
 * Initialize the class.
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private void initialize() {
	try {
		// user code begin {1}
		// user code end
		setName("ExpressionCanvas");
		setLayout(null);
		setSize(160, 120);
	} catch (java.lang.Throwable ivjExc) {
		handleException(ivjExc);
	}
	// user code begin {2}
	// user code end
}


/**
 * main entrypoint - starts the part when it is run as an application
 * @param args java.lang.String[]
 */
public static void main(java.lang.String[] args) {
	try {
		javax.swing.JFrame frame = new javax.swing.JFrame();
		ExpressionCanvas aExpressionCanvas;
		aExpressionCanvas = new ExpressionCanvas();
		frame.setContentPane(aExpressionCanvas);
		frame.setSize(aExpressionCanvas.getSize());
		frame.addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent e) {
				System.exit(0);
			};
		});
		frame.show();
		java.awt.Insets insets = frame.getInsets();
		frame.setSize(frame.getWidth() + insets.left + insets.right, frame.getHeight() + insets.top + insets.bottom);
		frame.setVisible(true);
	} catch (Throwable exception) {
		System.err.println("Exception occurred in main() of javax.swing.JPanel");
		exception.printStackTrace(System.out);
	}
}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void paintComponent(java.awt.Graphics g) {
	super.paintComponent(g);
	if (bImageDirty){
		refreshGraphics();
	}
	if (offScreenImage != null){
		g.drawImage(offScreenImage,-1,-1,this);
	}	
	return;
}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
private void refreshGraphics () {

	try {
		offScreenImageSize = new java.awt.Dimension(getSize().width,getSize().height);
		offScreenImage = createImage(offScreenImageSize.width,offScreenImageSize.height);
		if (offScreenImage==null){
			return;
		}	

		java.awt.Graphics2D g = (Graphics2D)offScreenImage.getGraphics();
//		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
		g.setClip(0,0,getSize().width,getSize().height);
		g.setFont(new Font("SansSerif", Font.ITALIC, 11));
		g.setColor(getBackground());
	  	g.fillRect(0,0,getSize().width,getSize().height);
  	
		if (fieldExpressions!=null){
			g.setColor(getForeground());
			java.awt.Rectangle rect = g.getClipBounds();
			int posY = Math.max(10,(rect.height - getSize().height)/2);
			int posX = Math.max(10,(rect.width - getSize().width)/2);
			for (int i=0;i<fieldExpressions.length;i++){
				int prefixWidth = 0;
				cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(fieldExpressions[i]);
				java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
				if (fieldPrefixLabels!=null && fieldPrefixLabels[i]!=null){
					prefixWidth = g.getFontMetrics().stringWidth(fieldPrefixLabels[i]) + 10;
					g.setClip(posX,posY,getSize().width,getSize().height);
					g.setColor(Color.blue);
					g.drawString(fieldPrefixLabels[i],posX,posY+expressionDim.height/2+g.getFontMetrics().getDescent());
				}
				g.setColor(getForeground());
				g.setClip(posX+prefixWidth,posY,expressionDim.width,expressionDim.height);
				expPrintFormatter.paint(g);
				if (fieldSuffixLabels!=null && fieldSuffixLabels[i]!=null){
					g.setColor(Color.blue);
					g.setClip(posX,posY,getSize().width,getSize().height);
					g.drawString(fieldSuffixLabels[i],posX+expressionDim.width+prefixWidth+20,posY+expressionDim.height/2+g.getFontMetrics().getDescent());
				}
				posY += expressionDim.height+20;
			}
		}
		if (fieldStrings != null){ //added Oct 3rd, 2006 to display the stochastic stuff in expression canvas
			g.setColor(getForeground());
			java.awt.Rectangle rect = g.getClipBounds();
			int posY = Math.max(10,(rect.height - getSize().height)/2);
			int posX = Math.max(10,(rect.width - getSize().width)/2);
			for (int i=0;i<fieldStrings.length;i++){
				g.setClip(posX,posY,getSize().width,getSize().height);
				g.setColor(getForeground());
				g.drawString(fieldStrings[i],posX,posY+10);
				posY += 40;
			}
		}	
	}catch (Exception e){
		offScreenImage = null;
		System.out.println("exception in ExpressionCanvas.refreshGraphics()");
		e.printStackTrace(System.out);
	}

	bImageDirty = false;
	return;
}


/**
 * Insert the method's description here.
 * Creation date: (11/19/2002 12:25:45 PM)
 * @param x int
 * @param y int
 * @param w int
 * @param h int
 */
public void reshape(int x, int y, int w, int h) {
	if (w!=getSize().width || h!=getHeight()){
		bImageDirty = true;
	}
	super.reshape(x,y,w,h);
}


/**
 * This method was created by a SmartGuide.
 * @param expression cbit.vcell.parser.Expression
 */
public void setExpression(Expression expression) {
	Expression expList[] = null;
	if (expression != null){
		expList = new Expression[1];
		expList[0] = expression;
	}		
	setExpressions(expList,null,null);
}


/**
 * Sets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @param expressions The new value for the property.
 * @see #getExpressions
 */
public void setExpressions(cbit.vcell.parser.Expression[] expressions) {
	setExpressions(expressions,null,null);
}


/**
 * Sets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @param expressions The new value for the property.
 * @see #getExpressions
 */
public void setExpressions(cbit.vcell.parser.Expression[] expressions, String prefixLabels[], String suffixLabels[]) {
	fieldExpressions = expressions;
	fieldPrefixLabels = prefixLabels;
	fieldSuffixLabels = suffixLabels;
	bImageDirty = true;
	updateAll();
}


/**
 * Sets the nameScope property (cbit.vcell.parser.NameScope) value.
 * @param nameScope The new value for the property.
 * @see #getNameScope
 */
public void setNameScope(cbit.vcell.parser.NameScope nameScope) {
	cbit.vcell.parser.NameScope oldValue = fieldNameScope;
	fieldNameScope = nameScope;
	firePropertyChange("nameScope", oldValue, nameScope);
}


/**
 * Set stochastic expressions as strings and prepare to display them on canvas.
 * Creation date: (10/2/2006 11:51:09 AM)
 * @param newFieldStrings java.lang.String[]
 */
public void setStrings(java.lang.String[] newStrings) {
	fieldStrings = newStrings;
	fieldPrefixLabels = null;
	fieldSuffixLabels = null;
	bImageDirty = true;
	updateAll();
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void updateAll() {
	try {
		if ((fieldExpressions!=null) || (fieldStrings != null)){
			if (getJScrollPaneParent()!=null){
				invalidate();
				getJScrollPaneParent().revalidate();
			}
			setSize(getPreferredSize());
			repaint();
		}
	}catch (Exception e){
		handleException(e);
	}			
}


/**
 * 
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private static void getBuilderData() {
/*V1.1
**start of data**
	D0CB838494G88G88G41DAB1B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135D8FDEC94C594478495CD950DC5A022C1C503DACD0D900D922386A391CDEA50A8CD0DA47287094460E70CDF195B3B03D6DAAC5898CD2F9FE895B464440811DC2A213428052AA7AD25344532F7B7EDD776EE575D3D2FC20B6F4D6C6CED6B9DD4921A7CB23B6F6D3CF973BEFEB3D7D25734506F116A887178097D77030710059F91123E327FB7A1FB6B4F72AA627A5B8E58CAF624FCB0D69EAE2F5A445E67
	57D7433885508CB29CD598EB495D751F58728EDBAE60118859550D5FBCD19F30E525704D8AG81F9DDF76EFB6E4045213D767B60550B496B0F9BD28D5AF15994306C39736C31193C6D595703EB3D417C44B9E5202B8499EE5ECB9E103E0631B5FCF26427E8C4310229A8D555E0DC36C603A3C9A594BA10518DEA1A0A16E81793A959A4E4993377E320124DA7E4A63C7FFA84E5B31AF18D824F1FGF683387FBF6EE8357D6BBBF5AFB93D747B4D9F96703F688877FB49111C7F4B2E2B10BEE5319EC9E3CCB7002E2E
	373CEAA7208B20820AG75207B08A4D2381F3608552E4563DA22CD57772BB163B7ADC6D5F88E05C0E34B8E5328E6448861F9FC27FED79EFF4E86BE2FAA70FF677118AC7ECE64346470DD24621EEB25CDF9E2D231781434281747E2D9EFAEA6FC6D7D85572E681DDCF31357BECA5CEB6FB97D34571FE76D307234F703ED47F7B437761E23186B57D92EDB6059E35781173F4F6499171C575FA5CC0E6F33C0377E28280D3EAD4217AE5FCD24765B39F963B06F11A2A95C47FD986D4B79426BC24FE29F95033C943082
	3086C00E15D785G3B0F095A38B7754DB4EBA3AC9B567E24224628C178DCBD7DB10CB4E399F2E7423464C414764A06A2C7D48ABD413F492651774824F9932CE6233046AFB4C18D5902CE826BF21CDA54B079B717263762B786E55A9EA5CEE10138CE045D59E920A6224A26F5C40F49964DFD4175F353984B145C8B9641GBC7338DCBF06B18F437EC78199A78E5BB2E86F90B592D48D053AB46DE4D26F411D109547B0D747D8EF974173A2G37B57F944A2A7B4B2BDA7A051D4E4CB6171D8EA50A6E4BC6D674465B
	4D4815FB7BC52EDF6E93396E2839136CFAE6CE5EDCAF073A6B69373934FFEA4D7B3623CD740B3F97B577CD23677676676F07697578AD53DA43FB9E7637B8395AB40E39AA86BFCB81E5CE0CE7E61AF94D6E17CDAA2A748F838A0C46F291675F0EE511D7E90AA62C8E2A53C48C9ECC3BC6AE4AD6656AF7D8F3EA6BD2A657215E5B2140CCC7FEC596EBD236ACC309A4AD5ACDADCBC90C6474F358DAE6B22267DAC52C35A00BFC2225215E1D6FEF4CEEE3FD10C8D06634B345565F4CEA152AB48ECE37EB49044565370D
	E13ECF522C5DABF70EEDE4352EA6316F7899D6AAEF46BD98CA9CC2012DCB768EE09D6B81F186A356C1CC71AC2E86DD73002849746722A6DB46EEA38F8D69D2BEAE1CF74BECE946G2F216201DCCDF21FEEB8155F77C52CE7EC3949FD2D5CDE8B6354D31557403E893433846C2FG2C9990B550FC7AD3D71F5949EF57D415075209F14DB85AB669BFC98A74048DFD4809DB5D7836A93ADEBB06DC9F9847982AAEAE607E3E769546105D8F7E16D3F2A6E826218EC22103E1993C61F701F24697787DDB8362AE70E493
	6EE577A03C83CE8C0AF8BFD5A36E8245A797135A71D55EC2F7194CA00F730241DC3C570613DE9E2B4B4F601A9520DBBFA862B4F75C4DEBED2629C595C629769EFF1EF067034B8ECDFCG6330E218D6A7B4CCC644634F897497B957965BDC7042FF4EDCF2BC47ADF5477F4BB37CDCECE3675F4E637CDC74B87203CC3E47A56767652AA6F1DF5B873AC547858FBFC6B09F15FF818F83DA81BDG8BD07C1708436A096F48B94E394E849CBF89D96D1E5440623CB96365BDE73FDFF346AFFA8EC6FEC63C49F2DE8AEBAE
	87F0D9EBA34A5641BB99927C7C8B52179D3B306BF9F553F4B875FC4157F875022E41E3D3C68AF36E33A4BF67BECF72F36E0BE4AB17038D778DC468DFA2E7676457C8BECE76B2DDCD43C6D64FD9ADE9419DEC88735552A07831855EDB07F86D6AC37C5C677DFFF79AF9E198AEAC30D437CE23A4F68267F6B70A39E5707DDA008F64AD008EG2F612E86D143A5A0DBFBC2589C796C8BA2FEF3E871209209871329F8D00ED8C19AD32CD06877242AF6592E924EA717B1DB81393CEA8F20CB96FC1279D270C9492DB791
	DFB6BF1F2C699917E2B25F5FACB947A7E5705B02F358332CF6F15EF2503FAB234C5FD4673201F1FC859084F07D8F1374181B2FA66915C9FA74374D6356DFB7C96FF74D67FBDB7905585B3BABCB093AF4E6415FFD9D917BEEEC0FD72D1D6F294EE63C3C8F8EB71C5FEF1B937FFB9E673477D82E96C626F25D46C61417C426F25DEC27CE6E83DDA0AA38EE2904B5B6835E97G16G1EG2C87D44684574D726CA667603A9ECD6F0286D5DDAD4577D751F8FE3F5D9E5EA47232647E5B49FD17F4C81B8B64A5906379E8
	35471DAF4E77604877772B8F772702EE962084309C709CE003333FB24FAE3E3F835099ED16A5C7C75969A5B6572B50F4CE0C8D4A7766EDA4CE9E2BDD4FF39AAEBC6F5EF5C15760F1F9D0AA4C3B0FCA79F9F725141FF71F124E4E2B2B2542F75DB5127B2E4B73FA259F7B5AC7611E8968G7481D46A7C0F427B994FE91EFC9E080D50F60D7D42341C3B082F70DE7BFC677EDDAA7B700E9351ACCB0B23FDA19F71E13EACCDE7C2AED3FD98A3C39999357827365C70A1BF2AF41809396CDAFFE13F2E771F5B2FDB7D6C
	BE8676FA323AED738EBF1ED35A7030C91D7D177AEB9DD9279956CC85AFF57F82D0CB8788845C39FC4687GG4893GGD0CB818294G94G88G88G41DAB1B6845C39FC4687GG4893GG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGGG88GGGG
**end of data**/
}
}
