/*
 * Copyright (C) 1999-2011 University of Connecticut Health Center
 *
 * Licensed under the MIT License (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *  http://www.opensource.org/licenses/mit-license.php
 */

package cbit.vcell.math;
import java.util.Enumeration;

import org.vcell.util.CommentStringTokenizer;
import org.vcell.util.Compare;
import org.vcell.util.Matchable;
import org.vcell.util.Token;

import cbit.vcell.parser.Expression;
import cbit.vcell.parser.ExpressionException;
/**
 * This class was generated by a SmartGuide.
 * 
 */
@SuppressWarnings("serial")
public class CompartmentSubDomain extends SubDomain {
	public final static int NON_SPATIAL_PRIORITY = -1;
	
	private BoundaryConditionType boundaryConditionTypeXp = BoundaryConditionType.getDIRICHLET();
	private BoundaryConditionType boundaryConditionTypeXm = BoundaryConditionType.getDIRICHLET();
	private BoundaryConditionType boundaryConditionTypeYp = BoundaryConditionType.getDIRICHLET();
	private BoundaryConditionType boundaryConditionTypeYm = BoundaryConditionType.getDIRICHLET();
	private BoundaryConditionType boundaryConditionTypeZp = BoundaryConditionType.getDIRICHLET();
	private BoundaryConditionType boundaryConditionTypeZm = BoundaryConditionType.getDIRICHLET();

/**
 * This method was created by a SmartGuide.
 * @param name java.lang.String
 * @param unused -- ignored 
 */
public CompartmentSubDomain (String name, int unused) {
	super(name);
}


CompartmentSubDomain (Token token, MathDescription mathdesc, CommentStringTokenizer tokens) throws cbit.vcell.parser.ExpressionException, MathException {
	super(token,tokens);
	parseBlock(mathdesc, tokens);
}


@Override
protected String startToken() {
	return VCML.CompartmentSubDomain;
}

/**
 * This method was created in VisualAge.
 * @return boolean
 * @param object java.lang.Object
 */
public boolean compareEqual(Matchable object) {
	if (!super.compareEqual0(object)){
		return false;
	}
	CompartmentSubDomain csd = null;
	if (!(object instanceof CompartmentSubDomain)){
		return false;
	}else{
		csd = (CompartmentSubDomain)object;
	}
	//
	// compare boundaryConditions
	//
	if (!Compare.isEqual(boundaryConditionTypeXp,csd.boundaryConditionTypeXp)){
		return false;
	}
	if (!Compare.isEqual(boundaryConditionTypeXm,csd.boundaryConditionTypeXm)){
		return false;
	}
	if (!Compare.isEqual(boundaryConditionTypeYp,csd.boundaryConditionTypeYp)){
		return false;
	}
	if (!Compare.isEqual(boundaryConditionTypeYm,csd.boundaryConditionTypeYm)){
		return false;
	}
	if (!Compare.isEqual(boundaryConditionTypeZp,csd.boundaryConditionTypeZp)){
		return false;
	}
	if (!Compare.isEqual(boundaryConditionTypeZm,csd.boundaryConditionTypeZm)){
		return false;
	}

	return true;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public BoundaryConditionType getBoundaryConditionXm() {
	return boundaryConditionTypeXm;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public BoundaryConditionType getBoundaryConditionXp() {
	return boundaryConditionTypeXp;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public BoundaryConditionType getBoundaryConditionYm() {
	return boundaryConditionTypeYm;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public BoundaryConditionType getBoundaryConditionYp() {
	return boundaryConditionTypeYp;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public BoundaryConditionType getBoundaryConditionZm() {
	return boundaryConditionTypeZm;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public BoundaryConditionType getBoundaryConditionZp() {
	return boundaryConditionTypeZp;
}

/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String getVCML(int spatialDimension) {
	StringBuffer buffer = new StringBuffer();
	buffer.append(VCML.CompartmentSubDomain+" "+getName()+" {\n");
	if (spatialDimension>=1){
		buffer.append("\t"+VCML.BoundaryXm+"\t "+boundaryConditionTypeXm.boundaryTypeStringValue()+"\n");
		buffer.append("\t"+VCML.BoundaryXp+"\t "+boundaryConditionTypeXp.boundaryTypeStringValue()+"\n");
	}
	if (spatialDimension>=2){
		buffer.append("\t"+VCML.BoundaryYm+"\t "+boundaryConditionTypeYm.boundaryTypeStringValue()+"\n");
		buffer.append("\t"+VCML.BoundaryYp+"\t "+boundaryConditionTypeYp.boundaryTypeStringValue()+"\n");
	}
	if (spatialDimension==3){
		buffer.append("\t"+VCML.BoundaryZm+"\t "+boundaryConditionTypeZm.boundaryTypeStringValue()+"\n");
		buffer.append("\t"+VCML.BoundaryZp+"\t "+boundaryConditionTypeZp.boundaryTypeStringValue()+"\n");
	}
	
	// BoundaryconditionSpecs
	if (getBoundaryconditionSpecs().size() > 0) {
		for (BoundaryConditionSpec bcs : getBoundaryconditionSpecs()) {
			buffer.append(bcs.getVCML());
		}
		buffer.append("\n");
	}
	
	Enumeration<Equation> enum1 = getEquations();
	while (enum1.hasMoreElements()){
		Equation equ = enum1.nextElement();
		buffer.append(equ.getVCML());
	}	
	if (getFastSystem()!=null){
		buffer.append(getFastSystem().getVCML());
	}
	//Var initial conditions
	if(getVarIniConditions().size()>0)
	{
		for(VarIniCondition vic : getVarIniConditions()){
			buffer.append(vic.getVCML());
		}
		buffer.append("\n");
	}
	//particle initial conditions
	for (ParticleProperties pp : getParticleProperties()){
		buffer.append(pp.getVCML(spatialDimension));
		buffer.append("\n");
	}
	//Jump processes
	for (ParticleJumpProcess particleJumpProcess : getParticleJumpProcesses()){
		buffer.append(particleJumpProcess.getVCML());
		buffer.append("\n");
	}
	//Jump processes
	if(getJumpProcesses().size()>0)
	{
		for(JumpProcess jp : getJumpProcesses()){
			buffer.append(jp.getVCML());
		}
	}	
	buffer.append("}\n");
	return buffer.toString();		
}


@Override
protected void parse(MathDescription mathDesc, String token, CommentStringTokenizer tokens) throws MathException, ExpressionException {
	if (token.equalsIgnoreCase(VCML.Handle)){
		//
		// throw away "handle information" deprecated
		//
		token = tokens.nextToken();
		//handle = Integer.valueOf(token).intValue();
		return;
	}
	if (token.equalsIgnoreCase(VCML.BoundaryXm)){
		String type = tokens.nextToken();
		boundaryConditionTypeXm = new BoundaryConditionType(type);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.BoundaryXp)){
		String type = tokens.nextToken();
		boundaryConditionTypeXp = new BoundaryConditionType(type);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.BoundaryYm)){
		String type = tokens.nextToken();
		boundaryConditionTypeYm = new BoundaryConditionType(type);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.BoundaryYp)){
		String type = tokens.nextToken();
		boundaryConditionTypeYp = new BoundaryConditionType(type);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.BoundaryZm)){
		String type = tokens.nextToken();
		boundaryConditionTypeZm = new BoundaryConditionType(type);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.BoundaryZp)){
		String type = tokens.nextToken();
		boundaryConditionTypeZp = new BoundaryConditionType(type);
		return;
	}
	if (token.equalsIgnoreCase(VCML.BoundaryConditionSpec)) {
		String name = tokens.nextToken();
		String type = tokens.nextToken();
		BoundaryConditionSpec  bcs = new BoundaryConditionSpec(name, new BoundaryConditionType(type));
		addBoundaryConditionSpec(bcs);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.PdeEquation)){
		token = tokens.nextToken();
		boolean bSteady = false;
		if (token.equals(VCML.Steady)) {
			bSteady = true;
			token = tokens.nextToken();
		}
		Variable var = mathDesc.getVariable(token);
		if (var == null){
			throw new MathFormatException("variable "+token+" not defined");
		}	
		if (!(var instanceof VolVariable)){
			throw new MathFormatException("variable "+token+" not a VolumeVariable");
		}	
		PdeEquation pde = new PdeEquation((VolVariable)var, bSteady);
		pde.read(tokens);
		addEquation(pde);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.OdeEquation)){
		token = tokens.nextToken();
		Variable var = mathDesc.getVariable(token);
		if (var == null){
			throw new MathFormatException("variable "+token+" not defined");
		}	
		if (!(var instanceof VolVariable)){
			throw new MathFormatException("variable "+token+" not a VolumeVariable");
		}	
		OdeEquation ode = new OdeEquation((VolVariable)var,null,null);
		ode.read(tokens);
		addEquation(ode);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.VolumeRegionEquation)){
		token = tokens.nextToken();
		Variable var = mathDesc.getVariable(token);
		if (var == null){
			throw new MathFormatException("variable "+token+" not defined");
		}	
		if (!(var instanceof VolumeRegionVariable)){
			throw new MathFormatException("variable "+token+" not a VolumeRegionVariable");
		}	
		VolumeRegionEquation vre = new VolumeRegionEquation((VolumeRegionVariable)var,null);
		vre.read(tokens);
		addEquation(vre);
		return;
	}			
	/**
	 * ParticleJumpProcess name A B {
	 *    MacroscopicRateConstant dkdkdk;
	 *    Action destroy A
	 *    Action destroy B
	 *    Action create C
	 * }
	 */
	if (token.equalsIgnoreCase(VCML.ParticleJumpProcess)){
		ParticleJumpProcess particleJumpProcess = ParticleJumpProcess.fromVCML(mathDesc, tokens);
		addParticleJumpProcess(particleJumpProcess);
		return;
	}			
	if (token.equalsIgnoreCase(VCML.ParticleProperties)){
		ParticleProperties pp = new ParticleProperties(mathDesc, tokens);
		if(pp.getVariable().getDomain().getName().equals(this.getName())){
			addParticleProperties(pp);
		}else{
			throw new MathException("Variable (" + pp.getVariable().getName() + ") is defined in domain " + pp.getVariable().getDomain().getName() +
					                 ". \nHowever the variable particle properties of " + pp.getVariable().getName() + " is defined in domain " + this.getName() + ". \nPlease check your model.");
		}
		return;
	}			
	if (token.equalsIgnoreCase(VCML.FastSystem)){
		FastSystem fs = new FastSystem(mathDesc);
		fs.read(tokens);
		setFastSystem(fs);
		return;
	}	
	//Variable initial conditions as count		
	if (token.equalsIgnoreCase(VCML.VarIniCount_Old) || token.equalsIgnoreCase(VCML.VarIniCount))
	{
		token = tokens.nextToken();
		Variable var = mathDesc.getVariable(token);
		if (var == null){
			throw new MathFormatException("variable "+token+" not defined");
		}	
		if (!(var instanceof StochVolVariable)){
			throw new MathFormatException("variable "+token+" not a Stochastic Volume Variable");
		}
		
		Expression varIniExp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
		try{
			varIniExp.bindExpression(mathDesc);
		}catch(Exception ex){
			ex.printStackTrace(System.out);
			throw new MathException(ex.getMessage());
		}
		VarIniCount vic= new VarIniCount(var,varIniExp);
		addVarIniCondition(vic);
		
		return;
	}
	//Variable inital conditions as concentration
	if (token.equalsIgnoreCase(VCML.VarIniPoissonExpectedCount))
	{
		token = tokens.nextToken();
		Variable var = mathDesc.getVariable(token);
		if (var == null){
			throw new MathFormatException("variable "+token+" not defined");
		}	
		if (!(var instanceof StochVolVariable)){
			throw new MathFormatException("variable "+token+" not a Stochastic Volume Variable");
		}
		
		Expression varIniExp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
		try{
			varIniExp.bindExpression(mathDesc);
		}catch(Exception ex){
			ex.printStackTrace(System.out);
			throw new MathException(ex.getMessage());
		}
		VarIniPoissonExpectedCount vic= new VarIniPoissonExpectedCount(var,varIniExp);
		addVarIniCondition(vic);
		
		return;
	}
	//Jump processes 
	if (token.equalsIgnoreCase(VCML.JumpProcess))
	{
		JumpProcess jump = null;
		token = tokens.nextToken();
		String name=token;
		token = tokens.nextToken();
		if(!token.equalsIgnoreCase(VCML.BeginBlock))
			throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
		token = tokens.nextToken();	
		if(token.equalsIgnoreCase(VCML.ProbabilityRate))
		{
			Expression probExp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
			//check if probability functions contain "t", which is not allowed.
			Expression extProb = MathUtilities.substituteFunctions(probExp,mathDesc).flatten();
			String[] symbols = extProb.getSymbols();
			if(symbols != null)
			{
				for(int i=0; i<symbols.length; i++)
				{
					if(symbols[i].equals("t"))
					{
						throw new MathFormatException("Unexpected symbol \'t\'  in probability rate of jump process "+name+". Probability rate should not be a function of t.");
					}	
				}
			}
			probExp.bindExpression(mathDesc);
			jump = new JumpProcess(name,probExp);
			addJumpProcess(jump);
		}
		else {
			throw new MathFormatException("unexpected identifier "+token);
		}

		if(jump != null)
		{
			while (tokens.hasMoreTokens())
			{
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				if (token.equalsIgnoreCase(VCML.Action))
				{
					token = tokens.nextToken();
					Variable var = mathDesc.getVariable(token);
					if (var == null){
						throw new MathFormatException("variable "+token+" not defined");
					}	
					if (!(var instanceof StochVolVariable)){
						throw new MathFormatException("variable "+token+" not a Stochastic Volume Variable");
					}
					String opera = tokens.nextToken();
					if (!opera.equals(Action.ACTION_INC)){
						throw new MathFormatException("expected 'INC' for action, found "+opera);
					}
					Expression exp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
					try{
						exp.bindExpression(mathDesc);
					}
					catch(Exception ex){
						ex.printStackTrace(System.out);
						throw new MathException(ex.getMessage());
					}
					Action action = Action.createIncrementAction(var,exp);
					jump.addAction(action);
				}
				else throw new MathFormatException("unexpected identifier "+token);
			}
		}
		
		return;
	}	
	throw new MathFormatException("unexpected identifier "+token);
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
/*
private void read(MathDescription mathDesc, CommentStringTokenizer tokens) throws MathException, cbit.vcell.parser.ExpressionException {
	String token = null;
	token = tokens.nextToken();
	if (!token.equalsIgnoreCase(VCML.BeginBlock)){
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
	}			
	while (tokens.hasMoreTokens()){
		token = tokens.nextToken();
		if (token.equalsIgnoreCase(VCML.EndBlock)){
			break;
		}			
		if (token.equalsIgnoreCase(VCML.Handle)){
			//
			// throw away "handle information" deprecated
			//
			token = tokens.nextToken();
			//handle = Integer.valueOf(token).intValue();
			continue;
		}
		if (token.equalsIgnoreCase(VCML.Priority)){
			token = tokens.nextToken();
			priority = Integer.valueOf(token).intValue();
			continue;
		}
		if (token.equalsIgnoreCase(VCML.BoundaryXm)){
			String type = tokens.nextToken();
			boundaryConditionTypeXm = new BoundaryConditionType(type);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.BoundaryXp)){
			String type = tokens.nextToken();
			boundaryConditionTypeXp = new BoundaryConditionType(type);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.BoundaryYm)){
			String type = tokens.nextToken();
			boundaryConditionTypeYm = new BoundaryConditionType(type);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.BoundaryYp)){
			String type = tokens.nextToken();
			boundaryConditionTypeYp = new BoundaryConditionType(type);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.BoundaryZm)){
			String type = tokens.nextToken();
			boundaryConditionTypeZm = new BoundaryConditionType(type);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.BoundaryZp)){
			String type = tokens.nextToken();
			boundaryConditionTypeZp = new BoundaryConditionType(type);
			continue;
		}
		if (token.equalsIgnoreCase(VCML.BoundaryConditionSpec)) {
			String name = tokens.nextToken();
			String type = tokens.nextToken();
			BoundaryConditionSpec  bcs = new BoundaryConditionSpec(name, new BoundaryConditionType(type));
			addBoundaryConditionSpec(bcs);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.PdeEquation)){
			token = tokens.nextToken();
			boolean bSteady = false;
			if (token.equals(VCML.Steady)) {
				bSteady = true;
				token = tokens.nextToken();
			}
			Variable var = mathDesc.getVariable(token);
			if (var == null){
				throw new MathFormatException("variable "+token+" not defined");
			}	
			if (!(var instanceof VolVariable)){
				throw new MathFormatException("variable "+token+" not a VolumeVariable");
			}	
			PdeEquation pde = new PdeEquation((VolVariable)var, bSteady);
			pde.read(tokens);
			addEquation(pde);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.OdeEquation)){
			token = tokens.nextToken();
			Variable var = mathDesc.getVariable(token);
			if (var == null){
				throw new MathFormatException("variable "+token+" not defined");
			}	
			if (!(var instanceof VolVariable)){
				throw new MathFormatException("variable "+token+" not a VolumeVariable");
			}	
			OdeEquation ode = new OdeEquation((VolVariable)var,null,null);
			ode.read(tokens);
			addEquation(ode);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.VolumeRegionEquation)){
			token = tokens.nextToken();
			Variable var = mathDesc.getVariable(token);
			if (var == null){
				throw new MathFormatException("variable "+token+" not defined");
			}	
			if (!(var instanceof VolumeRegionVariable)){
				throw new MathFormatException("variable "+token+" not a VolumeRegionVariable");
			}	
			VolumeRegionEquation vre = new VolumeRegionEquation((VolumeRegionVariable)var,null);
			vre.read(tokens);
			addEquation(vre);
			continue;
		}			
		/**
		 * ParticleJumpProcess name A B {
		 *    MacroscopicRateConstant dkdkdk;
		 *    Action destroy A
		 *    Action destroy B
		 *    Action create C
		 * }
		 */
/*
		if (token.equalsIgnoreCase(VCML.ParticleJumpProcess)){
			ParticleJumpProcess particleJumpProcess = ParticleJumpProcess.fromVCML(mathDesc, tokens);
			addParticleJumpProcess(particleJumpProcess);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.ParticleProperties)){
			ParticleProperties pp = new ParticleProperties(mathDesc, tokens);
			if((pp.getVariable() == null) || (pp.getVariable().getDomain() == null)) {
				throw new RuntimeException("either variable not found or no domain");
//				continue;
			}
			if(pp.getVariable().getDomain().getName().equals(this.getName())){
				addParticleProperties(pp);
			}else{
				throw new MathException("Variable (" + pp.getVariable().getName() + ") is defined in domain " + pp.getVariable().getDomain().getName() +
						                 ". \nHowever the variable particle properties of " + pp.getVariable().getName() + " is defined in domain " + this.getName() + ". \nPlease check your model.");
			}
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.FastSystem)){
			FastSystem fs = new FastSystem(mathDesc);
			fs.read(tokens);
			setFastSystem(fs);
			continue;
		}	
		//Variable initial conditions as count		
		if (token.equalsIgnoreCase(VCML.VarIniCount_Old) || token.equalsIgnoreCase(VCML.VarIniCount))
		{
			token = tokens.nextToken();
			Variable var = mathDesc.getVariable(token);
			if (var == null){
				throw new MathFormatException("variable "+token+" not defined");
			}	
			if (!(var instanceof StochVolVariable)){
				throw new MathFormatException("variable "+token+" not a Stochastic Volume Variable");
			}
			
			Expression varIniExp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
			try{
				varIniExp.bindExpression(mathDesc);
			}catch(Exception ex){
				ex.printStackTrace(System.out);
				throw new MathException(ex.getMessage());
			}
			VarIniCount vic= new VarIniCount(var,varIniExp);
			addVarIniCondition(vic);
			
			continue;
		}
		//Variable inital conditions as concentration
		if (token.equalsIgnoreCase(VCML.VarIniPoissonExpectedCount))
		{
			token = tokens.nextToken();
			Variable var = mathDesc.getVariable(token);
			if (var == null){
				throw new MathFormatException("variable "+token+" not defined");
			}	
			if (!(var instanceof StochVolVariable)){
				throw new MathFormatException("variable "+token+" not a Stochastic Volume Variable");
			}
			
			Expression varIniExp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
			try{
				varIniExp.bindExpression(mathDesc);
			}catch(Exception ex){
				ex.printStackTrace(System.out);
				throw new MathException(ex.getMessage());
			}
			VarIniPoissonExpectedCount vic= new VarIniPoissonExpectedCount(var,varIniExp);
			addVarIniCondition(vic);
			
			continue;
		}
		//Jump processes 
		if (token.equalsIgnoreCase(VCML.JumpProcess))
		{
			JumpProcess jump = null;
			token = tokens.nextToken();
			String name=token;
			token = tokens.nextToken();
			if(!token.equalsIgnoreCase(VCML.BeginBlock))
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			token = tokens.nextToken();	
			if(token.equalsIgnoreCase(VCML.ProbabilityRate))
			{
				Expression probExp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
				//check if probability functions contain "t", which is not allowed.
				Expression extProb = MathUtilities.substituteFunctions(probExp,mathDesc).flatten();
				String[] symbols = extProb.getSymbols();
				if(symbols != null)
				{
					for(int i=0; i<symbols.length; i++)
					{
						if(symbols[i].equals("t"))
						{
							throw new MathFormatException("Unexpected symbol \'t\'  in probability rate of jump process "+name+". Probability rate should not be a function of t.");
						}	
					}
				}
				probExp.bindExpression(mathDesc);
				jump = new JumpProcess(name,probExp);
				addJumpProcess(jump);
			}
			else {
				throw new MathFormatException("unexpected identifier "+token);
			}

			if(jump != null)
			{
				while (tokens.hasMoreTokens())
				{
					token = tokens.nextToken();
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}
					if (token.equalsIgnoreCase(VCML.Action))
					{
						token = tokens.nextToken();
						Variable var = mathDesc.getVariable(token);
						if (var == null){
							throw new MathFormatException("variable "+token+" not defined");
						}	
						if (!(var instanceof StochVolVariable)){
							throw new MathFormatException("variable "+token+" not a Stochastic Volume Variable");
						}
						String opera = tokens.nextToken();
						if (!opera.equals(Action.ACTION_INC)){
							throw new MathFormatException("expected 'INC' for action, found "+opera);
						}
						Expression exp = MathFunctionDefinitions.fixFunctionSyntax(tokens);
						try{
							exp.bindExpression(mathDesc);
						}
						catch(Exception ex){
							ex.printStackTrace(System.out);
							throw new MathException(ex.getMessage());
						}
						Action action = Action.createIncrementAction(var,exp);
						jump.addAction(action);
					}
					else throw new MathFormatException("unexpected identifier "+token);
				}
			}
			
			continue;
		}	
		throw new MathFormatException("unexpected identifier "+token);
	}	
		
}
*/

/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public void setBoundaryConditionXm(BoundaryConditionType bc) {
	boundaryConditionTypeXm = bc;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public void setBoundaryConditionXp(BoundaryConditionType bc) {
	if (boundaryConditionTypeXm.isPERIODIC() && !bc.isPERIODIC()) {
		throw new RuntimeException("Xm and Xp must both have periodic boundary condition");
	}
	boundaryConditionTypeXp = bc;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public void setBoundaryConditionYm(BoundaryConditionType bc) {
	boundaryConditionTypeYm = bc;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public void setBoundaryConditionYp(BoundaryConditionType bc) {
	if (boundaryConditionTypeYm.isPERIODIC() && !bc.isPERIODIC()) {
		throw new RuntimeException("Ym and Yp must both have periodic boundary condition");
	}	
	boundaryConditionTypeYp = bc;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public void setBoundaryConditionZm(BoundaryConditionType bc) {
	boundaryConditionTypeZm = bc;
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public void setBoundaryConditionZp(BoundaryConditionType bc) {
	if (boundaryConditionTypeZm.isPERIODIC() && !bc.isPERIODIC()) {
		throw new RuntimeException("Zm and Zp must both have periodic boundary condition");
	}	
	boundaryConditionTypeZp = bc;
}

}
