package org.vcell.wizard;

import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Hashtable;

import cbit.vcell.client.task.AsynchClientTask;
import cbit.vcell.client.task.ClientTaskDispatcher;

/**
 * This class is responsible for reacting to events generated by pushing any of the
 * three buttons, 'Next', 'back', and 'Cancel.' Based on what button is pressed,
 * the controller will update the model to show a new panel and reset the state of
 * the buttons as necessary.
 */
public class WizardController implements ActionListener {
    
    private Wizard wizard;
    
    /**
     * This constructor accepts a reference to the Wizard component that created it,
     * which it uses to update the button components and access the WizardModel.
?     */    
    public WizardController(Wizard w) {
        wizard = w;
    }

    /**
     * Calling method for the action listener. This class listens for actions
     * performed by the buttons in the Wizard class, and calls methods below to determine
     * the action.
     */    
    public void actionPerformed(java.awt.event.ActionEvent evt) {
        
        if (evt.getActionCommand().equals(Wizard.CANCEL_BUTTON_ACTION_COMMAND))
            cancelButtonPressed();
        else if (evt.getActionCommand().equals(Wizard.BACK_BUTTON_ACTION_COMMAND))
            backButtonPressed();
        else if (evt.getActionCommand().equals(Wizard.NEXT_BUTTON_ACTION_COMMAND))
            nextButtonPressed();
        
    }
    
    private void cancelButtonPressed() 
    {
    	ArrayList<AsynchClientTask> totalTasks = new ArrayList<AsynchClientTask>();
    	//add pre tasks
    	WizardPanelDescriptor descriptor = wizard.getModel().getCurrentPanelDescriptor();
    	totalTasks.addAll(descriptor.preCancelProcess());
    	//add close panel task
    	AsynchClientTask aTask1 = new AsynchClientTask("", AsynchClientTask.TASKTYPE_SWING_BLOCKING) 
		{
			public void run(Hashtable<String, Object> hashTable) throws Exception
			{
				try
				{
					wizard.close(Wizard.CANCEL_RETURN_CODE);
				}catch (Exception e){
					e.printStackTrace(System.out);
				}
			}
		};
        totalTasks.add(aTask1);
        //add post tasks
        totalTasks.addAll(descriptor.postCancelProcess());
        //dispatch tasks
        AsynchClientTask[] taskArray = new AsynchClientTask[totalTasks.size()];
        if(descriptor.isProgressPopupShown())
        {
        	ClientTaskDispatcher.dispatch(wizard.getDialog(), new Hashtable<String, Object>(), totalTasks.toArray(taskArray), descriptor.isTaskProgressKnown());
        }
        else
        {
        	ClientTaskDispatcher.dispatch(wizard.getDialog(), new Hashtable<String, Object>(), totalTasks.toArray(taskArray), false, false/*doesn't show popup, we don't need progress*/, false, null, false);
        }
    }

    private void nextButtonPressed() {
    	ArrayList<AsynchClientTask> totalTasks = new ArrayList<AsynchClientTask>();
    	//add pre tasks
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor descriptor = model.getCurrentPanelDescriptor();
        totalTasks.addAll(descriptor.preNextProcess());
        
        //add display panel task(if next button pressed) or close task(if finish button pressed)
        final String nextPanelDescriptorID = descriptor.getNextPanelDescriptorID();
        AsynchClientTask aTask1 = new AsynchClientTask("", AsynchClientTask.TASKTYPE_SWING_BLOCKING) 
		{
			public void run(Hashtable<String, Object> hashTable) throws Exception
			{
				try
				{
			        if (nextPanelDescriptorID.equals(Wizard.FINISH.getPanelDescriptorIdentifier())) {
			            wizard.close(Wizard.FINISH_RETURN_CODE);
			        } else {        
			            wizard.setCurrentPanel(nextPanelDescriptorID);
			        }
				}catch (Exception e){
					e.printStackTrace(System.out);
				}
			}
		};
        totalTasks.add(aTask1);
        //add post tasks
        totalTasks.addAll(descriptor.postNextProcess());
        //dispatch tasks
        AsynchClientTask[] taskArray = new AsynchClientTask[totalTasks.size()];
        if(descriptor.isProgressPopupShown())
        {
        	ClientTaskDispatcher.dispatch(wizard.getDialog(), new Hashtable<String, Object>(), totalTasks.toArray(taskArray), descriptor.isTaskProgressKnown());
        }
        else
        {
        	ClientTaskDispatcher.dispatch(wizard.getDialog(), new Hashtable<String, Object>(), totalTasks.toArray(taskArray), false, false/*doesn't show popup, we don't need progress*/, false, null, false);
        }
    }

    private void backButtonPressed() {
    	ArrayList<AsynchClientTask> totalTasks = new ArrayList<AsynchClientTask>();
    	//add pre tasks
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor descriptor = model.getCurrentPanelDescriptor();
        totalTasks.addAll(descriptor.preBackProcess());
        //add display panel task(if next descriptor is not null)
        final String backPanelDescriptorID = descriptor.getBackPanelDescriptorID();
        AsynchClientTask aTask1 = new AsynchClientTask("", AsynchClientTask.TASKTYPE_SWING_BLOCKING) 
		{
			public void run(Hashtable<String, Object> hashTable) throws Exception
			{
				try
				{
					if(backPanelDescriptorID != null)
			        {
			        	wizard.setCurrentPanel(backPanelDescriptorID);
			        }
				}catch (Exception e){
					e.printStackTrace(System.out);
				}
			}
		};
        totalTasks.add(aTask1);
        //add post tasks
        totalTasks.addAll(descriptor.postBackProcess());
        //dispatch tasks
        AsynchClientTask[] taskArray = new AsynchClientTask[totalTasks.size()];
        if(descriptor.isProgressPopupShown())
        {
        	ClientTaskDispatcher.dispatch(wizard.getDialog(), new Hashtable<String, Object>(), totalTasks.toArray(taskArray), descriptor.isTaskProgressKnown());
        }
        else
        {
        	ClientTaskDispatcher.dispatch(wizard.getDialog(), new Hashtable<String, Object>(), totalTasks.toArray(taskArray), false, false/*doesn't show popup, we don't need progress*/, false, null, false);
        }
    }

    
    void resetButtonsToPanelRules() {
    
        //  Reset the buttons to support the original panel rules,
        //  including whether the next or back buttons are enabled or
        //  disabled, or if the panel is finished.
        WizardModel model = wizard.getModel();
        WizardPanelDescriptor descriptor = model.getCurrentPanelDescriptor();
        
        model.setCancelButtonText(Wizard.CANCEL_TEXT);
        
        //  If the panel has another panel behind it, enable
        //  the back button. Otherwise, disable it.
        model.setBackButtonText(Wizard.BACK_TEXT);
        if (descriptor.getBackPanelDescriptorID() != null)
            model.setBackButtonEnabled(Boolean.TRUE);
        else
            model.setBackButtonEnabled(Boolean.FALSE);

        //  If the panel has one or more panels in front of it,
        //  enable the next button. Otherwise, disable it.
        if (descriptor.getNextPanelDescriptorID() != null)
            model.setNextFinishButtonEnabled(Boolean.TRUE);
        else
            model.setNextFinishButtonEnabled(Boolean.FALSE);
 
        //  If the panel is the last panel in the wizard, change
        //  the Next button to Finish. Otherwise, set the text back to Next.
        if (descriptor.getNextPanelDescriptorID().equals(Wizard.FINISH.getPanelDescriptorIdentifier())) {
            model.setNextFinishButtonText(Wizard.FINISH_TEXT);
        } else {
            model.setNextFinishButtonText(Wizard.NEXT_TEXT);
        }
    }
    
}
