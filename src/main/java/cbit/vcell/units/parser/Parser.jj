/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\Parser.jj */
/*@egen*//**
 *
 * VCell Unit Symbol Parser Grammer for JavaCC 
 *
 */

options {
  LOOKAHEAD = 1;
  UNICODE_INPUT = false;                 
  STATIC = false;
  DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(UnitSymbolParser)

package cbit.vcell.units.parser;

public class UnitSymbolParser/*@bgen(jjtree)*/implements UnitSymbolParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTUnitSymbolParserState jjtree = new JJTUnitSymbolParserState();

/*@egen*/

  public static void main(String args[]) {
    UnitSymbolParser parser;
    if (args.length == 0) {
      System.out.println("Java Parser Version 0.2:  Reading from standard input . . .");
      parser = new UnitSymbolParser(new java.io.DataInputStream(System.in));
    } else if (args.length == 1) {
      System.out.println("Java Parser Version 0.2:  Reading from file " + args[0] + " . . .");
      try {
        parser = new UnitSymbolParser(new java.io.DataInputStream(new java.io.FileInputStream(args[0])));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Java Parser Version 0.2:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("VCELL Unit Symbol Parser:  Usage is one of:");
      System.out.println("         java cbit.vcell.unit.parser.UnitSymbolParser < inputfile");
      System.out.println("OR");
      System.out.println("         java cbit.vcell.unit.parser.UnitSymbolParser inputfile");
      return;
    }
    try {
      SimpleNode n = parser.UnitSymbol();
      n.dump("");
      System.out.println("infix = "+n.toInfix());
      System.out.println("symbol = "+n.toSymbol());
      UnitSymbol unitSymbol1 = new UnitSymbol(n.toInfix());
      UnitSymbol unitSymbol2 = new UnitSymbol(n.toSymbol());
      System.out.println("infix1 = "+unitSymbol1.getUnitSymbolAsInfix());
      System.out.println("symbol1 = "+unitSymbol1.getUnitSymbol());
      System.out.println("infix2 = "+unitSymbol2.getUnitSymbolAsInfix());
      System.out.println("symbol2 = "+unitSymbol2.getUnitSymbol());
      
      System.out.println("Java Parser Version 0.2:  Java program parsed successfully.");
    } catch (Exception e) {
      System.out.println("Java Parser Version 0.2:  exception during parse.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}

PARSER_END(UnitSymbolParser)


/*
 * Tokens to consider in BNF follow.
 */

TOKEN : /* Arithmetic Operators */
{
  <POWER: "^"  > | 
  <SUB: "-" > |
  <MULT: "*" > |
  <DIV: "/" > 
}

TOKEN : /* LITERALS */
{
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ <EXPONENT>
   >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < INTEGER_LITERAL: ("0") | ("1" (["0"-"9"])+) | (["2"-"9"] (["0"-"9"])*) >
|
  < ONE_LITERAL: "1" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER:
      (<LETTER>) (<LETTER>)*
  >
|
  < #LETTER:
      ["a"-"z", "_", "A"-"Z"]
  >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Expression syntax follows.
 */
ASTUnitSymbol UnitSymbol() :
{/*@bgen(jjtree) UnitSymbol */
  ASTUnitSymbol jjtn000 = new ASTUnitSymbol(JJTUNITSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UnitSymbol */
   try {
/*@egen*/
   (
   LOOKAHEAD(NumericScale() (" " | "*"))
   NumericScale() (" " | "*") MultiplicativeExpression() ";"
   |
   LOOKAHEAD(NumericScale() ";")
   NumericScale() ";"
   |
   MultiplicativeExpression() ";"
   )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void MultiplicativeExpression()       :
{}
{/*@bgen(jjtree) #MultNode(> 1) */
  {
    ASTMultNode jjtn001 = new ASTMultNode(JJTMULTNODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/ 
  (
  ("1" | PowerTerm()) ( ((<MULT>|".") ("1" | PowerTerm() ) ) | DivTerm() )* 
  )/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
    }
  }
/*@egen*/
/*  |
  (
  IntegerBase() DivTerm() ( ((<MULT>|".") PowerTerm() ) | DivTerm() )* 
  ) #MultNode(>1)
*/  
}

void DivTerm()                 :
{/*@bgen(jjtree) InvertTermNode */
  ASTInvertTermNode jjtn000 = new ASTInvertTermNode(JJTINVERTTERMNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InvertTermNode */
   try {
/*@egen*/
   <DIV> PowerTerm()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void PowerTerm()            :
{/*@bgen(jjtree) PowerTerm */
  ASTPowerTerm jjtn000 = new ASTPowerTerm(JJTPOWERTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PowerTerm */
  try {
/*@egen*/

  BaseExpression() [ ExponentExpression() ]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ExponentExpression()                     :
{/*@bgen(jjtree) ExponentExpression */
  ASTExponentExpression jjtn000 = new ASTExponentExpression(JJTEXPONENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExponentExpression */
  try {
/*@egen*/
  
  [<POWER>] (Negative() | RationalNumberExponent())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Negative()           :
{/*@bgen(jjtree) Negative */
  ASTNegative jjtn000 = new ASTNegative(JJTNEGATIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Negative */
        try {
/*@egen*/
	<SUB> RationalNumberExponent()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void BaseExpression()       :
{}
{
  LOOKAHEAD(Name())
  Name()
|
  LOOKAHEAD("(")
  "(" MultiplicativeExpression() ")"
}

void NumericScale()              :
{/*@bgen(jjtree) NumericScale */
  ASTNumericScale jjtn000 = new ASTNumericScale(JJTNUMERICSCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) NumericScale */
  try {
/*@egen*/
  t = <FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = new Double(t.image); }
  |
  t = <INTEGER_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { jjtn000.value = new Double(t.image); }
  |
  t = <ONE_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { jjtn000.value = new Double(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/*
void IntegerBase() #IntegerBaseNode:
{ Token t; }
{
  t = <INTEGER_LITERAL> 
  { jjtThis.value = new Integer(t.image); }
}
*/

void RationalNumberExponent()                        :
{/*@bgen(jjtree) RationalNumberExponent */
  ASTRationalNumberExponent jjtn000 = new ASTRationalNumberExponent(JJTRATIONALNUMBEREXPONENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1; Token t2; }
{/*@bgen(jjtree) RationalNumberExponent */
  try {
/*@egen*/
  t1 = <ONE_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = new cbit.vcell.matrix.RationalNumber(Long.valueOf(t1.image)); }
  | 
  t1 = <INTEGER_LITERAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = new cbit.vcell.matrix.RationalNumber(Long.valueOf(t1.image)); }
  | 
  LOOKAHEAD(<INTEGER_LITERAL> <DIV> <INTEGER_LITERAL>)
  "(" t1 = <INTEGER_LITERAL> <DIV> t2 = <INTEGER_LITERAL> ")"/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { jjtn000.value = new cbit.vcell.matrix.RationalNumber(Long.valueOf(t1.image), Long.valueOf(t2.image)); }
  | 
  LOOKAHEAD(<ONE_LITERAL> <DIV> <INTEGER_LITERAL>)
  "(" t1 = <ONE_LITERAL> <DIV> t2 = <INTEGER_LITERAL> ")"/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { jjtn000.value = new cbit.vcell.matrix.RationalNumber(Long.valueOf(t1.image), Long.valueOf(t2.image)); }
  | 
  LOOKAHEAD(<INTEGER_LITERAL> <DIV> <ONE_LITERAL>)
  "(" t1 = <INTEGER_LITERAL> <DIV> t2 = <ONE_LITERAL> ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = new cbit.vcell.matrix.RationalNumber(Long.valueOf(t1.image), Long.valueOf(t2.image)); }
  | 
  LOOKAHEAD(<ONE_LITERAL> <DIV> <ONE_LITERAL>)
  "(" t1 = <ONE_LITERAL> <DIV> t2 = <ONE_LITERAL> ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.value = new cbit.vcell.matrix.RationalNumber(Long.valueOf(t1.image), Long.valueOf(t2.image)); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void Name()         :
{/*@bgen(jjtree) IdNode */
  ASTIdNode jjtn000 = new ASTIdNode(JJTIDNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t_name=null; }
{/*@bgen(jjtree) IdNode */
  try {
/*@egen*/
  t_name = <IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t_name.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

