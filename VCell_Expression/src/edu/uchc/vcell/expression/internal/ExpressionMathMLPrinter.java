package edu.uchc.vcell.expression.internal;

/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import org.vcell.expression.ExpressionException;
import org.vcell.expression.IExpression;

import cbit.util.xml.MathMLTags;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class ExpressionMathMLPrinter {
	private SimpleNode rootNode = null;
/**
 * This method was created by a SmartGuide.
 * @param font java.awt.Font
 */
ExpressionMathMLPrinter (SimpleNode rootNode) {
	this.rootNode = rootNode;
}
/**
 * Insert the method's description here.
 * Creation date: (2/8/2002 5:51:09 PM)
 * @return java.lang.String
 */
String getMathML() throws ExpressionException, java.io.IOException {
	org.jdom.output.XMLOutputter xmlwriter = new org.jdom.output.XMLOutputter();
	return xmlwriter.outputString(getMathML(rootNode));
}
/**
 * Insert the method's description here.
 * Creation date: (2/8/2002 5:53:06 PM)
 * @return java.lang.String
 */
public static String getMathML(IExpression exp) throws ExpressionException, java.io.IOException {
	ExpressionMathMLPrinter mathMLPrinter = new ExpressionMathMLPrinter(((Expression)exp).getRootNode());
	return mathMLPrinter.getMathML();
}
/**
 * draw the expression with y at the center and x at the left
 * @param g java.awt.Graphics
 * @param node cbit.vcell.parser.SimpleNode
 */
private org.jdom.Element getMathML(Node node) throws ExpressionException {
	//
	// Equals
	//
	if (node instanceof ASTRelationalNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(((ASTRelationalNode)node).getMathMLElementTag()));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		applyNode.addContent(getMathML(node.jjtGetChild(1)));
		return applyNode;
	}else if (node instanceof ASTAndNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.AND));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		applyNode.addContent(getMathML(node.jjtGetChild(1)));
		return applyNode;
	}else if (node instanceof ASTOrNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.OR));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		applyNode.addContent(getMathML(node.jjtGetChild(1)));
		return applyNode;
	}else if (node instanceof ASTNotNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.NOT));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		return applyNode;
	}else if (node instanceof ASTPowerNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.POWER));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		applyNode.addContent(getMathML(node.jjtGetChild(1)));
		return applyNode;
	}else if (node instanceof DerivativeNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.DIFFERENTIAL));
		org.jdom.Element bvarNode = new org.jdom.Element(MathMLTags.BVAR);
		org.jdom.Element idNode = new org.jdom.Element(MathMLTags.IDENTIFIER);
		idNode.setText(((DerivativeNode)node).independentVar);
		bvarNode.addContent(idNode);
		applyNode.addContent(bvarNode);
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		return applyNode;
	}else if (node instanceof ASTLaplacianNode){
		throw new RuntimeException("ExpressionMathMLPrinter.getMathML(), laplacian operator not yet supported");
	}else if (node instanceof ASTAssignNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.EQUAL));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		applyNode.addContent(getMathML(node.jjtGetChild(1)));
		return applyNode;
	}else if (node instanceof ASTAddNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.PLUS));
		for (int i = 0; i < node.jjtGetNumChildren(); i++){
			applyNode.addContent(getMathML(node.jjtGetChild(i)));	
		}
		return applyNode;
	}else if (node instanceof ASTExpression){
		if (node.jjtGetNumChildren()!=1){
			throw new ExpressionException("Expression node should have 1 child");
		}	
		return getMathML(node.jjtGetChild(0));
	}else if (node instanceof ASTFloatNode){
		org.jdom.Element floatNode = new org.jdom.Element(MathMLTags.CONSTANT);
		Double value = ((ASTFloatNode)node).value;
		floatNode.addContent(value.toString());
		//floatNode.setAttribute(new org.jdom.Attribute(MathMLTags.CellML_units,MathMLTags.DIMENSIONLESS,org.jdom.Namespace.getNamespace(cbit.util.XMLTags.CELLML_NAMESPACE_PREFIX, cbit.util.XMLTags.CELLML_NAMESPACE_URI) ));
		return floatNode;
	}else if (node instanceof ASTFuncNode){
		ASTFuncNode funcNode = (ASTFuncNode)node;
		//
		// functions that have direct MathML mappings
		//
		if (funcNode.getMathMLName()!=null){
			org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
			String mathMLFunctionName = funcNode.getMathMLName();
			applyNode.addContent(new org.jdom.Element(mathMLFunctionName));
			for (int i = 0; i < node.jjtGetNumChildren(); i++){
				applyNode.addContent(getMathML(node.jjtGetChild(i)));	
			}
			return applyNode;
		//
		// functions that do not have direct MathML mappings
		//
		}else if (funcNode.getFunction() == ASTFuncNode.SQRT){
			org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
			applyNode.addContent(new org.jdom.Element(MathMLTags.ROOT));
			applyNode.addContent(getMathML(node.jjtGetChild(0)));	
			org.jdom.Element rootNode = new org.jdom.Element(MathMLTags.CONSTANT);
			rootNode.addContent("2.0");
			//rootNode.setAttribute(new org.jdom.Attribute(MathMLTags.CellML_units,MathMLTags.DIMENSIONLESS,org.jdom.Namespace.getNamespace(cbit.util.XMLTags.CELLML_NAMESPACE_PREFIX, cbit.util.XMLTags.CELLML_NAMESPACE_URI)));
			applyNode.addContent(rootNode);
			return applyNode;
		}else if (funcNode.getFunction() == ASTFuncNode.ATAN2){
			throw new ExpressionException("cannot translate atan(a,b) into MathML");
		}else if (funcNode.getFunction() == ASTFuncNode.MIN){
			throw new ExpressionException("cannot translate min(a,b) into MathML");
		}else if (funcNode.getFunction() == ASTFuncNode.MAX){
			throw new ExpressionException("cannot translate max(a,b) into MathML");
		}else{
			throw new ExpressionException("cannot translate "+funcNode.getName()+" into MathML");
		}
			
	}else if (node instanceof ASTIdNode){
		org.jdom.Element idNode = new org.jdom.Element(MathMLTags.IDENTIFIER);
		idNode.setText(((ASTIdNode)node).name);
		return idNode;
	}else if (node instanceof ASTInvertTermNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.DIVIDE));
		org.jdom.Element unityNode = new org.jdom.Element(MathMLTags.CONSTANT);
		//unityNode.setAttribute(new org.jdom.Attribute(MathMLTags.CellML_units,MathMLTags.DIMENSIONLESS,org.jdom.Namespace.getNamespace(cbit.util.XMLTags.CELLML_NAMESPACE_PREFIX, cbit.util.XMLTags.CELLML_NAMESPACE_URI)));
		unityNode.setText("1.0");
		applyNode.addContent(unityNode);
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		return applyNode;
	}else if (node instanceof ASTMinusTermNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.MINUS));
		applyNode.addContent(getMathML(node.jjtGetChild(0)));
		return applyNode;
	}else if (node instanceof ASTMultNode){
		org.jdom.Element applyNode = new org.jdom.Element(MathMLTags.APPLY);
		applyNode.addContent(new org.jdom.Element(MathMLTags.TIMES));
		for (int i = 0; i < node.jjtGetNumChildren(); i++){
			applyNode.addContent(getMathML(node.jjtGetChild(i)));	
		}
		return applyNode;
	}else{
		throw new ExpressionException("node type "+node.getClass().toString()+" not supported yet");
	}		
}
}
