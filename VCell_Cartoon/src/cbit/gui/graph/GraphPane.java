package cbit.gui.graph;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.awt.Component;
import java.awt.Dimension;
import java.util.*;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class GraphPane extends javax.swing.JPanel implements GraphListener, java.awt.event.MouseListener, javax.swing.Scrollable {
	private GraphModel graphModel = null;
	private GraphLayoutManager layoutManager = new GraphLayout();
	private static final Dimension defaultPrefSize = new Dimension(50,50);

/**
 * Constructor
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
public GraphPane() {
	super();
	initialize();
	addMouseListener(this);
}

/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void clear(java.awt.Graphics g) {
	super.paint(g);
}


/**
 * This method was created by a SmartGuide.
 * @return java.awt.Frame
 */
public java.awt.Frame getFrame() {
	java.awt.Component comp = getParent();
	while (comp!=null){
		if (comp instanceof java.awt.Frame){
			return (java.awt.Frame)comp;
		}
		comp = comp.getParent();
	}
	return null;
}


/**
 * This method was created by a SmartGuide.
 * @return cbit.vcell.graph.GraphModel
 */
public GraphModel getGraphModel() {
	return graphModel;
}


/**
 * Insert the method's description here.
 * Creation date: (3/28/01 5:38:58 PM)
 * @return javax.swing.JScrollPane
 */
private javax.swing.JScrollPane getJScrollPaneParent() {
	if (getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent();
	}else if (getParent() instanceof javax.swing.JViewport && getParent().getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent().getParent();
	}else{
		return null;
	}
}


	/**
	 * Returns the preferred size of the viewport for a view component.
	 * For example the preferredSize of a JList component is the size
	 * required to acommodate all of the cells in its list however the
	 * value of preferredScrollableViewportSize is the size required for
	 * JList.getVisibleRowCount() rows.   A component without any properties
	 * that would effect the viewport size should just return 
	 * getPreferredSize() here.
	 * 
	 * @return The preferredSize of a JViewport whose view is this Scrollable.
	 * @see JViewport#getPreferredSize
	 */
public java.awt.Dimension getPreferredScrollableViewportSize() {
	return getPreferredSize();
}


/**
 * Insert the method's description here.
 * Creation date: (9/6/2002 12:17:16 PM)
 * @return java.awt.Dimension
 */
public Dimension getPreferredSize() {
	String javaVersion = System.getProperty("java.version");
	boolean javaLaterThan12 = (javaVersion.compareTo("1.3") >= 0) ? true : false;
	if (javaLaterThan12) {
		if (graphModel!=null){
			Dimension prefSize = graphModel.getPreferedSize((java.awt.Graphics2D)getGraphics());
			if (getJScrollPaneParent()!=null){
				java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
				prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
			}
			return prefSize;
		}else{
			return super.getPreferredSize();
		}
	} else {
		if (graphModel!=null && isShowing()){
			Dimension prefSize = graphModel.getPreferedSize((java.awt.Graphics2D)getGraphics());
			if (getJScrollPaneParent()!=null){
				java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
				prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
			}
			return prefSize;
		}else{
			return super.getPreferredSize();
		}
	}
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one block
	 * of rows or columns, depending on the value of orientation. 
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a block scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "block" increment for scrolling in the specified direction.
	 * @see JScrollBar#setBlockIncrement
	 */
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	if (javax.swing.SwingConstants.VERTICAL == orientation){
		return visibleRect.height/4;
	}else{
		return visibleRect.width/4;
	}
}


	/**
	 * Return true if a viewport should always force the height of this 
	 * Scrollable to match the height of the viewport.  For example a 
	 * columnar text view that flowed text in left to right columns 
	 * could effectively disable vertical scrolling by returning
	 * true here.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables height to match its own.
	 */
public boolean getScrollableTracksViewportHeight() {
	return false;
}


	/**
	 * Return true if a viewport should always force the width of this 
	 * Scrollable to match the width of the viewport.  For example a noraml 
	 * text view that supported line wrapping would return true here, since it
	 * would be undesirable for wrapped lines to disappear beyond the right
	 * edge of the viewport.  Note that returning true for a Scrollable
	 * whose ancestor is a JScrollPane effectively disables horizontal
	 * scrolling.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables width to match its own.
	 */
public boolean getScrollableTracksViewportWidth() {
	return false;
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one new row
	 * or column, depending on the value of orientation.  Ideally, 
	 * components should handle a partially exposed row or column by 
	 * returning the distance required to completely expose the item.
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a unit scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "unit" increment for scrolling in the specified direction
	 * @see JScrollBar#setUnitIncrement
	 */
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	return 1;
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void graphChanged(GraphEvent graphEvent) {
	updateAll();			
}


/**
 * Called whenever the part throws an exception.
 * @param exception java.lang.Throwable
 */
private void handleException(Throwable exception) {

	/* Uncomment the following lines to print uncaught exceptions to stdout */
	 System.out.println("--------- UNCAUGHT EXCEPTION --------- in CartoonCanvas");
	 exception.printStackTrace(System.out);
}

/**
 * Initialize class
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private void initialize() {
	try {
		// user code begin {1}
		// user code end
		setName("GraphPane");
		setLayout(null);
		setBackground(java.awt.Color.gray);
		setSize(150, 150);
	} catch (java.lang.Throwable ivjExc) {
		handleException(ivjExc);
	}
	// user code begin {2}
	// user code end
}

/**
 * Returns the value of a flag that indicates whether
 * this component can be traversed using
 * Tab or Shift-Tab keyboard focus traversal.  If this method
 * returns "false", this component may still request the keyboard
 * focus using <code>requestFocus()</code>, but it will not automatically
 * be assigned focus during tab traversal.
 * @return    <code>true</code> if this component is
 *            focus-traverable; <code>false</code> otherwise.
 * @since     JDK1.1
 */

//override isFocusTraversable() to return true (Canvas returns false by default) 
//catch the mouse-down event on the component and invoke requestFocus() (to implement click-to-type for your component) 
//when your component gets focus, provide visual feedback indicating it has the focus 

public boolean isFocusTraversable() {
	return true;
}

/**
 * main entrypoint - starts the part when it is run as an application
 * @param args java.lang.String[]
 */
public static void main(java.lang.String[] args) {
	try {
		javax.swing.JFrame frame = new javax.swing.JFrame();
		javax.swing.JDesktopPane desktop = new org.vcell.util.gui.JDesktopPaneEnhanced();
		javax.swing.JInternalFrame iframe = new org.vcell.util.gui.JInternalFrameEnhanced("", true, true, true, true);
		javax.swing.JPanel panel = new javax.swing.JPanel();
		GraphPane aGraphPane = new GraphPane();
		panel.setName("JInternalFrameContentPane");
		panel.setLayout(new java.awt.BorderLayout());
		panel.add(aGraphPane, "Center");
		panel.add(new javax.swing.JButton("hello"), "South");
		iframe.setName("JInternalFrame");
		iframe.setBounds(50, 50, 400, 300);
		iframe.setTitle("GraphPane");
		iframe.getContentPane().add(panel);
//		iframe.setContentPane(panel);
		desktop.setName("JDesktopPane1");
		desktop.add(iframe, iframe.getName());
		frame.getContentPane().setLayout(new java.awt.BorderLayout());
		frame.getContentPane().add(desktop, "Center");
		frame.setSize(iframe.getSize());
		frame.addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent e) {
				System.exit(0);
			};
		});
		frame.setVisible(true);
	} catch (Throwable exception) {
		System.err.println("Exception occurred in main() of cbit.vcell.graph.GraphPane");
		exception.printStackTrace(System.out);
	}
}


	/**
	 * Invoked when the mouse has been clicked on a component.
	 */
public void mouseClicked(java.awt.event.MouseEvent e) {

}


	/**
	 * Invoked when the mouse enters a component.
	 */
public void mouseEntered(java.awt.event.MouseEvent e) {}


	/**
	 * Invoked when the mouse exits a component.
	 */
public void mouseExited(java.awt.event.MouseEvent e) {}


	/**
	 * Invoked when a mouse button has been pressed on a component.
	 */
public void mousePressed(java.awt.event.MouseEvent e) {
	
//override isFocusTraversable() to return true (Canvas returns false by default) 
//catch the mouse-down event on the component and invoke requestFocus() (to implement click-to-type for your component) 
//when your component gets focus, provide visual feedback indicating it has the focus 

	requestFocus();
}


	/**
	 * Invoked when a mouse button has been released on a component.
	 */
public void mouseReleased(java.awt.event.MouseEvent e) {}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void paintComponent(java.awt.Graphics argGraphics) {
	super.paintComponent(argGraphics);
	try {
		java.awt.Graphics2D g = (java.awt.Graphics2D)argGraphics;
		if (graphModel!=null){
			try {
				layoutManager.layout(graphModel,this);
			}catch (LayoutException e){
				System.out.println("Layout error: "+e.getMessage());
			}
			graphModel.paint(g,this);
		}	
	}catch (Exception e){
		handleException(e);
	}		
}


/**
 * This method was created by a SmartGuide.
 * @param graphModel cbit.vcell.graph.GraphModel
 */
public void setGraphModel(GraphModel argGraphModel) {
	
	if (this.graphModel != null){
		this.graphModel.removeGraphListener(this);
	}
	
	this.graphModel = argGraphModel;
	
	if (this.graphModel != null){
		this.graphModel.addGraphListener(this);
	}
	
	updateAll();
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void updateAll() {
	try {
		if (graphModel!=null){
			if (getJScrollPaneParent()!=null){
				invalidate();
				getJScrollPaneParent().revalidate();
			}
			repaint();
		}
	}catch (Exception e){
		handleException(e);
	}			
}


/**
 * 
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private static void getBuilderData() {
/*V1.1
**start of data**
	D0CB838494G88G88G63FC71B4GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E13598EDF0D4D7B5C02081DB35A69DD324C324D4E30B8E0CF40C9DF430B2A3952C990DA3BAF44411EA47C9ABBFBA8EBF62F813107D4A125DCDD220B6C9E3842DCA83A3F6F4D26CG61C3A4161DE60B19019973F677E573485BFD0F37F7333BE4831EF3BFF6DF42AED8266C4C197B6EB977FC5CF34FB9775CA55D2F5734B537F493525CC6446FEF4D04D46FA76479C33F78394455DB8E9F317DFE8B90A08BA6
	77403883E89FDF6A707949B363AE183F8C7355958E9F08A0DD645971552F40C789BDB920D5AC5F366976FA8E39259EA71B6BAEAF0C9DG3B81076369A46AAFF79D90781EA447CBE8EEA144CFF14DCAD70F40D5401A9A002DGBB447A5DB03A196645C3FF976B2EBCD8CB9A3E395139976558E4CA98231CB7A7C6C27E69BC18C2DD1B191D48339EE80DG3879D672282B8F4663412958BB1130C687E3A9EDB0E6A966645050B99C02CAC2A5240649703BDD0C0710C9189F1EC6DCE5G656E04F993C07734447B3B90
	EF42F785C04D345C4BBF7EF0DC5ABA73A57242BEB360AB31173AE93E079D53053DECBE7AC44B2B4C6F2A877D5B13F678CEG04GB2G55GF5G2F3173565DFF0271E4188E9B713811B8E91A27742875EFA32A6A70BDB4849401FBCF0D98D61490FE264F3A8E973167F6407936FFE0BE6E135AE372FC573C778532610BBB1D4EA2BE59D07B0C33BE4DFD71C23A60932E7B95F7A95D2E4C5C781B2B7BBF442EFBF3AC4862E23E6E1D21202FC748B91AA9689E4F60D9FF25934FBA885F4DA2BEB87E9B8C3F5A066731
	78B00B991C2F875A012C0C0D318EE94B481ED5E45751670B7AA173748F1D39AC3721AABB5F16F296F79B33DCE7F35E168798FE2B8D4FED5957A573E29B500EDFF778F8FCA53C181BB5B05FG50G5088601DF1785EGB8BEA3E36CC977117FB346020AC5CF25B4BD2ADA0473A6BC7BE0D4B354D24EA712D4C9C454CB0A25A9E1DDCD9231A66DC19F04677065D86CC7C047B9B521DA8A550C84C8D762AAD52DA4DF33589340B5164A28A1AD2E020238C9245C87BCDDB06ACA123EEFC6952A96D6F07AC39EBC13E965
	92C88481704D7D72293D682FAB30FF8AD01E77033F9D65DDD02D042A8F8D0D9846D44A8C61CEC87D8C7A79B02B9D55703DF6C67A78139D086B4EC14D48C9B9675ABBEDF2CEEB91B4DF3132B2473E5E097577C4CE464CCBE3B2E6CE6F7DBC71FE6FA7C5E3E66C7D20EFAC47E3454C4D4F1DEFB119E8971F2F8C0C59F8CF640A674F5D8257D1B7C7C76B07A83FA3FFD6EDFEBC2BEA30FFBDC0C35E478B5B7BF94C1ED2122A0C520B9684189AADF81C5B398C0FD558DCE97B6E699A7B10ED3E55C7EF5DD39D5C9799AF
	5EBF6A341A2027D5D3CDC461A3A9E8B73D98E3A2BFA70CBC4FE206B7A11F07A10112F97CC73C18F38A251696CED1F5D425D4CB448A74CA26AB198A1B05D2A0F5AD77E25DB552104F7975AB3D188B91A311D0592164D9847D53AC97D5DD0D035143C6AAC1B97E33FBB11E27542C2885CF6CF5904CE5BD05F5055F7BEB15F65C032545612831B41143331827436EEE1B0F9AA1E630FFB9B0AB73AD7DBB19EF872FFF0E547C772B4EE277C56631671CF41667CD45ECA15F38BDABBA0A5B3D0A558301CFF2BB098B755A
	DA91915B6F30BB2496E4EFGE81815315D47EA0B2C9FA228078DDD67AE4C7B365D6F4733D02F25D4A83BD828AE647D55696F1CC73BA4FC47693F71236FF4DB0D63367ACFE1DE95FA2969082A6B37F4D33C17DA436AA146F9E35E3733E7E5EFD4B5D5CBD67836B85B0B7816797E0668B5EF94FC3B7B25EB222ED6F4226CF220D55D10FEF948EF2F4FA713C9A322312BC16C69F4406EFB0EBB9F7040B821D9C9FA9E92A3A377FFB10076625DA150A2DF575D5203548A7BB640D8FF6356BA4A6D5D5405B137936864A6
	449A40D10060CDE97B778347489D6E58B399387A920ABEBAA73964DD57594A73C14C9F6CEC1379GA33F1FB63373B0C1E7B9G47D536A32E96669B7338F1BF629AE05E1837EFEBD7699A725D2E62B56487DD45EB480F3A829C8FB26C9D03247F2C2BD40DE9657CEE87BB1B2C112210FBE5E873AF5D72AD6207799BGD7G4CB2FE9E1C6F71F6BC6B3092190AD91011508BB7B15E27198F6A61FBFB19FCB32CCBE3DCCEC043812AC7CDB5C29A96605A34DF6AB9817390G852882D88F407B2DBE0F6C37FA96421A05
	D2E6EC60D0BEF70C7820960E8F26266303CA188E2AD10D8E8D3D1B52759131AD719E197038042C7B974AF7C795133F89665B81DEDEA8F3AB73FB19DBEBBE330AD4C7AF7A0A3D21B60636B83D0BC41F3B2810DB5B615D21AF427720935BC26133B116D3D715E9E5D0C953C128B20605691E953DF5CD5A7EEEBB6029AFDAAB91568ADD1B44F8702DA6875F63A3FE3947A6207D359CF1DB7C769A0D363C898B86E16474DF4D21E33C1CA3F67A11001D6E3E05DF19C3C71B0785BF5F5716C35217CDDB561211A73FD372
	BD1AAB677B2991E3DDEB13E3450AF75D3CDE9C745C5DBB6BAFF749B7750179785BE1229DE3EADB797CB7054170BB4B673FA91667E3FC9750C20BE53F1B69457C2803F983C0A3401EA51097GA71648DAB25BFD145C2156058CF3840A0DEEAB8F7CDC3EFD599EEF3B9EFE4AA96D1A3F2F5092FE9E63CB8AB14EED7CF19F46DB95605766ED9A6979B30C17142B421AB3101006454C81E450B2CC5522D90EE5B7257077AA7F5D3D073F661471357E2947C97512CF143C876B057D3B4498ECE9F2946E158B7D686F7E7B
	603D86B08E1081389FE075FDF2EF15BD07393F517C1314AA11C9F683CAE7DF5254F4810D45CE7C6F03A609FD26EC5FB51EFB5F97FF791E6A60FED950DB7ACE2B68ADFE27FD3437781DD655FB7B3EF8C5EF693E7851DEFBDFAC5E6678D71C209F6BBBD4AAB661747E853579E278AA74FEA1A5166779E9DF075D9E9E320276E29F56BEAD21D1CD51356B2CC59A0505099857BDB30074BA081F86005DG5E8A072F3FC24653355787F8BC950925B35118BAEC3017BE157AC27D257DFC397F4E7F8FC47B593DEDD0EA44
	D13E44DF6D47D8210649109CE7746379D8DAEC127225821F6A471C575589066638C583256DDAB6F0E73BAA87D8BF8972C2D9D3482C9E405E441818C82A797DBFB2604F634EA703C6D2C30F737FEBDD3167E0DC73A2E9CBDA24E36EBD5B7C587EC57E0F9DCB359057D96218D0F4F3D2B9CF5AD8D3B7C25A43EC172A85EBA9710FA06F9160BD42F85F9EA1AD11A4A52F95709144F36A2829C4D4D8620EAA569413F00D5CA04D1709FB420A051982CADAAE1F3D8CEA598C492DA344C3A771F4A97805127D8551C1C543
	D78EA33C1D41FFE0482F4B4A4ACC76A332667D71263DF6EFDB3C2EE42F5030D47C8738F4FE6D4EE86873034B60BED9A663F173641B37490F5138226BD45127CEA62218AB2732D4AD64652C067213F20DA0F2DA3906F6DF35717C8FD0CB87883E1F388B1189GG4097GGD0CB818294G94G88G88G63FC71B43E1F388B1189GG4097GG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGG4B89GGGG
**end of data**/
}
}