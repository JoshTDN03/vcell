Index: notes.txt
===================================================================
--- notes.txt	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ notes.txt	(.../VCell_5.1_messaging)	(revision 12065)
@@ -1,143 +0,0 @@
-Patches applied to VCell_5.1_messaging:
-
-patch revision_11937.diff
-all except: 
-ModelTest			(NA)
-VCComprehensiveStatistics (NA)
-Expression			(NA)
-SimulationControllerImpl	(patched)
-XmlHelper			(patched)
-FileUtils			(patched)
-
-patch revision_11961.diff
-all except:
-PBSUtils			(patched)
-
-patch revision)_11981.diff
-all except:
-FRAPStudy			(patched) (read)
-PBSConstants		(patched) (copied … includes enums)
-PBSUtils			(patched) (removed)
-ClientSimManager		(patched) (read)
-ExportToXML		(NA)
-SimulationDispatcher	(patched) (read)
-LocalVCellServer		(patched) (read)
-SimulationControllerImpl	(copied … too many changes)
-CVodeFileWriter		(patched) (read) 
-SundialsSolver		(patched) (read)
-SolverFileWriter		(patched) (read)
-GibsonSolver		(patched) (read)
-HybridSolver			(patched) (read)
-HybridSolverTester		(NA)
-AbstractCompiledSolver	(patched) (read)
-CombinedSundialsSolver	(patched) (read)
-CppClassCoder		(patched) (read)
-CppClassCoderFastSystem (patched) (read)
-CppClassCoderSimulation (patched) (read)
-FiniteVolumeFileWriter	(patched) (read)
-FVSolver			(patched) (read)
-FVSolverStandalone	(patched) (read)
-OptXmlWriter		(patched) (read)
-SmoldynFileWriter		(patched) (read)
-SmoldynSolver		(patched) (read)
-PropertyLoader		(patched) (read)
-
-patch revision_11989.diff
-all except:
-.classpath			(patched)
-
-patch revision_11992.diff
-all except:
-.classpath			()
-ClientTester			(file does not exist)
-ServerManageConsole	(patched)
-LocalVCellServer		(patched)
-
-patch revision_12032.diff
-all except:
-DatabaseSearchPanel				(patched)
-messaging.admin.DatePanel			(patched … deleted)
-messaging.admin.ServerManageConsole	(patched … deleted)
-messaging.server.AbstractRpcServerImpl	(patched … deleted)
-messaging.server.LocalDataSetControllerMessaging	(patched … deleted)
-messaging.server.LocaluserMetaDbServerMessaging	(patched … deleted)
-messaging.server.RpcDataServerProxy		(patched … deleted)
-messaging.server.RpcDbServerProxy		(patched … deleted)
-messaging.server.SimulationDispatcher	(patched … deleted)
-messaging.SimulationDispatcherMessaging	(patched … deleted)
-messaging.SimulationTaskMessage		(patched … deleted)
-solver/SolverFileWriter				(patched)
-solvers/CppClassCoderSimulation		(patched)
-solver.smoldyn.SmoldynFileWriter		(patched)
-
-
-patch revision_12052.diff
-all except:
-cbit.vcell.client.LocalDataSetControllerProvider	(patched)
-cbit.vcell.server.LocalVCellServer			(patched)
-cbit.vcell.simdata.LocalDataSetController		(patched)
-
-patch revision_12055.diff
-all:
-
-patch revision_12069
-all:
-
-patch revision_12072
-all:
-
-patch revision_12073
-all:
-
-patch revision_12075
-all:
-
-patch revision_12088
-all:
-
-patch revision_12094
-all:
-
-patch revision_12096
-all:
-
-patch revision_12098
-all:
-
-patch revision_12144
-all:
-
-patch revision_12154
-all:
-
-patch revision_12158
-all:
-
-patch revision_12166
-all:
-
-patch revision_12175
-all:
-
-patch revision_12188
-all:
-
-patch revision_12209
-all:
-
-patch revision_12211
-all:
-
-patch revision_12227
-all:
-
-patch revision_12229
-all except:
-RpcDataServerProxy					(patched)
-RpcDbServerProxy					(patched)
-
-
-
-
-
-
Index: src_vfrap/cbit/vcell/microscopy/FRAPStudy.java
===================================================================
--- src_vfrap/cbit/vcell/microscopy/FRAPStudy.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src_vfrap/cbit/vcell/microscopy/FRAPStudy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -80,7 +80,6 @@
 import cbit.vcell.simdata.SimDataConstants;
 import cbit.vcell.simdata.SimulationData;
 import cbit.vcell.simdata.VariableType;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.DataProcessingInstructions;
 import cbit.vcell.solver.ErrorTolerance;
 import cbit.vcell.solver.Simulation;
@@ -714,16 +713,16 @@
 		}
 		
 		int jobIndex = 0;
-		SimulationTask simTask = new SimulationTask(new SimulationJob(sim,jobIndex, fieldDataIdentifierSpecs),0);
+		SimulationJob simJob = new SimulationJob(sim,jobIndex, fieldDataIdentifierSpecs);
 		ResourceUtil.prepareSolverExecutable(sim.getSolverTaskDescription().getSolverDescription());
 		//if we need to check steady state, do the following two lines
 		if(bCheckSteadyState)
 		{
-			simTask.getSimulation().getSolverTaskDescription().setStopAtSpatiallyUniformErrorTolerance(ErrorTolerance.getDefaultSpatiallyUniformErrorTolerance());
+			simJob.getSimulation().getSolverTaskDescription().setStopAtSpatiallyUniformErrorTolerance(ErrorTolerance.getDefaultSpatiallyUniformErrorTolerance());
 //			simJob.getSimulation().getSolverTaskDescription().setErrorTolerance(new ErrorTolerance(1e-6, 1e-2));
 		}
 		
-		FVSolverStandalone fvSolver = new FVSolverStandalone(simTask,simulationDataDir,sessionLog,false);		
+		FVSolverStandalone fvSolver = new FVSolverStandalone(simJob,simulationDataDir,sessionLog,false);		
 		fvSolver.startSolver();
 		
 		SolverStatus status = fvSolver.getSolverStatus();
@@ -775,17 +774,17 @@
 			}
 			
 			int jobIndex = 0;
-			SimulationTask simTask = new SimulationTask(new SimulationJob(sim,jobIndex, fieldDataIdentifierSpecs),0);
+			SimulationJob simJob = new SimulationJob(sim,jobIndex, fieldDataIdentifierSpecs);
 			//if we need to check steady state, do the following two lines
 			if(bCheckSteadyState)
 			{
-				simTask.getSimulation().getSolverTaskDescription().setStopAtSpatiallyUniformErrorTolerance(ErrorTolerance.getDefaultSpatiallyUniformErrorTolerance());
-				simTask.getSimulation().getSolverTaskDescription().setErrorTolerance(new ErrorTolerance(1e-6, 1e-2));
+				simJob.getSimulation().getSolverTaskDescription().setStopAtSpatiallyUniformErrorTolerance(ErrorTolerance.getDefaultSpatiallyUniformErrorTolerance());
+				simJob.getSimulation().getSolverTaskDescription().setErrorTolerance(new ErrorTolerance(1e-6, 1e-2));
 			}
 			
 			ResourceUtil.prepareSolverExecutable(sim.getSolverTaskDescription().getSolverDescription());
 			
-			FVSolverStandalone fvSolver = new FVSolverStandalone(simTask,simulationDataDir,sessionLog,false);		
+			FVSolverStandalone fvSolver = new FVSolverStandalone(simJob,simulationDataDir,sessionLog,false);		
 			fvSolver.startSolver();
 			
 			SolverStatus status = fvSolver.getSolverStatus();
Index: src/cbit/sql/OraclePoolingConnectionFactory.java
===================================================================
--- src/cbit/sql/OraclePoolingConnectionFactory.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/sql/OraclePoolingConnectionFactory.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -18,14 +18,9 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
-import oracle.ucp.UniversalConnectionPoolAdapter;
-import oracle.ucp.UniversalConnectionPoolException;
-import oracle.ucp.admin.UniversalConnectionPoolManager;
-import oracle.ucp.admin.UniversalConnectionPoolManagerImpl;
-import oracle.ucp.jdbc.PoolDataSource;
-import oracle.ucp.jdbc.PoolDataSourceFactory;
+import oracle.jdbc.pool.OracleConnectionCacheManager;
+import oracle.jdbc.pool.OracleDataSource;
 
-import org.vcell.util.ConfigurationException;
 import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 import org.vcell.util.StdoutSessionLog;
@@ -38,9 +33,8 @@
  */
 public final class OraclePoolingConnectionFactory implements ConnectionFactory  {
 
-	private UniversalConnectionPoolManager connectionPoolManaager = null;
-	private String connectionCacheName = null;
-	private PoolDataSource poolDataSource = null;
+	private String connectionCacheName = "ImplicitCache01";
+	private OracleDataSource oracleDataSource = null;
 	private SessionLog log = null;
 	private TimerTask refreshConnectionTask = new TimerTask() {
 		public void run() {
@@ -48,47 +42,38 @@
 		}
 	};
 
-public OraclePoolingConnectionFactory(SessionLog sessionLog) throws ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException, ConfigurationException, UniversalConnectionPoolException {
+public OraclePoolingConnectionFactory(SessionLog sessionLog) throws ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException {
 	this(sessionLog, PropertyLoader.getRequiredProperty(PropertyLoader.dbDriverName), 
 			PropertyLoader.getRequiredProperty(PropertyLoader.dbConnectURL), 
 			PropertyLoader.getRequiredProperty(PropertyLoader.dbUserid), 
 			PropertyLoader.getRequiredProperty(PropertyLoader.dbPassword));	
 }
 
-public OraclePoolingConnectionFactory(SessionLog sessionLog, String argDriverName, String argConnectURL, String argUserid, String argPassword) throws ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException, UniversalConnectionPoolException {
+public OraclePoolingConnectionFactory(SessionLog sessionLog, String argDriverName, String argConnectURL, String argUserid, String argPassword) throws ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException {
 	this.log = sessionLog;
-	connectionCacheName = "UCP_ManagedPool_" + System.nanoTime();
-
-	connectionPoolManaager = UniversalConnectionPoolManagerImpl.getUniversalConnectionPoolManager();
-	poolDataSource = PoolDataSourceFactory.getPoolDataSource();
-	poolDataSource.setConnectionFactoryClassName("oracle.jdbc.pool.OracleDataSource");
-	poolDataSource.setConnectionPoolName(connectionCacheName);
+	oracleDataSource = new OracleDataSource();
 	// set DataSource properties
-	poolDataSource.setURL(argConnectURL);
-	poolDataSource.setUser(argUserid);
-	poolDataSource.setPassword(argPassword);
-	connectionPoolManaager.createConnectionPool((UniversalConnectionPoolAdapter)poolDataSource);
+	oracleDataSource.setURL(argConnectURL);
+	oracleDataSource.setUser(argUserid);
+	oracleDataSource.setPassword(argPassword);
+	oracleDataSource.setConnectionCachingEnabled(true);
 	// set cache properties    
-	poolDataSource.setMinPoolSize(2);
-	poolDataSource.setMaxPoolSize(5);
-	poolDataSource.setInitialPoolSize(2);
-//	java.util.Properties prop = new java.util.Properties();
-//	prop.setProperty("MinLimit", "1");
-//	prop.setProperty("MaxLimit", "20");
-////	prop.setProperty("InitialLimit", "3"); // create 3 connections at startup
-////	prop.setProperty("InactivityTimeout", "300");    //  seconds
-////	prop.setProperty("TimeToLiveTimeout", "300");    //  seconds
-////	prop.setProperty("AbandonedConnectionTimeout", "300");  //  seconds
-////	prop.setProperty("ValidateConnection", "true");
-//	oracleDataSource.setConnectionCacheProperties (prop);
+	java.util.Properties prop = new java.util.Properties();
+	prop.setProperty("MinLimit", "1");
+	prop.setProperty("MaxLimit", "20");
+//	prop.setProperty("InitialLimit", "3"); // create 3 connections at startup
+//	prop.setProperty("InactivityTimeout", "300");    //  seconds
+//	prop.setProperty("TimeToLiveTimeout", "300");    //  seconds
+//	prop.setProperty("AbandonedConnectionTimeout", "300");  //  seconds
+//	prop.setProperty("ValidateConnection", "true");
+	oracleDataSource.setConnectionCacheProperties (prop);
 	
 	// when vcell runs in local model, every time reconnnect, it will create a new 
 	// OraclePoolingConnectionFactory which causes same cache error. So add current time 
 	// to cache name.
+	connectionCacheName = "ImplicitCache01" + System.currentTimeMillis();
+	oracleDataSource.setConnectionCacheName(connectionCacheName); // this cache's name
 	
-//	oracleDataSource.setConnectionCacheName(connectionCacheName); // this cache's name
-//	connectionPoolManaager.startConnectionPool(connectionCacheName);
-	
 	Timer timer = new Timer();
 	timer.schedule(refreshConnectionTask, 2*60*1000, 2*60*1000);
 }
@@ -103,36 +88,32 @@
 	log.print("OraclePoolingConnectionFactory.failed("+con+")");
 	release(con, lock);
 	// Get singleton ConnectionCacheManager instance
-	try {
-		connectionPoolManaager.refreshConnectionPool(connectionCacheName);
-	} catch (UniversalConnectionPoolException e) {
-		log.exception(e);
-	}
+	OracleConnectionCacheManager occm = OracleConnectionCacheManager.getConnectionCacheManagerInstance();
+	// Refresh all connections in cache
+	occm.refreshCache(connectionCacheName, OracleConnectionCacheManager.REFRESH_ALL_CONNECTIONS);
 }
 
 private synchronized void refreshConnections() {
 	try {
-		connectionPoolManaager.refreshConnectionPool(connectionCacheName);
-	} catch (UniversalConnectionPoolException e) {
-		log.exception(e);
+		OracleConnectionCacheManager occm = OracleConnectionCacheManager.getConnectionCacheManagerInstance();
+		occm.refreshCache(connectionCacheName, OracleConnectionCacheManager.REFRESH_ALL_CONNECTIONS);
+	} catch (SQLException e) {
+		e.printStackTrace();
 	}
 }
 
 public synchronized Connection getConnection(Object lock) throws SQLException {
 	Connection conn = null;
 	try {
-		conn = poolDataSource.getConnection();
+		conn = oracleDataSource.getConnection();
 	} catch (SQLException ex) {
 		// might be invalid or stale connection
-		log.exception(ex);
+		ex.printStackTrace(System.out);
+		OracleConnectionCacheManager occm = OracleConnectionCacheManager.getConnectionCacheManagerInstance();
 		// refresh cache
-		try {
-			connectionPoolManaager.refreshConnectionPool(connectionCacheName);
-		} catch (UniversalConnectionPoolException e) {
-			log.exception(e);
-		}
+		occm.refreshCache(connectionCacheName, OracleConnectionCacheManager.REFRESH_ALL_CONNECTIONS);
 		// get connection again.
-		conn = poolDataSource.getConnection();
+		conn = oracleDataSource.getConnection();
 	}
 	if (conn == null) {
 		throw new SQLException("Cannot get a connection to the database. This could be caused by\n" +
Index: src/cbit/vcell/simdata/LocalDataSetController.java
===================================================================
--- src/cbit/vcell/simdata/LocalDataSetController.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/simdata/LocalDataSetController.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,27 +9,29 @@
  */
 
 package cbit.vcell.simdata;
+import cbit.rmi.event.*;
+import cbit.vcell.solver.DataProcessingOutput;
+import cbit.vcell.client.data.OutputContext;
+import cbit.vcell.export.server.*;
+import cbit.vcell.field.FieldDataFileOperationResults;
+import cbit.vcell.field.FieldDataFileOperationSpec;
+import cbit.vcell.simdata.gui.SpatialSelection;
+import cbit.vcell.math.*;
+import java.rmi.*;
+import java.rmi.server.*;
 import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 import org.vcell.util.document.User;
 import org.vcell.util.document.VCDataIdentifier;
 
-import cbit.rmi.event.ExportEvent;
-import cbit.vcell.client.data.OutputContext;
-import cbit.vcell.export.server.ExportServiceImpl;
-import cbit.vcell.field.FieldDataFileOperationResults;
-import cbit.vcell.field.FieldDataFileOperationSpec;
-import cbit.vcell.math.AnnotatedFunction;
-import cbit.vcell.server.DataSetController;
-import cbit.vcell.server.LocalVCellConnection;
-import cbit.vcell.simdata.gui.SpatialSelection;
-import cbit.vcell.solver.DataProcessingOutput;
 import cbit.vcell.solvers.CartesianMesh;
+import cbit.vcell.server.*;
 /**
  * This interface was generated by a SmartGuide.
  * 
  */
-public class LocalDataSetController implements DataSetController {
+public class LocalDataSetController extends UnicastRemoteObject implements DataSetController {
 	private LocalVCellConnection vcConn = null;
 	private SessionLog log = null;
 	private User user = null;
@@ -38,7 +40,8 @@
 /**
  * This method was created by a SmartGuide.
  */
-public LocalDataSetController (LocalVCellConnection argvcConn, SessionLog log, DataSetControllerImpl dsControllerImpl, ExportServiceImpl exportServiceImpl, User user) {
+public LocalDataSetController (LocalVCellConnection argvcConn, SessionLog log, DataSetControllerImpl dsControllerImpl, ExportServiceImpl exportServiceImpl, User user) throws RemoteException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortDataSetController,0));
 	this.vcConn = argvcConn;
 	this.user = user;
 	this.log = log;
@@ -73,10 +76,10 @@
  * Insert the method's description here.
  * Creation date: (10/11/00 1:11:04 PM)
  * @param function cbit.vcell.math.Function
- * @exception DataAccessException The exception description.
- * @exception  The exception description.
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
  */
-public AnnotatedFunction[] getFunctions(OutputContext outputContext,VCDataIdentifier vcdID) throws DataAccessException  {
+public AnnotatedFunction[] getFunctions(OutputContext outputContext,VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
 	return dataServerImpl.getFunctions(outputContext,user, vcdID);
 }
 
@@ -87,9 +90,9 @@
  * @param variable java.lang.String
  * @param time double
  * @param spatialSelection cbit.vcell.simdata.gui.SpatialSelection
- * @exception  The exception description.
+ * @exception java.rmi.RemoteException The exception description.
  */
-public cbit.plot.PlotData getLineScan(OutputContext outputContext, VCDataIdentifier vcdID, java.lang.String varName, double time, SpatialSelection spatialSelection) throws DataAccessException  {
+public cbit.plot.PlotData getLineScan(OutputContext outputContext, VCDataIdentifier vcdID, java.lang.String varName, double time, SpatialSelection spatialSelection) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
 	return dataServerImpl.getLineScan(outputContext, user, vcdID,varName,time,spatialSelection);
 }
 
@@ -107,10 +110,10 @@
  * Insert the method's description here.
  * Creation date: (1/14/00 11:20:51 AM)
  * @return cbit.vcell.export.data.ODESimData
- * @exception DataAccessException The exception description.
- * @exception  The exception description.
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
  */
-public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws DataAccessException {
+public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws DataAccessException, RemoteException {
 	return dataServerImpl.getODEData(user, vcdID);
 }
 
@@ -169,9 +172,9 @@
  * Insert the method's description here.
  * Creation date: (3/30/2001 11:11:52 AM)
  * @param exportSpecs cbit.vcell.export.server.ExportSpecs
- * @exception DataAccessException The exception description.
+ * @exception org.vcell.util.DataAccessException The exception description.
  */
-public ExportEvent makeRemoteFile(OutputContext outputContext,cbit.vcell.export.server.ExportSpecs exportSpecs) throws DataAccessException {
+public ExportEvent makeRemoteFile(OutputContext outputContext,cbit.vcell.export.server.ExportSpecs exportSpecs) throws org.vcell.util.DataAccessException {
 	return dataServerImpl.makeRemoteFile(outputContext,user, exportSpecs);
 
 	/*
Index: src/cbit/vcell/simdata/LocalDataSetControllerProxy.java
===================================================================
--- src/cbit/vcell/simdata/LocalDataSetControllerProxy.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/simdata/LocalDataSetControllerProxy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,447 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.simdata;
+
+import cbit.rmi.event.*;
+import cbit.vcell.solver.*;
+import cbit.vcell.client.data.OutputContext;
+import cbit.vcell.export.server.*;
+import cbit.vcell.field.FieldDataFileOperationResults;
+import cbit.vcell.field.FieldDataFileOperationSpec;
+import cbit.vcell.simdata.gui.SpatialSelection;
+import cbit.vcell.math.*;
+import cbit.plot.*;
+import java.rmi.*;
+import java.rmi.server.*;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.VCDataIdentifier;
+
+import cbit.vcell.solvers.CartesianMesh;
+import cbit.vcell.server.*;
+/**
+ * This interface was generated by a SmartGuide.
+ * 
+ */
+public class LocalDataSetControllerProxy extends UnicastRemoteObject implements DataSetController {
+	private LocalDataSetController localDataSetController = null;
+	private RemoteDataSetControllerFactory remoteDataSetControllerFactory = null;
+	private DataSetController remoteDataSetController = null;
+	private SessionLog sessionLog = null;
+/**
+ * This method was created by a SmartGuide.
+ */
+public LocalDataSetControllerProxy (SessionLog sessionLog, 
+									RemoteDataSetControllerFactory argRemoteDataSetControllerFactory, 
+									LocalDataSetController argLocalDataSetController)
+									throws RemoteException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortDataSetController,0));
+	this.localDataSetController = argLocalDataSetController;
+	this.remoteDataSetControllerFactory = argRemoteDataSetControllerFactory;
+	this.sessionLog = sessionLog;
+}
+public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.fieldDataFileOperation(...)");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.fieldDataFileOperation(fieldDataFileOperationSpec);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().fieldDataFileOperation(fieldDataFileOperationSpec);
+	}catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String[]
+ */
+public DataIdentifier[] getDataIdentifiers(OutputContext outputContext, VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getDataIdentifiers(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getDataIdentifiers(outputContext,vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getDataIdentifiers(outputContext,vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ */
+public double[] getDataSetTimes(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getDataSetTimes(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getDataSetTimes(vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getDataSetTimes(vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/11/00 1:11:04 PM)
+ * @param function cbit.vcell.math.Function
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public AnnotatedFunction[] getFunctions(OutputContext outputContext,VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	sessionLog.print("LocalDataSetControllerProxy.getFunctions(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getFunctions(outputContext,vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getFunctions(outputContext,vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.plot.PlotData
+ * @param varName java.lang.String
+ * @param spatialSelection cbit.vcell.simdata.gui.SpatialSelection
+ */
+public PlotData getLineScan(OutputContext outputContext, VCDataIdentifier vcdID, String varName, double time, SpatialSelection spatialSelection) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getLineScan(simID="+vcdID.getID()+", "+varName+", "+time+", at "+spatialSelection+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getLineScan(outputContext,vcdID, varName, time, spatialSelection);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getLineScan(outputContext,vcdID, varName, time, spatialSelection);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/01 11:21:33 AM)
+ * @return cbit.vcell.server.DataSetController
+ * @param user cbit.vcell.server.User
+ */
+private LocalDataSetController getLocalDataSetController() {
+	return localDataSetController;
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return int[]
+ */
+public CartesianMesh getMesh(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getMesh(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getMesh(vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getMesh(vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (1/14/00 11:20:51 AM)
+ * @return cbit.vcell.export.data.ODESimData
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws DataAccessException, RemoteException {
+	sessionLog.print("LocalDataSetControllerProxy.getODEData(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getODEData(vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getODEData(vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param time double
+ */
+public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getParticleDataBlock(simID="+vcdID.getID()+",time="+time+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getParticleDataBlock(vcdID,time);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getParticleDataBlock(vcdID,time);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return boolean
+ */
+public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getDataProcessingOutput(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getDataProcessingOutput(vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getDataProcessingOutput(vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return boolean
+ */
+public boolean getParticleDataExists(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getParticleDataExists(simID="+vcdID.getID()+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getParticleDataExists(vcdID);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getParticleDataExists(vcdID);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/01 11:21:33 AM)
+ * @return cbit.vcell.server.DataSetController
+ * @param user cbit.vcell.server.User
+ */
+private DataSetController getRemoteDataSetController() {
+	//
+	// slave data server should have a null remote factory
+	//
+	if (remoteDataSetControllerFactory == null){
+		return null;
+	}
+	if (remoteDataSetController==null){
+		try {
+			remoteDataSetController = remoteDataSetControllerFactory.getRemoteDataSetController();
+		}catch (Throwable e){
+			sessionLog.exception(e);
+		}
+	}
+	return remoteDataSetController;
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param time double
+ */
+public SimDataBlock getSimDataBlock(OutputContext outputContext, VCDataIdentifier vcdID, String varName, double time) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getSimDataBlock(simID="+vcdID.getID()+", varName="+varName+", time="+time+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getSimDataBlock(outputContext,vcdID,varName,time);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getSimDataBlock(outputContext,vcdID,varName,time);
+	}catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw (DataAccessException)e;
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param index int
+ */
+public org.vcell.util.document.TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext, VCDataIdentifier vcdID,org.vcell.util.document.TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.getTimeSeriesValues(simID="+vcdID.getID()+", "+timeSeriesJobSpec+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.getTimeSeriesValues(outputContext,vcdID,timeSeriesJobSpec);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().getTimeSeriesValues(outputContext,vcdID,timeSeriesJobSpec);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/01 11:38:12 AM)
+ */
+private void invalidateRemoteDataSetController() {
+	this.remoteDataSetController = null;
+}
+/**
+ * This method was created in VisualAge.
+ * @param simInfo cbit.vcell.solver.SimulationInfo
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public ExportEvent makeRemoteFile(OutputContext outputContext,ExportSpecs exportSpecs) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerProxy.makeRemoteFile(simID="+exportSpecs.getVCDataIdentifier().getID()+","+exportSpecs+")");
+	try {
+		//
+		// try once with remote reference (if it exists)
+		// if it fails with a RemoteException, invalidate the remote reference and try local
+		//
+		DataSetController rdsc = getRemoteDataSetController();
+		if (rdsc!=null){
+			try {
+				return rdsc.makeRemoteFile(outputContext,exportSpecs);
+			}catch (RemoteException e){
+				sessionLog.exception(e);
+				invalidateRemoteDataSetController();
+			}
+		}
+		return getLocalDataSetController().makeRemoteFile(outputContext,exportSpecs);
+	}catch (Throwable e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+}
Index: src/cbit/vcell/modelopt/ParameterEstimationTask.java
===================================================================
--- src/cbit/vcell/modelopt/ParameterEstimationTask.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modelopt/ParameterEstimationTask.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -27,7 +27,6 @@
 import cbit.vcell.math.MathDescription;
 import cbit.vcell.math.MathException;
 import cbit.vcell.math.Variable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.model.Parameter;
 import cbit.vcell.opt.OdeObjectiveFunction;
 import cbit.vcell.opt.OptimizationResultSet;
@@ -459,7 +458,7 @@
 	}
 	//get input model string
 	StringWriter stringWriter = new StringWriter();
-	IDAFileWriter idaFileWriter = new IDAFileWriter(new PrintWriter(stringWriter,true), new SimulationTask(new SimulationJob(simulation, 0, null),0));
+	IDAFileWriter idaFileWriter = new IDAFileWriter(new PrintWriter(stringWriter,true), new SimulationJob(simulation, 0, null));
 	idaFileWriter.write();
 	stringWriter.close();
 	StringBuffer buffer = stringWriter.getBuffer();
Index: src/cbit/vcell/numericstest/TestCriteriaNew.java
===================================================================
--- src/cbit/vcell/numericstest/TestCriteriaNew.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/numericstest/TestCriteriaNew.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -144,10 +144,4 @@
 public cbit.vcell.solver.test.VariableComparisonSummary[] getVarComparisonSummaries() {
 	return varComparisonSummaries;
 }
-
-
-public int getScanCount() {
-	return 1;
 }
-
-}
Index: src/cbit/vcell/math/FastSystem.java
===================================================================
--- src/cbit/vcell/math/FastSystem.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/FastSystem.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -239,7 +239,7 @@
  * Creation date: (10/17/2002 1:58:28 AM)
  * @return cbit.vcell.parser.Expression[]
  */
-public final Expression[] getExpressions() {
+final Expression[] getExpressions() {
 	Vector<Expression> expList = new Vector<Expression>();
 	for (int i = 0; i < fastInvariantList.size(); i++) {
 		FastInvariant fi = fastInvariantList.elementAt(i);
Index: src/cbit/vcell/math/JumpCondition.java
===================================================================
--- src/cbit/vcell/math/JumpCondition.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/JumpCondition.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -84,7 +84,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public Vector<Expression> getExpressions(MathDescription mathDesc) {
+protected Vector<Expression> getExpressions(MathDescription mathDesc) {
 	Vector<Expression> list = new Vector<Expression>();
 	list.addElement(getInFluxExpression());
 	list.addElement(getOutFluxExpression());
Index: src/cbit/vcell/math/MembraneRegionEquation.java
===================================================================
--- src/cbit/vcell/math/MembraneRegionEquation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/MembraneRegionEquation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -82,7 +82,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public Vector<Expression> getExpressions(MathDescription mathDesc){
+protected Vector<Expression> getExpressions(MathDescription mathDesc){
 	Vector<Expression> list = new Vector<Expression>();
 	list.addElement(getUniformRateExpression());
 	list.addElement(getMembraneRateExpression());
Index: src/cbit/vcell/math/PdeEquation.java
===================================================================
--- src/cbit/vcell/math/PdeEquation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/PdeEquation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -237,7 +237,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public Vector<Expression> getExpressions(MathDescription mathDesc) {
+protected Vector<Expression> getExpressions(MathDescription mathDesc) {
 	Vector<Expression> list = new Vector<Expression>();
 	
 	if (getBoundaryXm()!=null)		list.addElement(getBoundaryXm());
Index: src/cbit/vcell/math/OdeEquation.java
===================================================================
--- src/cbit/vcell/math/OdeEquation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/OdeEquation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -69,7 +69,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public Vector<Expression> getExpressions(MathDescription mathDesc){
+protected Vector<Expression> getExpressions(MathDescription mathDesc){
 	Vector<Expression> list = new Vector<Expression>();
 	
 	if (getRateExpression()!=null)		list.addElement(getRateExpression());
Index: src/cbit/vcell/math/FilamentRegionEquation.java
===================================================================
--- src/cbit/vcell/math/FilamentRegionEquation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/FilamentRegionEquation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -77,7 +77,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public Vector<Expression> getExpressions(MathDescription mathDesc){
+protected Vector<Expression> getExpressions(MathDescription mathDesc){
 	Vector<Expression> list = new Vector<Expression>();
 	list.addElement(getFilamentRateExpression());
 	
Index: src/cbit/vcell/math/VolumeRegionEquation.java
===================================================================
--- src/cbit/vcell/math/VolumeRegionEquation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/VolumeRegionEquation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -82,7 +82,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public Vector<Expression> getExpressions(MathDescription mathDesc){
+protected Vector<Expression> getExpressions(MathDescription mathDesc){
 	Vector<Expression> list = new Vector<Expression>();
 	list.addElement(getVolumeRateExpression());
 	list.addElement(getUniformRateExpression());
Index: src/cbit/vcell/math/Equation.java
===================================================================
--- src/cbit/vcell/math/Equation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/math/Equation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -141,7 +141,7 @@
  * This method was created by a SmartGuide.
  * @return java.util.Vector
  */
-public abstract Vector<Expression> getExpressions(MathDescription mathDesc);
+protected abstract Vector<Expression> getExpressions(MathDescription mathDesc);
 /**
  * Insert the method's description here.
  * Creation date: (10/10/2002 10:31:03 AM)
Index: src/cbit/vcell/opt/solvers/OdeLSFunction.java
===================================================================
--- src/cbit/vcell/opt/solvers/OdeLSFunction.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/opt/solvers/OdeLSFunction.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -22,7 +22,6 @@
 import cbit.vcell.math.Constant;
 import cbit.vcell.math.Function;
 import cbit.vcell.math.MathException;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.opt.OdeObjectiveFunction;
 import cbit.vcell.opt.ReferenceData;
 import cbit.vcell.parser.Expression;
@@ -108,7 +107,7 @@
 		simulation.getSolverTaskDescription().setSolverDescription(SolverDescription.IDA);
 
 		java.io.StringWriter stringWriter = new java.io.StringWriter();
-		IDAFileWriter idaFileWriter = new IDAFileWriter(new PrintWriter(stringWriter,true), new SimulationTask(new SimulationJob(simulation, 0, null),0));
+		IDAFileWriter idaFileWriter = new IDAFileWriter(new PrintWriter(stringWriter,true), new SimulationJob(simulation, 0, null));
 		idaFileWriter.write(unscaledParameterNames);
 		stringWriter.close();
 		StringBuffer buffer = stringWriter.getBuffer();
Index: src/cbit/vcell/modeldb/LocalUserMetaDbServer.java
===================================================================
--- src/cbit/vcell/modeldb/LocalUserMetaDbServer.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modeldb/LocalUserMetaDbServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,10 +9,13 @@
  */
 
 package cbit.vcell.modeldb;
+import java.rmi.RemoteException;
+
 import org.vcell.util.BigString;
 import org.vcell.util.DataAccessException;
 import org.vcell.util.ObjectNotFoundException;
 import org.vcell.util.Preference;
+import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 import org.vcell.util.document.BioModelInfo;
 import org.vcell.util.document.CurateSpec;
@@ -54,14 +57,16 @@
 /**
  * This type was created in VisualAge.
  */
-public class LocalUserMetaDbServer implements UserMetaDbServer {
+public class LocalUserMetaDbServer extends java.rmi.server.UnicastRemoteObject implements UserMetaDbServer {
 	private DatabaseServerImpl dbServerImpl = null;
 	private User user = null;
 
 /**
  * This method was created in VisualAge.
  */
-public LocalUserMetaDbServer(ConnectionFactory conFactory, KeyFactory keyFactory, User argUser, SessionLog sessionLog) throws DataAccessException {
+public LocalUserMetaDbServer(ConnectionFactory conFactory, KeyFactory keyFactory, User argUser, SessionLog sessionLog) 
+						throws RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortUserMetaDbServer,0));
 	this.user = argUser;
 	dbServerImpl = new DatabaseServerImpl(conFactory,keyFactory, sessionLog);
 }
@@ -74,11 +79,11 @@
  * @exception org.vcell.util.DataAccessException The exception description.
  * @exception java.rmi.RemoteException The exception description.
  */
-public VCDocumentInfo curate(CurateSpec curateSpec) throws DataAccessException, ObjectNotFoundException {
+public VCDocumentInfo curate(CurateSpec curateSpec) throws DataAccessException, ObjectNotFoundException, java.rmi.RemoteException {
 	return dbServerImpl.curate(user,curateSpec);
 }
 
-public UserRegistrationResults userRegistrationOP(UserRegistrationOP userRegistrationOP) throws DataAccessException, ObjectNotFoundException {
+public UserRegistrationResults userRegistrationOP(UserRegistrationOP userRegistrationOP) throws DataAccessException, ObjectNotFoundException, java.rmi.RemoteException {
 	return dbServerImpl.userRegistrationOP(user,userRegistrationOP);
 }
 
@@ -137,7 +142,7 @@
  * @exception org.vcell.util.DataAccessException The exception description.
  * @exception java.rmi.RemoteException The exception description.
  */
-public TestSuiteOPResults doTestSuiteOP(TestSuiteOP tsop) throws DataAccessException {
+public TestSuiteOPResults doTestSuiteOP(TestSuiteOP tsop) throws DataAccessException, java.rmi.RemoteException {
 
 	return dbServerImpl.doTestSuiteOP(user, tsop);
 }
@@ -150,7 +155,7 @@
  * @exception org.vcell.util.DataAccessException The exception description.
  * @exception java.rmi.RemoteException The exception description.
  */
-public ReferenceQueryResult findReferences(ReferenceQuerySpec rqs) throws DataAccessException, ObjectNotFoundException {
+public ReferenceQueryResult findReferences(ReferenceQuerySpec rqs) throws DataAccessException, ObjectNotFoundException, java.rmi.RemoteException {
 	return dbServerImpl.findReferences(user, rqs);
 }
 
@@ -430,7 +435,7 @@
  * @exception org.vcell.util.DataAccessException The exception description.
  * @exception java.rmi.RemoteException The exception description.
  */
-public TestSuiteNew getTestSuite(java.math.BigDecimal getThisTS) throws DataAccessException {
+public TestSuiteNew getTestSuite(java.math.BigDecimal getThisTS) throws DataAccessException, java.rmi.RemoteException {
 
 	return dbServerImpl.getTestSuite(user,getThisTS);
 }
@@ -443,7 +448,7 @@
  * @exception org.vcell.util.DataAccessException The exception description.
  * @exception java.rmi.RemoteException The exception description.
  */
-public TestSuiteInfoNew[] getTestSuiteInfos() throws DataAccessException {
+public TestSuiteInfoNew[] getTestSuiteInfos() throws DataAccessException, java.rmi.RemoteException {
 
 	return dbServerImpl.getTestSuiteInfos(user);
 }
Index: src/cbit/vcell/modeldb/LocalAdminDbServer.java
===================================================================
--- src/cbit/vcell/modeldb/LocalAdminDbServer.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modeldb/LocalAdminDbServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,30 +9,26 @@
  */
 
 package cbit.vcell.modeldb;
-import java.rmi.RemoteException;
+import java.rmi.*;
 import java.util.List;
 
 import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 import org.vcell.util.document.ExternalDataIdentifier;
 import org.vcell.util.document.KeyValue;
 import org.vcell.util.document.User;
 import org.vcell.util.document.UserInfo;
-import org.vcell.util.document.VCellServerID;
 
-import cbit.sql.ConnectionFactory;
-import cbit.sql.KeyFactory;
-import cbit.vcell.messaging.db.SimpleJobStatus;
+import cbit.sql.*;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
-import cbit.vcell.messaging.db.SimulationJobStatusInfo;
-import cbit.vcell.messaging.db.UpdateSynchronizationException;
-import cbit.vcell.server.AdminDatabaseServer;
 import cbit.vcell.server.UserLoginInfo;
 
 /**
  * This type was created in VisualAge.
  */
-public class LocalAdminDbServer implements AdminDatabaseServer {
+public class LocalAdminDbServer extends java.rmi.server.UnicastRemoteObject implements cbit.vcell.server.AdminDatabaseServer {
 	private SessionLog log = null;
 	private AdminDBTopLevel adminDbTop = null;
 
@@ -43,6 +39,7 @@
 public LocalAdminDbServer(ConnectionFactory conFactory, KeyFactory keyFactory, SessionLog sessionLog) 
 		throws RemoteException, DataAccessException {
 
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortAdminDbServer,0));
 	this.log = sessionLog;
 	DbDriver.setKeyFactory(keyFactory);
 	try {
@@ -62,14 +59,6 @@
 	}
 }
 
-public SimulationJobStatusInfo[] getActiveJobs(VCellServerID[] serverIDs) throws DataAccessException{
-	try {
-		return adminDbTop.getActiveJobs(serverIDs,true);
-	}catch (Throwable e){
-		log.exception(e);
-		throw new DataAccessException("failure getting ActiveJobs");
-	}
-}
 /**
  * Insert the method's description here.
  * Creation date: (1/31/2003 2:34:12 PM)
@@ -78,23 +67,15 @@
  * @param userOnly cbit.vcell.server.User
  * @exception java.rmi.RemoteException The exception description.
  */
-public SimulationJobStatus[] getSimulationJobStatusArray(KeyValue simKey, int jobIndex) throws DataAccessException {
+public SimulationJobStatus getSimulationJobStatus(KeyValue simKey, int jobIndex) throws DataAccessException {
 	try {
-		return adminDbTop.getSimulationJobStatusArray(simKey,jobIndex,true);
+		return adminDbTop.getSimulationJobStatus(simKey,jobIndex,true);
 	}catch (Throwable e){
 		log.exception(e);
 		throw new DataAccessException("failure getting SimulationJobStatus");
 	}
 }
 
-public SimulationJobStatus getSimulationJobStatus(KeyValue simKey, int jobIndex, int taskID) throws DataAccessException {
-	try {
-		return adminDbTop.getSimulationJobStatus(simKey,jobIndex,taskID,true);
-	}catch (Throwable e){
-		log.exception(e);
-		throw new DataAccessException("failure getting SimulationJobStatus");
-	}
-}
 
 /**
  * getSimulationJobStatus method comment.
@@ -202,11 +183,9 @@
  * @param simulationJobStatus cbit.vcell.solvers.SimulationJobStatus
  * @exception java.rmi.RemoteException The exception description.
  */
-public SimulationJobStatus insertSimulationJobStatus(SimulationJobStatus simulationJobStatus) throws DataAccessException, UpdateSynchronizationException {
+public SimulationJobStatus insertSimulationJobStatus(SimulationJobStatus simulationJobStatus) throws DataAccessException {
 	try {
 		return adminDbTop.insertSimulationJobStatus(simulationJobStatus,true);
-	}catch (UpdateSynchronizationException ex){
-		throw ex;
 	}catch (Throwable e){
 		log.exception(e);
 		throw new DataAccessException("failure inserting SimulationJobStatus: "+simulationJobStatus);
Index: src/cbit/vcell/modeldb/DBBackupAndClean.java
===================================================================
--- src/cbit/vcell/modeldb/DBBackupAndClean.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modeldb/DBBackupAndClean.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,15 +15,10 @@
 import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
-import java.sql.SQLException;
 import java.sql.Statement;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
-import java.util.HashSet;
-import java.util.Set;
 
-import org.vcell.util.document.KeyValue;
-
 import oracle.jdbc.pool.OracleDataSource;
 
 
@@ -263,35 +258,6 @@
 		}
 	}
 	
-	private static final String selectUnreferencedSimKeySQL = 
-		" SELECT "+SimulationTable.table.id.getUnqualifiedColName()+" FROM " + SimulationTable.table.getTableName() +
-		" MINUS "+
-		" SELECT "+BioModelSimulationLinkTable.table.simRef.getQualifiedColName()+" FROM "+BioModelSimulationLinkTable.table.getTableName()+
-		" MINUS "+
-		" SELECT "+MathModelSimulationLinkTable.table.simRef.getQualifiedColName()+" FROM "+MathModelSimulationLinkTable.table.getTableName()+
-		" MINUS "+
-		" SELECT DISTINCT "+SimulationTable.table.versionParentSimRef.getQualifiedColName()+" FROM "+SimulationTable.table.getTableName()+
-			" WHERE "+SimulationTable.table.versionParentSimRef.getQualifiedColName()+" IS NOT NULL";
-
-
-	public static Set<KeyValue> getUnreferencedSimulations(Connection con) throws SQLException {
-		String sql = selectUnreferencedSimKeySQL;
-				
-		HashSet<KeyValue> unreferencedSimKeys = new HashSet<KeyValue>();
-		Statement stmt = con.createStatement();
-		try {
-			ResultSet rset = stmt.executeQuery(sql);
-			while (rset.next()){
-				KeyValue simKey = new KeyValue(rset.getBigDecimal(SimulationTable.table.id.toString()));
-				unreferencedSimKeys.add(simKey);
-			}
-		} finally {
-			stmt.close();
-		}
-		return unreferencedSimKeys;
-	}
-
-	
 	private static void cleanRemoveUnreferencedSimulations(Connection con, StringBuffer logStringBuffer) throws Exception{
 		//
 		//Remove Simulations not pointed to by MathModels or BioModels
@@ -300,7 +266,16 @@
 		final String SIMID = "SIMID";
 		final String SIMDATE = "SIMDATE";
 		String UNREFERENCED_SIMS_CLAUSE = 
-			SimulationTable.table.id.getQualifiedColName() + " IN (" + selectUnreferencedSimKeySQL + ")";
+			SimulationTable.table.id.getQualifiedColName()+" IN ("+
+			" SELECT "+SimulationTable.table.id.getUnqualifiedColName()+" FROM vc_simulation "+
+			" MINUS "+
+			" SELECT "+BioModelSimulationLinkTable.table.simRef.getQualifiedColName()+" FROM "+BioModelSimulationLinkTable.table.getTableName()+
+			" MINUS "+
+			" SELECT "+MathModelSimulationLinkTable.table.simRef.getQualifiedColName()+" FROM "+MathModelSimulationLinkTable.table.getTableName()+
+			" MINUS "+
+			" SELECT DISTINCT "+SimulationTable.table.versionParentSimRef.getQualifiedColName()+" FROM "+SimulationTable.table.getTableName()+
+				" WHERE "+SimulationTable.table.versionParentSimRef.getQualifiedColName()+" IS NOT NULL"+
+			")";
 
 		String sql =
 			"SELECT "+
Index: src/cbit/vcell/modeldb/DatabaseServerImpl.java
===================================================================
--- src/cbit/vcell/modeldb/DatabaseServerImpl.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modeldb/DatabaseServerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -55,7 +55,6 @@
 import cbit.vcell.server.UserRegistrationOP;
 import cbit.vcell.server.UserRegistrationResults;
 import cbit.vcell.solver.Simulation;
-import cbit.vcell.solver.SimulationInfo;
 import cbit.vcell.solver.SolverResultSetInfo;
 import cbit.vcell.solver.ode.gui.SimulationStatus;
 import cbit.vcell.xml.XmlHelper;
@@ -339,18 +338,6 @@
 
 
 /**
- * This method was created in VisualAge.
- * @return SimulationInfo
- * @param key KeyValue
- * @exception org.vcell.util.DataAccessException The exception description.
- * @exception java.rmi.RemoteException The exception description.
- */
-public SimulationInfo getSimulationInfo(User user, KeyValue key) throws DataAccessException, ObjectNotFoundException {
-	return ((SimulationInfo[])getVersionInfos(user, key, VersionableType.Simulation, true, true))[0];
-}
-
-
-/**
  * getVersionable method comment.
  */
 public BioModelMetaData getBioModelMetaData(User user, KeyValue key) throws DataAccessException, ObjectNotFoundException {
@@ -930,10 +917,6 @@
 			VCImageInfo[] imgInfos = new VCImageInfo[vector.size()];
 			vector.copyInto(imgInfos);
 			return imgInfos;
-		} else if (vType.equals(VersionableType.Simulation)) {
-			SimulationInfo[] simInfos = new SimulationInfo[vector.size()];
-			vector.copyInto(simInfos);
-			return simInfos;
 		} else {
 			throw new IllegalArgumentException("Wrong VersinableType vType:" + vType);
 		}		
Index: src/cbit/vcell/modeldb/AdminDBTopLevel.java
===================================================================
--- src/cbit/vcell/modeldb/AdminDBTopLevel.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modeldb/AdminDBTopLevel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,9 +9,15 @@
  */
 
 package cbit.vcell.modeldb;
+import cbit.vcell.messaging.admin.ServiceStatus;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
+import cbit.vcell.solver.ode.gui.SimulationStatus;
 import java.sql.Connection;
 import java.sql.SQLException;
-import java.util.Set;
+import cbit.sql.*;
+import cbit.vcell.server.*;
+import cbit.vcell.server.UserLoginInfo.DigestedPassword;
+import cbit.vcell.field.FieldDataDBOperationSpec;
 import java.util.Vector;
 
 import org.vcell.util.DataAccessException;
@@ -23,18 +29,12 @@
 import org.vcell.util.document.UserInfo;
 import org.vcell.util.document.VCellServerID;
 
-import cbit.sql.ConnectionFactory;
-import cbit.vcell.field.FieldDataDBOperationSpec;
-import cbit.vcell.message.server.ServiceStatus;
 import cbit.vcell.messaging.db.ServiceStatusDbDriver;
-import cbit.vcell.messaging.db.SimpleJobStatus;
-import cbit.vcell.messaging.db.SimulationJobDbDriver;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatusInfo;
 import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.db.SimulationJobDbDriver;
 import cbit.vcell.mongodb.VCMongoMessage;
-import cbit.vcell.server.UserLoginInfo;
-import cbit.vcell.solver.ode.gui.SimulationStatus;
 
 /**
  * This type was created in VisualAge.
@@ -86,72 +86,14 @@
 	return jobStatusArray;
 }
 
-public SimulationJobStatusInfo[] getActiveJobs(VCellServerID[] serverIDs, boolean bEnableRetry) throws java.sql.SQLException {
-	Object lock = new Object();
-	Connection con = conFactory.getConnection(lock);
-	try {
-		return jobDB.getActiveJobs(con,serverIDs);
-	} catch (Throwable e) {
-		log.exception(e);
-		if (bEnableRetry && isBadConnection(con)) {
-			conFactory.failed(con,lock);
-			return getActiveJobs(serverIDs, false);
-		}else{
-			handle_SQLException(e);
-			return null; // never gets here;
-		}
-	} finally {
-		conFactory.release(con,lock);
-	}
-}
 
-public Set<KeyValue> getUnreferencedSimulations(boolean bEnableRetry) throws java.sql.SQLException {
-	Object lock = new Object();
-	Connection con = conFactory.getConnection(lock);
-	try {
-		Set<KeyValue> unreferencedSimulations = DBBackupAndClean.getUnreferencedSimulations(con);
-		return unreferencedSimulations;
-	} catch (Throwable e) {
-		log.exception(e);
-		if (bEnableRetry && isBadConnection(con)) {
-			conFactory.failed(con,lock);
-			return getUnreferencedSimulations(false);
-		}else{
-			handle_SQLException(e);
-			return null; // never gets here;
-		}
-	} finally {
-		conFactory.release(con,lock);
-	}
-}
-
-
 /**
  * Insert the method's description here.
- * Creation date: (1/31/2003 2:35:44 PM)
- * @return cbit.vcell.solvers.SimulationJobStatus[]
- * @param bActiveOnly boolean
- * @param owner cbit.vcell.server.User
+ * Creation date: (10/6/2005 3:03:51 PM)
  */
-public SimulationJobStatus getSimulationJobStatus(KeyValue simKey, int jobIndex, int taskID, boolean bEnableRetry) throws java.sql.SQLException, DataAccessException {
-
-	Object lock = new Object();
-	Connection con = conFactory.getConnection(lock);
-	try {
-		SimulationJobStatus jobStatus = getSimulationJobStatus(con, simKey, jobIndex, taskID);
-		return jobStatus;
-	} catch (Throwable e) {
-		log.exception(e);
-		if (bEnableRetry && isBadConnection(con)) {
-			conFactory.failed(con,lock);
-			return getSimulationJobStatus(simKey,jobIndex,taskID,false);
-		}else{
-			handle_DataAccessException_SQLException(e);
-			return null; // never gets here;
-		}
-	} finally {
-		conFactory.release(con,lock);
-	}
+SimulationJobStatus getNextObsoleteSimulation(Connection con, long interval) throws SQLException {
+	SimulationJobStatus jobStatus = jobDB.getNextObsoleteSimulation(con, interval);
+	return jobStatus;
 }
 
 
@@ -162,18 +104,18 @@
  * @param bActiveOnly boolean
  * @param owner cbit.vcell.server.User
  */
-public SimulationJobStatus[] getSimulationJobStatusArray(KeyValue simKey, int jobIndex, boolean bEnableRetry) throws java.sql.SQLException, DataAccessException {
+SimulationJobStatus getSimulationJobStatus(KeyValue simKey, int jobIndex, boolean bEnableRetry) throws java.sql.SQLException, DataAccessException {
 
 	Object lock = new Object();
 	Connection con = conFactory.getConnection(lock);
 	try {
-		SimulationJobStatus[] jobStatus = getSimulationJobStatusArray(con, simKey, jobIndex);
+		SimulationJobStatus jobStatus = getSimulationJobStatus(con, simKey, jobIndex);
 		return jobStatus;
 	} catch (Throwable e) {
 		log.exception(e);
 		if (bEnableRetry && isBadConnection(con)) {
 			conFactory.failed(con,lock);
-			return getSimulationJobStatusArray(simKey,jobIndex,false);
+			return getSimulationJobStatus(simKey,jobIndex,false);
 		}else{
 			handle_DataAccessException_SQLException(e);
 			return null; // never gets here;
@@ -215,24 +157,14 @@
  * Insert the method's description here.
  * Creation date: (10/6/2005 3:08:22 PM)
  */
-SimulationJobStatus getSimulationJobStatus(Connection con, KeyValue simKey, int jobIndex, int taskID) throws SQLException {
-	SimulationJobStatus jobStatus = jobDB.getSimulationJobStatus(con,simKey,jobIndex,taskID,false);
+SimulationJobStatus getSimulationJobStatus(Connection con, KeyValue simKey, int jobIndex) throws SQLException {
+	SimulationJobStatus jobStatus = jobDB.getSimulationJobStatus(con,simKey,jobIndex,false);
 	return jobStatus;
 }
 
 
 /**
  * Insert the method's description here.
- * Creation date: (10/6/2005 3:08:22 PM)
- */
-SimulationJobStatus[] getSimulationJobStatusArray(Connection con, KeyValue simKey, int jobIndex) throws SQLException {
-	SimulationJobStatus[] jobStatus = jobDB.getSimulationJobStatusArray(con,simKey,jobIndex,false);
-	return jobStatus;
-}
-
-
-/**
- * Insert the method's description here.
  * Creation date: (1/31/2003 2:35:44 PM)
  * @return cbit.vcell.solvers.SimulationJobStatus[]
  * @param bActiveOnly boolean
@@ -420,7 +352,7 @@
  * @exception java.sql.SQLException The exception description.
  * @exception cbit.sql.RecordChangedException The exception description.
  */
-public User getUserFromSimulationKey(KeyValue simKey, boolean bEnableRetry) throws DataAccessException, java.sql.SQLException {
+User getUserFromSimulationKey(KeyValue simKey, boolean bEnableRetry) throws DataAccessException, java.sql.SQLException {
 
 	Object lock = new Object();
 	Connection con = conFactory.getConnection(lock);
@@ -529,7 +461,7 @@
  * @return cbit.sql.UserInfo
  * @param newUserInfo cbit.sql.UserInfo
  */
-public SimulationJobStatus insertSimulationJobStatus(SimulationJobStatus simulationJobStatus, boolean bEnableRetry) throws SQLException, DataAccessException, UpdateSynchronizationException {
+SimulationJobStatus insertSimulationJobStatus(SimulationJobStatus simulationJobStatus, boolean bEnableRetry) throws SQLException, DataAccessException {
 
 	Object lock = new Object();
 	Connection con = conFactory.getConnection(lock);
@@ -563,14 +495,15 @@
  * Creation date: (10/3/2005 3:33:09 PM)
  */
 SimulationJobStatus insertSimulationJobStatus(Connection con, SimulationJobStatus simulationJobStatus) throws SQLException, UpdateSynchronizationException {
-	SimulationJobStatus currentSimulationJobStatus = jobDB.getSimulationJobStatus(con,simulationJobStatus.getVCSimulationIdentifier().getSimulationKey(), simulationJobStatus.getJobIndex(),simulationJobStatus.getTaskID(),false);
+	SimulationJobStatus currentSimulationJobStatus = jobDB.getSimulationJobStatus(con,simulationJobStatus.getVCSimulationIdentifier().getSimulationKey(), simulationJobStatus.getJobIndex(),false);
 	if (currentSimulationJobStatus != null){
+		con.rollback();
 		VCMongoMessage.sendSimJobStatusInsertedAlready(simulationJobStatus, currentSimulationJobStatus);
 		log.alert("AdminDbTopLevel.insertSimulationJobStatus() : current Job Status = " + currentSimulationJobStatus + ", job status database record already exists");
-		throw new UpdateSynchronizationException("Job Status database record already exists:" + currentSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey()+" job: "+currentSimulationJobStatus.getJobIndex()+" taskID: "+currentSimulationJobStatus.getTaskID());
+		throw new UpdateSynchronizationException("Job Status database record already exists:" + currentSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey()+" job: "+currentSimulationJobStatus.getJobIndex());
 	}
 	jobDB.insertSimulationJobStatus(con,simulationJobStatus, DbDriver.getNewKey(con));
-	SimulationJobStatus newSimulationJobStatus = jobDB.getSimulationJobStatus(con,simulationJobStatus.getVCSimulationIdentifier().getSimulationKey(), simulationJobStatus.getJobIndex(),simulationJobStatus.getTaskID(),false);
+	SimulationJobStatus newSimulationJobStatus = jobDB.getSimulationJobStatus(con,simulationJobStatus.getVCSimulationIdentifier().getSimulationKey(), simulationJobStatus.getJobIndex(),false);
 	VCMongoMessage.sendSimJobStatusInsert(simulationJobStatus, newSimulationJobStatus);
 	return newSimulationJobStatus;
 }
@@ -618,7 +551,7 @@
  * @return cbit.sql.UserInfo
  * @param newUserInfo cbit.sql.UserInfo
  */
-public SimulationJobStatus updateSimulationJobStatus(SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus, boolean bEnableRetry) throws SQLException, DataAccessException {
+SimulationJobStatus updateSimulationJobStatus(SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus, boolean bEnableRetry) throws SQLException, DataAccessException {
 
 	Object lock = new Object();
 	Connection con = conFactory.getConnection(lock);
@@ -652,14 +585,14 @@
  * Creation date: (10/6/2005 3:20:41 PM)
  */
 SimulationJobStatus updateSimulationJobStatus(Connection con, SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws SQLException, UpdateSynchronizationException {
-	SimulationJobStatus currentSimulationJobStatus = jobDB.getSimulationJobStatus(con,newSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey(),newSimulationJobStatus.getJobIndex(),newSimulationJobStatus.getTaskID(),true);
+	SimulationJobStatus currentSimulationJobStatus = jobDB.getSimulationJobStatus(con,newSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey(),newSimulationJobStatus.getJobIndex(),true);
 	if (!currentSimulationJobStatus.compareEqual(oldSimulationJobStatus)){
 		VCMongoMessage.sendSimJobStatusUpdateCacheMiss(oldSimulationJobStatus, currentSimulationJobStatus, newSimulationJobStatus);
 		log.print("AdminDbTopLevel.updateSimulationJobStatus() : current Job Status = "+currentSimulationJobStatus+", old Job Status = "+oldSimulationJobStatus);
 		throw new UpdateSynchronizationException("current Job Status doesn't match argument for Simulation :"+currentSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey()+" job: "+currentSimulationJobStatus.getJobIndex());
 	}
 	jobDB.updateSimulationJobStatus(con,newSimulationJobStatus);
-	SimulationJobStatus updatedSimulationJobStatus = jobDB.getSimulationJobStatus(con,newSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey(),newSimulationJobStatus.getJobIndex(),newSimulationJobStatus.getTaskID(),false);
+	SimulationJobStatus updatedSimulationJobStatus = jobDB.getSimulationJobStatus(con,newSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey(),newSimulationJobStatus.getJobIndex(),false);
 	VCMongoMessage.sendSimJobStatusUpdate(oldSimulationJobStatus,newSimulationJobStatus,updatedSimulationJobStatus);
 	return updatedSimulationJobStatus;
 }
@@ -840,8 +773,7 @@
 		try {
 			newServiceStatus = serviceOP.doOperation(oldServiceStatus);
 		} catch (Exception ex) {
-			log.exception(ex);
-			throw new RuntimeException("transactional operation failed for " + newServiceStatus + " : " + ex.getMessage());
+			throw new UpdateSynchronizationException("transactional operation failed for " + newServiceStatus + " : " + ex.getMessage());
 		}
 		serviceStatusDB.updateServiceStatus(con,newServiceStatus);
 		con.commit();
Index: src/cbit/vcell/modeldb/AdminDatabaseServerXAImpl.java
===================================================================
--- src/cbit/vcell/modeldb/AdminDatabaseServerXAImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/modeldb/AdminDatabaseServerXAImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.modeldb;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.sql.*;
+import cbit.vcell.server.*;
+import cbit.vcell.messaging.db.*;
+/**
+ * Insert the type's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @author: Ion Moraru
+ */
+public class AdminDatabaseServerXAImpl implements AdminDatabaseServerXA {
+	private SessionLog log = null;
+	private AdminDBTopLevel adminDbTop = null;
+
+public AdminDatabaseServerXAImpl(KeyFactory keyFactory, SessionLog sessionLog) throws DataAccessException {
+
+	this.log = sessionLog;
+	DbDriver.setKeyFactory(keyFactory);
+	try {
+		adminDbTop = new AdminDBTopLevel(null,log);
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException("Error creating AdminDbTop " + e.getMessage());
+	}		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus[]
+ * @param con java.sql.Connection
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public cbit.vcell.messaging.db.SimulationJobStatusInfo[] getActiveJobs(java.sql.Connection con, VCellServerID[] serverIDs) throws DataAccessException {
+	try {
+		SimulationJobStatusInfo[] jobStatuses = adminDbTop.getActiveJobs(con, serverIDs);
+		return jobStatuses;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting active jobs");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param intervalSeconds long
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus getNextObsoleteSimulation(java.sql.Connection con, long intervalSeconds) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.getNextObsoleteSimulation(con, intervalSeconds);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting NextObsoleteSimulation");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simKey cbit.sql.KeyValue
+ * @param jobIndex int
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus getSimulationJobStatus(java.sql.Connection con, org.vcell.util.document.KeyValue simKey, int jobIndex) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.getSimulationJobStatus(con, simKey, jobIndex);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting SimulationJobStatus for ["+simKey+"]["+jobIndex+"]");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 2:34:12 PM)
+ * @return cbit.vcell.solvers.SimulationJobStatus[]
+ * @param bActiveOnly boolean
+ * @param userOnly cbit.vcell.server.User
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationJobStatus[] getSimulationJobStatus(java.sql.Connection con, boolean bActiveOnly, org.vcell.util.document.User userOnly) throws DataAccessException {
+	try {
+		return adminDbTop.getSimulationJobStatus(con, bActiveOnly,userOnly);
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting SimulationJobStatus");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus insertSimulationJobStatus(java.sql.Connection con, SimulationJobStatus simulationJobStatus) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.insertSimulationJobStatus(con, simulationJobStatus);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure inserting SimulationJobStatus: "+simulationJobStatus);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param oldSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @param newSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus updateSimulationJobStatus(java.sql.Connection con, SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.updateSimulationJobStatus(con, oldSimulationJobStatus, newSimulationJobStatus);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure updating SimulationJobStatus: "+oldSimulationJobStatus);
+	}
+}
+}
Index: src/cbit/vcell/modeldb/ResultSetCrawler.java
===================================================================
--- src/cbit/vcell/modeldb/ResultSetCrawler.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/modeldb/ResultSetCrawler.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -41,7 +41,7 @@
  * @author: Jim Schaff
  */
 public class ResultSetCrawler {
-	private AdminDBTopLevel adminDbTopLevel = null;
+	private AdminDatabaseServer adminDbServer = null;
 	private cbit.sql.ConnectionFactory conFactory = null;
 	private org.vcell.util.SessionLog log = null;
 	private cbit.vcell.modeldb.ResultSetDBTopLevel resultSetDbTopLevel = null;
@@ -74,18 +74,18 @@
 /**
  * ResultSetCrawler constructor comment.
  */
-public ResultSetCrawler(ConnectionFactory argConFactory, AdminDBTopLevel adminDbTopLevel, SessionLog argSessionLog) throws SQLException {
-	this(argConFactory, adminDbTopLevel, argSessionLog, null);
+public ResultSetCrawler(ConnectionFactory argConFactory, AdminDatabaseServer argAdminDbServer, SessionLog argSessionLog) throws SQLException {
+	this(argConFactory, argAdminDbServer, argSessionLog, null);
 }
 
 
 /**
  * ResultSetCrawler constructor comment.
  */
-private ResultSetCrawler(ConnectionFactory argConFactory, AdminDBTopLevel adminDbTopLevel, SessionLog argSessionLog, String argOutputDirName) throws SQLException {
+private ResultSetCrawler(ConnectionFactory argConFactory, AdminDatabaseServer argAdminDbServer, SessionLog argSessionLog, String argOutputDirName) throws SQLException {
 	this.conFactory = argConFactory;
 	this.log = argSessionLog;
-	this.adminDbTopLevel = adminDbTopLevel;
+	this.adminDbServer = argAdminDbServer;
 	this.resultSetDbTopLevel = new ResultSetDBTopLevel(conFactory,log);
 	dataRootDir = new File(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty));
 	outputDirName = argOutputDirName;
@@ -296,10 +296,10 @@
 		SessionLog log = new org.vcell.util.StdoutSessionLog("ResultSetCrawler");		
 		conFactory = new cbit.sql.OraclePoolingConnectionFactory(log);
 		cbit.sql.KeyFactory keyFactory = new cbit.sql.OracleKeyFactory();
-		DbDriver.setKeyFactory(keyFactory);
-		AdminDBTopLevel adminDbTopLevel = new AdminDBTopLevel(conFactory,log);
+		
+		AdminDatabaseServer adminDbServer = new LocalAdminDbServer(conFactory,keyFactory,log);
 			
-		ResultSetCrawler crawler = new ResultSetCrawler(conFactory, adminDbTopLevel, log, outputdir);
+		ResultSetCrawler crawler = new ResultSetCrawler(conFactory, adminDbServer, log, outputdir);
 		if (SCAN_SINGLE) {
 			crawler.scanAUser(username, SCAN_ONLY);
 		} else {
@@ -468,7 +468,7 @@
 	File userDirs[] = dataRootDir.listFiles();
 	log.print("Total user directories: " + userDirs.length);
 
-	org.vcell.util.document.UserInfo userInfos[] = adminDbTopLevel.getUserInfos(true);	
+	org.vcell.util.document.UserInfo userInfos[] = adminDbServer.getUserInfos();	
 	DBTopLevel dbTopLevel = new DBTopLevel(conFactory,log);
 
 	File userDir = null;
@@ -505,7 +505,7 @@
 			// find all the user simulations
 			Vector simInfoList = dbTopLevel.getVersionableInfos(user,null,org.vcell.util.document.VersionableType.Simulation,false,false, true);
 			SolverResultSetInfo[] resultSetInfos = resultSetDbTopLevel.getResultSetInfos(user, false, false);
-			ExternalDataIdentifier[] extDataIDArr = adminDbTopLevel.getExternalDataIdentifiers(user,true);
+			ExternalDataIdentifier[] extDataIDArr = adminDbServer.getExternalDataIdentifiers(user);
 			scan(userDir, extDataIDArr,simInfoList, resultSetInfos, outputDir, bScanOnly);
 		} catch (Exception ex) {
 			log.exception(ex);
@@ -532,7 +532,7 @@
 		log.print("----------------------------------------------------------");
 		log.print("USER: " + userDir.getName());
 
-		User user = adminDbTopLevel.getUser(username,true);
+		User user = adminDbServer.getUser(username);
 		
 		if (user == null) {
 			log.alert("User " + user + " doesn't exit!!");
@@ -544,7 +544,7 @@
 		// find all the user simulations
 		Vector simInfoList = dbTopLevel.getVersionableInfos(user,null,org.vcell.util.document.VersionableType.Simulation,false,false, true);
 		SolverResultSetInfo[] resultSetInfos = resultSetDbTopLevel.getResultSetInfos(user, false, false);
-		ExternalDataIdentifier[] extDataIDArr = adminDbTopLevel.getExternalDataIdentifiers(user,true);
+		ExternalDataIdentifier[] extDataIDArr = adminDbServer.getExternalDataIdentifiers(user);
 		scan(userDir, extDataIDArr,simInfoList, resultSetInfos, outputDir, bScanOnly);
 		log.print("----------------------------------------------------------");
 	} catch (Exception ex) {
Index: src/cbit/vcell/server/LocalVCellServerFactory.java
===================================================================
--- src/cbit/vcell/server/LocalVCellServerFactory.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/LocalVCellServerFactory.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -18,12 +18,8 @@
 
 import cbit.sql.ConnectionFactory;
 import cbit.sql.KeyFactory;
-import cbit.vcell.message.VCMessagingService;
-import cbit.vcell.message.server.dispatcher.SimulationDatabase;
-import cbit.vcell.modeldb.AdminDBTopLevel;
-import cbit.vcell.modeldb.DatabaseServerImpl;
+import cbit.vcell.messaging.JmsConnectionFactory;
 import cbit.vcell.modeldb.LocalAdminDbServer;
-import cbit.vcell.modeldb.ResultSetCrawler;
 /**
  * This type was created in VisualAge.
  */
@@ -38,7 +34,7 @@
 /**
  * LocalVCellConnectionFactory constructor comment.
  */
-public LocalVCellServerFactory(String userid, UserLoginInfo.DigestedPassword digestedPassword, String hostName, VCMessagingService vcMessagingService, ConnectionFactory conFactory, KeyFactory keyFactory, SessionLog sessionLog) throws java.sql.SQLException, java.io.FileNotFoundException, DataAccessException {
+public LocalVCellServerFactory(String userid, UserLoginInfo.DigestedPassword digestedPassword, String hostName, JmsConnectionFactory jmsConnFactory, ConnectionFactory conFactory, KeyFactory keyFactory, SessionLog sessionLog) throws java.sql.SQLException, java.io.FileNotFoundException, DataAccessException {
 	try {
 		AdminDatabaseServer adminDbServer = new LocalAdminDbServer(conFactory,keyFactory,sessionLog);
 		User adminUser = null;
@@ -51,14 +47,8 @@
 				throw new PermissionException("userid "+userid+" does not have sufficient privilage");
 			}
 		}
-		AdminDBTopLevel adminDbTopLevel = new AdminDBTopLevel(conFactory, sessionLog);
-		ResultSetCrawler resultSetCrawler = new ResultSetCrawler(conFactory, adminDbTopLevel, sessionLog);
-		DatabaseServerImpl databaseServerImpl = new DatabaseServerImpl(conFactory, keyFactory, sessionLog);
-		SimulationDatabase simulationDatabase = new SimulationDatabase(resultSetCrawler, adminDbTopLevel, databaseServerImpl, sessionLog);
-		vcServer = new LocalVCellServer(hostName, vcMessagingService, adminDbServer, simulationDatabase);
+		vcServer = new LocalVCellServer(hostName, jmsConnFactory, adminDbServer);
 	} catch (java.rmi.RemoteException e){
-		sessionLog.exception(e);
-		throw new RuntimeException(e.getMessage(),e);
 	}
 }
 /**
Index: src/cbit/vcell/server/LocalVCellServer.java
===================================================================
--- src/cbit/vcell/server/LocalVCellServer.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/LocalVCellServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,8 +16,8 @@
 import java.util.Date;
 import java.util.Vector;
 
-import javax.jms.JMSException;
 
+
 import org.vcell.util.BeanUtils;
 import org.vcell.util.CacheStatus;
 import org.vcell.util.DataAccessException;
@@ -28,9 +28,8 @@
 
 import cbit.vcell.client.desktop.biomodel.VCellErrorMessages;
 import cbit.vcell.export.server.ExportServiceImpl;
-import cbit.vcell.message.VCMessagingService;
-import cbit.vcell.message.server.dispatcher.SimulationDatabase;
-import cbit.vcell.message.server.bootstrap.LocalVCellConnectionMessaging;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.server.LocalVCellConnectionMessaging;
 import cbit.vcell.mongodb.VCMongoMessage;
 import cbit.vcell.simdata.Cachetable;
 import cbit.vcell.simdata.DataSetControllerImpl;
@@ -46,10 +45,10 @@
 	private SessionLog sessionLog = null;
 	private Cachetable dataCachetable = null;
 	private DataSetControllerImpl dscImpl = null;
-	private VCMessagingService vcMessagingService = null;
+	private SimulationControllerImpl simControllerImpl = null;
+	private JmsConnectionFactory fieldJmsConnFactory = null;
 	private ExportServiceImpl exportServiceImpl = null;
 	private java.util.Date bootTime = new java.util.Date();
-	private SimulationDatabase simulationDatabase = null;
 
 	private long CLEANUP_INTERVAL = 600*1000;	
 	
@@ -57,21 +56,20 @@
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-public LocalVCellServer(String argHostName, VCMessagingService vcMessagingService, AdminDatabaseServer dbServer, SimulationDatabase simulationDatabase) throws RemoteException, FileNotFoundException {
+public LocalVCellServer(String argHostName, JmsConnectionFactory jmsConnFactory, AdminDatabaseServer dbServer) throws RemoteException, FileNotFoundException {
 	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortVCellServer,0));
 	this.hostName = argHostName;
-	this.vcMessagingService = vcMessagingService;
+	this.fieldJmsConnFactory = jmsConnFactory;
 	adminDbServer = dbServer;
 	this.sessionLog = new StdoutSessionLog(PropertyLoader.ADMINISTRATOR_ACCOUNT);
 	this.dataCachetable = new Cachetable(10*Cachetable.minute);
 	this.dscImpl = new DataSetControllerImpl(sessionLog,dataCachetable, 
 			new File(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty)), 
 			new File(PropertyLoader.getRequiredProperty(PropertyLoader.secondarySimDataDirProperty)));
-	this.simulationDatabase = simulationDatabase;
-//	this.simControllerImpl = new SimulationControllerImpl(sessionLog,adminDbServer, this);
+	this.simControllerImpl = new SimulationControllerImpl(sessionLog,adminDbServer, this);
 	this.exportServiceImpl = new ExportServiceImpl(sessionLog);
 	
-	if (vcMessagingService != null) {
+	if (fieldJmsConnFactory != null) {
 		Thread cleanupThread = new Thread() { 
 			public void run() {
 				setName("CleanupThread");
@@ -87,14 +85,13 @@
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-private synchronized void addVCellConnection(UserLoginInfo userLoginInfo) throws RemoteException, java.sql.SQLException, FileNotFoundException {
+private synchronized void addVCellConnection(UserLoginInfo userLoginInfo) throws RemoteException, java.sql.SQLException, FileNotFoundException, javax.jms.JMSException {
 	if (getVCellConnection0(userLoginInfo) == null) {
 		VCellConnection localConn = null;
-		if (vcMessagingService == null){
-			localConn = new LocalVCellConnection(userLoginInfo, hostName, new StdoutSessionLog(userLoginInfo.getUser().getName()), simulationDatabase, getDataSetControllerImpl(), getExportServiceImpl());
+		if (fieldJmsConnFactory == null){
+			localConn = new LocalVCellConnection(userLoginInfo, hostName, new StdoutSessionLog(userLoginInfo.getUser().getName()), this);
 		} else {
-			localConn = new LocalVCellConnectionMessaging(userLoginInfo, hostName, new StdoutSessionLog(userLoginInfo.getUser().getName()), vcMessagingService, this);
-			((LocalVCellConnectionMessaging)localConn).init();
+			localConn = new LocalVCellConnectionMessaging(userLoginInfo, hostName, new StdoutSessionLog(userLoginInfo.getUser().getName()), fieldJmsConnFactory, this);
 			VCMongoMessage.sendClientConnectionNew(localConn.getUserLoginInfo());
 		}
 		vcellConnectionList.addElement(localConn);
@@ -107,7 +104,7 @@
  * Creation date: (4/16/2004 10:19:42 AM)
  */
 public void cleanupConnections() {	
-	if (vcMessagingService == null) {
+	if (fieldJmsConnFactory == null) {
 		return;
 	}
 	
@@ -147,7 +144,7 @@
  * This method was created in VisualAge.
  * @return cbit.vcell.server.AdminDatabaseServer
  */
-private AdminDatabaseServer getAdminDatabaseServer() {
+public AdminDatabaseServer getAdminDatabaseServer() {
 	try {
 		return adminDbServer;
 	}catch (Throwable e){
@@ -218,11 +215,19 @@
 }
 
 /**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.simdata.DataSetControllerImpl
+ */
+SimulationControllerImpl getSimulationControllerImpl() {
+	return simControllerImpl;
+}
+
+/**
  * This method was created by a SmartGuide.
  * @return cbit.vcell.server.DataSetController
  * @exception java.lang.Exception The exception description.
  */
-public VCellConnection getVCellConnection(UserLoginInfo userLoginInfo) throws RemoteException, java.sql.SQLException, DataAccessException, FileNotFoundException, AuthenticationException {
+VCellConnection getVCellConnection(UserLoginInfo userLoginInfo) throws RemoteException, java.sql.SQLException, DataAccessException, FileNotFoundException, AuthenticationException, javax.jms.JMSException {
 	VCellConnection localConnection = null;
 	//Authenticate User
 	User user = null;
Index: src/cbit/vcell/server/SimulationControllerImpl.java
===================================================================
--- src/cbit/vcell/server/SimulationControllerImpl.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/SimulationControllerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -22,27 +22,21 @@
 import org.vcell.util.PermissionException;
 import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
-import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.ExternalDataIdentifier;
+import org.vcell.util.document.User;
 import org.vcell.util.document.VCellServerID;
 
 import cbit.rmi.event.SimulationJobStatusEvent;
 import cbit.rmi.event.SimulationJobStatusListener;
 import cbit.rmi.event.WorkerEvent;
 import cbit.rmi.event.WorkerEventListener;
-import cbit.vcell.message.VCDestination;
-import cbit.vcell.message.VCMessage;
-import cbit.vcell.message.VCMessagingException;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
-import cbit.vcell.message.local.LocalVCMessageAdapter;
-import cbit.vcell.message.local.LocalVCMessageAdapter.LocalVCMessageListener;
-import cbit.vcell.message.messages.MessageConstants;
-import cbit.vcell.message.messages.SimulationTaskMessage;
-import cbit.vcell.message.server.dispatcher.SimulationDatabase;
-import cbit.vcell.message.server.dispatcher.SimulationDispatcherEngine;
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.field.FieldFunctionArguments;
 import cbit.vcell.messaging.db.SimulationJobStatus;
-import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
-import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.server.DispatcherDbManager;
+import cbit.vcell.messaging.server.LocalDispatcherDbManager;
 import cbit.vcell.solver.Simulation;
 import cbit.vcell.solver.SimulationInfo;
 import cbit.vcell.solver.SimulationJob;
@@ -51,6 +45,8 @@
 import cbit.vcell.solver.SolverStatus;
 import cbit.vcell.solver.VCSimulationIdentifier;
 import cbit.vcell.solvers.LocalSolverController;
+import cbit.vcell.solvers.SimExecutionException;
+import cbit.vcell.solvers.SolverController;
 
 /**
  * Insert the type's description here.
@@ -58,63 +54,22 @@
  * @author: Jim Schaff
  */
 public class SimulationControllerImpl implements WorkerEventListener {
-	public class SimulationTaskInfo {
-		public final KeyValue simKey;
-		public final int jobIndex;
-		public final int taskID;
-		public SimulationTaskInfo(KeyValue simKey,int jobIndex,int taskID){
-			this.simKey = simKey;
-			this.jobIndex = jobIndex;
-			this.taskID = taskID;
-		}
-		public SimulationTaskInfo(SimulationTask simTask){
-			this.simKey = simTask.getSimulation().getKey();
-			this.jobIndex = simTask.getSimulationJob().getJobIndex();
-			this.taskID = simTask.getTaskID();
-		}
-		public SimulationTaskInfo(SimulationJob simulationJob ,int taskID){
-			this.simKey = simulationJob.getSimulation().getKey();
-			this.jobIndex = simulationJob.getJobIndex();
-			this.taskID = taskID;
-		}
-		public SimulationTaskInfo(SimulationInfo simulationInfo, int jobIndex ,int taskID){
-			this.simKey = simulationInfo.getSimulationVersion().getVersionKey();
-			this.jobIndex = jobIndex;
-			this.taskID = taskID;
-		}
-		@Override
-		public boolean equals(Object obj){
-			if (obj instanceof SimulationTaskInfo){
-				return toString().equals(((SimulationTaskInfo)obj).toString());
-			}
-			return false;
-		}
-		@Override
-		public int hashCode(){
-			return toString().hashCode();
-		}
-		@Override
-		public String toString(){
-			return "SimTaskInfo("+simKey.toString()+","+jobIndex+","+taskID+")";
-		}
-	}
-	private java.util.Hashtable<SimulationTaskInfo, LocalSolverController> solverControllerHash = new java.util.Hashtable<SimulationTaskInfo, LocalSolverController>();
+	private java.util.Hashtable<String, SolverController> solverControllerHash = new java.util.Hashtable<String, SolverController>();
 	private SessionLog adminSessionLog = null;
-	private LocalVCellConnection localVCellConnection = null;
-	private SimulationDatabase simulationDatabase = null;
+	private LocalVCellServer fieldLocalVCellServer = null;
+	private AdminDatabaseServer adminDbServer = null;
 	private EventListenerList listenerList = new javax.swing.event.EventListenerList();
-	
-	private SimulationDispatcherEngine simulationDispatcherEngine = new SimulationDispatcherEngine();
-	
 
+	private DispatcherDbManager dispatcherDbManager = new LocalDispatcherDbManager();
+
 /**
  * SimulationControllerImpl constructor comment.
  */
-public SimulationControllerImpl(SessionLog argAdminSessionLog, SimulationDatabase simulationDatabase, LocalVCellConnection localVCellConnection) {
+public SimulationControllerImpl(SessionLog argAdminSessionLog, AdminDatabaseServer argAdminDbServer, LocalVCellServer argLocalVCellServer) {
 	super();
 	adminSessionLog = argAdminSessionLog;
-	this.localVCellConnection = localVCellConnection;
-	this.simulationDatabase = simulationDatabase;
+	fieldLocalVCellServer = argLocalVCellServer;
+	adminDbServer = argAdminDbServer;
 }
 
 /**
@@ -124,54 +79,33 @@
 	listenerList.add(SimulationJobStatusListener.class, listener);
 }
 
-private void onClientStatusTopic_SimulationJobStatus(VCMessage simJobStatusMessage){
-	Double progress = null;
-	if (simJobStatusMessage.propertyExists(MessageConstants.SIMULATION_STATUS_PROGRESS_PROPERTY)){
-		progress = simJobStatusMessage.getDoubleProperty(MessageConstants.SIMULATION_STATUS_PROGRESS_PROPERTY);
-	}
-	Double timepoint = null;
-	if (simJobStatusMessage.propertyExists(MessageConstants.SIMULATION_STATUS_TIMEPOINT_PROPERTY)){
-		timepoint = simJobStatusMessage.getDoubleProperty(MessageConstants.SIMULATION_STATUS_TIMEPOINT_PROPERTY);
-	}
-	SimulationJobStatus simJobStatus = (SimulationJobStatus)simJobStatusMessage.getObjectContent();
-	
-	SimulationJobStatusEvent simulationJobStatusEvent = new SimulationJobStatusEvent(
-			SimulationControllerImpl.this, simJobStatus.getVCSimulationIdentifier().getID(), 
-			simJobStatus, progress, timepoint);
 
-	fireSimulationJobStatusEvent(simulationJobStatusEvent);
-}
-
-public SimulationDatabase getSimulationDatabase(){
-	return this.simulationDatabase;
-}
 /**
  * Insert the method's description here.
  * Creation date: (6/28/01 1:19:54 PM)
  * @return cbit.vcell.solvers.SolverController
  * @param simulation cbit.vcell.solver.Simulation
- * @throws RemoteException 
  * @throws JMSException 
  * @throws AuthenticationException 
  * @throws DataAccessException 
  * @throws SQLException 
  * @throws FileNotFoundException 
- * @throws SolverException 
- * @throws ConfigurationException 
  */
-private LocalSolverController createNewSolverController(SimulationTask simTask, SessionLog userSessionLog) throws FileNotFoundException, DataAccessException, AuthenticationException, SQLException, ConfigurationException, SolverException  {
+private SolverController createNewSolverController(UserLoginInfo userLoginInfo, SimulationJob simulationJob, SessionLog userSessionLog) throws RemoteException, SimExecutionException, SolverException, FileNotFoundException, SQLException, DataAccessException, AuthenticationException, JMSException {
 	//
 	// either no appropriate slave server or THIS IS A SLAVE SERVER (can't pass the buck).
 	//
+	User user = userLoginInfo.getUser();
+	LocalVCellConnection localVCellConnection = (LocalVCellConnection)getLocalVCellServer().getVCellConnection(userLoginInfo);
 	LocalSolverController localSolverController = new LocalSolverController(
 		localVCellConnection,
 		userSessionLog,
-		simTask,
-		getUserSimulationDirectory(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty))
+		simulationJob,
+		getUserSimulationDirectory(user, PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty))
 		);
 
 	localSolverController.addWorkerEventListener(this);
-	userSessionLog.alert("returning local SolverController for "+simTask.getSimulationJobID());
+	userSessionLog.alert("returning local SolverController for "+simulationJob.getSimulationJobID());
 	return localSolverController;
 }
 
@@ -197,30 +131,36 @@
 
 
 /**
+ * Insert the method's description here.
+ * Creation date: (6/28/01 4:33:49 PM)
+ * @return cbit.vcell.server.LocalVCellServer
+ */
+public LocalVCellServer getLocalVCellServer() {
+	return fieldLocalVCellServer;
+}
+
+/**
  * This method was created by a SmartGuide.
- * @throws SolverException 
- * @throws DataAccessException 
- * @throws ConfigurationException 
  * @exception java.rmi.RemoteException The exception description.
  * @throws JMSException 
  * @throws AuthenticationException 
  * @throws SQLException 
  * @throws FileNotFoundException 
  */
-LocalSolverController getOrCreateSolverController(SimulationTask simTask, SessionLog userSessionLog) throws FileNotFoundException, ConfigurationException, DataAccessException, AuthenticationException, SQLException, SolverException  {
-	Simulation simulation = simTask.getSimulation();
+SolverController getSolverController(UserLoginInfo userLoginInfo, SimulationJob simulationJob, SessionLog userSessionLog) throws RemoteException, SimExecutionException, SolverException, PermissionException, DataAccessException, FileNotFoundException, SQLException, AuthenticationException, JMSException {
+	User user = userLoginInfo.getUser();
+	Simulation simulation = simulationJob.getSimulation();
 	VCSimulationIdentifier vcSimID = simulation.getSimulationInfo().getAuthoritativeVCSimulationIdentifier();
 	if (vcSimID == null){
 		throw new IllegalArgumentException("cannot run an unsaved simulation");
 	}
-	if (!simulation.getVersion().getOwner().equals(localVCellConnection.getUserLoginInfo().getUser())){
+	if (!simulation.getVersion().getOwner().equals(user)){
 		throw new PermissionException("insufficient privilege: startSimulation()");
 	}
-	SimulationTaskInfo simTaskInfo = new SimulationTaskInfo(simTask);
-	LocalSolverController solverController = solverControllerHash.get(simTaskInfo);
+	SolverController solverController = solverControllerHash.get(simulationJob.getSimulationJobID());
 	if (solverController==null){
-		solverController = createNewSolverController(simTask,userSessionLog);
-		solverControllerHash.put(simTaskInfo,solverController);
+		solverController = createNewSolverController(userLoginInfo,simulationJob,userSessionLog);
+		solverControllerHash.put(simulationJob.getSimulationJobID(),solverController);
 	}
 	return solverController;
 }
@@ -230,9 +170,8 @@
  * @return java.lang.String
  * @exception java.rmi.RemoteException The exception description.
  */
-public SolverStatus getSolverStatus(SimulationInfo simulationInfo, int jobIndex, int taskID) throws PermissionException, DataAccessException {
-	SimulationTaskInfo simTaskInfo = new SimulationTaskInfo(simulationInfo, jobIndex, taskID);
-	LocalSolverController solverController = solverControllerHash.get(simTaskInfo);
+public SolverStatus getSolverStatus(User user, SimulationInfo simulationInfo, int jobIndex) throws RemoteException, PermissionException, DataAccessException {
+	SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(simulationInfo.getAuthoritativeVCSimulationIdentifier().getSimulationKey()),jobIndex));
 	if (solverController==null){
 		return new SolverStatus(SolverStatus.SOLVER_READY, SimulationMessage.MESSAGE_SOLVER_READY);
 	}
@@ -240,9 +179,8 @@
 }
 
 
-private File getUserSimulationDirectory(String simDataRoot) {
-	String userName = localVCellConnection.getUserLoginInfo().getUserName();
-	File directory = new File(new File(simDataRoot), userName);
+private File getUserSimulationDirectory(User user, String simDataRoot) {
+	File directory = new File(new File(simDataRoot), user.getName());
 	if (!directory.exists()){
 		if (!directory.mkdirs()){
 			String msg = "could not create directory "+directory;
@@ -253,36 +191,93 @@
 	return directory;
 }
 
+
 /**
  * Insert the method's description here.
+ * Creation date: (2/11/2004 11:26:21 AM)
+ * @param ex java.lang.Exception
+ */
+private void handleException(VCSimulationIdentifier vcSimulationIdentifier, int jobIndex, Exception ex) {
+	VCellServerID serverID = VCellServerID.getSystemServerID();
+	try {
+		SimulationJobStatus oldJobStatus = adminDbServer.getSimulationJobStatus(vcSimulationIdentifier.getSimulationKey(), jobIndex);
+		if (oldJobStatus != null) {
+			serverID = oldJobStatus.getServerID();
+		}
+		SimulationJobStatus newJobStatus = updateFailedJobStatus(oldJobStatus, vcSimulationIdentifier, jobIndex, SimulationMessage.solverAborted(ex.getMessage()));
+		if (newJobStatus == null) {
+			newJobStatus = new SimulationJobStatus(serverID, vcSimulationIdentifier, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_FAILED, -1, SimulationMessage.jobFailed(ex.getMessage()), null, null);
+		}
+		
+		SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), newJobStatus, null, null);
+		fireSimulationJobStatusEvent(event);
+	} catch (DataAccessException e) {
+		SimulationJobStatus newJobStatus = new SimulationJobStatus(serverID, vcSimulationIdentifier, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_FAILED, -1, SimulationMessage.jobFailed(e.getMessage()), null, null);
+		SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), newJobStatus, null, null);
+		fireSimulationJobStatusEvent(event);
+	} catch (RemoteException e) {
+		SimulationJobStatus newJobStatus = new SimulationJobStatus(serverID, vcSimulationIdentifier, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_FAILED, -1, SimulationMessage.jobFailed(e.getMessage()), null, null);
+		SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), newJobStatus, null, null);
+		fireSimulationJobStatusEvent(event);
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
  * Creation date: (3/11/2004 10:44:18 AM)
  * @param newJobStatus cbit.vcell.messaging.db.SimulationJobStatus
  * @param progress java.lang.Double
  * @param timePoint java.lang.Double
  */
-public void onWorkerEvent(WorkerEvent workerEvent) {
+public void onWorkerEvent(WorkerEvent workerEvent) {	
 	try {
+		VCSimulationIdentifier vcSimulationIdentifier = workerEvent.getVCSimulationDataIdentifier().getVcSimID();
+		int jobIndex = workerEvent.getJobIndex();
+		SimulationJobStatus oldJobStatus = adminDbServer.getSimulationJobStatus(vcSimulationIdentifier.getSimulationKey(), jobIndex);
+		SimulationJobStatus newJobStatus = null;
+
+		if (oldJobStatus == null || oldJobStatus.isDone()) {
+			return;
+		}
 		
-		LocalVCMessageListener localVCMessageListener = new LocalVCMessageListener(){
+		if (workerEvent.isCompletedEvent()) {
+			newJobStatus = updateCompletedJobStatus(oldJobStatus, vcSimulationIdentifier, jobIndex, workerEvent.getSimulationMessage());			
 			
-			public void onLocalVCMessage(VCDestination destination, VCMessage objectMessage) {
-				if (destination == VCellTopic.ClientStatusTopic && objectMessage.getObjectContent() instanceof SimulationJobStatus){
-					onClientStatusTopic_SimulationJobStatus(objectMessage);
-				}else{
-					throw new RuntimeException("SimulationControllerImpl.onWorkerEvent().localMessageListener::  expecting object message with SimulationJobStatus to topic "+VCellTopic.ClientStatusTopic.getName()+": received \""+objectMessage.show()+"\"");
-				}
-			}
+		} else if (workerEvent.isFailedEvent()) {
+			newJobStatus = updateFailedJobStatus(oldJobStatus, vcSimulationIdentifier, jobIndex, workerEvent.getSimulationMessage());			
 			
-		};
-		
-		LocalVCMessageAdapter vcMessageSession = new LocalVCMessageAdapter(localVCMessageListener);
-		simulationDispatcherEngine.onWorkerEvent(workerEvent, simulationDatabase, vcMessageSession, adminSessionLog);
-		vcMessageSession.deliverAll();
-	}catch (Exception e){
-		adminSessionLog.exception(e);
+		} else if (workerEvent.isNewDataEvent()) {
+			newJobStatus = updateRunningJobStatus(oldJobStatus, vcSimulationIdentifier, jobIndex, true, workerEvent.getSimulationMessage());
+			
+		} else if (workerEvent.isProgressEvent()) {
+			newJobStatus = updateRunningJobStatus(oldJobStatus, vcSimulationIdentifier, jobIndex, false, workerEvent.getSimulationMessage());
+			
+		} else if (workerEvent.isStartingEvent()) {
+			if (oldJobStatus.isQueued() || oldJobStatus.isDispatched()) {
+				newJobStatus = updateRunningJobStatus(oldJobStatus, vcSimulationIdentifier, jobIndex, false, workerEvent.getSimulationMessage());
+			} else if (oldJobStatus.isRunning()) {
+				newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), oldJobStatus.getVCSimulationIdentifier(), oldJobStatus.getJobIndex(), oldJobStatus.getSubmitDate(), 
+					oldJobStatus.getSchedulerStatus(), oldJobStatus.getTaskID(), workerEvent.getSimulationMessage(), oldJobStatus.getSimulationQueueEntryStatus(), oldJobStatus.getSimulationExecutionStatus());
+			}				
+		}
+		if (workerEvent.isStartingEvent() && newJobStatus != null) {
+			SimulationJobStatusEvent newEvent = new SimulationJobStatusEvent(this, Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), newJobStatus, null, null);
+			fireSimulationJobStatusEvent(newEvent);
+		} else 	if (newJobStatus != null && (!newJobStatus.compareEqual(oldJobStatus) || workerEvent.isProgressEvent() || workerEvent.isNewDataEvent())) {
+			Double progress = workerEvent.getProgress();
+			Double timepoint = workerEvent.getTimePoint();
+			SimulationJobStatusEvent newEvent = new SimulationJobStatusEvent(this, Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), newJobStatus, progress, timepoint);
+			fireSimulationJobStatusEvent(newEvent);
+		}	
+	} catch (DataAccessException ex) {
+		adminSessionLog.exception(ex);
+	} catch (RemoteException ex) {
+		adminSessionLog.exception(ex);
 	}
 }
 
+
 /**
  * removeSimulationStatusEventListener method comment.
  */
@@ -290,91 +285,64 @@
 	listenerList.remove(SimulationJobStatusListener.class, listener);
 }
 
-private void onSimJobQueue_SimulationTask(VCMessage vcMessage) {
-	SimulationTask simTask = null;
-	try {
-		
-		SimulationTaskMessage simTaskMessage = new SimulationTaskMessage(vcMessage);
-		simTask = simTaskMessage.getSimulationTask();
-		
-		LocalSolverController solverController = getOrCreateSolverController(simTask,adminSessionLog);
-		
-		solverController.startSimulationJob(); // can only start after updating the database is done
-		
-	} catch (Exception e) {
-		adminSessionLog.exception(e);
-		KeyValue simKey = simTask.getSimKey();
-		VCSimulationIdentifier vcSimID = simTask.getSimulationJob().getVCDataIdentifier().getVcSimID();
-		int jobIndex = simTask.getSimulationJob().getJobIndex();
-		int taskID = simTask.getTaskID();
-		SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, jobIndex, null, SchedulerStatus.FAILED, taskID, SimulationMessage.jobFailed(e.getMessage()), null, null);
-		SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, Simulation.createSimulationID(simKey), newJobStatus, null, null);
-		fireSimulationJobStatusEvent(event);
-	}
-}
 
 /**
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-public void startSimulation(Simulation simulation, SessionLog userSessionLog) throws Exception {
-
-	LocalVCMessageListener localVCMessageListener = new LocalVCMessageListener(){
-		
-		public void onLocalVCMessage(VCDestination destination, VCMessage vcMessage) {
-			if (destination == VCellTopic.ClientStatusTopic && vcMessage.getObjectContent() instanceof SimulationJobStatus){
-				onClientStatusTopic_SimulationJobStatus(vcMessage);
-			}else if (destination == VCellQueue.SimJobQueue && vcMessage.getStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY).equals(MessageConstants.MESSAGE_TYPE_SIMULATION_JOB_VALUE)){
-				onSimJobQueue_SimulationTask(vcMessage);
-			}else{
-				throw new RuntimeException("SimulationControllerImpl.startSimulation().objectMessageListener:: expecting object message with SimulationJobStatus to topic "+VCellTopic.ClientStatusTopic.getName()+": received \""+vcMessage.show()+"\"");
+public void startSimulation(UserLoginInfo userLoginInfo, Simulation simulation, SessionLog userSessionLog) throws RemoteException, Exception {
+	User user = userLoginInfo.getUser();
+	LocalVCellConnection localVCellConnection = (LocalVCellConnection)getLocalVCellServer().getVCellConnection(userLoginInfo);
+	removeSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+	addSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+	
+	FieldFunctionArguments[] fieldFuncArgs = simulation.getMathDescription().getFieldFunctionArguments();
+	FieldDataIdentifierSpec[] fieldDataIDs = new FieldDataIdentifierSpec[fieldFuncArgs.length];
+	if (fieldFuncArgs.length != 0) {
+		ExternalDataIdentifier[]  qualifiedSpecs =
+			getLocalVCellServer().
+				getVCellConnection(userLoginInfo).
+					getUserMetaDbServer().
+						fieldDataDBOperation(
+								FieldDataDBOperationSpec.createGetExtDataIDsSpec(user)).extDataIDArr;
+		for(int i=0;i<fieldFuncArgs.length;i+= 1){
+			for(int j=0;j<qualifiedSpecs.length;j+= 1){
+				if(fieldFuncArgs[i].getFieldName().equals(qualifiedSpecs[j].getName())){
+					fieldDataIDs[i] = new FieldDataIdentifierSpec(fieldFuncArgs[i],qualifiedSpecs[j]);
+					break;
+				}
 			}
+			if(fieldDataIDs[i] == null){
+				throw new DataAccessException("Failed to resolve FieldData name "+fieldFuncArgs[i].getFieldName()+" for sim "+simulation.getName());
+			}
 		}
-		
-	};
+	} 
 	
-	LocalVCMessageAdapter vcMessageSession = new LocalVCMessageAdapter(localVCMessageListener);
+	boolean serialParameterScan = simulation.isSerialParameterScan();
+	int scanCount = simulation.getScanCount();
+	for (int i = 0; i < scanCount; i++){
+		SimulationJob simJob = new SimulationJob(simulation, i, fieldDataIDs);
+		VCSimulationIdentifier vcSimID = simJob.getVCDataIdentifier().getVcSimID();
+		try {
 
-	removeSimulationJobStatusListener(localVCellConnection.getMessageCollector());
-	addSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+			SolverController solverController = getSolverController(userLoginInfo,simJob,userSessionLog);
+			SimulationJobStatus oldJobStatus = adminDbServer.getSimulationJobStatus(simulation.getKey(),i);	
+			SimulationJobStatus newJobStatus = updateDispatchedJobStatus(oldJobStatus, vcSimID, i);
+			
+			if (newJobStatus != null) {
+				SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, simulation.getSimulationID(), newJobStatus, null, null);
+				fireSimulationJobStatusEvent(event);
+			}
 
-	VCSimulationIdentifier vcSimID = new VCSimulationIdentifier(simulation.getKey(), simulation.getVersion().getOwner());
-	simulationDispatcherEngine.onStartRequest(vcSimID, localVCellConnection.getUserLoginInfo().getUser(), simulation.getScanCount(), simulationDatabase, vcMessageSession, vcMessageSession, adminSessionLog);
-	vcMessageSession.deliverAll();
-	for (int jobIndex = 0; jobIndex < simulation.getScanCount(); jobIndex++){
-		int taskID = -1;
-		SimulationJobStatus[] simJobStatusArray = simulationDatabase.getSimulationJobStatusArray(simulation.getKey(), jobIndex);
-		for (SimulationJobStatus simJobStatus : simJobStatusArray){
-			if (simJobStatus.getTaskID()>taskID){
-				taskID = simJobStatus.getTaskID();
+			if (!serialParameterScan || i == 0 ) {
+				solverController.startSimulationJob(); // can only start after updating the database is done
 			}
-		}
-		simulationDispatcherEngine.onDispatch(vcSimID, jobIndex , taskID, simulationDatabase, vcMessageSession, adminSessionLog);
-		vcMessageSession.deliverAll();
+		} catch (Exception ex) {
+			handleException(vcSimID,i,ex);
+		}	
 	}
 }
 
-private void onServiceControlTopic_StopSimulation(VCMessage message){
-	KeyValue simKey = new KeyValue(String.valueOf(message.getLongProperty(MessageConstants.SIMKEY_PROPERTY)));
-	int jobIndex = message.getIntProperty(MessageConstants.JOBINDEX_PROPERTY);
-	int taskID = message.getIntProperty(MessageConstants.TASKID_PROPERTY);
-	
-	try {
-		SimulationTaskInfo simTaskInfo = new SimulationTaskInfo(simKey, jobIndex, taskID);
-		LocalSolverController solverController = solverControllerHash.get(simTaskInfo);
-		if (solverController!=null){
-			solverController.stopSimulationJob(); // can only start after updating the database is done
-		}
-		
-	} catch (Exception e) {
-		adminSessionLog.exception(e);
-		VCSimulationIdentifier vcSimID = new VCSimulationIdentifier(simKey, localVCellConnection.getUserLoginInfo().getUser());
-		SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, jobIndex, null, SchedulerStatus.FAILED, taskID, SimulationMessage.jobFailed(e.getMessage()), null, null);
-		SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, Simulation.createSimulationID(simKey), newJobStatus, null, null);
-		fireSimulationJobStatusEvent(event);
-	}
-	
-}
 /**
  * This method was created by a SmartGuide.
  * @throws JMSException 
@@ -383,30 +351,158 @@
  * @throws SQLException 
  * @throws FileNotFoundException 
  * @exception java.rmi.RemoteException The exception description.
- * @throws VCMessagingException 
  */
-public void stopSimulation(Simulation simulation) throws FileNotFoundException, SQLException, DataAccessException, AuthenticationException, JMSException, VCMessagingException {	
-	LocalVCMessageListener localVCMessageListener = new LocalVCMessageListener(){
-		
-		public void onLocalVCMessage(VCDestination destination, VCMessage objectMessage) {
-			String messageTypeProperty = MessageConstants.MESSAGE_TYPE_PROPERTY;
-			String stopSimulationValue = MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE;
-			if (destination == VCellTopic.ClientStatusTopic && objectMessage.getObjectContent() instanceof SimulationJobStatus){
-				onClientStatusTopic_SimulationJobStatus(objectMessage);
-			}else if (destination == VCellTopic.ServiceControlTopic && objectMessage.getStringProperty(messageTypeProperty).equals(stopSimulationValue)){
-				onServiceControlTopic_StopSimulation(objectMessage);
-			}else{
-				throw new RuntimeException("SimulationControllerImpl.startSimulation().objectMessageListener:: expecting message with SimulationJobStatus to topic "+VCellTopic.ClientStatusTopic.getName()+": received \""+objectMessage.show()+"\" on destination \""+destination+"\"");
+public void stopSimulation(UserLoginInfo userLoginInfo, Simulation simulation) throws RemoteException, FileNotFoundException, SQLException, DataAccessException, AuthenticationException, JMSException {	
+	User user = userLoginInfo.getUser();
+	LocalVCellConnection localVCellConnection = (LocalVCellConnection)getLocalVCellServer().getVCellConnection(userLoginInfo);
+	removeSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+	addSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+	for (int i = 0; i < simulation.getScanCount(); i++){
+		VCSimulationIdentifier vcSimID = new VCSimulationIdentifier(simulation.getKey(),simulation.getVersion().getOwner());
+		try {
+			if (!vcSimID.getOwner().equals(user)){
+				throw new PermissionException("insufficient privilege: stopSimulation()");
 			}
+			SimulationJobStatus oldJobStatus = adminDbServer.getSimulationJobStatus(vcSimID.getSimulationKey(), i);	
+			SimulationJobStatus newJobStatus = updateStoppedJobStatus(oldJobStatus, vcSimID, i);
+			if (newJobStatus != null) {
+				SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, simulation.getSimulationID(), newJobStatus, null, null);
+				fireSimulationJobStatusEvent(event);
+			}
+				
+			SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimID.getSimulationKey()), i));
+			if (solverController != null){
+				solverController.stopSimulationJob();
+			}
+		} catch (Exception ex) {
+			handleException(vcSimID,i,ex);
 		}
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void stopSimulation(UserLoginInfo userLoginInfo, VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage simulationMessage) {	
+	try {
+		LocalVCellConnection localVCellConnection = (LocalVCellConnection)getLocalVCellServer().getVCellConnection(userLoginInfo);
+		removeSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+		addSimulationJobStatusListener(localVCellConnection.getMessageCollector());
+		if (!vcSimID.getOwner().equals(userLoginInfo.getUser())){
+			throw new PermissionException("insufficient privilege: stopSimulation()");
+		}
+		SimulationJobStatus oldJobStatus = adminDbServer.getSimulationJobStatus(vcSimID.getSimulationKey(),jobIndex);	
+		SimulationJobStatus newJobStatus = updateStoppedJobStatus(oldJobStatus, vcSimID, jobIndex);
+		if (newJobStatus != null) {
+			SimulationJobStatusEvent event = new SimulationJobStatusEvent(this, Simulation.createSimulationID(vcSimID.getSimulationKey()), newJobStatus, null, null);
+			fireSimulationJobStatusEvent(event);
+		}
+			
+		SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimID.getSimulationKey()), jobIndex));
+		if (solverController != null){
+			solverController.stopSimulationJob();
+		}
+	} catch (Exception ex) {
+		handleException(vcSimID,jobIndex,ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/5/2003 11:50:34 AM)
+ * @param sim cbit.vcell.solver.Simulation
+ * @param jobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ */
+private SimulationJobStatus updateCompletedJobStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimulationIdentifier, int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, RemoteException {
+	SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), jobIndex));
+	if (solverController == null) {
+		return null;
+	}
+
+	synchronized (solverController) {
+		String host = (solverController != null) ? solverController.getHost() : null;
 		
-	};
+		return dispatcherDbManager.updateEndStatus(oldJobStatus, adminDbServer, vcSimulationIdentifier, jobIndex, host, SimulationJobStatus.SCHEDULERSTATUS_COMPLETED, simulationMessage);		
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private SimulationJobStatus updateDispatchedJobStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimulationIdentifier, int jobIndex) throws RemoteException, DataAccessException, UpdateSynchronizationException {
+	SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), jobIndex));
+	if (solverController == null) {
+		return null;
+	}
+
+	synchronized (solverController) {	
+		String host = (solverController != null) ? solverController.getHost() : null;
+		
+		return dispatcherDbManager.updateDispatchedStatus(oldJobStatus, adminDbServer, host, vcSimulationIdentifier, jobIndex, SimulationMessage.MESSAGE_JOB_DISPATCHED);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/5/2003 11:50:34 AM)
+ * @param sim cbit.vcell.solver.Simulation
+ * @param jobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ */
+private SimulationJobStatus updateFailedJobStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimulationIdentifier, int jobIndex, SimulationMessage solverMsg) throws DataAccessException, RemoteException {
+	SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), jobIndex));
+	if (solverController == null) {
+		return null;
+	}
 	
-	LocalVCMessageAdapter vcMessageSession = new LocalVCMessageAdapter(localVCMessageListener);
+	synchronized (solverController) {		
+		String host = (solverController != null) ? solverController.getHost() : null;
+		
+		return dispatcherDbManager.updateEndStatus(oldJobStatus, adminDbServer, vcSimulationIdentifier, jobIndex, host, SimulationJobStatus.SCHEDULERSTATUS_FAILED, solverMsg);
+	}
+}
 
-	VCSimulationIdentifier vcSimID = new VCSimulationIdentifier(simulation.getKey(), simulation.getVersion().getOwner());
-	simulationDispatcherEngine.onStopRequest(vcSimID, localVCellConnection.getUserLoginInfo().getUser(), simulationDatabase, vcMessageSession, adminSessionLog);
-	vcMessageSession.deliverAll();
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/5/2003 11:50:34 AM)
+ * @param sim cbit.vcell.solver.Simulation
+ * @param jobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ */
+private SimulationJobStatus updateRunningJobStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimulationIdentifier, int jobIndex, boolean hasData, SimulationMessage solverMsg) throws DataAccessException, RemoteException {
+	SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimulationIdentifier.getSimulationKey()), jobIndex));
+	if (solverController == null) {
+		return null;
+	}
+
+	synchronized (solverController) {
+		String host = (solverController != null) ? solverController.getHost() : null;
+		
+		return dispatcherDbManager.updateRunningStatus(oldJobStatus, adminDbServer, host, vcSimulationIdentifier, jobIndex, hasData, solverMsg);
+	}
 }
 
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/5/2003 11:50:34 AM)
+ * @param sim cbit.vcell.solver.Simulation
+ * @param jobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ */
+private SimulationJobStatus updateStoppedJobStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimID, int jobIndex) throws DataAccessException, RemoteException {	
+	SolverController solverController = solverControllerHash.get(SimulationJob.createSimulationJobID(Simulation.createSimulationID(vcSimID.getSimulationKey()), jobIndex));
+	if (solverController != null) {
+		synchronized (solverController) {
+			return dispatcherDbManager.updateEndStatus(oldJobStatus, adminDbServer, vcSimID, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_STOPPED, SimulationMessage.MESSAGE_JOB_STOPPED);
+		}
+	} else {
+		return dispatcherDbManager.updateEndStatus(oldJobStatus, adminDbServer, vcSimID, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_STOPPED, SimulationMessage.MESSAGE_JOB_STOPPED);
+	}	
 }
+}
Index: src/cbit/vcell/server/LocalVCellBootstrap.java
===================================================================
--- src/cbit/vcell/server/LocalVCellBootstrap.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/server/LocalVCellBootstrap.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.server;
+
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PermissionException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.UserInfo;
+
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.sql.OraclePoolingConnectionFactory;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsConnectionFactoryImpl;
+import cbit.vcell.modeldb.DatabasePolicySQL;
+import cbit.vcell.modeldb.LocalAdminDbServer;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+/**
+ * This class was generated by a SmartGuide.
+ * 
+ */
+@SuppressWarnings("serial")
+public class LocalVCellBootstrap extends UnicastRemoteObject implements VCellBootstrap {
+	private LocalVCellServer localVCellServer = null;
+	private AdminDatabaseServer adminDbServer = null;
+	private SessionLog sessionLog = new StdoutSessionLog(PropertyLoader.ADMINISTRATOR_ACCOUNT);
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+private LocalVCellBootstrap(String hostName, AdminDatabaseServer adminDbServer, JmsConnectionFactory jmsConnFactory) throws RemoteException, FileNotFoundException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortVCellBootstrap,0));
+	this.adminDbServer = adminDbServer;
+	this.localVCellServer = new LocalVCellServer(hostName, jmsConnFactory, adminDbServer);
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.server.DataSetController
+ * @exception java.lang.Exception The exception description.
+ */
+public VCellConnection getVCellConnection(UserLoginInfo userLoginInfo) throws DataAccessException, AuthenticationException {
+	try {
+		VCellConnection vcConn = localVCellServer.getVCellConnection(userLoginInfo);
+		if (vcConn!=null){
+			sessionLog.print("LocalVCellBootstrap.getVCellConnection(" + userLoginInfo.getUserName() +") <<<<SUCCESS>>>>");
+		}else{
+			sessionLog.print("LocalVCellBootstrap.getVCellConnection(" + userLoginInfo.getUserName() +") <<<<RETURNED NULL>>>>");
+		}
+		return vcConn;
+	}catch (RemoteException e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}catch (FileNotFoundException e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}catch (java.sql.SQLException e){
+		sessionLog.exception(e);
+		throw new DataAccessException(e.getMessage());
+	} catch (javax.jms.JMSException ex) {
+		sessionLog.exception(ex);
+		throw new DataAccessException(ex.getMessage());
+	}
+}
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.server.DataSetController
+ * @exception java.lang.Exception The exception description.
+ */
+public VCellServer getVCellServer(User user, UserLoginInfo.DigestedPassword digestedPassword) throws DataAccessException, AuthenticationException, PermissionException {
+	//
+	// Authenticate User
+	//
+	boolean bAuthenticated = false;
+	
+	try{
+		bAuthenticated = adminDbServer.getUser(user.getName(),digestedPassword).compareEqual(user);
+	}catch(RemoteException e){
+		sessionLog.exception(e);
+		throw new DataAccessException("Failure authenticating user "+user.getName()+", RemoteException: " + e.getMessage());
+	}
+	if (!bAuthenticated){
+		sessionLog.print("LocalVCellBootstrap.getVCellServer(" + user +"), didn't authenticate");
+		throw new AuthenticationException("Authentication Failed for user " + user.getName());
+	}else if (user.getName().equals(PropertyLoader.ADMINISTRATOR_ACCOUNT)){
+		sessionLog.print("LocalVCellBootstrap.getVCellServer(" + user + "), returning remote copy of VCellServer");
+		return localVCellServer;
+	}else{
+		sessionLog.print("LocalVCellBootstrap.getVCellServer(" + user + "), insufficient privilege for user "+user.getName());
+		throw new PermissionException("insufficient privilege for user "+user.getName());
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/8/2006 3:25:26 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getVCellSoftwareVersion() {
+	String ver = PropertyLoader.getRequiredProperty(PropertyLoader.vcellSoftwareVersion);
+	sessionLog.print("LocalVCellBootstrap.getVCellSoftwareVersion() : " + ver);
+	return ver;
+}
+/**
+ * main entrypoint - starts the application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	String MESSAGING = "messaging";
+	if (args.length != 4) {
+		System.out.println("usage: cbit.vcell.server.LocalVCellBootstrap host port messaging [logfile|-] \n");
+		System.out.println(" example -  cbit.vcell.server.LocalVCellBootstrap nrcam.vcell.uchc.edu 40099 messaging server.log");
+		System.exit(1);
+	}
+	try {
+		//
+		// Redirect output to the logfile (append if exists)
+		//
+		if (!args[3].equals("-")){
+			System.setOut(new PrintStream(new FileOutputStream(args[3], true), true));
+		}
+		
+		//
+		// Create and install a security manager
+		//
+		//System.setSecurityManager(new RMISecurityManager());
+
+		
+		Thread.currentThread().setName("Application");
+		new PropertyLoader();
+
+		//
+		// get Host and Port
+		//
+		String host = args[0];
+		if (host.equals("localhost")){
+			try {
+				host = java.net.InetAddress.getLocalHost().getHostName();
+			}catch (java.net.UnknownHostException e){
+				// do nothing, "localhost" is ok
+			}
+		}
+		int argRmiPort = Integer.parseInt(args[1]);
+		int rmiPort = PropertyLoader.getIntProperty(PropertyLoader.rmiPortRegistry, argRmiPort);
+
+		if (argRmiPort!=rmiPort){
+			System.out.println("RMI Registry using port ("+rmiPort+") from propertyfile ");
+		}
+		
+
+		VCMongoMessage.serviceStartup(ServiceName.bootstrap, new Integer(rmiPort), args);
+		//
+		// decide whether it will be a Primary or Slave Server
+		//
+		String serverConfig = args[2];
+		if (!serverConfig.equals(MESSAGING)){
+			throw new Exception("expecting '" + MESSAGING + "' as third argument");
+		}
+		JmsConnectionFactory jmsConnFactory = new JmsConnectionFactoryImpl();
+		
+		SessionLog log = new StdoutSessionLog("local(unauthenticated)_administrator");
+		
+		ConnectionFactory conFactory = new OraclePoolingConnectionFactory(log);
+		KeyFactory keyFactory = new cbit.sql.OracleKeyFactory();
+		DatabasePolicySQL.bSilent=true;
+		//
+		// don't timeout entries, and use vcell.properties for cacheSize
+		//
+		LocalVCellConnection.setDatabaseResources(conFactory,keyFactory);
+		
+		AdminDatabaseServer adminDbServer = new LocalAdminDbServer(conFactory,keyFactory,log);
+		LocalVCellBootstrap localVCellBootstrap = new LocalVCellBootstrap(host+":"+rmiPort,adminDbServer,jmsConnFactory);
+		
+		//
+		// spawn the WatchdogMonitor (which spawns the RMI registry, and binds the localVCellBootstrap)
+		//
+		long minuteMS = 60000;
+		long monitorSleepTime = 20*minuteMS;
+		String rmiUrl = "//" + host + ":" + rmiPort + "/VCellBootstrapServer";
+		Thread watchdogMonitorThread = new Thread(new WatchdogMonitor(monitorSleepTime,rmiPort,rmiUrl,localVCellBootstrap,serverConfig),"WatchdogMonitor");
+		watchdogMonitorThread.setDaemon(true);
+		watchdogMonitorThread.setName("WatchdogMonitor");
+		watchdogMonitorThread.start();
+	} catch (Throwable e) {
+		System.out.println("LocalVCellBootstrap err: " + e.getMessage());
+		e.printStackTrace();
+	}
+}
+public UserInfo insertUserInfo(UserInfo newUserInfo) throws RemoteException,DataAccessException {
+	return adminDbServer.insertUserInfo(newUserInfo);
+}
+public void sendLostPassword(String userid) throws RemoteException,DataAccessException {
+	adminDbServer.sendLostPassword(userid);
+}
+
+}
Index: src/cbit/vcell/server/SimulationController.java
===================================================================
--- src/cbit/vcell/server/SimulationController.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/SimulationController.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -20,7 +20,7 @@
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-public void startSimulation(VCSimulationIdentifier vcSimulationIdentifier, int numSimulationScanJobs) throws RemoteException;
+public void startSimulation(VCSimulationIdentifier vcSimulationIdentifier) throws RemoteException;
 
 
 /**
Index: src/cbit/vcell/server/VCellServer.java
===================================================================
--- src/cbit/vcell/server/VCellServer.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/VCellServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -21,6 +21,14 @@
 
 /**
  * This method was created in VisualAge.
+ * @return cbit.vcell.server.AdminDatabaseServer
+ * @exception java.rmi.RemoteException The exception description.
+ */
+AdminDatabaseServer getAdminDatabaseServer() throws RemoteException;
+
+
+/**
+ * This method was created in VisualAge.
  * @return CacheStatus
  */
 CacheStatus getCacheStatus() throws RemoteException;
Index: src/cbit/vcell/server/AdminDatabaseServerXA.java
===================================================================
--- src/cbit/vcell/server/AdminDatabaseServerXA.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/server/AdminDatabaseServerXA.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.server;
+import cbit.vcell.messaging.db.*;
+import java.sql.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+public interface AdminDatabaseServerXA {
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:06:44 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus[]
+ * @param con java.sql.Connection
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatusInfo[] getActiveJobs(java.sql.Connection con, VCellServerID[] serverIDs) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:01:00 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param intervalSeconds long
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus getNextObsoleteSimulation(Connection con, long intervalSeconds) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 1:06:45 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simKey cbit.sql.KeyValue
+ * @param jobIndex int
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus getSimulationJobStatus(Connection con, KeyValue simKey, int jobIndex) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/14/2006 4:08:59 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus[]
+ * @param con java.sql.Connection
+ * @param bActiveOnly boolean
+ * @param userOnly cbit.vcell.server.User
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus[] getSimulationJobStatus(Connection con, boolean bActiveOnly, User userOnly) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:43:20 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus insertSimulationJobStatus(Connection con, SimulationJobStatus simulationJobStatus) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:03:06 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param oldSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @param newSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus updateSimulationJobStatus(Connection con, SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws DataAccessException;
+}
Index: src/cbit/vcell/server/LocalVCellConnection.java
===================================================================
--- src/cbit/vcell/server/LocalVCellConnection.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/LocalVCellConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -11,7 +11,8 @@
 package cbit.vcell.server;
 import java.io.FileNotFoundException;
 import java.net.URL;
-import java.sql.SQLException;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
 
 import org.vcell.util.BeanUtils;
 import org.vcell.util.DataAccessException;
@@ -30,10 +31,7 @@
 import cbit.rmi.event.SimpleMessageService;
 import cbit.sql.ConnectionFactory;
 import cbit.sql.KeyFactory;
-import cbit.vcell.export.server.ExportServiceImpl;
-import cbit.vcell.message.server.dispatcher.SimulationDatabase;
 import cbit.vcell.modeldb.LocalUserMetaDbServer;
-import cbit.vcell.simdata.DataSetControllerImpl;
 import cbit.vcell.simdata.LocalDataSetController;
 import cbit.vcell.visit.VisitConnectionInfo;
 /**
@@ -43,11 +41,8 @@
  * @author: Jim Schaff.
  */
 @SuppressWarnings("serial")
-public class LocalVCellConnection implements VCellConnection, ExportListener, DataJobListener {
+public class LocalVCellConnection extends UnicastRemoteObject implements VCellConnection, ExportListener, DataJobListener {
 	private SimulationController simulationController = null;
-	private SimulationControllerImpl simulationControllerImpl = null;
-	private ExportServiceImpl exportServiceImpl = null;
-	private DataSetControllerImpl dataSetControllerImpl = null;
 	private UserMetaDbServer userMetaDbServer = null;
 	private SimpleMessageService messageService = new SimpleMessageService();
 	private SimpleMessageCollector messageCollector = new SimpleMessageCollector();
@@ -62,6 +57,7 @@
 
 	
 	private SessionLog fieldSessionLog = null;
+	private LocalVCellServer fieldLocalVCellServer = null;
 	private String fieldHost = null;
 	private PerformanceMonitoringFacility performanceMonitoringFacility;
 	private LocalDataSetController localDataSetController;
@@ -70,19 +66,18 @@
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-public LocalVCellConnection(UserLoginInfo userLoginInfo, String host, SessionLog sessionLog, SimulationDatabase simulationDatabase, DataSetControllerImpl dataSetControllerImpl, ExportServiceImpl exportServiceImpl) throws SQLException, FileNotFoundException {
+public LocalVCellConnection(UserLoginInfo userLoginInfo, String host, SessionLog sessionLog, LocalVCellServer aLocalVCellServer) throws RemoteException, java.sql.SQLException, FileNotFoundException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortVCellConnection,0));
 	this.userLoginInfo = userLoginInfo;
 	this.fieldHost = host;
 	this.fieldSessionLog = sessionLog;
-	this.simulationControllerImpl = new SimulationControllerImpl(sessionLog, simulationDatabase, this);
+	this.fieldLocalVCellServer = aLocalVCellServer;
 	sessionLog.print("new LocalVCellConnection(" + userLoginInfo.getUserName() + ")");
 	
 	messageCollector.addMessageListener(messageService);
 	
-	this.exportServiceImpl = exportServiceImpl;
-	this.dataSetControllerImpl = dataSetControllerImpl;
-	this.exportServiceImpl.addExportListener(this);
-	this.dataSetControllerImpl.addDataJobListener(this);
+	getLocalVCellServer().getExportServiceImpl().addExportListener(this);
+	getLocalVCellServer().getDataSetControllerImpl().addDataJobListener(this);
 
 	performanceMonitoringFacility = new PerformanceMonitoringFacility(this.userLoginInfo.getUser(), sessionLog);	
 }
@@ -111,10 +106,10 @@
  * @return cbit.vcell.server.DataSetController
  * @exception java.lang.Exception The exception description.
  */
-public DataSetController getDataSetController() throws DataAccessException {
+public DataSetController getDataSetController() throws RemoteException, DataAccessException {
 	getSessionLog().print("LocalVCellConnection.getDataSetController()");
 	if (localDataSetController == null) {
-		localDataSetController = new LocalDataSetController(this, getSessionLog(), dataSetControllerImpl, exportServiceImpl, getUserLoginInfo().getUser());
+		localDataSetController = new LocalDataSetController(this, getSessionLog(), getLocalVCellServer().getDataSetControllerImpl(), getLocalVCellServer().getExportServiceImpl(), getUserLoginInfo().getUser());
 	}
 
 	return localDataSetController;
@@ -133,6 +128,17 @@
 
 /**
  * Insert the method's description here.
+ * Creation date: (8/29/2000 1:14:39 PM)
+ * @author: John Wagner
+ * @return: the <code>LocalVCellServer</code> associated with this connection.
+ */
+private LocalVCellServer getLocalVCellServer() {
+	return (fieldLocalVCellServer);
+}
+
+
+/**
+ * Insert the method's description here.
  * Creation date: (6/29/01 10:33:49 AM)
  * @return cbit.rmi.event.SimpleMessageService
  */
@@ -159,9 +165,13 @@
  * @param mathDesc cbit.vcell.math.MathDescription
  * @exception java.rmi.RemoteException The exception description.
  */
-public SimulationController getSimulationController() {
+public SimulationController getSimulationController() throws RemoteException {
 	if (simulationController == null){
-		simulationController = new LocalSimulationController(getUserLoginInfo().getUser(),simulationControllerImpl,getSessionLog());
+		try {
+			simulationController = new LocalSimulationController(getUserLoginInfo(),getSessionLog(),getLocalVCellServer().getAdminDatabaseServer(), getLocalVCellServer().getSimulationControllerImpl(),getUserMetaDbServer());
+		}catch (DataAccessException e){
+			throw new RuntimeException("DataAccessException creating LocalSimulationController, :"+e.getMessage());
+		}
 	}
 	return simulationController;
 }
@@ -199,7 +209,7 @@
  * @param userid java.lang.String
  * @exception java.rmi.RemoteException The exception description.
  */
-public UserMetaDbServer getUserMetaDbServer() throws DataAccessException {
+public UserMetaDbServer getUserMetaDbServer() throws RemoteException, DataAccessException {
 	getSessionLog().print("LocalVCellConnection.getUserMetaDbServer(" + getUserLoginInfo().getUser() + ")");
 	if (userMetaDbServer == null) {
 		userMetaDbServer = new LocalUserMetaDbServer(conFactory, keyFactory, getUserLoginInfo().getUser(), getSessionLog());
@@ -212,7 +222,7 @@
  * This method was created in VisualAge.
  * @param conFactory cbit.sql.ConnectionFactory
  */
-public static void setDatabaseResources(ConnectionFactory argConFactory, KeyFactory argKeyFactory) {
+static void setDatabaseResources(ConnectionFactory argConFactory, KeyFactory argKeyFactory) {
 	conFactory = argConFactory;
 	keyFactory = argKeyFactory;
 }
@@ -225,16 +235,16 @@
 }
 
 
-public void sendErrorReport(Throwable exception) {
+public void sendErrorReport(Throwable exception) throws RemoteException {
 	BeanUtils.sendErrorReport(exception);
 }
 
-public MessageEvent[] getMessageEvents() {
+public MessageEvent[] getMessageEvents() throws RemoteException {
 	return messageService.getMessageEvents();
 }
 
 
-public void reportPerformanceMonitorEvent(PerformanceMonitorEvent performanceMonitorEvent) {
+public void reportPerformanceMonitorEvent(PerformanceMonitorEvent performanceMonitorEvent) throws RemoteException {
 	performanceMonitoringFacility.performanceMonitorEvent(performanceMonitorEvent);
 	
 }
Index: src/cbit/vcell/server/LocalSimulationController.java
===================================================================
--- src/cbit/vcell/server/LocalSimulationController.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/LocalSimulationController.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,42 +9,70 @@
  */
 
 package cbit.vcell.server;
+import java.rmi.*;
+
 import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
-import org.vcell.util.document.User;
-
-import cbit.vcell.solver.Simulation;
-import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.solver.*;
 /**
  * Insert the type's description here.
  * Creation date: (6/28/01 12:55:29 PM)
  * @author: Jim Schaff
  */
-public class LocalSimulationController implements SimulationController {
+public class LocalSimulationController extends java.rmi.server.UnicastRemoteObject implements SimulationController {
 	private SessionLog sessionLog = null;
+	private UserLoginInfo userLoginInfo = null;
 	private SimulationControllerImpl simulationControllerImpl = null;
-	private User user = null;
+	private UserMetaDbServer userMetaDbServer = null;
+	private AdminDatabaseServer adminDbServer = null;
 
 /**
  * LocalSimulationController constructor comment.
  * @exception java.rmi.RemoteException The exception description.
  */
-protected LocalSimulationController(User user, SimulationControllerImpl simulationControllerImpl, SessionLog argSessionLog) {
-	this.sessionLog = argSessionLog;
-	this.simulationControllerImpl = simulationControllerImpl;
-	this.user = user;
+protected LocalSimulationController(UserLoginInfo argUserLoginInfo, SessionLog argSessionLog, AdminDatabaseServer adminDbServer0, SimulationControllerImpl argSimulationControllerImpl, UserMetaDbServer argUserMetaDbServer) throws java.rmi.RemoteException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortSimulationController,0));
+	sessionLog = argSessionLog;
+	userLoginInfo = argUserLoginInfo;
+	adminDbServer = adminDbServer0;
+	simulationControllerImpl = argSimulationControllerImpl;
+	userMetaDbServer = argUserMetaDbServer;
 }
 
 
 /**
+ * Insert the method's description here.
+ * Creation date: (6/28/01 1:30:46 PM)
+ * @return cbit.vcell.solver.Simulation
+ * @param simulationInfo cbit.vcell.solver.SimulationInfo
+ */
+private Simulation getSimulation(VCSimulationIdentifier vcSimulationIdentifier) throws DataAccessException, ObjectNotFoundException, RemoteException {
+	String simulationXML = userMetaDbServer.getSimulationXML(vcSimulationIdentifier.getSimulationKey()).toString();
+	Simulation simulation = null;
+	try {
+		simulation = cbit.vcell.xml.XmlHelper.XMLToSim(simulationXML);
+	}catch (cbit.vcell.xml.XmlParseException e){
+		e.printStackTrace(System.out);
+		throw new DataAccessException(e.getMessage());
+	}
+	return simulation;
+}
+
+
+/**
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-public void startSimulation(VCSimulationIdentifier vcSimulationIdentifier, int numSimulationScanJobs) {
+public void startSimulation(VCSimulationIdentifier vcSimulationIdentifier) throws java.rmi.RemoteException {
 	sessionLog.print("LocalSimulationController.startSimulation(simInfo="+vcSimulationIdentifier+")");
 	try {
-		Simulation simulation = simulationControllerImpl.getSimulationDatabase().getSimulation(user,vcSimulationIdentifier.getSimulationKey());
-		simulationControllerImpl.startSimulation(simulation,sessionLog);
+		Simulation simulation = getSimulation(vcSimulationIdentifier);
+		simulationControllerImpl.startSimulation(userLoginInfo,simulation,sessionLog);
+	}catch (RemoteException e){
+		sessionLog.exception(e);
+		throw e;
 	}catch (DataAccessException e){
 		sessionLog.exception(e);
 		throw new RuntimeException(e.getMessage());
@@ -59,11 +87,14 @@
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-public void stopSimulation(VCSimulationIdentifier vcSimulationIdentifier) {
+public void stopSimulation(VCSimulationIdentifier vcSimulationIdentifier) throws java.rmi.RemoteException {
 	sessionLog.print("LocalSimulationController.getSolverStatus(simInfo="+vcSimulationIdentifier+")");
 	try {
-		Simulation simulation = simulationControllerImpl.getSimulationDatabase().getSimulation(user,vcSimulationIdentifier.getSimulationKey());
-		simulationControllerImpl.stopSimulation(simulation);
+		Simulation simulation = getSimulation(vcSimulationIdentifier);
+		simulationControllerImpl.stopSimulation(userLoginInfo,simulation);
+	}catch (RemoteException e){
+		sessionLog.exception(e);
+		throw e;
 	}catch (DataAccessException e){
 		sessionLog.exception(e);
 		throw new RuntimeException(e.getMessage());
Index: src/cbit/vcell/server/AdminDatabaseServer.java
===================================================================
--- src/cbit/vcell/server/AdminDatabaseServer.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/server/AdminDatabaseServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -10,22 +10,23 @@
 
 package cbit.vcell.server;
 
+import java.rmi.*;
+
 import org.vcell.util.DataAccessException;
 import org.vcell.util.document.ExternalDataIdentifier;
 import org.vcell.util.document.KeyValue;
 import org.vcell.util.document.User;
 import org.vcell.util.document.UserInfo;
 
-import cbit.vcell.messaging.db.SimpleJobStatus;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
-import cbit.vcell.messaging.db.UpdateSynchronizationException;
 
 /**
  * This type was created in VisualAge.
  */
-public interface AdminDatabaseServer {
+public interface AdminDatabaseServer extends java.rmi.Remote {
 	
-ExternalDataIdentifier[] getExternalDataIdentifiers(User fielddataOwner) throws DataAccessException;
+ExternalDataIdentifier[] getExternalDataIdentifiers(User fielddataOwner) throws RemoteException, DataAccessException;
 
 /**
  * Insert the method's description here.
@@ -36,12 +37,8 @@
  * @exception java.rmi.RemoteException The exception description.
  */
 
-SimulationJobStatus[] getSimulationJobStatusArray(KeyValue simKey, int jobIndex) throws DataAccessException;
-
-SimulationJobStatus getSimulationJobStatus(KeyValue simKey, int jobIndex, int taskID) throws DataAccessException;
-
-
-java.util.List<SimpleJobStatus> getSimulationJobStatus(String conditions) throws DataAccessException;
+SimulationJobStatus getSimulationJobStatus(KeyValue simKey, int jobIndex) throws RemoteException, DataAccessException;
+	public java.util.List<SimpleJobStatus> getSimulationJobStatus(String conditions) throws RemoteException, DataAccessException;
 /**
  * Insert the method's description here.
  * Creation date: (1/31/2003 2:33:54 PM)
@@ -50,42 +47,42 @@
  * @param userOnly cbit.vcell.server.User
  * @exception java.rmi.RemoteException The exception description.
  */
-SimulationJobStatus[] getSimulationJobStatus(boolean bActiveOnly, User userOnly) throws DataAccessException;
+SimulationJobStatus[] getSimulationJobStatus(boolean bActiveOnly, User userOnly) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-User getUser(String userid) throws DataAccessException;
+User getUser(String userid) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-User getUser(String userid, UserLoginInfo.DigestedPassword digestedPassword) throws DataAccessException;
+User getUser(String userid, UserLoginInfo.DigestedPassword digestedPassword) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-User getUserFromSimulationKey(KeyValue simKey) throws DataAccessException;
+User getUserFromSimulationKey(KeyValue simKey) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-UserInfo getUserInfo(KeyValue userKey) throws DataAccessException;
+UserInfo getUserInfo(KeyValue userKey) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-UserInfo[] getUserInfos() throws DataAccessException;
+UserInfo[] getUserInfos() throws RemoteException, DataAccessException;
 /**
  * Insert the method's description here.
  * Creation date: (1/31/2003 2:30:21 PM)
@@ -93,14 +90,14 @@
  * @param simulationJobStatus cbit.vcell.solvers.SimulationJobStatus
  * @exception java.rmi.RemoteException The exception description.
  */
-SimulationJobStatus insertSimulationJobStatus(SimulationJobStatus simulationJobStatus) throws DataAccessException, UpdateSynchronizationException;
+SimulationJobStatus insertSimulationJobStatus(SimulationJobStatus simulationJobStatus) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-org.vcell.util.document.UserInfo insertUserInfo(org.vcell.util.document.UserInfo newUserInfo) throws DataAccessException;
+org.vcell.util.document.UserInfo insertUserInfo(org.vcell.util.document.UserInfo newUserInfo) throws RemoteException, DataAccessException;
 /**
  * Insert the method's description here.
  * Creation date: (1/31/2003 2:30:21 PM)
@@ -108,15 +105,15 @@
  * @param simulationJobStatus cbit.vcell.solvers.SimulationJobStatus
  * @exception java.rmi.RemoteException The exception description.
  */
-SimulationJobStatus updateSimulationJobStatus(SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws DataAccessException, UpdateSynchronizationException;
+SimulationJobStatus updateSimulationJobStatus(SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws RemoteException, DataAccessException;
 /**
  * This method was created in VisualAge.
  * @return cbit.vcell.server.User
  * @param userid java.lang.String
  * @param password java.lang.String
  */
-org.vcell.util.document.UserInfo updateUserInfo(org.vcell.util.document.UserInfo newUserInfo) throws DataAccessException;
+org.vcell.util.document.UserInfo updateUserInfo(org.vcell.util.document.UserInfo newUserInfo) throws RemoteException, DataAccessException;
 
-void sendLostPassword(String userid) throws DataAccessException;
-void updateUserStat(UserLoginInfo userLoginInfo) throws DataAccessException;
+void sendLostPassword(String userid) throws RemoteException,DataAccessException;
+void updateUserStat(UserLoginInfo userLoginInfo) throws RemoteException,DataAccessException;
 }
Index: src/cbit/vcell/solver/stoch/NetCDFWriter.java
===================================================================
--- src/cbit/vcell/solver/stoch/NetCDFWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/stoch/NetCDFWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,9 +16,7 @@
 import java.util.Hashtable;
 import java.util.Vector;
 
-import org.apache.commons.math.random.RandomDataImpl;
 import org.vcell.util.Compare;
-import org.vcell.util.PropertyLoader;
 
 import ucar.ma2.ArrayChar;
 import ucar.ma2.ArrayDouble;
@@ -37,17 +35,18 @@
 import cbit.vcell.math.VarIniCondition;
 import cbit.vcell.math.VarIniCount;
 import cbit.vcell.math.Variable;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
-import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.messaging.JmsUtils;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationSymbolTable;
 import cbit.vcell.solver.SolverTaskDescription;
 import cbit.vcell.solver.TimeBounds;
 import cbit.vcell.solver.UniformOutputTimeSpec;
 
+import org.apache.commons.math.random.RandomDataImpl;
+
 /**
  * This class is used to write input file for stochastic hybrid solvers.
  * The input file will be in NetCDF format containing all the requred model information
@@ -60,7 +59,7 @@
 public class NetCDFWriter {
 
 	private String filename = null;
-	private SimulationTask simTask = null;
+	private SimulationJob simJob = null;
 	// to store variables and their orders in the reactions. It is set to global in this
 	// class, since it is useful in a few functions and we don't want to calculate it 
 	// again and again. it is calculated in function getReactionRateLaws.
@@ -71,9 +70,9 @@
 	 * another constructor
 	 * @param arg_simulation
 	 */
-	public NetCDFWriter(SimulationTask simTask, String fn, boolean argMessaging) 
+	public NetCDFWriter(SimulationJob arg_simulationJob, String fn, boolean argMessaging) 
 	{
-		this.simTask = simTask;
+		simJob = arg_simulationJob;
 		filename = fn;
 		bMessaging = argMessaging;
 	}
@@ -87,7 +86,7 @@
 	 */
 	public boolean initialize() throws Exception
 	{
-		Simulation simulation = simTask.getSimulation();	
+		Simulation simulation = simJob.getSimulation();	
 		//check variables
 		if(!simulation.getMathDescription().getVariables().hasMoreElements())
 		{
@@ -128,8 +127,8 @@
 	 */
 	public void writeHybridInputFile(String[] parameterNames) throws Exception,cbit.vcell.parser.ExpressionException,IOException, MathException, InvalidRangeException
 	{
-		Simulation simulation = simTask.getSimulation();
-		SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+		Simulation simulation = simJob.getSimulation();
+		SimulationSymbolTable simSymbolTable = simJob.getSimulationSymbolTable();
 		if(initialize())
 		{
 			//we need to get model and control information first
@@ -254,15 +253,15 @@
 				// write jms info
 				if (bMessaging) {
 					ArrayChar.D1 jmsString = new ArrayChar.D1(stringLen.getLength());
-					jmsString.setString(PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL));
+					jmsString.setString(JmsUtils.getJmsUrl());
 					ncfile.write("JMS_BROKER", jmsString);
-					jmsString.setString(PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser));
+					jmsString.setString(JmsUtils.getJmsUserID());
 					ncfile.write("JMS_USER", jmsString);
-					jmsString.setString(PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword));
+					jmsString.setString(JmsUtils.getJmsPassword());
 					ncfile.write("JMS_PASSWORD", jmsString);
-					jmsString.setString(VCellQueue.WorkerEventQueue.getName());
+					jmsString.setString(JmsUtils.getQueueWorkerEvent());
 					ncfile.write("JMS_QUEUE", jmsString);
-					jmsString.setString(VCellTopic.ServiceControlTopic.getName());
+					jmsString.setString(JmsUtils.getTopicServiceControl());
 					ncfile.write("JMS_TOPIC", jmsString);
 					jmsString.setString(simulation.getVersion().getOwner().getName());
 					ncfile.write("VCELL_USER", jmsString);
@@ -270,7 +269,7 @@
 					ArrayInt.D0 scalarJMS = new ArrayInt.D0();
 					scalarJMS.set(Integer.parseInt(simulation.getVersion().getVersionKey()+""));
 					ncfile.write("SIMULATION_KEY", scalarJMS);
-					scalarJMS.set(simTask.getSimulationJob().getJobIndex());
+					scalarJMS.set(simJob.getJobIndex());
 					ncfile.write("JOB_INDEX", scalarJMS);
 				}
 
@@ -569,7 +568,7 @@
 	 */		
 	private  ReactionRateLaw[] getReactionRateLaws(Expression[] probs) throws ExpressionException, MathException
 	{
-		SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+		SimulationSymbolTable simSymbolTable = simJob.getSimulationSymbolTable();
 		
 		ReactionRateLaw[] results = new ReactionRateLaw[probs.length];
 		varInProbOrderHash = new Hashtable[probs.length];
@@ -712,7 +711,7 @@
 		
 	private String[] getVariableSymbols(String[] symbols)
 	{
-		Simulation simulation = simTask.getSimulation();
+		Simulation simulation = simJob.getSimulation();
 		
 		Vector<String> vars = new Vector<String>();
 		if(symbols != null)
Index: src/cbit/vcell/solver/stoch/GibsonSolver.java
===================================================================
--- src/cbit/vcell/solver/stoch/GibsonSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/stoch/GibsonSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -26,7 +26,6 @@
 import cbit.vcell.math.MathException;
 import cbit.vcell.math.AnnotatedFunction.FunctionCategory;
 import cbit.vcell.math.Variable.Domain;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.simdata.VariableType;
@@ -51,8 +50,8 @@
 	private int saveToFileInterval = 6;	// seconds
 	private long lastSavedMS = 0; // milliseconds since last save
 
-public GibsonSolver(SimulationTask simTask, java.io.File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
-	super(simTask, directory, sessionLog, bMessaging);
+public GibsonSolver(SimulationJob simulationJob, java.io.File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
+	super(simulationJob, directory, sessionLog, bMessaging);
 }
 
 
@@ -176,7 +175,7 @@
 	Add appropriate Function columns to result set if the stochastic simulation is to display the trajectory.
 	No function columns for the results of multiple stochastic trials
 	*/
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	if(simSymbolTable.getSimulation().getSolverTaskDescription().getStochOpt().getNumOfTrials() == 1)
 	{
 		Function functions[] = simSymbolTable.getFunctions();
@@ -218,7 +217,8 @@
 	writeFunctionsFile();
 	writeLogFile();
 
-	String inputFilename = getInputFilename();
+	String inputFilename = getBaseName() + STOCHINPUT_DATA_EXTENSION;	
+	String outputFileName = getBaseName() + IDA_DATA_EXTENSION;
 	sessionLog.print("StochSolver.initialize() baseName = " + getBaseName());
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INPUT_FILE));
@@ -227,7 +227,7 @@
 	PrintWriter pw = null;
 	try {
 		pw = new PrintWriter(inputFilename);
-		StochFileWriter stFileWriter = new StochFileWriter(pw, simTask, bMessaging);
+		StochFileWriter stFileWriter = new StochFileWriter(pw, simulationJob, bMessaging);
 		stFileWriter.write();
 	} catch (Exception e) {
 		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, SimulationMessage.solverAborted("Could not generate input file: " + e.getMessage())));
@@ -241,26 +241,12 @@
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,SimulationMessage.MESSAGE_SOLVER_RUNNING_START));	
 	//get executable path+name.
-	setMathExecutable(new MathExecutable(getMathExecutableCommand()));	
+	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.stochExecutableProperty);
+	setMathExecutable(new MathExecutable(new String[] {executableName, "gibson", inputFilename, outputFileName}));	
 	//setMathExecutable(new cbit.vcell.solvers.MathExecutable(executableName + " gibson " + getBaseName() + ".stochInput" + " " + getBaseName() + ".stoch"));
 }
 
-private String getInputFilename(){
-	return getBaseName() + STOCHINPUT_DATA_EXTENSION;	
-}
 
-private String getOutputFilename(){
-	return getBaseName() + IDA_DATA_EXTENSION;
-}
-
-@Override
-public String[] getMathExecutableCommand() {
-	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.stochExecutableProperty);
-	String inputFilename = getInputFilename();
-	String outputFilename = getOutputFilename();
-	return new String[] { executableName, "gibson", inputFilename, outputFilename };
-}
-
 /**
  * Write out the log file and result binary file.
  * Creation date: (8/15/2006 9:44:06 AM)
@@ -285,7 +271,7 @@
 //	cbit.vcell.solver.ode.ODESimData.writeODEDataFile(stSimData, dataFile);
 //	stSimData.writeODELogFile(logFile, dataFile);
 	// fire event to inform that solver has data printed. however, for gibson multiple trial and hybrid solvers, we don't show intermediate results
-	if(simTask.getSimulation().getSolverTaskDescription().getStochOpt().getNumOfTrials() == 1)
+	if(simulationJob.getSimulation().getSolverTaskDescription().getStochOpt().getNumOfTrials() == 1)
 		fireSolverPrinted(getCurrentTime());
 }
 
@@ -372,7 +358,7 @@
 	//
 	Vector<AnnotatedFunction> funcList = new Vector<AnnotatedFunction>();
 	
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Function functions[] = simSymbolTable.getFunctions();
 	for (int i = 0; i < functions.length; i++){
 		if (SimulationSymbolTable.isFunctionSaved(functions[i])){
Index: src/cbit/vcell/solver/stoch/HybridSolver.java
===================================================================
--- src/cbit/vcell/solver/stoch/HybridSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/stoch/HybridSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -28,7 +28,6 @@
 import cbit.vcell.math.MathException;
 import cbit.vcell.math.AnnotatedFunction.FunctionCategory;
 import cbit.vcell.math.Variable.Domain;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.simdata.VariableType;
@@ -66,8 +65,8 @@
 	private int integratorType = EMIntegrator;
 
 
-public HybridSolver(SimulationTask simTask, java.io.File directory, SessionLog sessionLog, int type, boolean b_Msging) throws cbit.vcell.solver.SolverException {
-	super(simTask, directory, sessionLog, b_Msging);
+public HybridSolver(SimulationJob simulationJob, java.io.File directory, SessionLog sessionLog, int type, boolean b_Msging) throws cbit.vcell.solver.SolverException {
+	super(simulationJob, directory, sessionLog, b_Msging);
 	integratorType = type;
 }
 
@@ -269,7 +268,7 @@
 	 *No function columns for the results of multiple stochastic trials.
 	 *In stochastic simulation the functions include probability functions and clamped variable.
 	 */
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	if(simSymbolTable.getSimulation().getSolverTaskDescription().getStochOpt().getNumOfTrials() == 1)
 	{
 		Function functions[] = simSymbolTable.getFunctions();
@@ -333,11 +332,11 @@
 	
 	
 	//
-	String inputFilename = getInputFilename();//file used by precompiled solver.
+	String inputFilename = getBaseName() + ".nc";//file used by precompiled solver.
 	//
 	sessionLog.print("HybridSolver.initialize() baseName = " + getBaseName());
 	//
-	NetCDFWriter ncWriter = new NetCDFWriter(simTask,inputFilename, bMessaging);
+	NetCDFWriter ncWriter = new NetCDFWriter(simulationJob,inputFilename, bMessaging);
 	try {
 		ncWriter.initialize();
 	} catch (Exception e) {
@@ -360,15 +359,6 @@
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,SimulationMessage.MESSAGE_SOLVER_RUNNING_START));	
 	//get executable path+name.
 	//Hybrid solver's usage: ProgramName <NetCDF Filename> <epsilon> <lambda> <MSR_Tolerance> <SDE_Tolerance> <SDE_dt> [-R <Random Seed>] [-OV]
-	setMathExecutable(new MathExecutable(getMathExecutableCommand()));
-}
-
-private String getInputFilename(){
-	return getBaseName() + ".nc";//file used by precompiled solver.
-}
-
-@Override
-public String[] getMathExecutableCommand() {
 	String executableName = "";
 	String randomNumber = "";
 	//if one of the following paras is applied, all the paras in front of it must be set.
@@ -379,7 +369,7 @@
 	String SDE_dt = " 0.1";
 	String paraString = "";
 
-	SolverTaskDescription solverTaskDescription = simTask.getSimulation().getSolverTaskDescription();
+	SolverTaskDescription solverTaskDescription = simulationJob.getSimulation().getSolverTaskDescription();
 	if(solverTaskDescription.getStochOpt() instanceof StochHybridOptions)
 	{
 		StochHybridOptions sho = ((StochHybridOptions)solverTaskDescription.getStochOpt());
@@ -410,13 +400,13 @@
 	
 	ArrayList<String> commandList = new ArrayList<String>();
 	commandList.add(executableName);
-	commandList.add(getInputFilename());
+	commandList.add(inputFilename);
 	String argumentString = paraString.toLowerCase() +randomNumber + " -OV";
 	StringTokenizer st = new StringTokenizer(argumentString);
 	while (st.hasMoreTokens()) {
 		commandList.add(st.nextToken());
 	}	
-	return commandList.toArray(new String[0]);
+	setMathExecutable(new MathExecutable(commandList.toArray(new String[0])));
 }
 
 
@@ -531,7 +521,7 @@
 	//
 	Vector<AnnotatedFunction> funcList = new Vector<AnnotatedFunction>();
 	
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	Function functions[] = simSymbolTable.getFunctions();
 	for (int i = 0; i < functions.length; i++){
Index: src/cbit/vcell/solver/stoch/StochFileWriter.java
===================================================================
--- src/cbit/vcell/solver/stoch/StochFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/stoch/StochFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -23,7 +23,6 @@
 import cbit.vcell.math.SubDomain;
 import cbit.vcell.math.VarIniCondition;
 import cbit.vcell.math.VarIniCount;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.DefaultOutputTimeSpec;
@@ -46,9 +45,9 @@
 /**
  * StochFileWriter constructor comment.
  */
-public StochFileWriter(PrintWriter pw, SimulationTask simTask, boolean bMessaging) 
+public StochFileWriter(PrintWriter pw, SimulationJob arg_simulationJob, boolean bMessaging) 
 {
-	super(pw, simTask, bMessaging);
+	super(pw, arg_simulationJob, bMessaging);
 }
 
 
@@ -73,7 +72,7 @@
 			if(!process.compareEqual(processList.get(i)))//to avoid comparing with it's own
 			{
 				Expression probExp = processList.get(i).getProbabilityRate();
-				probExp = simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(probExp).flatten();
+				probExp = simulationJob.getSimulationSymbolTable().substituteFunctions(probExp).flatten();
 				String[] vars = probExp.getSymbols();
 				if((vars != null)&&(vars.length>0))
 				{				
@@ -117,7 +116,7 @@
  */
 public void initialize() throws Exception
 {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	//check variables
 	if(!simulation.getMathDescription().getVariables().hasMoreElements())
 	{
@@ -145,7 +144,7 @@
  */
 public boolean isValidProbabilityExpression(Expression probExp)
 {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	
 	String[] symbols = probExp.getSymbols();
 	for(int i=0; symbols != null && i<symbols.length; i++)
@@ -164,8 +163,8 @@
  */
 public void write(String[] parameterNames) throws Exception,ExpressionException
 {
-	Simulation simulation = simTask.getSimulation();
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable(); 
+	Simulation simulation = simulationJob.getSimulation();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable(); 
 	
 	initialize();
 	
Index: src/cbit/vcell/solver/SolverFactory.java
===================================================================
--- src/cbit/vcell/solver/SolverFactory.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/SolverFactory.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,7 +15,6 @@
 import org.vcell.solver.smoldyn.SmoldynSolver;
 import org.vcell.util.SessionLog;
 
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.ode.AdamsMoultonFiveSolver;
 import cbit.vcell.solver.ode.CVodeSolverStandalone;
 import cbit.vcell.solver.ode.ForwardEulerSolver;
@@ -39,44 +38,44 @@
 /**
  * create Solvers according to the solver description.
  */
-public static Solver createSolver(SessionLog sessionLog, File directory, SimulationTask simTask, boolean bMessaging) throws SolverException {
-	SolverDescription solverDescription = simTask.getSimulationJob().getSimulation().getSolverTaskDescription().getSolverDescription();
+public static Solver createSolver(SessionLog sessionLog, File directory, SimulationJob simJob, boolean bMessaging) throws SolverException {
+	SolverDescription solverDescription = simJob.getSimulation().getSolverTaskDescription().getSolverDescription();
 	if (solverDescription == null) {
 		throw new IllegalArgumentException("SolverDescription cannot be null");
 	}
 	Solver solver = null;
 	if (solverDescription.equals(SolverDescription.ForwardEuler)) {
-		solver = new ForwardEulerSolver(simTask, directory, sessionLog);
+		solver = new ForwardEulerSolver(simJob, directory, sessionLog);
 	} else if (solverDescription.equals(SolverDescription.RungeKutta2)) {
-		solver = new RungeKuttaTwoSolver(simTask, directory, sessionLog);
+		solver = new RungeKuttaTwoSolver(simJob, directory, sessionLog);
 	} else if (solverDescription.equals(SolverDescription.RungeKutta4)) {
-		solver = new RungeKuttaFourSolver(simTask, directory, sessionLog);
+		solver = new RungeKuttaFourSolver(simJob, directory, sessionLog);
 	} else if (solverDescription.equals(SolverDescription.AdamsMoulton)) {
-		solver = new AdamsMoultonFiveSolver(simTask, directory, sessionLog);
+		solver = new AdamsMoultonFiveSolver(simJob, directory, sessionLog);
 	} else if (solverDescription.equals(SolverDescription.RungeKuttaFehlberg)) {
-		solver = new RungeKuttaFehlbergSolver(simTask, directory, sessionLog);
+		solver = new RungeKuttaFehlbergSolver(simJob, directory, sessionLog);
 	} else if (solverDescription.equals(SolverDescription.IDA)) {
-		solver = new IDASolverStandalone(simTask, directory, sessionLog, bMessaging);
+		solver = new IDASolverStandalone(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.CVODE)) {
-		solver = new CVodeSolverStandalone(simTask, directory, sessionLog, bMessaging);
+		solver = new CVodeSolverStandalone(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.CombinedSundials)) {
-		solver = new CombinedSundialsSolver(simTask, directory, sessionLog, bMessaging);
+		solver = new CombinedSundialsSolver(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.FiniteVolume)) {
-		solver = new FVSolver(simTask, directory, sessionLog, bMessaging);
+		solver = new FVSolver(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.FiniteVolumeStandalone)) {
-		solver = new FVSolverStandalone(simTask, directory, sessionLog, bMessaging);
+		solver = new FVSolverStandalone(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.SundialsPDE)) {
-		solver = new FVSolverStandalone(simTask, directory, sessionLog, bMessaging);
+		solver = new FVSolverStandalone(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.StochGibson)) {
-		solver = new GibsonSolver(simTask, directory, sessionLog, bMessaging);
+		solver = new GibsonSolver(simJob, directory, sessionLog, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.HybridEuler)) {
-		solver = new cbit.vcell.solver.stoch.HybridSolver(simTask, directory, sessionLog, HybridSolver.EMIntegrator, bMessaging);
+		solver = new cbit.vcell.solver.stoch.HybridSolver(simJob, directory, sessionLog, HybridSolver.EMIntegrator, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.HybridMilstein)) {
-		solver = new cbit.vcell.solver.stoch.HybridSolver(simTask, directory, sessionLog, HybridSolver.MilsteinIntegrator, bMessaging);
+		solver = new cbit.vcell.solver.stoch.HybridSolver(simJob, directory, sessionLog, HybridSolver.MilsteinIntegrator, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.HybridMilAdaptive)) {
-		solver = new cbit.vcell.solver.stoch.HybridSolver(simTask, directory, sessionLog, HybridSolver.AdaptiveMilsteinIntegrator, bMessaging);
+		solver = new cbit.vcell.solver.stoch.HybridSolver(simJob, directory, sessionLog, HybridSolver.AdaptiveMilsteinIntegrator, bMessaging);
 	} else if (solverDescription.equals(SolverDescription.Smoldyn)) {
-		solver = new SmoldynSolver(simTask, directory, sessionLog, bMessaging);
+		solver = new SmoldynSolver(simJob, directory, sessionLog, bMessaging);
 	}
 	else {
 		throw new SolverException("Unknown solver: " + solverDescription);
Index: src/cbit/vcell/solver/SolverEvent.java
===================================================================
--- src/cbit/vcell/solver/SolverEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/SolverEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -10,7 +10,7 @@
 
 package cbit.vcell.solver;
 
-import cbit.vcell.message.server.htc.HtcJobID;
+import cbit.htc.PbsJobID;
 import cbit.vcell.solvers.AbstractSolver;
 
 /**
@@ -36,18 +36,18 @@
 	private SimulationMessage fieldSimulationMessage = null;
 	private double fieldTimePoint = -1;
 	private double fieldProgress = -1;
-	private HtcJobID fieldHtcJobId = null;
+	private PbsJobID fieldPbsJobId = null;
 /**
  * IntegratorEvent constructor comment.
  * @param source java.lang.Object
  */
-public SolverEvent(AbstractSolver source, int type, SimulationMessage simulationMessage, double progress, double timePoint, HtcJobID htcJobId) {
+public SolverEvent(AbstractSolver source, int type, SimulationMessage simulationMessage, double progress, double timePoint, PbsJobID pbsJobId) {
 	super(source);
 	this.fieldSimulationMessage = simulationMessage;
 	this.fieldType = type;
 	this.fieldProgress = progress;
 	this.fieldTimePoint = timePoint;
-	this.fieldHtcJobId = htcJobId;
+	this.fieldPbsJobId = pbsJobId;
 }
 /**
  * Insert the method's description here.
@@ -81,8 +81,8 @@
 	return fieldType;
 }
 
-public HtcJobID getPbsJobId(){
-	return fieldHtcJobId;
+public PbsJobID getPbsJobId(){
+	return fieldPbsJobId;
 }
 /**
  * Insert the method's description here.
Index: src/cbit/vcell/solver/SimulationMessage.java
===================================================================
--- src/cbit/vcell/solver/SimulationMessage.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/SimulationMessage.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -14,8 +14,8 @@
 
 import org.vcell.util.Compare;
 
-import cbit.vcell.message.server.htc.HtcJobID;
-import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.htc.PbsJobID;
+import cbit.vcell.messaging.db.SimulationJobStatus;
 
 public class SimulationMessage implements Serializable {
 	
@@ -58,7 +58,6 @@
 		JOB_RUNNING,
 		SOLVEREVENT_PROGRESS,
 		WORKEREVENT_PROGRESS,
-		WORKEREVENT_WORKEREXIT,
 		SOLVEREVENT_FINISHED,
 		SOLVER_FINISHED,
 		WORKEREVENT_COMPLETED,
@@ -114,7 +113,7 @@
 	
 	private final DetailedState detailedState;
 	private final String message;
-	private HtcJobID htcJobId;
+	private PbsJobID pbsJobId;
 	private SimulationMessage(DetailedState detailedState, String message){
 		this.detailedState = detailedState;
 		this.message = message;
@@ -128,44 +127,44 @@
 	}
 	
 
-	public static SimulationMessage fromSerialized(SchedulerStatus schedulerStatus, String serializedMessage){
+	public static SimulationMessage fromSerialized(int schedulerStatus, String serializedMessage){
 		
 		SimulationMessage simulationMessage = fromSerializedMessage(serializedMessage);
 		if (simulationMessage != null) {
 			return simulationMessage;
 		}
 		
-		if (schedulerStatus == SchedulerStatus.WAITING){
+		if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_WAITING){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_WAITING;
 			}
 			return new SimulationMessage(DetailedState.JOB_WAITING, serializedMessage);
-		}else if (schedulerStatus == SchedulerStatus.QUEUED){
+		}else if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_QUEUED){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_QUEUED;
 			}
 			return new SimulationMessage(DetailedState.JOB_QUEUED, serializedMessage);
-		}else if (schedulerStatus == SchedulerStatus.DISPATCHED){
+		}else if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_DISPATCHED){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_DISPATCHED;
 			}
 			return new SimulationMessage(DetailedState.JOB_DISPATCHED, serializedMessage);
-		}else if (schedulerStatus == SchedulerStatus.RUNNING){
+		}else if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_RUNNING){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_RUNNING_UNKNOWN;
 			}
 			return new SimulationMessage(DetailedState.JOB_RUNNING, serializedMessage);
-		}else if (schedulerStatus == SchedulerStatus.COMPLETED){
+		}else if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_COMPLETED){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_COMPLETED;
 			}
 			return new SimulationMessage(DetailedState.JOB_COMPLETED, serializedMessage);
-		}else if (schedulerStatus == SchedulerStatus.STOPPED){
+		}else if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_STOPPED){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_STOPPED;
 			}
 			return new SimulationMessage(DetailedState.JOB_STOPPED, serializedMessage);
-		}else if (schedulerStatus == SchedulerStatus.FAILED){
+		}else if (schedulerStatus == SimulationJobStatus.SCHEDULERSTATUS_FAILED){
 			if (serializedMessage == null) {
 				return MESSAGE_JOB_FAILED_UNKNOWN;
 			}
@@ -240,13 +239,9 @@
 		return new SimulationMessage(DetailedState.JOB_FAILED,failureMessage);
 	}
 
-	public static SimulationMessage WorkerExited(int solverExitCode){
-		return new SimulationMessage(DetailedState.WORKEREVENT_WORKEREXIT,"solver exited (code="+solverExitCode+")");
-	}
-
-	public static SimulationMessage solverEvent_Starting_Submit(String submitMsg, HtcJobID htcJobId){
+	public static SimulationMessage solverEvent_Starting_Submit(String submitMsg, PbsJobID pbsJobId){
 		SimulationMessage simMessage = new SimulationMessage(DetailedState.SOLVEREVENT_STARTING_SUBMITTED,submitMsg);
-		simMessage.htcJobId = htcJobId;
+		simMessage.pbsJobId = pbsJobId;
 		return simMessage;
 	}
 	
@@ -262,8 +257,8 @@
 		return detailedState;
 	}
 	
-	public HtcJobID getHtcJobId(){
-		return htcJobId;
+	public PbsJobID getPbsJobId(){
+		return pbsJobId;
 	}
 	
 	@Override
Index: src/cbit/vcell/solver/SolverFileWriter.java
===================================================================
--- src/cbit/vcell/solver/SolverFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/SolverFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,13 +9,9 @@
  */
 
 package cbit.vcell.solver;
-import java.io.PrintWriter;
+import java.io.*;
 
-import org.vcell.util.PropertyLoader;
-
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
-import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.messaging.JmsUtils;
 /**
  * Insert the type's description here.
  * Creation date: (3/8/00 10:29:24 PM)
@@ -24,7 +20,7 @@
 public abstract class SolverFileWriter {
 	protected PrintWriter printWriter = null;
 	protected boolean bUseMessaging = true;
-	protected final SimulationTask simTask;
+	protected final SimulationJob simulationJob;
 
 	enum SolverInputFileKeyword {
 		JMS_PARAM_BEGIN,
@@ -40,9 +36,9 @@
 /**
  * OdeFileCoder constructor comment.
  */
-public SolverFileWriter(PrintWriter pw, SimulationTask simTask, boolean messaging) {
+public SolverFileWriter(PrintWriter pw, SimulationJob simJob, boolean messaging) {
 	printWriter = pw;
-	this.simTask = simTask;
+	simulationJob = simJob;
 	bUseMessaging = messaging;
 }
 
@@ -69,13 +65,13 @@
 	if (bUseMessaging) {
 		printWriter.println("# JMS_Paramters");
 		printWriter.println(SolverInputFileKeyword.JMS_PARAM_BEGIN);
-		printWriter.println(SolverInputFileKeyword.JMS_BROKER + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL));
-	    printWriter.println(SolverInputFileKeyword.JMS_USER + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser) + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword));
-	    printWriter.println(SolverInputFileKeyword.JMS_QUEUE + " " + VCellQueue.WorkerEventQueue.getName());  
-		printWriter.println(SolverInputFileKeyword.JMS_TOPIC + " " + VCellTopic.ServiceControlTopic.getName());
-		printWriter.println(SolverInputFileKeyword.VCELL_USER + " " + simTask.getSimulation().getVersion().getOwner().getName());
-		printWriter.println(SolverInputFileKeyword.SIMULATION_KEY + " " + simTask.getSimulation().getVersion().getVersionKey());
-		printWriter.println(SolverInputFileKeyword.JOB_INDEX + " " + simTask.getSimulationJob().getJobIndex());
+		printWriter.println(SolverInputFileKeyword.JMS_BROKER + " " + JmsUtils.getJmsUrl());
+	    printWriter.println(SolverInputFileKeyword.JMS_USER + " " + JmsUtils.getJmsUserID() + " " + JmsUtils.getJmsPassword());
+	    printWriter.println(SolverInputFileKeyword.JMS_QUEUE + " " + JmsUtils.getQueueWorkerEvent());  
+		printWriter.println(SolverInputFileKeyword.JMS_TOPIC + " " + JmsUtils.getTopicServiceControl());
+		printWriter.println(SolverInputFileKeyword.VCELL_USER + " " + simulationJob.getSimulation().getVersion().getOwner().getName());
+		printWriter.println(SolverInputFileKeyword.SIMULATION_KEY + " " + simulationJob.getSimulation().getVersion().getVersionKey());
+		printWriter.println(SolverInputFileKeyword.JOB_INDEX + " " + simulationJob.getJobIndex());
 		printWriter.println(SolverInputFileKeyword.JMS_PARAM_END);
 		printWriter.println();
 	}
Index: src/cbit/vcell/solver/SimulationJob.java
===================================================================
--- src/cbit/vcell/solver/SimulationJob.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/SimulationJob.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,12 +9,9 @@
  */
 
 package cbit.vcell.solver;
-import org.vcell.util.Compare;
-import org.vcell.util.Matchable;
-
 import cbit.vcell.field.FieldDataIdentifierSpec;
 
-public class SimulationJob implements java.io.Serializable, Matchable {
+public class SimulationJob implements java.io.Serializable {
 	private Simulation sim = null;
 	private int jobIndex = -1;				// expect non-negative value.
 	private FieldDataIdentifierSpec[] fieldDataIdentifierSpecs = null;
@@ -101,29 +98,4 @@
 	}
 	return simulationSymbolTable;
 }
-
-public boolean compareEqual(Matchable obj) {
-	if (obj instanceof SimulationJob){
-		SimulationJob other = (SimulationJob)obj;
-		if (!Compare.isEqual(getSimulation(), other.getSimulation())){
-			return false;
-		}
-		if (!Compare.isEqual(getJobIndex(), other.getJobIndex())){
-			return false;
-		}
-		FieldDataIdentifierSpec[] thisFDIS = null;
-		if (this.fieldDataIdentifierSpecs!=null && this.fieldDataIdentifierSpecs.length>0){
-			thisFDIS = this.fieldDataIdentifierSpecs;
-		}
-		FieldDataIdentifierSpec[] otherFDIS = null;
-		if (other.fieldDataIdentifierSpecs!=null && other.fieldDataIdentifierSpecs.length>0){
-			otherFDIS = other.fieldDataIdentifierSpecs;
-		}
-		if (!Compare.isEqualOrNull(thisFDIS,otherFDIS)){
-			return false;
-		}
-		return true;
-	}
-	return false;
 }
-}
Index: src/cbit/vcell/solver/ode/AbstractJavaSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/AbstractJavaSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/AbstractJavaSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -14,7 +14,6 @@
 
 import org.vcell.util.SessionLog;
 
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.DefaultOutputTimeSpec;
 import cbit.vcell.solver.OutputTimeSpec;
 import cbit.vcell.solver.Simulation;
@@ -44,8 +43,8 @@
 /**
  * AbstractIntegrator constructor comment.
  */
-public AbstractJavaSolver(SimulationTask simTask, File directory, SessionLog sessionLog) throws SolverException {
-	super(simTask, directory, sessionLog);
+public AbstractJavaSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog) throws SolverException {
+	super(simulationJob, directory, sessionLog);
 }
 
 
@@ -134,7 +133,7 @@
 			// write file and fire event
 			if (this instanceof ODESolver) {
 				ODESolverResultSet odeSolverResultSet = ((ODESolver)this).getODESolverResultSet();
-				Simulation simulation = simTask.getSimulationJob().getSimulation();
+				Simulation simulation = simulationJob.getSimulation();
 				OutputTimeSpec outputTimeSpec = simulation.getSolverTaskDescription().getOutputTimeSpec();
 				if (outputTimeSpec.isDefault()) {
 					odeSolverResultSet.trimRows(((DefaultOutputTimeSpec)outputTimeSpec).getKeepAtMost());
Index: src/cbit/vcell/solver/ode/IDASolverStandalone.java
===================================================================
--- src/cbit/vcell/solver/ode/IDASolverStandalone.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/IDASolverStandalone.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,7 +16,6 @@
 import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
 import cbit.vcell.solver.SolverException;
@@ -35,8 +34,8 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @exception cbit.vcell.solver.SolverException The exception description.
  */
-public IDASolverStandalone(SimulationTask simTask, File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
-	super(simTask, directory, sessionLog, bMessaging);
+public IDASolverStandalone(SimulationJob simulationJob, File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
+	super(simulationJob, directory, sessionLog, bMessaging);
 }
 /**
  *  This method takes the place of the old runUnsteady()...
@@ -46,14 +45,15 @@
 	fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_INIT);
 	super.initialize();
 	
-	String inputFilename = getInputFilename();
+	String inputFilename = getBaseName() + IDAINPUT_DATA_EXTENSION;
+	String outputFilename = getBaseName() + IDA_DATA_EXTENSION;
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INPUT_FILE));
 	fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_INPUT_FILE);
 
 	PrintWriter pw = null;
 	try {
 		pw = new PrintWriter(inputFilename);
-		IDAFileWriter idaFileWriter = new IDAFileWriter(pw, simTask, bMessaging);
+		IDAFileWriter idaFileWriter = new IDAFileWriter(pw, simulationJob, bMessaging);
 		idaFileWriter.write();
 	} catch (Exception e) {
 		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, SimulationMessage.solverAborted("Could not generate input file: " + e.getMessage())));
@@ -67,24 +67,7 @@
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,SimulationMessage.MESSAGE_SOLVER_RUNNING_START));	
 	
-	setMathExecutable(new MathExecutable(getMathExecutableCommand()));
-}
-
-private String getInputFilename(){
-	return getBaseName() + IDAINPUT_DATA_EXTENSION;
-}
-
-private String getOutputFilename(){
-	return getBaseName() + IDA_DATA_EXTENSION;
-}
-
-@Override
-public String[] getMathExecutableCommand() {
 	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.sundialsSolverExecutableProperty);
-	String inputFilename = getInputFilename();
-	String outputFilename = getOutputFilename();
-	return new String[] { executableName, inputFilename, outputFilename };
+	setMathExecutable(new MathExecutable(new String[] {executableName, inputFilename, outputFilename}));
 }
-
-
 }
Index: src/cbit/vcell/solver/ode/CVodeSolverStandalone.java
===================================================================
--- src/cbit/vcell/solver/ode/CVodeSolverStandalone.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/CVodeSolverStandalone.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,7 +15,7 @@
 import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 
-import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.math.MathDescription;
 import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
 import cbit.vcell.solver.SolverException;
@@ -34,18 +34,20 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @exception cbit.vcell.solver.SolverException The exception description.
  */
-public CVodeSolverStandalone(SimulationTask simTask, java.io.File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
-	super(simTask, directory, sessionLog, bMessaging);
+public CVodeSolverStandalone(SimulationJob simulationJob, java.io.File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
+	super(simulationJob, directory, sessionLog, bMessaging);
 }
 /**
  *  This method takes the place of the old runUnsteady()...
  */
 protected void initialize() throws SolverException {
+	MathDescription mathDescription = getSimulationJob().getSimulation().getMathDescription();
 	
 	fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_INIT);
 	super.initialize();
 
-	String inputFilename = getInputFilename();
+	String inputFilename = getBaseName() + CVODEINPUT_DATA_EXTENSION;
+	String outputFilename = getBaseName() + IDA_DATA_EXTENSION;
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INPUT_FILE));
 	fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_INPUT_FILE);
@@ -53,7 +55,7 @@
 	PrintWriter pw = null;
 	try {
 		pw = new java.io.PrintWriter(inputFilename);
-		CVodeFileWriter cvodeFileWriter = new CVodeFileWriter(pw, simTask, bMessaging);
+		CVodeFileWriter cvodeFileWriter = new CVodeFileWriter(pw, simulationJob, bMessaging);
 		cvodeFileWriter.write();
 	} catch (Exception e) {
 		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, SimulationMessage.solverAborted("CVODE solver could not generate input file: " + e.getMessage())));
@@ -67,22 +69,7 @@
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,SimulationMessage.MESSAGE_SOLVER_RUNNING_START));	
 	
-	setMathExecutable(new MathExecutable(getMathExecutableCommand()));
-}
-
-private String getInputFilename(){
-	return getBaseName() + CVODEINPUT_DATA_EXTENSION;
-}
-
-private String getOutputFilename(){
-	return getBaseName() + IDA_DATA_EXTENSION;
-}
-
-@Override
-public String[] getMathExecutableCommand() {
 	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.sundialsSolverExecutableProperty);
-	String inputFilename = getInputFilename();
-	String outputFilename = getOutputFilename();
-	return new String[] { executableName, inputFilename, outputFilename };
+	setMathExecutable(new MathExecutable(new String[] {executableName, inputFilename, outputFilename}));
 }
 }
Index: src/cbit/vcell/solver/ode/OdeFileWriter.java
===================================================================
--- src/cbit/vcell/solver/ode/OdeFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/OdeFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -29,7 +29,6 @@
 import cbit.vcell.math.VolVariable;
 import cbit.vcell.math.Event.Delay;
 import cbit.vcell.math.Event.EventAssignment;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Discontinuity;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
@@ -40,6 +39,7 @@
 import cbit.vcell.solver.ExplicitOutputTimeSpec;
 import cbit.vcell.solver.OutputTimeSpec;
 import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationSymbolTable;
 import cbit.vcell.solver.SolverFileWriter;
 import cbit.vcell.solver.SolverTaskDescription;
@@ -60,8 +60,8 @@
 /**
  * OdeFileCoder constructor comment.
  */
-public OdeFileWriter(PrintWriter pw, SimulationTask simTask, boolean messaging) {
-	super(pw, simTask, messaging);
+public OdeFileWriter(PrintWriter pw, SimulationJob simJob, boolean messaging) {
+	super(pw, simJob, messaging);
 }
 
 public Discontinuity getSubsitutedAndFlattened(Discontinuity discontinuity, SymbolTable st) throws ExpressionException {		
@@ -85,7 +85,7 @@
 	varsSymbolTable.addVar(ReservedVariable.TIME); // SymbolTableEntry.index doesn't matter ... just code generating binding by var names not index.
 	int count = 0;
 	
-	Variable variables[] = simTask.getSimulationJob().getSimulationSymbolTable().getVariables();
+	Variable variables[] = simulationJob.getSimulationSymbolTable().getVariables();
 	
 	for (int i = 0; i < variables.length; i++) {
 		if (variables[i] instanceof VolVariable) {
@@ -113,7 +113,7 @@
 	// Get the vector of sensVariables, needed for creating SensStateVariables 
 	Vector<SensStateVariable> sensVars = new Vector<SensStateVariable>();
 	for (int i = 0; i < getStateVariableCount(); i++) {
-		if (simTask.getSimulation().getSolverTaskDescription().getSensitivityParameter() != null) {
+		if (simulationJob.getSimulation().getSolverTaskDescription().getSensitivityParameter() != null) {
 			if (getStateVariable(i) instanceof SensStateVariable) {
 				sensVars.addElement((SensStateVariable)getStateVariable(i));
 			}
@@ -143,14 +143,14 @@
 
 
 private void createStateVariables() throws Exception {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 
 	MathDescription mathDescription = simulation.getMathDescription();
 	SolverTaskDescription solverTaskDescription = simulation.getSolverTaskDescription();
 
 	// get Ode's from MathDescription and create ODEStateVariables
 	Enumeration<Equation> enum1 = mathDescription.getSubDomains().nextElement().getEquations();
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	while (enum1.hasMoreElements()) {
 		Equation equation = enum1.nextElement();
 		if (equation instanceof OdeEquation) {
@@ -203,7 +203,7 @@
 	createStateVariables();
 	createSymbolTable();
 	
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	
 	if (simulation.getSolverTaskDescription().getUseSymbolicJacobian()){
 		throw new RuntimeException("symbolic jacobian option not yet supported in interpreted Stiff solver");
@@ -257,7 +257,7 @@
 }
 
 private String writeEvents(HashMap<Discontinuity, String> discontinuityNameMap) throws ExpressionException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	
 	StringBuffer sb = new StringBuffer();
 	MathDescription mathDescription = simulation.getMathDescription();
Index: src/cbit/vcell/solver/ode/gui/SimulationStatus.java
===================================================================
--- src/cbit/vcell/solver/ode/gui/SimulationStatus.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/gui/SimulationStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,16 +9,14 @@
  */
 
 package cbit.vcell.solver.ode.gui;
-import java.util.ArrayList;
 import java.util.HashMap;
 
 import org.vcell.util.BeanUtils;
+import org.vcell.util.MessageConstants;
 
-import cbit.rmi.event.SimulationJobStatusEvent;
-import cbit.vcell.message.server.dispatcher.SimulationStateMachine;
 import cbit.vcell.messaging.db.SimulationJobStatus;
-import cbit.vcell.solver.SimulationMessage;
-import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.solver.*;
+import cbit.rmi.event.*;
 
 /**
  * Insert the type's description here.
@@ -50,7 +48,6 @@
 	private String details = null;
 	private boolean hasData = false;
 	private SimulationJobStatus[] jobStatuses = null;
-	private SimulationJobStatus[] oldJobStatuses = null;		// historical entries ... for debugging and administrative use (currently unused).
 
 /**
  * Insert the method's description here.
@@ -61,22 +58,7 @@
  * @param hasData boolean
  */
 public SimulationStatus(SimulationJobStatus[] jobStatuses0) {
-	//
-	// list of jobStatus passed in contain status
-	//
-	HashMap<Integer, SimulationJobStatus> currentJobStatusMap = new HashMap<Integer,SimulationJobStatus>();
-	ArrayList<SimulationJobStatus> oldJobStatusList = new ArrayList<SimulationJobStatus>();
-	for (SimulationJobStatus status : jobStatuses0){
-		SimulationJobStatus currentJobStatus = currentJobStatusMap.get(status.getJobIndex());
-		if (currentJobStatus==null || status.getTaskID()>currentJobStatus.getTaskID()){
-			SimulationJobStatus oldStatus = currentJobStatusMap.put(status.getJobIndex(),status);
-			if (oldStatus!=null){
-				oldJobStatusList.add(oldStatus);
-			}
-		}
-	}
-	this.jobStatuses = currentJobStatusMap.values().toArray(new SimulationJobStatus[0]);
-	this.oldJobStatuses = oldJobStatusList.toArray(new SimulationJobStatus[0]);
+	this.jobStatuses = jobStatuses0;
 	initStatus();
 }
 
@@ -159,7 +141,7 @@
 	}
 	int failCount = 0;
 	for (SimulationJobStatus jobStatus : jobStatuses) {
-		if (jobStatus.getSchedulerStatus().isFailed()) {
+		if (jobStatus.isFailed()) {
 			failCount ++;
 		}
 	}
@@ -187,7 +169,7 @@
 	double progress = 0;
 	for (int i = 0; i < jobStatuses.length; i++){
 		if (jobStatuses[i] != null) {
-			if (jobStatuses[i].getSchedulerStatus().isDone()) {
+			if (jobStatuses[i].isDone()) {
 				progress += 1;
 				bAllNullProgress = false;
 			} else {
@@ -267,23 +249,23 @@
 			hasData = hasData  || jobStatuses[i].hasData();			
 			
 			int currentStatus = status;
-			if (jobStatuses[i].getSchedulerStatus().isWaiting()) {
+			if (jobStatuses[i].isWaiting()) {
 				status = Math.max(status, WAITING);
 				bRunning = true;
-			} else if (jobStatuses[i].getSchedulerStatus().isQueued()) {
+			} else if (jobStatuses[i].isQueued()) {
 				status = Math.max(status, QUEUED);
 				bRunning = true;
-			} else if (jobStatuses[i].getSchedulerStatus().isDispatched()) {			
+			} else if (jobStatuses[i].isDispatched()) {			
 				status = Math.max(status, DISPATCHED);
 				bRunning = true;
-			} else if (jobStatuses[i].getSchedulerStatus().isRunning()) {
+			} else if (jobStatuses[i].isRunning()) {
 				status = Math.max(status, RUNNING);
 				bRunning = true;
-			} else if (jobStatuses[i].getSchedulerStatus().isCompleted()) {
+			} else if (jobStatuses[i].isCompleted()) {
 				status = Math.max(status, COMPLETED);
-			} else if (jobStatuses[i].getSchedulerStatus().isStopped()) {
+			} else if (jobStatuses[i].isStopped()) {
 				status = Math.max(status, STOPPED);
-			} else if (jobStatuses[i].getSchedulerStatus().isFailed()) {
+			} else if (jobStatuses[i].isFailed()) {
 				status = Math.max(status, FAILED);
 			}
 			if (status > currentStatus) highStatusIndex = i;
@@ -329,7 +311,7 @@
 	// only one simulation is considered, the jobindex is 0; hence we are checking the first jobStatus in the list of
 	// SimulationJobStatuses corresponding to this simulationstatus.
 	//
-	return getJobStatuses()[0].getSchedulerStatus().isCompleted();
+	return getJobStatuses()[0].isCompleted();
 }
 
 
@@ -415,13 +397,11 @@
  */
 public static SimulationStatus newNeverRan(int jobCount) {
 	SimulationStatus newStatus = new SimulationStatus(NEVER_RAN, false, jobCount);
-	System.out.println("##  ##  ##  ##  ##  ##  ##  ##  >>>> NEW NEVER RAN <<<<< ######################   newstatus=" + newStatus);
 	return newStatus;
 }
 
 public static SimulationStatus newNotSaved(int jobCount) {
 	SimulationStatus newStatus = new SimulationStatus(NOT_SAVED, false, jobCount);
-	System.out.println("##  ##  ##  ##  ##  ##  ##  ##  >>>> NEW NOT SAVED <<<<< ######################   newstatus=" + newStatus);
 	return newStatus;
 }
 
@@ -435,7 +415,6 @@
  */
 public static SimulationStatus newStartRequest(int jobCount) {
 	SimulationStatus newStatus = new SimulationStatus(START_REQUESTED, false, jobCount);
-	System.out.println("##  ##  ##  ##  ##  ##  ##  ##  >>>> NEW START REQUEST <<<<< ######################   newstatus=" + newStatus);
 	return newStatus;
 }
 
@@ -450,7 +429,6 @@
 public static SimulationStatus newStartRequestFailure(String failMsg, int jobCount) {
 	SimulationStatus newStatus = new SimulationStatus(FAILED, false, jobCount);
 	newStatus.details = failMsg;
-	System.out.println("##  ##  ##  ##  ##  ##  ##  ##  >>>> NEW START REQUEST FAILURE <<<<< ######################   newstatus=" + newStatus);
 	return newStatus;
 }
 
@@ -466,7 +444,6 @@
 	SimulationStatus newStatus = new SimulationStatus(currentStatus);
 	newStatus.status = STOP_REQUESTED;
 	newStatus.details = null;
-	System.out.println("##  ##  ##  ##  ##  ##  ##  ##  >>>> NEW STOP REQUEST <<<< ###########   oldstatus=" + currentStatus + "\n###########  newstatus=" + newStatus + "\n###########");
 	return newStatus;
 }
 
@@ -492,7 +469,7 @@
 public int numberOfJobsDone() {
 	int done = 0;
 	for (int i = 0; i < getJobStatuses().length; i++){
-		if (getJobStatuses()[i] != null && getJobStatuses()[i].getSchedulerStatus().isDone()) {
+		if (getJobStatuses()[i] != null && getJobStatuses()[i].isDone()) {
 			done ++;
 		}
 	}
@@ -501,7 +478,7 @@
 
 public boolean isCompleted() {
 	for (int i = 0; i < getJobStatuses().length; i++){
-		if (getJobStatuses()[i] == null || !getJobStatuses()[i].getSchedulerStatus().isCompleted()) {
+		if (getJobStatuses()[i] == null || !getJobStatuses()[i].isCompleted()) {
 			return false;
 		}
 	}
@@ -520,7 +497,7 @@
 
 public static SimulationStatus updateFromJobEvent(SimulationStatus oldStatus, SimulationJobStatusEvent simJobStatusEvent) {
 	SimulationStatus newstatus = updateFromJobEvent0(oldStatus, simJobStatusEvent);
-	System.out.println("##  ##  ##  ##  ##  ##  ##  ##    >>>> NEW SIMULATION STATUS <<<< ###########   oldstatus=" + oldStatus + "\n###########  newstatus=" + newstatus + "\n###########  jobstatusevent=" + simJobStatusEvent.getJobStatus());
+	System.out.println("###########oldstatus=" + oldStatus + "\n###########newstatus=" + newstatus + "\n###########jobstatusevent=" + simJobStatusEvent.getJobStatus());
 	return newstatus;	
 }
 /**
@@ -553,12 +530,12 @@
 	// figure out task ID ordinality...
 	int someOldID = oldStatus.getJobStatuses()[0].getTaskID(); // doesn't matter which one, should all be on same block
 	int newID = newJobStatus.getTaskID();
-	if (newID - newID % SimulationStateMachine.TASKID_USERINCREMENT > someOldID) {
+	if (newID - newID % MessageConstants.TASKID_USERINCREMENT > someOldID) {
 		// upper block; event comes from a new submission; discard all old stuff
 		newSimStatus = new SimulationStatus(new SimulationJobStatus[] {newJobStatus});
 		newSimStatus.progressHash.put(newJobStatus.getJobIndex(), newProgress);
 		return newSimStatus;
-	} else if (someOldID - someOldID % SimulationStateMachine.TASKID_USERINCREMENT > newID) {
+	} else if (someOldID - someOldID % MessageConstants.TASKID_USERINCREMENT > newID) {
 		// lower block; event comes from an old submission; ignore
 		return oldStatus;
 	}
Index: src/cbit/vcell/solver/ode/DefaultODESolver.java
===================================================================
--- src/cbit/vcell/solver/ode/DefaultODESolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/DefaultODESolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -28,7 +28,6 @@
 import cbit.vcell.math.SubDomain;
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.DefaultOutputTimeSpec;
@@ -65,9 +64,9 @@
  * is not to be performed...
  * @param simContext cbit.vcell.math.MathDescription
  */
-public DefaultODESolver(SimulationTask simTask, File directory, SessionLog sessionLog, int valueVectorCount)  throws SolverException {
-	super(simTask, directory, sessionLog);
-	if (simTask.getSimulation().isSpatial()) {
+public DefaultODESolver(SimulationJob simJob, File directory, SessionLog sessionLog, int valueVectorCount)  throws SolverException {
+	super(simJob, directory, sessionLog);
+	if (simulationJob.getSimulation().isSpatial()) {
 		throw new SolverException("Cannot use DefaultODESolver on spatial simulation");
 	}
 	fieldValueVectorCount = valueVectorCount;
@@ -108,7 +107,7 @@
  * This method was created in VisualAge.
  */
 private Vector<Variable> createIdentifiers() throws MathException, ExpressionException {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	// create list of possible identifiers (including reserved x,y,z,t)
 	Vector<Variable> identifiers = new Vector<Variable>();
@@ -154,7 +153,7 @@
 /**
  */
 private ODESolverResultSet createODESolverResultSet() throws ExpressionException {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	//
 	// create symbol table for binding expression
@@ -249,7 +248,7 @@
  * This method was created in VisualAge.
  */
 private Vector<StateVariable> createStateVariables() throws MathException, ExpressionException {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Simulation sim = simSymbolTable.getSimulation();
 	
 	Vector<StateVariable> stateVariables = new Vector<StateVariable>();
@@ -351,7 +350,7 @@
  * @return double
  */
 public double getProgress() {
-	Simulation sim = simTask.getSimulation();
+	Simulation sim = simulationJob.getSimulation();
 
 	double currTime = getCurrentTime();
 	TimeBounds timeBounds = sim.getSolverTaskDescription().getTimeBounds();
@@ -373,7 +372,7 @@
  * @see #setSensitivityParameter
  */
 public Constant getSensitivityParameter() {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	Constant origSensParam = simSymbolTable.getSimulation().getSolverTaskDescription().getSensitivityParameter();
 	//
@@ -426,7 +425,7 @@
  * @return The timeIndex property value.
  */
 protected SubDomain getSubDomain() {
-	return ((SubDomain) simTask.getSimulation().getMathDescription().getSubDomains().nextElement());
+	return ((SubDomain) simulationJob.getSimulation().getMathDescription().getSubDomains().nextElement());
 }
 
 
@@ -474,7 +473,7 @@
  * @exception SolverException The exception description.
  */
 protected void initialize() throws SolverException {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Simulation sim = simSymbolTable.getSimulation();
 	try {
 		// create a fast system if necessary
@@ -530,7 +529,7 @@
  */
 protected void integrate() throws SolverException, UserStopException, IOException {
 	try {
-		SolverTaskDescription taskDescription = simTask.getSimulation().getSolverTaskDescription();
+		SolverTaskDescription taskDescription = simulationJob.getSimulation().getSolverTaskDescription();
 		double timeStep = taskDescription.getTimeStep().getDefaultTimeStep();
 		fieldCurrentTime = taskDescription.getTimeBounds().getStartingTime();
 		// before computation begins, settle fast equilibrium
@@ -606,7 +605,7 @@
 		results.addRow (values);
 	}
 	//setSolverStatus(new SolverStatus (SolverStatus.SOLVER_RUNNING));
-	Simulation sim = simTask.getSimulation();
+	Simulation sim = simulationJob.getSimulation();
 	double t = getCurrentTime();
 	TimeBounds timeBounds = sim.getSolverTaskDescription().getTimeBounds();
 	double t0 = timeBounds.getStartingTime();
Index: src/cbit/vcell/solver/ode/AdamsMoultonFiveSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/AdamsMoultonFiveSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/AdamsMoultonFiveSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,7 +16,6 @@
 import org.vcell.util.SessionLog;
 
 import cbit.vcell.math.MathException;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.DefaultOutputTimeSpec;
 import cbit.vcell.solver.SimulationJob;
@@ -37,8 +36,8 @@
  * @param valueVectorCount int
  * @param temporaryVectorCount int
  */
-public AdamsMoultonFiveSolver(SimulationTask simTask, File directory, SessionLog sessionLog)  throws SolverException {
-	super(simTask, directory, sessionLog, 2, 5);
+public AdamsMoultonFiveSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog)  throws SolverException {
+	super(simulationJob, directory, sessionLog, 2, 5);
 }
 protected void initialize() throws SolverException {
 	super.initialize();
@@ -52,7 +51,7 @@
  */
 protected void integrate() throws SolverException, UserStopException, IOException {
 	try {
-		SolverTaskDescription taskDescription = simTask.getSimulation().getSolverTaskDescription();
+		SolverTaskDescription taskDescription = simulationJob.getSimulation().getSolverTaskDescription();
 		double timeStep = taskDescription.getTimeStep().getDefaultTimeStep();
 		fieldCurrentTime = taskDescription.getTimeBounds().getStartingTime();
 
Index: src/cbit/vcell/solver/ode/SundialsSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/SundialsSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/SundialsSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -32,7 +32,6 @@
 import cbit.vcell.math.SubDomain;
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.math.AnnotatedFunction.FunctionCategory;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
@@ -62,9 +61,9 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @param simulation cbit.vcell.solver.Simulation
  */
-public SundialsSolver(SimulationTask simTask, File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
-	super(simTask, directory, sessionLog, bMessaging);
-	if (simTask.getSimulation().isSpatial()) {
+public SundialsSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog, boolean bMessaging) throws SolverException {
+	super(simulationJob, directory, sessionLog, bMessaging);
+	if (simulationJob.getSimulation().isSpatial()) {
 		throw new SolverException("Cannot use SundialsSolver on spatial simulation");
 	}
 }
@@ -94,7 +93,7 @@
 private StateVariable[] createStateVariables() throws MathException, ExpressionException {
 	Vector<StateVariable> stateVariables = new Vector<StateVariable>();
 	// get Ode's from MathDescription and create ODEStateVariables
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	MathDescription mathDescription = simSymbolTable.getSimulation().getMathDescription();
 	Enumeration<Equation> enum1 = ((SubDomain)mathDescription.getSubDomains().nextElement()).getEquations();
@@ -157,7 +156,7 @@
 	if (message.startsWith(PROGRESS_PREFIX)){
 		String progressString = message.substring(message.lastIndexOf(SEPARATOR)+1,message.indexOf("%"));
 		double progress = Double.parseDouble(progressString)/100.0;
-		TimeBounds timeBounds = simTask.getSimulation().getSolverTaskDescription().getTimeBounds();
+		TimeBounds timeBounds = simulationJob.getSimulation().getSolverTaskDescription().getTimeBounds();
 		double startTime = timeBounds.getStartingTime();
 		double endTime = timeBounds.getEndingTime();
 		setCurrentTime(startTime + (endTime-startTime)*progress);
@@ -188,7 +187,7 @@
 	//
 	// add appropriate Function columns to result set
 	//
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Function functions[] = simSymbolTable.getFunctions();
 	for (int i = 0; i < functions.length; i++){
 		if (SimulationSymbolTable.isFunctionSaved(functions[i])){
@@ -270,7 +269,7 @@
  * @return int
  */
 public Constant getSensitivityParameter() {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Constant origSensParam = simSymbolTable.getSimulation().getSolverTaskDescription().getSensitivityParameter();
 	//
 	// sensitivity parameter from solverTaskDescription will have the non-overridden nominal value.
@@ -427,7 +426,7 @@
 	//
 	// add appropriate Function columns to result set
 	//
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Vector<AnnotatedFunction> funcList = new Vector<AnnotatedFunction>();
 	
 	cbit.vcell.math.Function functions[] = simSymbolTable.getFunctions();
@@ -499,7 +498,7 @@
 		pw.println(IDA_DATA_IDENTIFIER);
 		pw.println(IDA_DATA_FORMAT_ID);
 		pw.println(ideDataFileName);
-		OutputTimeSpec outputTimeSpec = simTask.getSimulation().getSolverTaskDescription().getOutputTimeSpec();
+		OutputTimeSpec outputTimeSpec = simulationJob.getSimulation().getSolverTaskDescription().getOutputTimeSpec();
 		if (outputTimeSpec.isDefault()) {	
 			pw.println(KEEP_MOST + " " + ((DefaultOutputTimeSpec)outputTimeSpec).getKeepAtMost());
 		}		
Index: src/cbit/vcell/solver/ode/RungeKuttaTwoSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/RungeKuttaTwoSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/RungeKuttaTwoSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,7 +15,6 @@
 import org.vcell.util.SessionLog;
 
 import cbit.vcell.solver.*;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.ExpressionException;
 /**
  * Insert the class' description here.
@@ -29,8 +28,8 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @param numVectors int
  */
-public RungeKuttaTwoSolver(SimulationTask simTask, File directory, SessionLog sessionLog) throws SolverException {
-	super(simTask, directory, sessionLog, 2, 2);
+public RungeKuttaTwoSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog) throws SolverException {
+	super(simulationJob, directory, sessionLog, 2, 2);
 }
 /**
  * Integrate over time step using the forward Euler method (1st order explicit)
Index: src/cbit/vcell/solver/ode/AdamsSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/AdamsSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/AdamsSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -14,7 +14,6 @@
 
 import org.vcell.util.SessionLog;
 
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.*;
 /**
  * Insert the class' description here.
@@ -31,8 +30,8 @@
  * @param valueVectorCount int
  * @param temporaryVectorCount int
  */
-public AdamsSolver(SimulationTask simTask, File directory, SessionLog sessionLog, int valueVectorCount, int workArrayCount)  throws SolverException {
-	super(simTask, directory, sessionLog, valueVectorCount);
+public AdamsSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog, int valueVectorCount, int workArrayCount)  throws SolverException {
+	super(simulationJob, directory, sessionLog, valueVectorCount);
 	fieldWorkArrayCount = workArrayCount;
 }
 protected void initialize() throws cbit.vcell.solver.SolverException {
Index: src/cbit/vcell/solver/ode/RungeKuttaFourSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/RungeKuttaFourSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/RungeKuttaFourSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,7 +15,6 @@
 import org.vcell.util.SessionLog;
 
 import cbit.vcell.solver.*;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.ExpressionException;
 /**
  * Insert the class' description here.
@@ -29,8 +28,8 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @param numVectors int
  */
-public RungeKuttaFourSolver(SimulationTask simTask, File directory, SessionLog sessionLog) throws SolverException {
-	super(simTask, directory, sessionLog, 2, 4);
+public RungeKuttaFourSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog) throws SolverException {
+	super(simulationJob, directory, sessionLog, 2, 4);
 }
 /**
  * Integrate over time step using the forward Euler method (1st order explicit)
Index: src/cbit/vcell/solver/ode/RungeKuttaFehlbergSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/RungeKuttaFehlbergSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/RungeKuttaFehlbergSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,7 +16,6 @@
 import org.vcell.util.SessionLog;
 
 import cbit.vcell.math.MathException;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.DefaultOutputTimeSpec;
 import cbit.vcell.solver.SimulationJob;
@@ -46,8 +45,8 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @param numVectors int
  */
-public RungeKuttaFehlbergSolver(SimulationTask simTask, File directory, SessionLog sessionLog) throws SolverException {
-	super(simTask, directory, sessionLog, 3, 6);
+public RungeKuttaFehlbergSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog) throws SolverException {
+	super(simulationJob, directory, sessionLog, 3, 6);
 }
 public double calculateErrorTerm(int i) {
 	int I = getVariableIndex(i);
@@ -60,7 +59,7 @@
 		final double epsilon = DBL_EPSILON;
 		final double twentySixEpsilon = 26 * epsilon;
 		//
-		SolverTaskDescription taskDescription = simTask.getSimulation().getSolverTaskDescription();
+		SolverTaskDescription taskDescription = simulationJob.getSimulation().getSolverTaskDescription();
 		double startingTime = taskDescription.getTimeBounds().getStartingTime();
 		double endingTime = taskDescription.getTimeBounds().getEndingTime();
 		double relativeErrorTolerance = taskDescription.getErrorTolerance().getRelativeErrorTolerance();
Index: src/cbit/vcell/solver/ode/RungeKuttaSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/RungeKuttaSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/RungeKuttaSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -14,7 +14,6 @@
 
 import org.vcell.util.SessionLog;
 
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.*;
 /**
  * Insert the class' description here.
@@ -31,8 +30,8 @@
  * @param valueVectorCount int
  * @param temporaryVectorCount int
  */
-public RungeKuttaSolver(SimulationTask simTask, File directory, SessionLog sessionLog, int valueVectorCount, int workArrayCount)  throws SolverException {
-	super(simTask, directory, sessionLog, valueVectorCount);
+public RungeKuttaSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog, int valueVectorCount, int workArrayCount)  throws SolverException {
+	super(simulationJob, directory, sessionLog, valueVectorCount);
 	fieldWorkArrayCount = workArrayCount;
 }
 protected void initialize() throws cbit.vcell.solver.SolverException {
Index: src/cbit/vcell/solver/ode/IDAFileWriter.java
===================================================================
--- src/cbit/vcell/solver/ode/IDAFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/IDAFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -28,7 +28,6 @@
 import cbit.vcell.matrix.MatrixException;
 import cbit.vcell.matrix.RationalExp;
 import cbit.vcell.matrix.RationalExpMatrix;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Discontinuity;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
@@ -45,20 +44,20 @@
 /**
  * OdeFileCoder constructor comment.
  */
-public IDAFileWriter(PrintWriter pw, SimulationTask simTask) {
-	this(pw, simTask, false);
+public IDAFileWriter(PrintWriter pw, SimulationJob simJob) {
+	this(pw, simJob, false);
 }
 
 
-public IDAFileWriter(PrintWriter pw, SimulationTask simTask, boolean bUseMessaging) {
-	super(pw, simTask, bUseMessaging);
+public IDAFileWriter(PrintWriter pw, SimulationJob simJob, boolean bUseMessaging) {
+	super(pw, simJob, bUseMessaging);
 }
 /**
  * Insert the method's description here.
  * Creation date: (3/8/00 10:31:52 PM)
  */
 protected String writeEquations(HashMap<Discontinuity, String> discontinuityNameMap) throws MathException, ExpressionException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 		
 	StringBuffer sb = new StringBuffer();
 	MathDescription mathDescription = simulation.getMathDescription();
@@ -66,7 +65,7 @@
 		//
 		// define vector of original variables
 		//
-		SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+		SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 		
 		CompartmentSubDomain subDomain = (CompartmentSubDomain)mathDescription.getSubDomains().nextElement();
 		FastSystem fastSystem = subDomain.getFastSystem();
Index: src/cbit/vcell/solver/ode/ForwardEulerSolver.java
===================================================================
--- src/cbit/vcell/solver/ode/ForwardEulerSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/ForwardEulerSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -13,8 +13,6 @@
 import java.io.*;
 
 import org.vcell.util.SessionLog;
-
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.*;
 /**
@@ -29,8 +27,8 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @param numVectors int
  */
-public ForwardEulerSolver(SimulationTask simTask, File directory, SessionLog sessionLog)  throws SolverException {
-	super(simTask, directory, sessionLog, 2);
+public ForwardEulerSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog)  throws SolverException {
+	super(simulationJob, directory, sessionLog, 2);
 }
 /**
  * Integrate over time step using the forward Euler method (1st order explicit)
Index: src/cbit/vcell/solver/ode/CVodeFileWriter.java
===================================================================
--- src/cbit/vcell/solver/ode/CVodeFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solver/ode/CVodeFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -17,11 +17,11 @@
 import cbit.vcell.math.MathUtilities;
 import cbit.vcell.math.ReservedVariable;
 import cbit.vcell.model.ReservedSymbol;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Discontinuity;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.parser.SymbolTableEntry;
+import cbit.vcell.solver.SimulationJob;
 /**
  * Insert the type's description here.
  * Creation date: (3/8/00 10:29:24 PM)
@@ -29,12 +29,12 @@
  */
 public class CVodeFileWriter extends OdeFileWriter {
 
-public CVodeFileWriter(PrintWriter pw, SimulationTask simTask) {
-	super(pw, simTask, false);
+public CVodeFileWriter(PrintWriter pw, SimulationJob simJob) {
+	super(pw, simJob, false);
 }
 	
-public CVodeFileWriter(PrintWriter pw, SimulationTask simTask, boolean bUseMessaging) {
-	super(pw, simTask, bUseMessaging);
+public CVodeFileWriter(PrintWriter pw, SimulationJob simJob, boolean bUseMessaging) {
+	super(pw, simJob, bUseMessaging);
 }
 
 /**
Index: src/cbit/vcell/messaging/QueueMessageCollector.java
===================================================================
--- src/cbit/vcell/messaging/QueueMessageCollector.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/QueueMessageCollector.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/26/2003 10:54:16 AM)
+ * @author: Fei Gao
+ */
+public class QueueMessageCollector extends QueueListenerImpl {
+	private QueueListener queueListener;
+/**
+ * QueueMessageCollector constructor comment.
+ */
+public QueueMessageCollector(QueueListener queueListener0) {
+	super();
+	queueListener = queueListener0;
+}
+/**
+ * onQueueMessage method comment.
+ */
+public void onQueueMessage(Message message) throws JMSException {
+	if (queueListener != null) {
+		queueListener.onQueueMessage(message);
+	}
+}
+}
Index: src/cbit/vcell/messaging/JmsConnectionFactory.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnectionFactory.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnectionFactory.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.JMSException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/24/2004 2:24:10 PM)
+ * @author: Fei Gao
+ */
+public interface JmsConnectionFactory {
+	public JmsXAConnection createXAConnection() throws JMSException;
+	public JmsConnection createConnection() throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsXAConnection.java
===================================================================
--- src/cbit/vcell/messaging/JmsXAConnection.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsXAConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/2/2003 8:32:58 AM)
+ * @author: Fei Gao
+ */
+public interface JmsXAConnection extends JmsConnection {
+	XAConnection getXAConnection();
+	public JmsXASession getXASession() throws JMSException;
+}
Index: src/cbit/vcell/messaging/db/SimpleJobStatus.java
===================================================================
--- src/cbit/vcell/messaging/db/SimpleJobStatus.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/SimpleJobStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.messaging.db;
-import cbit.vcell.solver.VCSimulationIdentifier;
-import java.math.BigDecimal;
-
-import org.vcell.util.ComparableObject;
-
-import cbit.vcell.solver.SolverTaskDescription;
-
-/**
- * Insert the type's description here.
- * Creation date: (9/3/2003 10:39:26 AM)
- * @author: Fei Gao
- */
-public class SimpleJobStatus implements ComparableObject {
-	private String userID = null;
-	private SimulationJobStatus jobStatus = null;
-	private SolverTaskDescription solverTaskDesc = null;
-	private Long elapsedTime = null;
-
-/**
- * SimpleJobStatus constructor comment.
- */
-public SimpleJobStatus(String user, SimulationJobStatus arg_jobStatus, SolverTaskDescription arg_solverTaskDesc) {	
-	super();
-	this.userID = user;
-	this.jobStatus = arg_jobStatus;
-	this.solverTaskDesc = arg_solverTaskDesc;
-	this.elapsedTime = null;
-	if (getStartDate()!=null){
-		if (getEndDate()!=null){
-			this.elapsedTime = ((getEndDate().getTime()-getStartDate().getTime()));
-		}else if (jobStatus.getSchedulerStatus().isRunning()){
-			this.elapsedTime = ((System.currentTimeMillis()-getStartDate().getTime()));
-		}
-	}
-
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public java.lang.String getComputeHost() {
-	if (jobStatus == null) {
-		return null;
-	}	
-	return jobStatus.getComputeHost();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.util.Date
- */
-public java.util.Date getEndDate() {
-	if (jobStatus == null) {
-		return null;
-	}
-	return jobStatus.getEndDate();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public Integer getJobIndex() {
-	if (jobStatus == null || jobStatus.getServerID() == null) {
-		return null;
-	}	
-	return new Integer(jobStatus.getJobIndex());
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public java.lang.String getServerID() {
-	if (jobStatus == null || jobStatus.getServerID() == null) {
-		return null;
-	}	
-	return jobStatus.getServerID().toString();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (7/8/2004 1:29:11 PM)
- * @return java.lang.String
- */
-public String getSolverDescriptionVCML() {
-	if (solverTaskDesc == null) {
-		return "Error: Null Solver Description";
-	}
-	return solverTaskDesc.getVCML();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.util.Date
- */
-public java.util.Date getStartDate() {
-	if (jobStatus == null) {
-		return null;
-	}
-	return jobStatus.getStartDate();
-}
-
-/**
- * Insert the method's description here.
- * Creation date: (12/17/2003 2:47:11 PM)
- * @return java.lang.String
- */
-public String getStatusMessage() {
-	return jobStatus.getSimulationMessage().getDisplayMessage();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.util.Date
- */
-public java.util.Date getSubmitDate() {
-	return jobStatus.getSubmitDate();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public Integer getTaskID() {
-	if (jobStatus == null || jobStatus.getServerID() == null) {
-		return null;
-	}	
-	return new Integer(jobStatus.getTaskID());
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public java.lang.String getUserID() {
-	return userID;
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (12/17/2003 2:54:17 PM)
- * @return cbit.sql.KeyValue
- */
-public VCSimulationIdentifier getVCSimulationIdentifier() {
-	return jobStatus.getVCSimulationIdentifier();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (7/19/2004 3:21:23 PM)
- * @return boolean
- */
-public boolean isDone() {
-	return jobStatus.getSchedulerStatus().isDone();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (5/7/2004 8:53:02 AM)
- * @return boolean
- */
-public boolean isRunning() {
-	return jobStatus.getSchedulerStatus().isRunning();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (9/3/2003 10:45:39 AM)
- * @return java.lang.String[]
- */
-public Object[] toObjects() {	
-	return new Object[] {userID,  new BigDecimal(getVCSimulationIdentifier().getSimulationKey().toString()), getJobIndex(), 
-		solverTaskDesc == null || solverTaskDesc.getSolverDescription() == null ? "" : solverTaskDesc.getSolverDescription().getDisplayLabel(), 		
-		getStatusMessage(), getComputeHost(), getServerID(), getTaskID(), getSubmitDate(), getStartDate(), getEndDate(),
-		elapsedTime};
-}
-}
Index: src/cbit/vcell/messaging/db/SimulationQueueEntryStatus.java
===================================================================
--- src/cbit/vcell/messaging/db/SimulationQueueEntryStatus.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/SimulationQueueEntryStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -12,8 +12,6 @@
 
 import java.util.Date;
 
-import cbit.vcell.messaging.db.SimulationJobStatus.SimulationQueueID;
-
 /**
  * Insert the type's description here.
  * Creation date: (1/31/2003 11:21:39 AM)
@@ -22,7 +20,7 @@
 public class SimulationQueueEntryStatus implements org.vcell.util.Matchable, java.io.Serializable {
 	private int fieldQueuePriority = 0;
 	private Date fieldQueueDate = null;
-	private SimulationJobStatus.SimulationQueueID fieldQueueID;
+	private int fieldQueueID;
 /**
  * SimulationQueueEntryStatus constructor comment.
  * @param simKey cbit.sql.KeyValue
@@ -32,10 +30,7 @@
  * @param queueDate java.util.Date
  * @param queueID java.lang.Integer
  */
-public SimulationQueueEntryStatus(Date queueDate, int queuePriority, SimulationJobStatus.SimulationQueueID queueID) {
-	if (queueID==null){
-		throw new RuntimeException("queueID must not be null");
-	}
+public SimulationQueueEntryStatus(Date queueDate, int queuePriority, int queueID) {
 	this.fieldQueueDate = queueDate;
 	this.fieldQueuePriority = queuePriority;	
 	this.fieldQueueID = queueID;
@@ -79,7 +74,7 @@
  * Creation date: (1/31/2003 11:23:56 AM)
  * @return int
  */
-public SimulationJobStatus.SimulationQueueID getQueueID() {
+public int getQueueID() {
 	return fieldQueueID;
 }
 /**
@@ -95,10 +90,7 @@
  * Creation date: (5/29/2003 10:03:41 AM)
  * @param newFieldQueueID int
  */
-public void setQueueID(SimulationJobStatus.SimulationQueueID newFieldQueueID) {
-	if (newFieldQueueID==null){
-		throw new RuntimeException("queueID must not be null");
-	}
+public void setQueueID(int newFieldQueueID) {
 	fieldQueueID = newFieldQueueID;
 }
 /**
Index: src/cbit/vcell/messaging/db/SimulationJobDbDriver.java
===================================================================
--- src/cbit/vcell/messaging/db/SimulationJobDbDriver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/SimulationJobDbDriver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -12,15 +12,10 @@
 import java.sql.*;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobTable;
-import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
-import cbit.vcell.modeldb.BioModelSimulationLinkTable;
-import cbit.vcell.modeldb.MathModelSimulationLinkTable;
 import cbit.vcell.modeldb.SimulationTable;
 import cbit.vcell.modeldb.DatabaseConstants;
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
 
 import org.vcell.util.DataAccessException;
 import org.vcell.util.SessionLog;
@@ -28,6 +23,7 @@
 import org.vcell.util.document.User;
 import org.vcell.util.document.VCellServerID;
 
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.modeldb.UserTable;
 
 /**
@@ -90,10 +86,10 @@
 			
 			
 	sql += " AND "
-			+ jobTable.schedulerStatus + " in (" + SchedulerStatus.QUEUED.getDatabaseNumber() // in job queue
-			+ ","  + SchedulerStatus.DISPATCHED.getDatabaseNumber() // worker just accepted it
-			+ "," + SchedulerStatus.RUNNING.getDatabaseNumber()  // worker running it
-			+ "," + SchedulerStatus.WAITING.getDatabaseNumber() // waiting
+			+ jobTable.schedulerStatus + " in (" + SimulationJobStatus.SCHEDULERSTATUS_QUEUED // in job queue
+			+ ","  + SimulationJobStatus.SCHEDULERSTATUS_DISPATCHED // worker just accepted it
+			+ "," + SimulationJobStatus.SCHEDULERSTATUS_RUNNING  // worker running it
+			+ "," + SimulationJobStatus.SCHEDULERSTATUS_WAITING // waiting
 			+ ")";
 
 	// AND upper(serverID) in ('serverid1', serverid2');
@@ -128,12 +124,41 @@
 	return (SimulationJobStatusInfo[])simJobStatusInfoList.toArray(new SimulationJobStatusInfo[0]);
 }
 
+
 /**
  * This method was created in VisualAge.
  * @return int
  * @param user java.lang.String
  * @param imageName java.lang.String
  */
+public SimulationJobStatus getNextObsoleteSimulation(Connection con, long intervalSeconds) throws SQLException {
+	String sql = new String(standardJobStatusSQL);
+	sql += " AND (sysdate-" + jobTable.latestUpdateDate + ")*86400>" + intervalSeconds
+		+ " AND (" + jobTable.serverID + "='" + VCellServerID.getSystemServerID() + "')"
+		+ " AND (" + jobTable.schedulerStatus + "=" + SimulationJobStatus.SCHEDULERSTATUS_RUNNING // running
+		+ " OR " + jobTable.schedulerStatus + "=" + SimulationJobStatus.SCHEDULERSTATUS_DISPATCHED // worker just accepted it
+		+ ") and rownum<2 order by " + jobTable.submitDate;	
+			
+	Statement stmt = con.createStatement();
+	SimulationJobStatus simJobStatus = null;
+	try {
+		ResultSet rset = stmt.executeQuery(sql);
+		if (rset.next()) {
+			simJobStatus = jobTable.getSimulationJobStatus(rset);
+		}
+	} finally {
+		stmt.close();
+	}
+	return simJobStatus;
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return int
+ * @param user java.lang.String
+ * @param imageName java.lang.String
+ */
 public SimulationJobStatus[] getSimulationJobStatus(Connection con, KeyValue simulationKeys[]) throws SQLException {
 	//log.print("SchedulerDbDriver.getSimulationJobStatus(bActiveOnly=" + bActiveOnly + ", owner=" + owner);	
 	String sql = new String(standardJobStatusSQL);
@@ -196,17 +221,16 @@
  * @param user java.lang.String
  * @param imageName java.lang.String
  */
-public SimulationJobStatus getSimulationJobStatus(Connection con, KeyValue simKey, int jobIndex, int taskID, boolean lockRowForUpdate) throws SQLException {
+public SimulationJobStatus getSimulationJobStatus(Connection con, KeyValue simKey, int index, boolean lockRowForUpdate) throws SQLException {
 	//log.print("SchedulerDbDriver.getSimulationJobStatus(SimKey="+simKey+")");
 	String sql = new String(standardJobStatusSQL);	
 	sql += " AND " + simTable.id.getQualifiedColName() + " = " + simKey;
-	sql += " AND " + jobTable.jobIndex.getQualifiedColName() + " = " + jobIndex;
-	sql += " AND " + jobTable.taskID.getQualifiedColName() + " = " + taskID;
+	sql += " AND " + jobTable.jobIndex.getQualifiedColName() + " = " + index;
 		
 	if (lockRowForUpdate){
 		sql += " FOR UPDATE OF " + jobTable.getTableName() + ".id";
 	}
-//	log.print(sql);
+	//log.print(sql);
 	Statement stmt = con.createStatement();
 	SimulationJobStatus simJobStatus = null;
 	try {
@@ -217,41 +241,10 @@
 	} finally {
 		stmt.close();
 	}
-	log.print("retrieved simJobStatus = "+simJobStatus);
 	return simJobStatus;
 }
 
-/**
- * This method was created in VisualAge.
- * @return int
- * @param user java.lang.String
- * @param imageName java.lang.String
- */
-public SimulationJobStatus[] getSimulationJobStatusArray(Connection con, KeyValue simKey, int jobIndex, boolean lockRowForUpdate) throws SQLException {
-	//log.print("SchedulerDbDriver.getSimulationJobStatus(SimKey="+simKey+")");
-	String sql = new String(standardJobStatusSQL);	
-	sql += " AND " + simTable.id.getQualifiedColName() + " = " + simKey;
-	sql += " AND " + jobTable.jobIndex.getQualifiedColName() + " = " + jobIndex;
-		
-	if (lockRowForUpdate){
-		sql += " FOR UPDATE OF " + jobTable.getTableName() + ".id";
-	}
-	//log.print(sql);
-	Statement stmt = con.createStatement();
-	ArrayList<SimulationJobStatus> simulationJobStatusArrayList = new ArrayList<SimulationJobStatus>();
-	try {
-		ResultSet rset = stmt.executeQuery(sql);
-		while (rset.next()) {
-			SimulationJobStatus simJobStatus = jobTable.getSimulationJobStatus(rset);
-			simulationJobStatusArrayList.add(simJobStatus);
-		}
-	} finally {
-		stmt.close();
-	}
-	return simulationJobStatusArrayList.toArray(new SimulationJobStatus[0]);
-}
 
-
 /**
  * Insert the method's description here.
  * Creation date: (9/3/2003 8:59:46 AM)
@@ -319,9 +312,9 @@
 	}
 
 	if (bActiveOnly) {
-		sql += " AND (" + jobTable.schedulerStatus + "=" + SchedulerStatus.QUEUED.getDatabaseNumber() // in job queue
-			+ " OR " + jobTable.schedulerStatus + "=" + SchedulerStatus.DISPATCHED.getDatabaseNumber() // worker just accepted it
-			+ " OR " + jobTable.schedulerStatus + "=" + SchedulerStatus.RUNNING.getDatabaseNumber()  // worker running it
+		sql += " AND (" + jobTable.schedulerStatus + "=" + SimulationJobStatus.SCHEDULERSTATUS_QUEUED // in job queue
+			+ " OR " + jobTable.schedulerStatus + "=" + SimulationJobStatus.SCHEDULERSTATUS_DISPATCHED // worker just accepted it
+			+ " OR " + jobTable.schedulerStatus + "=" + SimulationJobStatus.SCHEDULERSTATUS_RUNNING  // worker running it
 			+ ")";
 	}
 	
@@ -383,7 +376,7 @@
 	String sql = "INSERT INTO " + jobTable.getTableName() + " " + jobTable.getSQLColumnList() + " VALUES " 
 		+ jobTable.getSQLValueList(key, simulationJobStatus);
 
-	log.print(sql);			
+	//log.print(sql);			
 	executeUpdate(con,sql);
 }
 
@@ -403,8 +396,7 @@
 	
 	String sql = "UPDATE " + jobTable.getTableName() +	" SET "  + jobTable.getSQLUpdateList(simulationJobStatus) + 
 			" WHERE " + jobTable.simRef + "=" + simulationJobStatus.getVCSimulationIdentifier().getSimulationKey() +
-			" AND " + jobTable.jobIndex + "=" + simulationJobStatus.getJobIndex() +
-			" AND " + jobTable.taskID + "=" + simulationJobStatus.getTaskID();
+			" AND " + jobTable.jobIndex + "=" + simulationJobStatus.getJobIndex();
 	//log.print(sql);			
 	executeUpdate(con,sql);
 }
Index: src/cbit/vcell/messaging/db/SimulationJobStatus.java
===================================================================
--- src/cbit/vcell/messaging/db/SimulationJobStatus.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/SimulationJobStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,15 +9,15 @@
  */
 
 package cbit.vcell.messaging.db;
+import cbit.htc.PbsJobID;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import java.util.Date;
 import java.io.Serializable;
-import java.util.Date;
 
 import org.vcell.util.Compare;
 import org.vcell.util.document.VCellServerID;
 
-import cbit.vcell.solver.SimulationMessage;
-import cbit.vcell.solver.VCSimulationIdentifier;
-
 /**
  * Insert the type's description here.
  * Creation date: (1/31/2003 11:02:54 AM)
@@ -30,123 +30,41 @@
 	private Date fieldTimeDateStamp = null;
 	private VCSimulationIdentifier fieldVCSimID = null;
 	private Date fieldSubmitDate = null;
-	private SchedulerStatus fieldSchedulerStatus; // define here
+	private int fieldSchedulerStatus; // define here
 	private int fieldTaskID = 0;
 	private SimulationMessage fieldSimulationMessage = null;
 	private VCellServerID fieldServerID = null;
 	private int fieldJobIndex;
+
+	public static final int SCHEDULERSTATUS_WAITING = 0;
+	public static final int SCHEDULERSTATUS_QUEUED = 1;
+	public static final int SCHEDULERSTATUS_DISPATCHED = 2;
+	public static final int SCHEDULERSTATUS_RUNNING = 3;
+	public static final int SCHEDULERSTATUS_COMPLETED = 4;
+	public static final int SCHEDULERSTATUS_STOPPED = 5;
+	public static final int SCHEDULERSTATUS_FAILED = 6;
+	
+	private final static String[] schedulerStatusDescription = new String[] {
+		"waiting",
+		"queued",
+		"dispatched",
+		"running",
+		"completed",
+		"stopped",
+		"failed"
+	};
+
 	private SimulationQueueEntryStatus fieldSimulationQueueEntryStatus = null;	// may be null
 	private SimulationExecutionStatus fieldSimulationExecutionStatus = null;	// may be null
-
-	public static enum SchedulerStatus {
-		WAITING(0,"waiting"),
-		QUEUED(1,"queued"),
-		DISPATCHED(2,"dispatched"),
-		RUNNING(3,"running"),
-		COMPLETED(4,"completed"),
-		STOPPED(5,"stopped"),
-		FAILED(6,"failed");
-		
-		private int databaseNumber;
-		private String description;
-		private SchedulerStatus(int databaseNumber, String desc){
-			this.databaseNumber = databaseNumber;
-			this.description = desc;
-		}
-		
-		public int getDatabaseNumber(){
-			return databaseNumber;
-		}
-		public String getDescription(){
-			return description;
-		}
-
-		public boolean isSupercededBy(SchedulerStatus other) {
-			return other.getDatabaseNumber() > getDatabaseNumber();
-		}
-
-		public boolean isWaiting() {
-			return this.equals(WAITING);
-		}
-		public boolean isQueued() {
-			return this.equals(QUEUED);
-		}
-		public boolean isDispatched() {
-			return this.equals(DISPATCHED);
-		}
-		public boolean isRunning() {
-			return this.equals(RUNNING);
-		}
-		public boolean isCompleted() {
-			return this.equals(COMPLETED);
-		}
-		public boolean isStopped() {
-			return this.equals(STOPPED);
-		}
-		public boolean isFailed() {
-			return this.equals(FAILED);
-		}
-		public boolean inQueue(){
-			return this.equals(WAITING)||this.equals(QUEUED);
-		}
-		public boolean isActive() {
-			return (isRunning() || isWaiting() || isQueued() || isDispatched());
-		}
-		public boolean isDone() {
-			return  (isStopped() || isFailed() || isCompleted());
-		}
-
-		public static SchedulerStatus fromDatabaseNumber(int databaseNumber) {
-			for (SchedulerStatus status : values()){
-				if (status.getDatabaseNumber()==databaseNumber){
-					return status;
-				}
-			}
-			throw new RuntimeException("unexpected SchedulerStatus database number "+databaseNumber);
-		}
-	}
-
 	
 
-	public static enum SimulationQueueID {
-		QUEUE_ID_WAITING(0),
-		QUEUE_ID_SIMULATIONJOB(1),
-		QUEUE_ID_NULL(2);
-		
-		private int databaseNumber;
-		private SimulationQueueID(int databaseNumber){
-			this.databaseNumber = databaseNumber;
-		}
-		
-		public int getDatabaseNumber(){
-			return this.databaseNumber;
-		}
-		
-		public static SimulationQueueID fromDatabaseNumber(int databaseNumber){
-			if (databaseNumber == QUEUE_ID_NULL.databaseNumber){
-				return QUEUE_ID_NULL;
-			}else if (databaseNumber == QUEUE_ID_SIMULATIONJOB.databaseNumber){
-				return QUEUE_ID_SIMULATIONJOB;
-			}else if (databaseNumber == QUEUE_ID_WAITING.databaseNumber){
-				return QUEUE_ID_WAITING;
-			}else{
-				return null;
-			}
-		}
-	}
-
-
-
 /**
  * SimulationJobStatus constructor comment.
  */
-public SimulationJobStatus(VCellServerID serverID, VCSimulationIdentifier vcSimID, int jobIndex, Date submitDate, SchedulerStatus schedulerStatus, int taskID, SimulationMessage simMessage, SimulationQueueEntryStatus simQueueStatus, SimulationExecutionStatus simExeStatus){
+public SimulationJobStatus(VCellServerID serverID, VCSimulationIdentifier vcSimID, int jobIndex, Date submitDate, int schedulerStatus, int taskID, SimulationMessage simMessage, SimulationQueueEntryStatus simQueueStatus, SimulationExecutionStatus simExeStatus){
 	if (simMessage == null) {
 		throw new RuntimeException("SimulationJobStatus : SimulationMessage should not be null");
 	}
-	if (schedulerStatus == null) {
-		throw new RuntimeException("SimulationJobStatus : SchedulerStatus should not be null");
-	}
 	fieldServerID = serverID;
 	fieldVCSimID = vcSimID;
 	fieldSubmitDate = submitDate;
@@ -221,16 +139,16 @@
 		return true;
 	}
 	
-	if (fieldSchedulerStatus.isSupercededBy(simJobStatus.fieldSchedulerStatus)){
+	if (simJobStatus.fieldSchedulerStatus > fieldSchedulerStatus){
 		return true;
-	}else if (simJobStatus.fieldSchedulerStatus.isSupercededBy(fieldSchedulerStatus)){
+	}else if (simJobStatus.fieldSchedulerStatus < fieldSchedulerStatus){
 		return false;
 	}
 	
 	//
 	// simJobStatus.schedulerStatus == fieldSchedulerStatus 
 	//
-	if (simJobStatus.fieldSchedulerStatus == SchedulerStatus.RUNNING && fieldSchedulerStatus == SchedulerStatus.RUNNING){
+	if (simJobStatus.fieldSchedulerStatus == SCHEDULERSTATUS_RUNNING && fieldSchedulerStatus == SCHEDULERSTATUS_RUNNING){
 		if (oldProgress!=null && newProgress!=null){
 			if (oldProgress < newProgress){
 				return true;
@@ -290,10 +208,16 @@
  * Creation date: (1/31/2003 11:15:48 AM)
  * @return int
  */
-public SchedulerStatus getSchedulerStatus() {
+public int getSchedulerStatus() {
 	return fieldSchedulerStatus;
 }
 
+
+public String getSchedulerStatusDescription() {
+	return schedulerStatusDescription[fieldSchedulerStatus];
+}
+
+
 /**
  * Insert the method's description here.
  * Creation date: (4/27/2005 2:09:03 PM)
@@ -401,6 +325,111 @@
 
 /**
  * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean inQueue() {
+	return (fieldSchedulerStatus == SCHEDULERSTATUS_QUEUED || fieldSchedulerStatus == SCHEDULERSTATUS_WAITING) ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/11/2006 10:13:18 AM)
+ * @return boolean
+ */
+public boolean isActive() {
+	if (isRunning() || isWaiting() || isQueued() || isDispatched()) {
+		return true;
+	}
+	
+	return false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isCompleted() {
+	return  fieldSchedulerStatus == SCHEDULERSTATUS_COMPLETED ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isDispatched() {
+	return  fieldSchedulerStatus == SCHEDULERSTATUS_DISPATCHED ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isDone() {
+	return  (fieldSchedulerStatus == SCHEDULERSTATUS_STOPPED || fieldSchedulerStatus == SCHEDULERSTATUS_FAILED 
+		|| fieldSchedulerStatus == SCHEDULERSTATUS_COMPLETED) ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isFailed() {
+	return  fieldSchedulerStatus == SCHEDULERSTATUS_FAILED ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isQueued() {
+	return  (fieldSchedulerStatus == SCHEDULERSTATUS_QUEUED) ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isRunning() {
+	return  fieldSchedulerStatus == SCHEDULERSTATUS_RUNNING ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isStopped() {
+	return  fieldSchedulerStatus == SCHEDULERSTATUS_STOPPED ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 11:15:48 AM)
+ * @return int
+ */
+public boolean isWaiting() {
+	return  (fieldSchedulerStatus == SCHEDULERSTATUS_WAITING) ? true : false;
+}
+
+
+/**
+ * Insert the method's description here.
  * Creation date: (2/2/2004 12:00:50 PM)
  * @param newFieldTimeDateStamp java.util.Date
  */
Index: src/cbit/vcell/messaging/db/ServiceStatusDbDriver.java
===================================================================
--- src/cbit/vcell/messaging/db/ServiceStatusDbDriver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/ServiceStatusDbDriver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,18 +9,15 @@
  */
 
 package cbit.vcell.messaging.db;
-import java.sql.Connection;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Statement;
+import java.sql.*;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.vcell.util.MessageConstants.ServiceType;
 import org.vcell.util.document.KeyValue;
 import org.vcell.util.document.VCellServerID;
 
-import cbit.vcell.message.server.ServiceSpec.ServiceType;
-import cbit.vcell.message.server.ServiceStatus;
+import cbit.vcell.messaging.admin.ServiceStatus;
 
 /**
  * Insert the type's description here.
@@ -81,7 +78,7 @@
  * @param user java.lang.String
  * @param imageName java.lang.String
  */
-public ServiceStatus getServiceStatus(Connection con, VCellServerID serverID, ServiceType type, int ordinal, boolean lockRowForUpdate) throws SQLException {
+public ServiceStatus getServiceStatus(Connection con, String serverID, ServiceType type, int ordinal, boolean lockRowForUpdate) throws SQLException {
 	String sql = "select * from " + serviceTable.getTableName() + " where "	
 		+ serviceTable.serverID.getQualifiedColName() + "='" + serverID + "'" 
 		+ " AND " + serviceTable.type.getQualifiedColName() + "='" + type.getName() + "'"
Index: src/cbit/vcell/messaging/db/SimulationJobTable.java
===================================================================
--- src/cbit/vcell/messaging/db/SimulationJobTable.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/SimulationJobTable.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,11 +16,9 @@
 import org.vcell.util.document.KeyValue;
 import org.vcell.util.document.VCellServerID;
 
+import cbit.htc.PbsJobID;
 import cbit.sql.Field;
 import cbit.sql.Table;
-import cbit.vcell.message.server.htc.HtcJobID;
-import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
-import cbit.vcell.messaging.db.SimulationJobStatus.SimulationQueueID;
 import cbit.vcell.modeldb.DatabaseConstants;
 import cbit.vcell.modeldb.SimulationTable;
 import cbit.vcell.modeldb.UserTable;
@@ -92,8 +90,7 @@
 	//taskID
 	int parsedTaskID = rset.getInt(taskID.toString());
 	//schedulerStatus
-	int parsedSchedulerStatusInt = rset.getInt(schedulerStatus.toString());
-	SchedulerStatus parsedSchedulerStatus = SchedulerStatus.fromDatabaseNumber(parsedSchedulerStatusInt);
+	int parsedSchedulerStatus = rset.getInt(schedulerStatus.toString());	
 	//statusMsg
 	String parsedStatusMsg = TokenMangler.getSQLRestoredString(rset.getString(statusMsg.toString()));
 	
@@ -113,10 +110,8 @@
 	if (rset.wasNull()) {
 		parsedQueueID = -1;
 	}
-	SimulationJobStatus.SimulationQueueID simulationQueueID = SimulationJobStatus.SimulationQueueID.fromDatabaseNumber(parsedQueueID);
+	SimulationQueueEntryStatus simQueueEntryStatus = new SimulationQueueEntryStatus(parsedQueuedDate,parsedQueuePriority,parsedQueueID);	
 	
-	SimulationQueueEntryStatus simQueueEntryStatus = new SimulationQueueEntryStatus(parsedQueuedDate,parsedQueuePriority,simulationQueueID);	
-	
 	//
 	// read solver stuff
 	//
@@ -131,13 +126,13 @@
 	//hasData
 	String parsedHasData = rset.getString(hasData.toString());
 	
-	HtcJobID parsedHtcJobID = null;
-	String htcJobIDString = rset.getString(pbsJobID.toString());
-	if (!rset.wasNull() && htcJobIDString!=null && htcJobIDString.length()>0){
-		parsedHtcJobID = HtcJobID.fromDatabase(htcJobIDString);
+	PbsJobID parsedPbsJobID = null;
+	String pbsJobIDString = rset.getString(pbsJobID.toString());
+	if (!rset.wasNull() && pbsJobIDString!=null && pbsJobIDString.length()>0){
+		parsedPbsJobID = new PbsJobID(pbsJobIDString);
 	}
 	
-	SimulationExecutionStatus simExeStatus = new SimulationExecutionStatus(parsedStartDate, parsedComputeHost, parsedLatestUpdateDate, parsedEndDate,parsedHasData != null, parsedHtcJobID);
+	SimulationExecutionStatus simExeStatus = new SimulationExecutionStatus(parsedStartDate, parsedComputeHost, parsedLatestUpdateDate, parsedEndDate,parsedHasData != null, parsedPbsJobID);
 
 	VCSimulationIdentifier parsedVCSimID = new VCSimulationIdentifier(parsedSimKey,owner);
 	//jobIndex
@@ -174,7 +169,7 @@
 	//taskID
 	buffer.append(taskID + "=" + simulationJobStatus.getTaskID() + ",");
 	//schedulerStatus
-	buffer.append(schedulerStatus + "=" + simulationJobStatus.getSchedulerStatus().getDatabaseNumber() + ",");
+	buffer.append(schedulerStatus + "=" + simulationJobStatus.getSchedulerStatus() + ",");
 	//statusMsg
 	String message = simulationJobStatus.getSimulationMessage().toSerialization();
 	buffer.append(statusMsg + "='" + TokenMangler.getSQLEscapedString(message, 4000) + "',");
@@ -188,7 +183,7 @@
 	if (simQueueEntryStatus != null && simQueueEntryStatus.getQueueDate() != null){
 		buffer.append(VersionTable.formatDateToOracle(simQueueEntryStatus.getQueueDate()) + ",");
 	} else {
-		if (simulationJobStatus.getSchedulerStatus().inQueue()) {
+		if (simulationJobStatus.inQueue()) {
 			buffer.append("sysdate,");
 		} else {
 			buffer.append("null,");
@@ -204,12 +199,7 @@
 	//queueID
 	buffer.append(queueID + "=");
 	if (simQueueEntryStatus != null){
-		SimulationJobStatus.SimulationQueueID simQueueID = simQueueEntryStatus.getQueueID();
-		if (simQueueID!=null){
-			buffer.append(simQueueEntryStatus.getQueueID().getDatabaseNumber() + ",");
-		}else{
-			buffer.append("null,");
-		}
+		buffer.append(simQueueEntryStatus.getQueueID() + ",");
 	} else {
 		buffer.append("null,");
 	}
@@ -223,7 +213,7 @@
 	if (simExecutionStatus != null && simExecutionStatus.getStartDate() != null){
 		buffer.append(VersionTable.formatDateToOracle(simExecutionStatus.getStartDate()) + ",");
 	} else {	
-		if (simulationJobStatus.getSchedulerStatus().isWaiting()) {	
+		if (simulationJobStatus.isWaiting()) {	
 			buffer.append("null,");
 		} else {
 			buffer.append("sysdate,");
@@ -244,7 +234,7 @@
 	if (simExecutionStatus != null && simExecutionStatus.getEndDate() != null){
 		buffer.append(VersionTable.formatDateToOracle(simExecutionStatus.getEndDate()) + ",");
 	} else {
-		if (simulationJobStatus.getSchedulerStatus().isDone()) {
+		if (simulationJobStatus.isDone()) {
 			buffer.append("sysdate,");
 		} else {
 			buffer.append("null,");
@@ -272,8 +262,8 @@
 	
 	//pbsJobID
 	buffer.append(pbsJobID + "=");
-	if (simExecutionStatus!=null && simExecutionStatus.getHtcJobID() != null) {
-		buffer.append("'" + simExecutionStatus.getHtcJobID().toDatabase() + "'");
+	if (simExecutionStatus!=null && simExecutionStatus.getPbsJobID() != null) {
+		buffer.append("'" + simExecutionStatus.getPbsJobID().getID() + "'");
 	} else {
 		buffer.append("null");
 	}
@@ -306,7 +296,7 @@
 	//taskID
 	buffer.append(simulationJobStatus.getTaskID() + ",");
 	//schedulerStatus
-	buffer.append(simulationJobStatus.getSchedulerStatus().getDatabaseNumber() + ",");
+	buffer.append(simulationJobStatus.getSchedulerStatus() + ",");
 	//statusMsg
 	String message = simulationJobStatus.getSimulationMessage().toSerialization();
 	buffer.append("'" + TokenMangler.getSQLEscapedString(message, 4000) + "',");
@@ -314,7 +304,7 @@
 	// queue stuff
 	SimulationQueueEntryStatus simQueueEntryStatus = simulationJobStatus.getSimulationQueueEntryStatus();
 	//queueDate
-	if (simulationJobStatus.getSchedulerStatus().inQueue()) {
+	if (simulationJobStatus.inQueue()) {
 		buffer.append("sysdate,");
 	} else {		
 		if (simQueueEntryStatus != null && simQueueEntryStatus.getQueueDate() != null) {
@@ -330,7 +320,7 @@
 		//queuePriority
 		buffer.append(simQueueEntryStatus.getQueuePriority() + ",");
 		//queueID
-		buffer.append(simQueueEntryStatus.getQueueID().getDatabaseNumber() + ",");
+		buffer.append(simQueueEntryStatus.getQueueID() + ",");
 	}
 	
 	// execution stuff
@@ -342,7 +332,7 @@
 		if (simExecutionStatus.getStartDate() != null) {
 			buffer.append(VersionTable.formatDateToOracle(simExecutionStatus.getStartDate()) + ",");
 		} else {
-			if (simulationJobStatus.getSchedulerStatus() == SchedulerStatus.COMPLETED) {
+			if (simulationJobStatus.getSchedulerStatus() == SimulationJobStatus.SCHEDULERSTATUS_COMPLETED) {
 				buffer.append("sysdate,");
 			} else {
 				buffer.append("null,");
@@ -360,7 +350,7 @@
 		if (simExecutionStatus.getEndDate() != null) {
 			buffer.append(VersionTable.formatDateToOracle(simExecutionStatus.getEndDate()) + ",");
 		} else {
-			if (simulationJobStatus.getSchedulerStatus().isDone()) {
+			if (simulationJobStatus.isDone()) {
 				buffer.append("sysdate,");
 			} else {
 				buffer.append("null,");
@@ -372,8 +362,8 @@
 	buffer.append(simulationJobStatus.getServerID() == null? "null," : "'" + simulationJobStatus.getServerID() + "',");
 	buffer.append(simulationJobStatus.getJobIndex()+",");
 	
-	if (simExecutionStatus!=null && simExecutionStatus.getHtcJobID()!=null){
-		buffer.append("'"+simExecutionStatus.getHtcJobID().toDatabase()+"'");
+	if (simExecutionStatus!=null && simExecutionStatus.getPbsJobID()!=null){
+		buffer.append("'"+simExecutionStatus.getPbsJobID().getID()+"'");
 	}else{
 		buffer.append("null");
 	}
Index: src/cbit/vcell/messaging/db/ServiceTable.java
===================================================================
--- src/cbit/vcell/messaging/db/ServiceTable.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/ServiceTable.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,21 +9,15 @@
  */
 
 package cbit.vcell.messaging.db;
-import java.sql.ResultSet;
-import java.sql.SQLException;
+import cbit.vcell.messaging.admin.ServiceSpec;
+import cbit.vcell.messaging.admin.ServiceStatus;
+import cbit.htc.PbsJobID;
+import cbit.sql.*;
+import java.sql.*;
 
+import org.vcell.util.MessageConstants.ServiceType;
 import org.vcell.util.document.KeyValue;
-import org.vcell.util.document.VCellServerID;
 
-import cbit.sql.Field;
-import cbit.sql.Table;
-import cbit.vcell.message.server.ServiceSpec;
-import cbit.vcell.message.server.ServiceSpec.ServiceStartupType;
-import cbit.vcell.message.server.ServiceSpec.ServiceType;
-import cbit.vcell.message.server.ServiceStatus;
-import cbit.vcell.message.server.ServiceStatus.ServiceStatusType;
-import cbit.vcell.message.server.htc.HtcJobID;
-
 public class ServiceTable extends cbit.sql.Table {
 	private static final String TABLE_NAME = "vc_service";
 	public static final String REF_TYPE = "REFERENCES " + TABLE_NAME + "(" + Table.id_ColumnName + ")";
@@ -63,8 +57,7 @@
  */
 public ServiceStatus getServiceStatus(ResultSet rset) throws SQLException {	
 	//serverID
-	String parsedServerIDString = rset.getString(serverID.toString());
-	VCellServerID parsedServerID = VCellServerID.getServerID(parsedServerIDString);
+	String parsedServerID = rset.getString(serverID.toString());
 	//type
 	String parsedType = rset.getString(type.toString());
 	//ordinal
@@ -86,13 +79,13 @@
 		parsedStatusMsg = null;
 	}
 	//host
-	HtcJobID parsedHtcJobId = null;
-	String parsedHtcJobDatabaseString = rset.getString(pbsjobid.toString());
-	if (!rset.wasNull() && parsedHtcJobDatabaseString!=null && parsedHtcJobDatabaseString.length()>0) {
-		parsedHtcJobId = HtcJobID.fromDatabase(parsedHtcJobDatabaseString);
+	PbsJobID parsedPBSJobId = null;
+	String parsedPBSJobIdString = rset.getString(pbsjobid.toString());
+	if (!rset.wasNull() && parsedPBSJobIdString!=null && parsedPBSJobIdString.length()>0) {
+		parsedPBSJobId = new PbsJobID(parsedPBSJobIdString);
 	}
-	ServiceStatus serviceStatus = new ServiceStatus(new ServiceSpec(parsedServerID, ServiceType.fromName(parsedType), parsedOrdinal, ServiceStartupType.fromDatabaseNumber(parsedStartupType), parsedMemory), 
-			parsedDate, ServiceStatusType.fromDatabaseNumber(parsedStatus), parsedStatusMsg, parsedHtcJobId);
+	ServiceStatus serviceStatus = new ServiceStatus(new ServiceSpec(parsedServerID, ServiceType.fromName(parsedType), parsedOrdinal, parsedStartupType, parsedMemory), 
+			parsedDate, parsedStatus, parsedStatusMsg, parsedPBSJobId);
 	
 	return serviceStatus;
 }
@@ -115,19 +108,19 @@
 	//ordinal
 	buffer.append(ordinal + "=" + serviceStatus.getServiceSpec().getOrdinal() + ",");
 	//startupType
-	buffer.append(startupType + "=" + serviceStatus.getServiceSpec().getStartupType().getDatabaseNumber() + ",");
+	buffer.append(startupType + "=" + serviceStatus.getServiceSpec().getStartupType() + ",");
 	//memory
 	buffer.append(memoryMB + "=" + serviceStatus.getServiceSpec().getMemoryMB() + ",");
 	//date
 	buffer.append(date + "=sysdate,");
 	//status
-	buffer.append(status + "=" + serviceStatus.getStatus().getDatabaseNumber() + ",");
+	buffer.append(status + "=" + serviceStatus.getStatus() + ",");
 	//statusMsg
 	buffer.append(statusMsg + "='" + serviceStatus.getStatusMsg() + "',");
 	//host
 	buffer.append(pbsjobid + "=");
-	if (serviceStatus.getHtcJobId() != null){
-		buffer.append("'" + serviceStatus.getHtcJobId().toDatabase() + "'");
+	if (serviceStatus.getPbsJobId() != null){
+		buffer.append("'" + serviceStatus.getPbsJobId() + "'");
 	} else {
 		buffer.append("null");
 	}
@@ -155,18 +148,18 @@
 	//ordinal
 	buffer.append(serviceStatus.getServiceSpec().getOrdinal() + ",");
 	//startupType
-	buffer.append(serviceStatus.getServiceSpec().getStartupType().getDatabaseNumber() + ",");
+	buffer.append(serviceStatus.getServiceSpec().getStartupType() + ",");
 	//memory
 	buffer.append(serviceStatus.getServiceSpec().getMemoryMB() + ",");
 	//date
 	buffer.append("sysdate,");
 	//status
-	buffer.append(serviceStatus.getStatus().getDatabaseNumber() + ",");
+	buffer.append(serviceStatus.getStatus() + ",");
 	//statusMsg
 	buffer.append("'" + serviceStatus.getStatusMsg() + "',");
 	//host
-	if (serviceStatus.getHtcJobId() != null){
-		buffer.append("'" + serviceStatus.getHtcJobId().toDatabase() + "'");
+	if (serviceStatus.getPbsJobId() != null){
+		buffer.append("'" + serviceStatus.getPbsJobId() + "'");
 	} else {
 		buffer.append("null");
 	}
Index: src/cbit/vcell/messaging/db/SimulationExecutionStatus.java
===================================================================
--- src/cbit/vcell/messaging/db/SimulationExecutionStatus.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/db/SimulationExecutionStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,7 +15,7 @@
 import org.vcell.util.Compare;
 import org.vcell.util.Matchable;
 
-import cbit.vcell.message.server.htc.HtcJobID;
+import cbit.htc.PbsJobID;
 
 
 /**
@@ -29,17 +29,17 @@
 	private Date fieldEndDate = null;
 	private String fieldComputeHost = null;
 	private boolean fieldHasData = false;
-	private HtcJobID fieldHtcJobID = null;
+	private PbsJobID fieldPbsJobID = null;
 /**
  * SimulationExecutionStatus constructor comment.
  */
-public SimulationExecutionStatus(Date startDate, String computeHost, Date latestUpdateDate, Date endDate, boolean hasData, HtcJobID htcJobID) {
+public SimulationExecutionStatus(Date startDate, String computeHost, Date latestUpdateDate, Date endDate, boolean hasData, PbsJobID pbsJobID) {
 	fieldStartDate = startDate;
 	fieldComputeHost = computeHost;
 	fieldLatestUpdateDate = latestUpdateDate;
 	fieldEndDate = endDate;
 	fieldHasData = hasData;
-	fieldHtcJobID = htcJobID;
+	fieldPbsJobID = pbsJobID;
 }
 /**
  * Checks for internal representation of objects, not keys from database
@@ -69,7 +69,7 @@
 			//System.out.println("fieldLatestUpdateDate not = ");
 			return false;
 		}
-		if (!Compare.isEqualOrNull(fieldHtcJobID,exeStatus.fieldHtcJobID)){
+		if (!Compare.isEqualOrNull(fieldPbsJobID,exeStatus.fieldPbsJobID)){
 			return false;
 		}
 		
@@ -118,8 +118,8 @@
 	return fieldHasData;
 }
 
-public HtcJobID getHtcJobID(){
-	return fieldHtcJobID;
+public PbsJobID getPbsJobID(){
+	return fieldPbsJobID;
 }
 /**
  * Insert the method's description here.
Index: src/cbit/vcell/messaging/TopicListenerImpl.java
===================================================================
--- src/cbit/vcell/messaging/TopicListenerImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/TopicListenerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/9/2003 12:05:19 PM)
+ * @author: Fei Gao
+ */
+public abstract class TopicListenerImpl implements MessageListener {
+	
+	
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/17/2003 10:09:06 AM)
+ */
+public TopicListenerImpl() {
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public final void onMessage(Message message) {
+	try {
+		onTopicMessage(message);
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public abstract void onTopicMessage(Message message) throws JMSException ; 
+}
Index: src/cbit/vcell/messaging/WorkerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/WorkerMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/WorkerMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.server.Worker;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.solver.SimulationMessage;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/2/2003 3:00:59 PM)
+ * @author: Fei Gao
+ */
+public class WorkerMessaging extends JmsServiceProviderMessaging implements ControlTopicListener {
+	private JmsSession jobRetriever = null;
+	private JmsSession workerEventSession = null;
+	private String jobSelector = null;
+	private Worker myWorker = null;
+	private SimulationTask currentTask = null;	
+	private long lastMsgTimeStamp;
+	private boolean bProgress = true;
+	
+	class KeepAliveThread extends Thread {
+		public KeepAliveThread() {
+			super();
+			setName("KeepAliveThread_Worker");
+		}	
+		public void run() {
+			while (true) {
+				try {
+					sleep(MessageConstants.INTERVAL_PING_SERVER);
+				} catch (InterruptedException ex) {
+				}
+		
+				long t = System.currentTimeMillis();
+				if (myWorker.isRunning() && lastMsgTimeStamp != 0 && t - lastMsgTimeStamp > MessageConstants.INTERVAL_PING_SERVER) {
+					log.print("@@@@Worker:Sending alive message");
+					sendWorkerAlive();
+				}
+			}
+		}	
+	}	
+
+/**
+ * WorkerMessaging constructor comment.
+ */
+public WorkerMessaging(Worker worker0, SessionLog log0) throws JMSException {
+	super(worker0, log0);
+	myWorker = worker0;
+	reconnect();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public SimulationTask getNextTask() { 	
+	//
+	// create a transactional receive/send to get a "task" object (that this worker can handle) 
+	// and send an "accept" status message to the SchedulerControl queue
+	//
+	//log.print("==GNT");
+	currentTask = null;
+	
+	try {			
+		//log.print("Created receiver with filter = " + jobSelector);		
+		Message message = jobRetriever.receiveMessage(JmsUtils.getQueueSimJob(), jobSelector, 100);
+		if (message == null) { // no message
+			try {
+				jobRetriever.rollback(); 
+			} catch (Exception ex) {
+				log.exception(ex);
+			}
+			currentTask = null;
+			
+		} else { 
+			log.print("received message " + JmsUtils.toString(message));
+			SimulationTaskMessage taskMsg = new SimulationTaskMessage(message);
+			currentTask = taskMsg.getSimulationTask();
+			
+			log.print("Job accepted: " + currentTask);
+			WorkerEventMessage.sendAccepted(jobRetriever, this, currentTask, ManageUtils.getHostName());
+			jobRetriever.commit();
+			
+			lastMsgTimeStamp = System.currentTimeMillis();
+		}
+		
+	} catch (Exception ex) {
+		try {
+			jobRetriever.rollback(); 
+		} catch (Exception e) {
+			log.exception(e);
+		}
+		currentTask = null;
+	}
+	
+	return currentTask;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/2/2003 3:06:25 PM)
+ */
+protected void reconnect() throws JMSException {
+	jobSelector = myWorker.getJobSelector();	
+	
+	super.reconnect();
+	log.print("Job Selector : " + jobSelector);
+	jobRetriever = jmsConn.getTransactedSession(); // transactional
+	int workerPrefetchCount = Integer.parseInt(PropertyLoader.getProperty(PropertyLoader.jmsWorkerPrefetchCount, "-1"));
+	if (workerPrefetchCount > 0) {
+		jobRetriever.setPrefetchCount(workerPrefetchCount); // get messages one by one
+		jobRetriever.setPrefetchThreshold(0);
+	}
+	workerEventSession = jmsConn.getAutoSession();		
+	
+	JmsSession serviceListenTopicSession = jmsConn.getAutoSession();
+	serviceListenTopicSession.setupTopicListener(JmsUtils.getTopicServiceControl(), null, new ControlMessageCollector(myWorker));
+	jmsConn.startConnection();
+	
+	if (myWorker.getServiceType() == ServiceType.LOCALCOMPUTE) { // only start the keepalive thread for local worker
+		log.print("Start keep alive thread");
+		new KeepAliveThread().start();
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendCompleted(double progress, double timeSec, SimulationMessage simulationMessage) {
+	if (currentTask == null) {
+		return;
+	}
+
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendComplete(" + currentTask.getSimulationJobIdentifier() + ")");
+		WorkerEventMessage.sendCompleted(workerEventSession, this, currentTask, ManageUtils.getHostName(),  progress, timeSec, simulationMessage);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendFailed(SimulationMessage failureMessage) {
+	if (currentTask == null) {
+		return;
+	}
+		
+	try {
+		log.print("sendFailure(" + currentTask.getSimulationJobIdentifier() + "," + failureMessage +")");
+		WorkerEventMessage.sendFailed(workerEventSession, this, currentTask, ManageUtils.getHostName(), failureMessage);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException ex) {
+        log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendNewData(double progress, double timeSec, SimulationMessage simulationMessage) {
+	if (currentTask == null) {
+		return;
+	}
+	
+	try {
+		long t = System.currentTimeMillis();
+		if (bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE) { // don't send data message too frequently
+			log.print("sendNewData(" + currentTask.getSimulationJobIdentifier() + "," + (progress * 100) + "%," + timeSec + ")");		
+			WorkerEventMessage.sendNewData(workerEventSession, this, currentTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+		
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = false;
+		}
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendProgress(double progress, double timeSec, SimulationMessage simulationMessage) {
+	if (currentTask == null) {
+		return;
+	}
+
+	try {
+		long t = System.currentTimeMillis();
+	if (!bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE 
+		|| ((int)(progress * 100)) % 25 == 0) { // don't send progress message too frequently
+			log.print("sendProgress(" + currentTask.getSimulationJobIdentifier() + "," + (progress * 100) + "%," + timeSec + ")");
+			WorkerEventMessage.sendProgress(workerEventSession, this, currentTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+			
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = true;
+		}
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendStarting(SimulationMessage startingMessage) {
+	if (currentTask == null) {
+		return;
+	}
+	
+	try {
+		log.print("sendStarting(" + currentTask.getSimulationJobIdentifier() + ")");
+		WorkerEventMessage.sendStarting(workerEventSession, this, currentTask, ManageUtils.getHostName(), startingMessage);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+void sendWorkerAlive() {
+	if (currentTask == null) {
+		return;
+	}
+
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendWorkerAlive(" + currentTask.getSimulationJobIdentifier() + ")");
+		WorkerEventMessage.sendWorkerAlive(workerEventSession, this, currentTask, ManageUtils.getHostName(), SimulationMessage.MESSAGE_WORKEREVENT_WORKERALIVE);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2004 11:21:59 AM)
+ */
+public void startReceiving() throws JMSException {
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2004 11:21:59 AM)
+ */
+public void stopReceiving() throws JMSException {
+	jmsConn.stopConnection();
+}
+}
Index: src/cbit/vcell/messaging/JmsConnection.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnection.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/10/2003 10:21:50 AM)
+ * @author: Fei Gao
+ */
+public interface JmsConnection extends ExceptionListener {
+	public void close() throws JMSException;
+	public void closeSession(JmsSession session) throws JMSException;
+	JmsProvider getJmsProvider();
+	public boolean isBadConnection(JMSException ex);
+	public boolean isConnectionDropped();
+	public void startConnection() throws JMSException;
+	public void stopConnection() throws JMSException;
+	
+	public JmsSession getAutoSession() throws JMSException;
+	public JmsSession getClientAckSession() throws JMSException;
+	Connection getConnection();
+	public JmsSession getTransactedSession() throws JMSException;
+
+}
Index: src/cbit/vcell/messaging/JmsUtils.java
===================================================================
--- src/cbit/vcell/messaging/JmsUtils.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.PropertyLoader;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/17/2001 10:16:55 AM)
+ * @author: Jim Schaff
+ */
+public class JmsUtils {
+
+
+
+/**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.server.ProcessStatus
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public static cbit.vcell.messaging.admin.ServicePerformance getServicePerformance() {
+	try {
+		long javaFreeMemoryBytes = Runtime.getRuntime().freeMemory();
+		long javaTotalMemoryBytes = Runtime.getRuntime().totalMemory();
+		long maxJavaMemoryBytes = -1;
+		try {
+			maxJavaMemoryBytes = Long.parseLong(org.vcell.util.PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty));
+		} catch (NumberFormatException e){
+			System.out.println("error reading property '"+org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty+"', "+e.getMessage());
+		}
+		return new cbit.vcell.messaging.admin.ServicePerformance(javaFreeMemoryBytes,javaTotalMemoryBytes,maxJavaMemoryBytes);
+	} catch (Throwable e){
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/9/2004 9:17:51 AM)
+ * @return java.lang.String
+ * @param message javax.jms.Message
+ * @param propertyName java.lang.String
+ */
+public static Object parseProperty(Message message, String propertyName, Class propertyType) throws MessagePropertyNotFoundException {
+	try {
+		if (message.propertyExists(propertyName)) {
+			if (propertyType.equals(String.class)) {
+				return message.getStringProperty(propertyName);
+			} else 	if (propertyType.equals(int.class)) {
+				return new Integer(message.getIntProperty(propertyName));
+			} else 	if (propertyType.equals(long.class)) {
+				return new Long(message.getLongProperty(propertyName));
+			} else 	if (propertyType.equals(double.class)) {
+				return new Double(message.getDoubleProperty(propertyName));
+			} else {
+				throw new RuntimeException("Unexpected Property [" + propertyName + "," + propertyType + "]");
+			}
+		} else {
+			throw new MessagePropertyNotFoundException(propertyName);
+		}
+	} catch (JMSException ex) {
+		throw new MessagePropertyNotFoundException("JMSException on parsing [" + propertyName + "," + propertyType + "]:" + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:03:40 AM)
+ * @return java.lang.String
+ * @param message javax.jms.Message
+ */
+public static String toString(Message message) throws JMSException {
+	if (message == null)
+		return null;
+		
+	java.util.Enumeration enum1 = message.getPropertyNames();
+	StringBuffer buffer = new StringBuffer();
+	while (enum1.hasMoreElements()){
+		String propName = (String)enum1.nextElement();
+		try {
+			String value = (String)parseProperty(message, propName, String.class);
+			buffer.append(" " + propName + "='" + value + "'");
+		} catch (MessagePropertyNotFoundException ex) {
+			// definitely should not happen
+		}
+	}
+	return buffer.toString();
+}
+
+public final static String getJmsProvider() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsProvider);
+}
+
+public final static String getJmsUrl() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL);
+}
+
+public final static String getJmsUserID() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser);
+}
+
+public final static String getJmsPassword() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword);
+}
+
+public static final String getQueueDbReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsDbRequestQueue);
+}
+
+public static final String getQueueSimDataReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsDataRequestQueue);
+}
+
+
+public static final String getQueueSimJob() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsSimJobQueue);
+}
+
+
+public static final String getQueueSimReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsSimReqQueue);
+}
+
+
+public static final String getQueueWorkerEvent() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsWorkerEventQueue);
+}
+
+
+public static final String getTopicClientStatus() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsClientStatusTopic);
+}
+
+
+public static final String getTopicDaemonControl() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsDaemonControlTopic);
+}
+
+
+public static final String getTopicServiceControl() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsServiceControlTopic);
+}
+
+public static final int getMaxOdeJobsPerUser() {
+	return Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.maxOdeJobsPerUser));
+}
+
+
+public static final int getMaxPdeJobsPerUser() {
+	return Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.maxPdeJobsPerUser));
+}
+
+
+public static final String getQueueBNGReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsBNGRequestQueue);
+}
+}
Index: src/cbit/vcell/messaging/SimulationTaskMessage.java
===================================================================
--- src/cbit/vcell/messaging/SimulationTaskMessage.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/SimulationTaskMessage.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+
+import cbit.vcell.xml.XmlParseException;
+
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.xml.XmlHelper;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.parser.ExpressionException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/31/2003 11:39:39 AM)
+ * @author: Fei Gao
+ */
+public class SimulationTaskMessage {
+	private SimulationTask simTask = null;
+
+/**
+ * SimulationMessageHelper constructor comment.
+ */
+public SimulationTaskMessage(SimulationTask simTask0) {
+	super();
+	simTask = simTask0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/20/2004 11:02:09 AM)
+ * @param message javax.jms.Message
+ */
+public SimulationTaskMessage(Message message) throws XmlParseException, JMSException {
+	parse(message);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/20/2004 11:01:40 AM)
+ * @return cbit.vcell.solver.Simulation
+ */
+public SimulationTask getSimulationTask() {
+	return simTask;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/29/2003 2:51:01 PM)
+ * @return cbit.vcell.solver.Simulation
+ * @param xml java.lang.String
+ */
+private void parse(Message message) throws XmlParseException, JMSException {
+	if (message == null | !(message instanceof javax.jms.TextMessage)) {
+		return;
+	}		
+		
+	String xmlString = ((TextMessage)message).getText();
+	Simulation simulation = XmlHelper.XMLToSim(xmlString);
+	int taskID = -1;
+	int jobIndex = -1;
+	FieldDataIdentifierSpec[] fieldDataIDs = null;
+	try {
+		taskID = ((Integer)JmsUtils.parseProperty(message, MessageConstants.TASKID_PROPERTY, int.class)).intValue();
+	} catch (MessagePropertyNotFoundException ex) {
+		throw new JMSException("Required property " + MessageConstants.TASKID_PROPERTY + " is missing");
+	}	
+	try {
+		jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+	} catch (MessagePropertyNotFoundException ex) {
+		throw new JMSException("Required property " + MessageConstants.JOBINDEX_PROPERTY + " is missing");
+	}
+
+	// is ok if there is no field data
+	try {
+		String fdstrs = (String)JmsUtils.parseProperty(message, MessageConstants.FIELDDATAID_PROPERTY, String.class);
+		java.util.StringTokenizer st = new java.util.StringTokenizer(fdstrs, "\n");
+		fieldDataIDs = new FieldDataIdentifierSpec[st.countTokens()];
+		int count = 0;
+		while (st.hasMoreTokens()) {
+			try{
+				fieldDataIDs[count ++] = 
+					FieldDataIdentifierSpec.fromCSVString(st.nextToken());
+			}catch(ExpressionException e){
+				throw new XmlParseException("Error creating FieldDataIdentifierSpec "+e.getMessage());
+			}
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		 System.out.println("Property " + MessageConstants.FIELDDATAID_PROPERTY + " is missing");
+	}	
+
+	simTask = new SimulationTask(new SimulationJob(simulation, jobIndex, fieldDataIDs), taskID);
+}
+
+
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 11:08:17 AM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+public void sendSimulationTask(JmsSession session) throws javax.jms.JMSException, cbit.vcell.xml.XmlParseException {
+	session.sendMessage(JmsUtils.getQueueSimJob(), toMessage(session), DeliveryMode.PERSISTENT, 0);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/29/2003 2:49:00 PM)
+ * @return java.lang.String
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private String simulation2XML() throws XmlParseException {
+	return XmlHelper.simToXML(simTask.getSimulationJob().getSimulation());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 11:08:17 AM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+private javax.jms.Message toMessage(JmsSession session) throws javax.jms.JMSException, cbit.vcell.xml.XmlParseException {
+	javax.jms.Message message = session.createTextMessage(simulation2XML());		
+
+	message.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_SIMULATION_JOB_VALUE); // must have
+	message.setIntProperty(MessageConstants.JOBINDEX_PROPERTY, simTask.getSimulationJob().getJobIndex()); // must have
+	message.setIntProperty(MessageConstants.TASKID_PROPERTY, simTask.getTaskID()); // must have
+	
+	message.setStringProperty(MessageConstants.USERNAME_PROPERTY, simTask.getUserName()); // might be used to remove from the job queue when do stopSimulation
+	message.setLongProperty(MessageConstants.SIMKEY_PROPERTY, Long.parseLong(simTask.getSimKey() + "")); // might be used to remove from the job queue when do stopSimulation
+
+	message.setDoubleProperty(MessageConstants.SIZE_MB_PROPERTY, simTask.getEstimatedMemorySizeMB()); // for worker message filter
+	
+	if (simTask.getComputeResource() != null) {
+		message.setStringProperty(MessageConstants.COMPUTE_RESOURCE_PROPERTY, simTask.getComputeResource()); // for worker message filter
+	}
+
+	FieldDataIdentifierSpec[] fieldDataIDs = simTask.getSimulationJob().getFieldDataIdentifierSpecs();
+	if (fieldDataIDs != null && fieldDataIDs.length > 0) {
+		StringBuffer sb = new StringBuffer();
+		for (int i = 0; i < fieldDataIDs.length; i ++) {
+			sb.append(fieldDataIDs[i].toCSVString() + "\n");
+		}
+		message.setStringProperty(MessageConstants.FIELDDATAID_PROPERTY, sb.toString());
+	}
+	return message;
+}
+}
Index: src/cbit/vcell/messaging/QueueListenerImpl.java
===================================================================
--- src/cbit/vcell/messaging/QueueListenerImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/QueueListenerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/26/2003 10:48:42 AM)
+ * @author: Fei Gao
+ */
+public abstract class QueueListenerImpl implements javax.jms.MessageListener {
+/**
+ * QueueListenerImpl constructor comment.
+ */
+public QueueListenerImpl() {
+	super();
+}
+/**
+ * onMessage method comment.
+ */
+public final void onMessage(Message message) {
+	try {
+		onQueueMessage(message);
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}	
+}
+	public abstract void onQueueMessage(Message message) throws JMSException ;
+}
Index: src/cbit/vcell/messaging/AbstractJmsConnectionImpl.java
===================================================================
--- src/cbit/vcell/messaging/AbstractJmsConnectionImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/AbstractJmsConnectionImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (6/6/2003 11:16:18 AM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractJmsConnectionImpl implements ExceptionListener, JmsConnection {
+	protected JmsProvider jmsProvider = null;
+	protected boolean connectionDropped = false;
+	protected boolean inSetup = false;
+	protected Connection connection = null;	
+
+	protected static final int JMSCONNECTION_PING_INTERVAL = 30; // second
+	protected static final long JMSCONNECTION_RETRY_INTERVAL = 10 * MessageConstants.SECOND_IN_MS; //second
+		
+	protected List<JmsSession> sessionList = Collections.synchronizedList(new ArrayList<JmsSession>());
+
+	protected AbstractJmsConnectionImpl(JmsProvider argJmsProvider) throws JMSException {
+		jmsProvider = argJmsProvider;
+	}
+
+	protected final synchronized void checkConnection() {
+		while (connectionDropped) {
+			try {
+				System.out.println("I am waiting for Queue Connection");
+				wait();
+			} catch (InterruptedException ex) {
+			}
+		}
+	}
+
+	protected final void closeAllSessions() {
+		synchronized (sessionList) {
+			for (JmsSession session : sessionList) {
+				try {
+					session.close();
+				} catch (JMSException ex) {
+					// try to close it, if can't, it's ok
+				}
+			}		
+		}
+		sessionList.clear();
+	}
+
+	public final void closeSession(JmsSession session) throws JMSException {
+		synchronized (sessionList) {
+			session.close();
+			sessionList.remove(session);	
+		}
+	}
+
+	public final JmsProvider getJmsProvider() {
+		return jmsProvider;
+	}
+	
+	public final boolean isBadConnection(JMSException ex){
+		return jmsProvider.isBadConnection(ex);
+	}
+
+	public final boolean isConnectionDropped() {
+		return connectionDropped;
+	}
+	
+	public final void onException(JMSException jmse) { 
+		// See if connection was dropped.
+	
+		// Tell the user that there is a problem.
+	
+		// See if the error is a dropped connection. If so, try to reconnect.
+		// NOTE: the test is against SonicMQ error codes.
+		if (isBadConnection(jmse)) {	
+			// Reestablish the connection
+			// If we are in connection setup, the setupConnection method itself will retry.
+			if (!inSetup) {
+				System.out.println(this + ":Please wait while the application tries to re-establish the connection...");
+				synchronized (this) {
+					connectionDropped = true;
+					inSetup = true;
+					setupConnection();			
+					setupOnException();
+					inSetup = false;
+					connectionDropped = false;					
+					notifyAll();
+				}
+			}	
+		}
+	}
+
+	protected final synchronized void setupOnException() {
+		try {
+			List<JmsSession> tempList = new ArrayList<JmsSession>();
+			tempList.addAll(sessionList);
+			sessionList.clear();
+			
+			for (JmsSession session : tempList) {
+				session.setupOnException();				
+				sessionList.add(session);
+			}
+				
+			startConnection();
+		} catch (Exception ex) {
+			ex.printStackTrace(System.out);
+		}
+		
+	}
+ 
+	protected abstract void setupConnection();
+ 
+	public final void close() throws javax.jms.JMSException {
+		closeAllSessions();	
+		connection.close();
+	}
+	
+	public final JmsSession getAutoSession() throws JMSException {
+		return getSession(false, Session.AUTO_ACKNOWLEDGE);
+	}
+	
+	
+	public final JmsSession getClientAckSession() throws JMSException {
+		return getSession(false, Session.CLIENT_ACKNOWLEDGE);
+	}
+	
+	public final JmsSession getTransactedSession() throws JMSException {
+		return getSession(true, Session.AUTO_ACKNOWLEDGE);
+	}
+	
+	public final javax.jms.Connection getConnection() {
+		return connection;
+	}
+
+	private final JmsSession getSession(boolean transactional, int ackMode) throws JMSException {
+		checkConnection();
+		
+		JmsSession session = new JmsSessionImp(this, transactional, ackMode);
+		session.setupSession();
+		synchronized (sessionList) {
+			sessionList.add(session);	
+		}
+		
+		return session;	
+	}
+	
+	public final void startConnection() throws JMSException {
+		connection.start();
+	}
+	
+	
+	public final void stopConnection() throws javax.jms.JMSException {
+		connection.stop();
+	}
+}
Index: src/cbit/vcell/messaging/WorkerEventMessage.java
===================================================================
--- src/cbit/vcell/messaging/WorkerEventMessage.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/WorkerEventMessage.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,310 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import cbit.vcell.messaging.server.SimulationDispatcher;
+import cbit.vcell.messaging.server.SimulationTask;
+import javax.jms.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+
+import cbit.vcell.solver.SimulationInfo;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.rmi.event.WorkerEvent;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/5/2004 12:35:20 PM)
+ * @author: Fei Gao
+ */
+public class WorkerEventMessage {
+	private WorkerEvent workerEvent = null;	
+	private static final String MESSAGE_TYPE_WORKEREVENT_VALUE	= "WorkerEvent";
+
+	private static final String WORKEREVENT_STATUS = "WorkerEvent_Status";
+	private static final String WORKEREVENT_PROGRESS = "WorkerEvent_Progress";
+	private static final String WORKEREVENT_TIMEPOINT = "WorkerEvent_TimePoint";
+	private static final String WORKEREVENT_STATUSMSG = "WorkerEvent_StatusMsg";
+	
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public WorkerEventMessage(WorkerEvent event) {
+	workerEvent = event;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public WorkerEventMessage(SimulationDispatcher dispatcher, Message message0) throws JMSException, DataAccessException {
+	parseMessage(dispatcher, message0);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/11/2004 11:32:33 AM)
+ * @return cbit.rmi.event.WorkerEvent
+ */
+public cbit.rmi.event.WorkerEvent getWorkerEvent() {
+	return workerEvent;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:19:48 PM)
+ * @param message javax.jms.Message
+ */
+private void parseMessage(SimulationDispatcher dispatcher, Message message) throws JMSException {
+	if (message == null) {
+		throw new RuntimeException("Null message");
+	}	
+
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		if (msgType != null && !msgType.equals(MESSAGE_TYPE_WORKEREVENT_VALUE)) {
+			throw new RuntimeException("Wrong message");
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		throw new RuntimeException("Wrong message");
+	}
+			
+	if (message instanceof ObjectMessage) {
+		Object obj = ((ObjectMessage)message).getObject();
+		if (!(obj instanceof WorkerEvent)) {
+			throw new IllegalArgumentException("Expecting " + SimulationInfo.class.getName() + " in message.");
+		}
+		workerEvent = (WorkerEvent)obj;
+
+		// from c++ executable
+	} else if (message instanceof TextMessage) {
+		try {
+			String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+			if (msgType != null && !msgType.equals(MESSAGE_TYPE_WORKEREVENT_VALUE)) {
+				throw new RuntimeException("Wrong message"); // wrong message
+			}
+			int status = ((Integer)JmsUtils.parseProperty(message, WORKEREVENT_STATUS, int.class)).intValue();
+			String hostname = (String)JmsUtils.parseProperty(message, MessageConstants.HOSTNAME_PROPERTY, String.class);
+			String username = (String)JmsUtils.parseProperty(message, MessageConstants.USERNAME_PROPERTY, String.class);
+			int taskID = ((Integer)JmsUtils.parseProperty(message, MessageConstants.TASKID_PROPERTY, int.class)).intValue();
+			int jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+			Long longkey = (Long)JmsUtils.parseProperty(message, MessageConstants.SIMKEY_PROPERTY, long.class);
+
+			KeyValue simKey = new KeyValue(longkey + "");
+			Simulation sim = null;
+			try {
+				User user = dispatcher.getUser(simKey, username);
+				sim = dispatcher.getSimulation(user, simKey);			
+				if (sim == null) {
+					throw new RuntimeException("Null Simulation"); //wrong message	
+				}
+			} catch (DataAccessException ex) {
+				throw new RuntimeException("Null Simulation"); // wrong message
+			}
+			
+			String statusMessage = null;
+			Double progress = null;
+			Double timepoint = null;
+			
+			try {
+				statusMessage = (String)JmsUtils.parseProperty(message, WORKEREVENT_STATUSMSG, String.class);
+			} catch (MessagePropertyNotFoundException ex) {
+				// it's OK not to have status message
+			}
+
+			try {
+				progress = (Double)JmsUtils.parseProperty(message, WORKEREVENT_PROGRESS, double.class);
+				timepoint = (Double)JmsUtils.parseProperty(message, WORKEREVENT_TIMEPOINT, double.class);
+			} catch (MessagePropertyNotFoundException ex) {
+				// it's OK not to have progress or timepoint
+			}
+			
+			SimulationMessage simulationMessage = SimulationMessage.fromSerializedMessage(statusMessage);
+			if (simulationMessage == null) {			
+				switch (status) {
+				case WorkerEvent.JOB_ACCEPTED:
+					throw new RuntimeException("unexpected job_accepted status");
+				case WorkerEvent.JOB_STARTING:
+					if (statusMessage == null) {
+						simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_STARTING;
+					} else {
+						simulationMessage = SimulationMessage.workerStarting(statusMessage);
+					}
+					break;
+				case WorkerEvent.JOB_DATA:
+					simulationMessage = SimulationMessage.workerData(timepoint);
+					break;
+				case WorkerEvent.JOB_PROGRESS:
+					simulationMessage = SimulationMessage.workerProgress(progress);
+					break;
+				case WorkerEvent.JOB_FAILURE:
+					if (statusMessage == null) {
+						simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_FAILURE;
+					} else {
+						simulationMessage = SimulationMessage.workerFailure(statusMessage);
+					}
+					break;
+				case WorkerEvent.JOB_COMPLETED:
+					if (statusMessage == null) {
+						simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_COMPLETED;
+					} else {
+						simulationMessage = SimulationMessage.workerCompleted(statusMessage);
+					}
+					break;
+				case WorkerEvent.JOB_WORKER_ALIVE:
+					simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_WORKERALIVE;
+					break;
+				default:
+					throw new RuntimeException("unexpected worker event status : " + status);
+				}
+			}
+
+			workerEvent = new WorkerEvent(status, dispatcher, sim.getSimulationInfo().getAuthoritativeVCSimulationIdentifier(), jobIndex, hostname, taskID, progress, timepoint, simulationMessage);
+					
+		} catch (MessagePropertyNotFoundException ex) {
+			throw new RuntimeException("Wrong message"); //wrong message
+		} 
+	} else {
+		throw new IllegalArgumentException("Expecting object message.");
+	}
+
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendAccepted(JmsSession session, Object source, SimulationTask simTask, String hostName) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_ACCEPTED, source, simTask, hostName, SimulationMessage.MESSAGE_JOB_ACCEPTED);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendCompleted(JmsSession session, Object source, SimulationTask simTask, String hostName, double progress, double timePoint, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_COMPLETED, source, simTask, hostName, new Double(progress), new Double(timePoint), simulationMessage);		
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendFailed(JmsSession session, Object source, SimulationTask simTask, String hostName, SimulationMessage failMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_FAILURE, source, simTask,	hostName, failMessage);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendNewData(JmsSession session, Object source, SimulationTask simTask, String hostName, double progress, double timePoint, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_DATA, source, simTask, hostName, new Double(progress), new Double(timePoint), simulationMessage);		
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendProgress(JmsSession session, Object source, SimulationTask simTask, String hostName, double progress, double timePoint, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_PROGRESS, source, simTask, hostName, new Double(progress), new Double(timePoint), simulationMessage);		
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendStarting(JmsSession session, Object source, SimulationTask simTask, String hostName, SimulationMessage startMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_STARTING, source, simTask, hostName, startMessage);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendWorkerAlive(JmsSession session, Object source, SimulationTask simTask, String hostName, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_WORKER_ALIVE, source, simTask, hostName, simulationMessage);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+private void sendWorkerEvent(JmsSession session) throws JMSException {
+	session.sendMessage(JmsUtils.getQueueWorkerEvent(), toMessage(session), DeliveryMode.PERSISTENT, MessageConstants.INTERVAL_SERVER_FAIL);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/20/2003 1:36:36 PM)
+ * @return javax.jms.Message
+ */
+private Message toMessage(JmsSession session) throws JMSException {		
+	Message message = session.createObjectMessage(workerEvent);
+	message.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_WORKEREVENT_VALUE);
+	
+	return message;
+}
+}
Index: src/cbit/vcell/messaging/JmsServiceProviderMessaging.java
===================================================================
--- src/cbit/vcell/messaging/JmsServiceProviderMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsServiceProviderMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+import static cbit.vcell.messaging.admin.ManageConstants.*;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.server.ServiceProvider;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/2/2003 3:00:11 PM)
+ * @author: Fei Gao
+ */
+public abstract class JmsServiceProviderMessaging implements ControlTopicListener {
+	protected JmsConnectionFactory jmsConnFactory = null;
+	protected org.vcell.util.SessionLog log = null;
+	protected JmsConnection jmsConn = null;
+	protected JmsSession listenTopicSession = null;
+	protected ServiceProvider jmsServiceProvider = null;
+
+/**
+ * JmsMessaging constructor comment.
+ */
+protected JmsServiceProviderMessaging(ServiceProvider serviceProvider0, org.vcell.util.SessionLog log0) throws JMSException {
+	log = log0;
+	jmsConnFactory = new JmsConnectionFactoryImpl();
+	jmsServiceProvider = serviceProvider0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 10:46:29 AM)
+ */
+private void closeJmsConnection() {
+	try {
+		if (jmsConn != null) {
+			jmsConn.close();
+		}
+	} catch (JMSException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 10:28:36 AM)
+ * @return java.lang.String
+ */
+private final String getDaemonControlFilter() {
+	return MESSAGE_TYPE_PROPERTY + " NOT IN " 
+		+ "('" + MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_IAMALIVE_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_STARTSERVICE_VALUE + "'"
+		+ ")";		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/31/2003 11:49:03 AM)
+ * @return cbit.vcell.messaging.VCellQueueConnection
+ */
+public JmsConnection getJmsConnection() {
+	return jmsConn;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ * Got message from server_control topic 
+ */
+public void onControlTopicMessage(Message message) {
+	onDaemonMessage(listenTopicSession, message, jmsServiceProvider.getServiceInstanceStatus());
+}
+
+
+/**
+ * onMessage method comment.
+ */
+public final void onDaemonMessage(JmsSession controlSession, javax.jms.Message message, ServiceInstanceStatus serviceInstanceStatus) {
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MESSAGE_TYPE_PROPERTY, String.class);
+		String serviceID = null;
+		
+		if (msgType == null) {
+			return;
+		}
+		
+		log.print("JmsMessaging: onDaemonMessage:onMessage [" + JmsUtils.toString(message) + "]");	
+		
+		if (msgType.equals(MESSAGE_TYPE_ISSERVICEALIVE_VALUE)) {			
+			Message reply = controlSession.createObjectMessage(serviceInstanceStatus);
+			reply.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_IAMALIVE_VALUE);
+			reply.setStringProperty(SERVICE_ID_PROPERTY, serviceInstanceStatus.getID());
+			log.print("sending reply [" + JmsUtils.toString(reply) + "]");
+			if (message.getJMSReplyTo() != null) {
+				reply.setJMSCorrelationID(message.getJMSMessageID());
+				controlSession.publishMessage((Topic)message.getJMSReplyTo(), reply);
+			} else {
+				controlSession.publishMessage(JmsUtils.getTopicDaemonControl(), reply);
+			}		
+		} else if (msgType.equals(MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE)) {				
+			Message reply = controlSession.createObjectMessage(serviceInstanceStatus);
+			reply.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE);
+			reply.setStringProperty(SERVICE_ID_PROPERTY, serviceInstanceStatus.getID());
+			controlSession.publishMessage(JmsUtils.getTopicDaemonControl(), reply);			
+			log.print("sending reply [" + JmsUtils.toString(reply) + "]");
+			
+		} else if (msgType.equals(MESSAGE_TYPE_STOPSERVICE_VALUE)) {
+			serviceID = (String)JmsUtils.parseProperty(message, SERVICE_ID_PROPERTY, String.class);
+			if (serviceID != null && serviceID.equalsIgnoreCase(serviceInstanceStatus.getID()))  {
+				stopService();
+			}
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+	} catch (JMSException ex) {
+		log.exception(ex);
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+protected void reconnect() throws JMSException {
+	jmsConn = jmsConnFactory.createConnection();
+	listenTopicSession = jmsConn.getAutoSession();	
+	listenTopicSession.setupTopicListener(JmsUtils.getTopicDaemonControl(), getDaemonControlFilter(), new ControlMessageCollector(this));
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/10/2003 8:42:49 AM)
+ */
+protected void stopService() {
+	try {
+		Thread t = new Thread() {
+			public void run() {
+				jmsServiceProvider.stop();
+				closeJmsConnection();
+			}
+		};
+		t.start();
+		t.join(3000);	
+	} catch (InterruptedException ex) {
+	} finally {
+		System.exit(0);
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/JmsDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/JmsDispatcherDbManager.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/JmsDispatcherDbManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+
+import java.sql.Connection;
+import java.util.Date;
+import cbit.vcell.solver.SimulationMessage;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.document.VCellServerID;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:45:15 PM)
+ * @author: Fei Gao
+ */
+public class JmsDispatcherDbManager extends AbstractDispatcherDbManager implements MessagingDispatcherDbManager {
+/**
+ * JmsSimulationDispatcherDbDriver constructor comment.
+ */
+public JmsDispatcherDbManager() {
+	super();
+}
+
+
+/**
+ * updateDispatchedStatus method comment.
+ */
+public SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+		String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage startMsg) 
+			throws DataAccessException, UpdateSynchronizationException {
+
+	if (oldJobStatus != null && !oldJobStatus.isDone()) {
+		
+		SimulationJobStatus newJobStatus = getNewStatus_updateDispatchedStatus(oldJobStatus, computeHost, vcSimID, jobIndex, startMsg);
+
+		newJobStatus = adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+
+		return newJobStatus;
+	}
+
+	return oldJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, String hostName, int status, SimulationMessage solverMsg) 
+			throws DataAccessException, UpdateSynchronizationException {
+	if (oldJobStatus == null ||  oldJobStatus != null && !oldJobStatus.isDone()) {		
+
+		SimulationJobStatus newJobStatus = getNewStatus_updateEndStatus(oldJobStatus, vcSimID, jobIndex, hostName, status, solverMsg);
+
+		if (oldJobStatus == null) {
+			newJobStatus = adminDbXA.insertSimulationJobStatus(con, newJobStatus);
+		} else {
+			newJobStatus = adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+		}
+
+		return newJobStatus;
+	}
+
+	return oldJobStatus;
+}
+
+
+/**
+ * updateLatestUpdateDate method comment.
+ */
+public void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+
+	if (oldJobStatus != null && !oldJobStatus.isDone()) {
+
+		SimulationJobStatus	newJobStatus = getNewStatus_updateLatestUpdateDate(oldJobStatus, vcSimID, jobIndex, simulationMessage);
+		
+		if (newJobStatus != null) {
+			adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+		}
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateQueueStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDb, Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int queueID, int taskID, boolean firstSubmit) 
+			throws DataAccessException, UpdateSynchronizationException {
+	if (oldJobStatus == null || oldJobStatus.isDone() || oldJobStatus.isWaiting()) {	
+		// no job for the same simulation running						
+		Date submitDate = firstSubmit ? null : oldJobStatus.getSubmitDate();
+		int schedulerStatus = SimulationJobStatus.SCHEDULERSTATUS_WAITING;
+		SimulationMessage simulationMessage = SimulationMessage.MESSAGE_JOB_WAITING;
+		if (queueID == MessageConstants.QUEUE_ID_SIMULATIONJOB) {
+			schedulerStatus = SimulationJobStatus.SCHEDULERSTATUS_QUEUED;
+			simulationMessage = SimulationMessage.MESSAGE_JOB_QUEUED;
+		}
+
+		// update the job status in the database and local memory
+		SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, jobIndex, submitDate, schedulerStatus, taskID, 
+				simulationMessage,	new SimulationQueueEntryStatus(null, MessageConstants.PRIORITY_DEFAULT, queueID), null);
+		
+		if (oldJobStatus == null) {
+			newJobStatus = adminDb.insertSimulationJobStatus(con, newJobStatus);
+		} else {
+			newJobStatus = adminDb.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+		}
+
+		return newJobStatus;
+	}
+
+	return oldJobStatus;
+		
+}
+
+
+/**
+ * updateRunningStatus method comment.
+ */
+public SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, String hostName, 
+		VCSimulationIdentifier vcSimID, int jobIndex, boolean hasData, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+	if (oldJobStatus != null && !oldJobStatus.isDone()) {
+
+		SimulationJobStatus newJobStatus = getNewStatus_updateRunningStatus(oldJobStatus, hostName, vcSimID, jobIndex, hasData, solverMsg);
+
+		if (oldJobStatus == newJobStatus) { // running statuses, don't always store into the database		
+			updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, solverMsg);
+			return oldJobStatus;
+		} else {
+			newJobStatus = adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+			return newJobStatus;
+		}
+	}
+
+	return oldJobStatus;
+}
+}
Index: src/cbit/vcell/messaging/server/LocalDataSetControllerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalDataSetControllerMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalDataSetControllerMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.rmi.event.*;
+import cbit.vcell.solver.*;
+import cbit.vcell.client.data.OutputContext;
+import cbit.vcell.export.server.*;
+import cbit.vcell.field.FieldDataFileOperationResults;
+import cbit.vcell.field.FieldDataFileOperationSpec;
+import cbit.vcell.simdata.gui.SpatialSelection;
+import cbit.plot.*;
+import java.rmi.*;
+import java.rmi.server.*;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCDataIdentifier;
+
+import cbit.vcell.solvers.CartesianMesh;
+import cbit.vcell.server.*;
+import cbit.vcell.simdata.*;
+
+/**
+ * This interface was generated by a SmartGuide.
+ * 
+ */
+public class LocalDataSetControllerMessaging extends UnicastRemoteObject implements DataSetController {
+    private RpcDataServerProxy dataServerProxy = null;
+    private User user = null;
+    private SessionLog sessionLog = null;
+
+/**
+ * This method was created by a SmartGuide.
+ */
+public LocalDataSetControllerMessaging (SessionLog sLog, User argUser, cbit.vcell.messaging.JmsClientMessaging clientMessaging) throws RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortDataSetController,0));
+	this.sessionLog = sLog;
+	this.user = argUser;
+	try {
+		this.dataServerProxy = new RpcDataServerProxy(user, clientMessaging, sessionLog);
+	} catch (javax.jms.JMSException e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException("JMS exception creating DataServerProxy: "+e.getMessage());
+	}
+}
+
+
+
+public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.fieldDataFileOperationSpec(...)");
+	try {
+		return dataServerProxy.fieldDataFileOperation(fieldDataFileOperationSpec);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String[]
+ */
+public DataIdentifier[] getDataIdentifiers(OutputContext outputContext,VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getDataIdentifiers(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getDataIdentifiers(outputContext,vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ */
+public double[] getDataSetTimes(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getDataSetTimes(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getDataSetTimes(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/26/2004 1:05:01 PM)
+ * @param function cbit.vcell.math.Function
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+
+public cbit.vcell.math.AnnotatedFunction[] getFunctions(OutputContext outputContext,org.vcell.util.document.VCDataIdentifier vcdataID) throws org.vcell.util.DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getFunctions(vcdataID=" + vcdataID + ")");
+	try {
+		return dataServerProxy.getFunctions(outputContext,vcdataID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.plot.PlotData
+ * @param varName java.lang.String
+ * @param spatialSelection cbit.vcell.simdata.gui.SpatialSelection
+ */
+public PlotData getLineScan(OutputContext outputContext,VCDataIdentifier vcdID, String varName, double time, SpatialSelection spatialSelection) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getLineScan(vcdID=" + vcdID + ", " + varName + ", " + time + ", at " + spatialSelection+")");
+	try {
+		return dataServerProxy.getLineScan(outputContext,vcdID, varName, time, spatialSelection);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return int[]
+ */
+public CartesianMesh getMesh(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getMesh(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getMesh(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/14/00 11:20:51 AM)
+ * @return cbit.vcell.export.data.ODESimData
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getODEData(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getODEData(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param time double
+ */
+public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getParticleDataBlock(vcdID=" + vcdID + ",time=" + time + ")");
+	try {
+		return dataServerProxy.getParticleDataBlock(vcdID,time);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return boolean
+ */
+public boolean getParticleDataExists(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getParticleDataExists(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getParticleDataExists(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param time double
+ */
+public SimDataBlock getSimDataBlock(OutputContext outputContext,VCDataIdentifier vcdID, String varName, double time) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getSimDataBlock(vcdID=" + vcdID + ", varName=" + varName + ", time=" + time + ")");
+	try {
+		return dataServerProxy.getSimDataBlock(outputContext,vcdID,varName,time);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param index int
+ */
+public org.vcell.util.document.TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext,VCDataIdentifier vcdID,org.vcell.util.document.TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getTimeSeriesValues(vcdID=" + vcdID + ", " + timeSeriesJobSpec + ")");
+	try {
+		return dataServerProxy.getTimeSeriesValues(outputContext,vcdID,timeSeriesJobSpec);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @param simInfo cbit.vcell.solver.SimulationInfo
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public ExportEvent makeRemoteFile(OutputContext outputContext,ExportSpecs exportSpecs) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.makeRemoteFile(vcdID=" + exportSpecs.getVCDataIdentifier() + ")");
+	try {
+		return dataServerProxy.makeRemoteFile(outputContext,exportSpecs);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+
+public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdataID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getDataProcessingOutput(vcdataID=" + vcdataID + ")");
+	try {
+		return dataServerProxy.getDataProcessingOutput(vcdataID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+}
Index: src/cbit/vcell/messaging/server/RpcDbServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDbServerImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDbServerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.sql.OraclePoolingConnectionFactory;
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import org.vcell.util.DataAccessException;
+import cbit.vcell.modeldb.DatabaseServerImpl;
+import cbit.sql.OracleKeyFactory;
+/**
+ * Insert the type's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @author: Jim Schaff
+ *
+ * stateless database service for any user (should be thread safe ... reentrant)
+ *
+ */
+public class RpcDbServerImpl extends AbstractRpcServerImpl {
+	private DatabaseServerImpl dbServerImpl = null;	
+
+/**
+ * DbServerImpl constructor comment.
+ */
+public RpcDbServerImpl(org.vcell.util.SessionLog sessionLog) throws DataAccessException {
+	super(sessionLog);
+	try {
+		ConnectionFactory conFactory = new OraclePoolingConnectionFactory(log);
+		KeyFactory	keyFactory = new OracleKeyFactory();
+		dbServerImpl = new DatabaseServerImpl(conFactory, keyFactory, sessionLog);	 
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException("Error creating DBTopLevel " + e.getMessage());
+	}		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/16/2004 12:30:44 PM)
+ * @return java.lang.Object
+ */
+public java.lang.Object getServerImpl() {
+	return dbServerImpl;
+}
+}
Index: src/cbit/vcell/messaging/server/PropertyLoaderThread.java
===================================================================
--- src/cbit/vcell/messaging/server/PropertyLoaderThread.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/PropertyLoaderThread.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/17/2003 8:59:18 AM)
+ * @author: Fei Gao
+ */
+public class PropertyLoaderThread extends Thread {
+/**
+ * PropertyLoaderThread constructor comment.
+ */
+public PropertyLoaderThread() {
+	super();
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param target java.lang.Runnable
+ */
+public PropertyLoaderThread(Runnable target) {
+	super(target);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param target java.lang.Runnable
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(Runnable target, String name) {
+	super(target, name);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(String name) {
+	super(name);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param group java.lang.ThreadGroup
+ * @param target java.lang.Runnable
+ */
+public PropertyLoaderThread(ThreadGroup group, Runnable target) {
+	super(group, target);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param group java.lang.ThreadGroup
+ * @param target java.lang.Runnable
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(ThreadGroup group, Runnable target, String name) {
+	super(group, target, name);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param group java.lang.ThreadGroup
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(ThreadGroup group, String name) {
+	super(group, name);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 8:59:45 AM)
+ */
+public void run() {
+	while (true){
+		//
+		// sleep for a while
+		//
+		try {
+			Thread.sleep(20 * MessageConstants.MINUTE_IN_MS);
+		} catch (InterruptedException e){
+		}
+		
+		//
+		// re-read the property file
+		//
+		System.out.println("re-read the property file");
+		try {
+			PropertyLoader.loadProperties();
+		} catch (Throwable e){
+			e.printStackTrace(System.out);
+		}
+	}		
+}
+}
Index: src/cbit/vcell/messaging/server/SimulationTask.java
===================================================================
--- src/cbit/vcell/messaging/server/SimulationTask.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/messaging/server/SimulationTask.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,9 +9,7 @@
  */
 
 package cbit.vcell.messaging.server;
-import org.vcell.util.Compare;
 import org.vcell.util.ISize;
-import org.vcell.util.Matchable;
 import org.vcell.util.document.KeyValue;
 import org.vcell.util.document.User;
 
@@ -30,7 +28,7 @@
  * Creation date: (10/24/2001 10:44:09 PM)
  * @author: Jim Schaff
  */
-public class SimulationTask implements java.io.Serializable, Matchable {
+public class SimulationTask implements java.io.Serializable {
 	private SimulationJob simulationJob = null;
 	private int taskID = 0;
 	private String computeResource = null;
@@ -131,7 +129,7 @@
  * Creation date: (10/24/2001 10:45:58 PM)
  * @return cbit.vcell.solver.Simulation
  */
-public String getSimulationJobID() {
+public String getSimulationJobIdentifier() {
 	return simulationJob.getSimulationJobID();
 }
 
@@ -177,31 +175,10 @@
  * @return java.lang.String
  */
 public String toString() {
-	return "[" + getSimulationJobID() + "," + taskID + "]";
+	return "[" + getSimulationJobIdentifier() + "," + taskID + "]";
 }
 
 public String getComputeResource() {
 	return computeResource;
 }
-
-public boolean compareEqual(Matchable obj) {
-	if (obj instanceof SimulationTask){
-		SimulationTask other = (SimulationTask)obj;
-		if (!Compare.isEqual(getSimulationJob(), other.getSimulationJob())){
-			return false;
-		}
-		if (!Compare.isEqual(getTaskID(), other.getTaskID())){
-			return false;
-		}
-		if (!Compare.isEqualOrNull(getComputeResource(), other.getComputeResource())){
-			return false;
-		}
-		return true;
-	}
-	return false;
 }
-
-public Simulation getSimulation() {
-	return getSimulationJob().getSimulation();
-}
-}
Index: src/cbit/vcell/messaging/server/RpcDataServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDataServerProxy.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDataServerProxy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCDataIdentifier;
+
+import cbit.vcell.client.data.OutputContext;
+import cbit.vcell.field.FieldDataFileOperationResults;
+import cbit.vcell.field.FieldDataFileOperationSpec;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.simdata.*;
+import cbit.vcell.solver.DataProcessingOutput;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/6/2001 1:51:41 PM)
+ * @author: Jim Schaff
+ */
+public class RpcDataServerProxy extends AbstractRpcServerProxy implements cbit.vcell.server.DataSetController {
+/**
+ * DataServerProxy constructor comment.
+ */
+public RpcDataServerProxy(User argUser, JmsClientMessaging clientMessaging, SessionLog log) throws javax.jms.JMSException {
+	super(argUser, clientMessaging, cbit.vcell.messaging.JmsUtils.getQueueSimDataReq(), log);
+}
+
+
+
+public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws org.vcell.util.DataAccessException {
+	return (FieldDataFileOperationResults)rpc("fieldDataFileOperation",new Object[]{user, fieldDataFileOperationSpec});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.simdata.DataIdentifier[] getDataIdentifiers(OutputContext outputContext,VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (DataIdentifier[])rpc("getDataIdentifiers",new Object[]{outputContext,user, vcdID});
+}
+
+public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdID) throws DataAccessException {
+	return (DataProcessingOutput)rpc("getDataProcessingOutput", new Object[]{user, vcdID});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public double[] getDataSetTimes(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (double[])rpc("getDataSetTimes",new Object[]{user, vcdID});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/26/2004 1:01:25 PM)
+ * @param function cbit.vcell.math.Function
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.math.AnnotatedFunction[] getFunctions(OutputContext outputContext,org.vcell.util.document.VCDataIdentifier vcdataID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.math.AnnotatedFunction[])rpc("getFunctions",new Object[]{outputContext,user, vcdataID});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.plot.PlotData
+ * @param variable java.lang.String
+ * @param time double
+ * @param spatialSelection cbit.vcell.simdata.gui.SpatialSelection
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.plot.PlotData getLineScan(OutputContext outputContext,VCDataIdentifier vcdID, String variable, double time, cbit.vcell.simdata.gui.SpatialSelection spatialSelection) throws org.vcell.util.DataAccessException {
+	return (cbit.plot.PlotData)rpc("getLineScan",new Object[]{outputContext,user, vcdID,variable,new Double(time),spatialSelection});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return CartesianMesh
+ */
+public cbit.vcell.solvers.CartesianMesh getMesh(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.solvers.CartesianMesh)rpc("getMesh",new Object[]{user, vcdID});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/6/2001 1:51:41 PM)
+ * @param odeSimData cbit.vcell.export.data.ODESimData
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.solver.ode.ODESimData)rpc("getODEData",new Object[]{user, vcdID});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return ParticleData
+ * @param time double
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws org.vcell.util.DataAccessException {
+	return (ParticleDataBlock)rpc("getParticleDataBlock",new Object[]{user, vcdID,new Double(time)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return boolean
+ */
+public boolean getParticleDataExists(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	Boolean bParticleDataExists = (Boolean)rpc("getParticleDataExists",new Object[]{user, vcdID});
+	return bParticleDataExists.booleanValue();
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimDataBlock getSimDataBlock(OutputContext outputContext,VCDataIdentifier vcdID, String varName, double time) throws org.vcell.util.DataAccessException {
+	return (SimDataBlock)rpc("getSimDataBlock",new Object[]{outputContext,user, vcdID,varName,new Double(time)});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param x int
+ * @param y int
+ * @param z int
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext,VCDataIdentifier vcdID,org.vcell.util.document.TimeSeriesJobSpec timeSeriesJobSpec) throws org.vcell.util.DataAccessException {
+//	return (cbit.util.TimeSeriesJobResults)rpc("getTimeSeriesValues",new Object[]{user, vcdID,timeSeriesJobSpec});
+	try {
+		if(!timeSeriesJobSpec.getVcDataJobID().isBackgroundTask()){
+			return (org.vcell.util.document.TimeSeriesJobResults)rpc("getTimeSeriesValues",new Object[]{outputContext,user, vcdID,timeSeriesJobSpec});
+		}else{
+			rpc(ServiceType.DATA, "getTimeSeriesValues", new Object[]{outputContext,user, vcdID,timeSeriesJobSpec}, false);
+		}
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+	return null;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/6/2001 3:56:41 PM)
+ * @return cbit.rmi.event.ExportEvent
+ * @param exportSpecs cbit.vcell.export.server.ExportSpecs
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.rmi.event.ExportEvent makeRemoteFile(OutputContext outputContext,cbit.vcell.export.server.ExportSpecs exportSpecs) throws org.vcell.util.DataAccessException {
+	try {
+		rpc(ServiceType.DATA, "makeRemoteFile", new Object[]{outputContext,user, exportSpecs}, false, new String[]{ServiceType.DATAEXPORT.getName()}, new Object[]{new Boolean(true)});
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+	return null;
+}
+
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private Object rpc(String methodName, Object[] args) throws DataAccessException {
+	try {
+		return rpc(ServiceType.DATA, methodName, args, true);
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/Worker.java
===================================================================
--- src/cbit/vcell/messaging/server/Worker.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/Worker.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:20:06 PM)
+ * @author: Fei Gao
+ */
+public interface Worker extends ServiceProvider, cbit.vcell.messaging.ControlTopicListener, cbit.vcell.solver.SolverListener {
+	public String getJobSelector();
+	public boolean isRunning();
+}
Index: src/cbit/vcell/messaging/server/SimDataServer.java
===================================================================
--- src/cbit/vcell/messaging/server/SimDataServer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/SimDataServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+
+import static org.vcell.util.MessageConstants.*;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public class SimDataServer extends JmsRpcServer {
+	private RpcDataServerImpl rpcDataServerImpl = null;
+	private static String filter = "(" + MESSAGE_TYPE_PROPERTY + "='" + MESSAGE_TYPE_RPC_SERVICE_VALUE  + "') AND (" 
+		+ SERVICE_TYPE_PROPERTY + "='" + ServiceType.DATA.getName() + "')";	
+
+/**
+ * Scheduler constructor comment.
+ */
+public SimDataServer(int serviceOrdinal, boolean bExportOnly, String logdir) throws Exception {
+	super(bExportOnly ? ServiceType.DATAEXPORT : ServiceType.DATA, serviceOrdinal, JmsUtils.getQueueSimDataReq(), 
+		filter + " AND (" + ServiceType.DATAEXPORT.getName() + (bExportOnly ? " is NOT NULL)" : " is NULL)"), logdir);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/1/2003 9:34:57 AM)
+ */
+public RpcServerImpl getRpcServerImpl() throws DataAccessException {
+	if (rpcDataServerImpl == null) {
+		try {
+			rpcDataServerImpl = new RpcDataServerImpl(rpcServerMessaging, log);			
+		} catch (java.io.FileNotFoundException ex) {
+			log.exception(ex);
+			throw new org.vcell.util.DataAccessException(ex.getMessage());
+		}
+	}
+
+	return rpcDataServerImpl;
+}
+
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 1) {
+		System.out.println("Missing arguments: " + SimDataServer.class.getName() + " serviceOrdinal [EXPORTONLY] [logdir]");
+		System.exit(1);
+	}
+	
+	try {
+		PropertyLoader.loadProperties();
+		
+		int serviceOrdinal = Integer.parseInt(args[0]);		
+		String logdir = null;
+		boolean bExportOnly = false;		
+		if (args.length > 1) {
+			if (args[1].equalsIgnoreCase("EXPORTONLY")) {
+				bExportOnly = true;
+				VCMongoMessage.serviceStartup(ServiceName.export, new Integer(serviceOrdinal), args);
+				if (args.length > 2) {	
+					logdir = args[2];
+				}
+			} else {
+				VCMongoMessage.serviceStartup(ServiceName.simData, new Integer(serviceOrdinal), args);
+				logdir = args[1];
+			}
+		}
+        SimDataServer simDataServer = new SimDataServer(serviceOrdinal, bExportOnly, logdir);
+        simDataServer.start();
+    } catch (Throwable e) {
+        e.printStackTrace(System.out);
+    }
+}
+}
Index: src/cbit/vcell/messaging/server/ServiceProvider.java
===================================================================
--- src/cbit/vcell/messaging/server/ServiceProvider.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/ServiceProvider.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import org.vcell.util.MessageConstants.ServiceType;
+
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:23:36 PM)
+ * @author: Fei Gao
+ */
+public interface ServiceProvider {
+public ServiceInstanceStatus getServiceInstanceStatus();
+public String getServiceInstanceID();
+public ServiceType getServiceType();
+public void stop();
+}
Index: src/cbit/vcell/messaging/server/AbstractDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractDispatcherDbManager.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractDispatcherDbManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.htc.PbsJobID;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.server.AdminDatabaseServer;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+import cbit.vcell.messaging.db.SimulationExecutionStatus;
+import java.util.Date;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.solver.VCSimulationIdentifier;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/16/2004 10:52:07 AM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractDispatcherDbManager implements DispatcherDbManager {
+/**
+ * SimulationDispatcherHelper constructor comment.
+ */
+public AbstractDispatcherDbManager() {
+	super();
+}
+
+
+/**
+ * updateDispatchedStatus method comment.
+ */
+SimulationJobStatus getNewStatus_updateDispatchedStatus(SimulationJobStatus oldJobStatus, String computeHost, VCSimulationIdentifier vcSimID, 
+		int jobIndex, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+
+	// new queue status
+	SimulationQueueEntryStatus oldQueueStatus = oldJobStatus.getSimulationQueueEntryStatus();
+	SimulationQueueEntryStatus newQueueStatus = new SimulationQueueEntryStatus(oldQueueStatus.getQueueDate(), 
+		oldQueueStatus.getQueuePriority(), MessageConstants.QUEUE_ID_NULL);
+	
+	// new exe status
+	SimulationExecutionStatus newExeStatus = new SimulationExecutionStatus(null, computeHost, null,	null, false, startMsg.getPbsJobId());
+
+	// new job status
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), vcSimID, jobIndex, oldJobStatus.getSubmitDate(), SimulationJobStatus.SCHEDULERSTATUS_DISPATCHED,
+			oldJobStatus.getTaskID(), startMsg, newQueueStatus, newExeStatus);
+
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+SimulationJobStatus getNewStatus_updateEndStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimID, int jobIndex, 
+		String hostName, int status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+
+	// new queue status
+	SimulationQueueEntryStatus oldQueueStatus = oldJobStatus == null ? null : oldJobStatus.getSimulationQueueEntryStatus();
+	SimulationQueueEntryStatus newQueueStatus = oldQueueStatus;
+	if (oldQueueStatus != null && oldQueueStatus.getQueueID() != MessageConstants.QUEUE_ID_NULL) {		
+		newQueueStatus = new SimulationQueueEntryStatus(oldQueueStatus.getQueueDate(), oldQueueStatus.getQueuePriority(), MessageConstants.QUEUE_ID_NULL);
+	}
+
+	// new exe status
+	SimulationExecutionStatus oldExeStatus = oldJobStatus == null ? null : oldJobStatus.getSimulationExecutionStatus();
+	SimulationExecutionStatus newExeStatus = null;
+	boolean hasData = false;
+	
+	if (oldExeStatus == null) {
+		if (status == SimulationJobStatus.SCHEDULERSTATUS_COMPLETED) {
+			hasData = true;
+		}
+		newExeStatus = new SimulationExecutionStatus(null, hostName, null, null, hasData, solverMsg.getPbsJobId());				
+	} else {
+		if (status == SimulationJobStatus.SCHEDULERSTATUS_COMPLETED) {
+			hasData = true;
+		} else {
+			hasData = oldExeStatus.hasData();
+		}
+		PbsJobID pbsJobID = oldExeStatus.getPbsJobID();
+		if (solverMsg.getPbsJobId()!=null){
+			pbsJobID = solverMsg.getPbsJobId();
+		}
+		newExeStatus = new SimulationExecutionStatus(oldExeStatus.getStartDate(), (hostName != null) ? hostName : oldExeStatus.getComputeHost(), null, null, hasData, pbsJobID);
+	}
+
+	// new job status
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, jobIndex, 
+		oldJobStatus == null ? null : oldJobStatus.getSubmitDate(), status, oldJobStatus == null ? 0 : oldJobStatus.getTaskID(), solverMsg,
+		newQueueStatus, newExeStatus);
+	
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+SimulationJobStatus getNewStatus_updateLatestUpdateDate(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimID, 
+		int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+
+	SimulationExecutionStatus oldExeStatus = oldJobStatus.getSimulationExecutionStatus();
+	if (oldExeStatus == null) {
+		return null;
+	}
+	
+	Date latestUpdate = oldExeStatus.getLatestUpdateDate();
+	Date sysDate = oldJobStatus.getTimeDateStamp();
+	if (sysDate.getTime() - latestUpdate.getTime() < MessageConstants.INTERVAL_PING_SERVER * 3 / 5) {
+		return null;
+	}
+	
+	// new exe status
+	PbsJobID pbsJobID = oldExeStatus.getPbsJobID();
+	if (simulationMessage.getPbsJobId()!=null){
+		pbsJobID = simulationMessage.getPbsJobId();
+	}
+	SimulationExecutionStatus newExeStatus = new SimulationExecutionStatus(oldExeStatus.getStartDate(), oldExeStatus.getComputeHost(), null, 
+			oldExeStatus.getEndDate(), oldExeStatus.hasData(), pbsJobID);
+	
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), vcSimID, jobIndex, oldJobStatus.getSubmitDate(), 
+		oldJobStatus.getSchedulerStatus(),	oldJobStatus.getTaskID(), simulationMessage, oldJobStatus.getSimulationQueueEntryStatus(), newExeStatus);
+
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+SimulationJobStatus getNewStatus_updateRunningStatus(SimulationJobStatus oldJobStatus, String hostName, VCSimulationIdentifier vcSimID, 
+		int jobIndex, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException {
+
+	// new queue status		
+	SimulationQueueEntryStatus oldQueueStatus = oldJobStatus.getSimulationQueueEntryStatus();
+	SimulationQueueEntryStatus newQueueStatus = oldQueueStatus;
+	if (oldQueueStatus.getQueueID() != MessageConstants.QUEUE_ID_NULL) {
+		newQueueStatus = new SimulationQueueEntryStatus(oldQueueStatus.getQueueDate(), oldQueueStatus.getQueuePriority(), MessageConstants.QUEUE_ID_NULL);
+	}
+
+	// new exe status
+	SimulationExecutionStatus oldExeStatus = oldJobStatus.getSimulationExecutionStatus();
+	SimulationExecutionStatus newExeStatus = null;
+	if (oldExeStatus == null) {
+		newExeStatus = new SimulationExecutionStatus(null, hostName, null, null, hasData, solverMsg.getPbsJobId());
+	} else if (!oldJobStatus.isRunning() || !oldExeStatus.hasData() && hasData) {
+		PbsJobID pbsJobID = oldExeStatus.getPbsJobID();
+		if (solverMsg.getPbsJobId()!=null){
+			pbsJobID = solverMsg.getPbsJobId();
+		}
+		newExeStatus = new SimulationExecutionStatus(oldExeStatus.getStartDate(), (hostName != null) ? hostName : oldExeStatus.getComputeHost(), null, null, hasData, pbsJobID);		
+	} else {
+		return oldJobStatus;
+	}
+	
+	// new job status
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), vcSimID, jobIndex, oldJobStatus.getSubmitDate(), 
+		SimulationJobStatus.SCHEDULERSTATUS_RUNNING, oldJobStatus.getTaskID(), solverMsg, newQueueStatus, newExeStatus);
+
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus getSimulationJobStatus(AdminDatabaseServer adminDb, KeyValue simKey, int jobIndex) throws DataAccessException {
+	try {		
+		return adminDb.getSimulationJobStatus(simKey, jobIndex);
+	} catch (java.rmi.RemoteException ex) {
+		throw new DataAccessException("updateDispatchedStatus " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus,	AdminDatabaseServer adminDb, String computeHost, 
+		VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+	try {
+
+		if (oldJobStatus != null && !oldJobStatus.isDone()) {
+			
+			SimulationJobStatus newJobStatus = getNewStatus_updateDispatchedStatus(oldJobStatus, computeHost, vcSimID, jobIndex, startMsg);
+
+			newJobStatus = adminDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+
+			return newJobStatus;
+		}
+
+		return oldJobStatus;
+		
+	} catch (java.rmi.RemoteException ex) {
+		throw new DataAccessException("updateEndStatus " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, VCSimulationIdentifier vcSimID, 
+		int jobIndex, String hostName, int status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus != null && !oldJobStatus.isDone()) {		
+
+			SimulationJobStatus newJobStatus = getNewStatus_updateEndStatus(oldJobStatus, vcSimID, jobIndex, hostName, status, solverMsg);
+			
+			newJobStatus = adminDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+
+			return newJobStatus;
+		}
+
+		return oldJobStatus;
+	} catch (java.rmi.RemoteException ex) {
+		throw new DataAccessException("updateEndStatus " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, VCSimulationIdentifier vcSimID, 
+		int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus != null && !oldJobStatus.isDone()) {
+
+			SimulationJobStatus	newJobStatus = getNewStatus_updateLatestUpdateDate(oldJobStatus, vcSimID, jobIndex, simulationMessage);
+			
+			if (newJobStatus != null) {
+				adminDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+			}
+		}
+	} catch (java.rmi.RemoteException ex) {
+		throw new DataAccessException("updateLatestUpdateDate " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, String hostName, 
+		VCSimulationIdentifier vcSimID, int jobIndex, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus != null && !oldJobStatus.isDone()) {
+
+			SimulationJobStatus newJobStatus = getNewStatus_updateRunningStatus(oldJobStatus, hostName, vcSimID, jobIndex, hasData, solverMsg);
+			if (oldJobStatus == newJobStatus) { // running statuses, don't always store into the database				
+				updateLatestUpdateDate(oldJobStatus, adminDb, vcSimID, jobIndex, solverMsg);
+				return oldJobStatus;
+			} else {
+				newJobStatus = adminDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+				return newJobStatus;
+			}
+		}
+
+		return oldJobStatus;
+	} catch (java.rmi.RemoteException ex) {
+		throw new DataAccessException("updateRunningStatus " + ex.getMessage());
+	}		
+}
+}
Index: src/cbit/vcell/messaging/server/RpcServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcServerProxy.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcServerProxy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import org.vcell.util.MessageConstants.ServiceType;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:16:36 PM)
+ * @author: Fei Gao
+ */
+public interface RpcServerProxy {
+	public Object rpc(ServiceType serviceType, String methodName, Object[] args, boolean returnRequired) throws Exception;
+}
Index: src/cbit/vcell/messaging/server/RpcDataServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDataServerImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDataServerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.simdata.DataServerImpl;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+
+import cbit.vcell.simdata.Cachetable;
+import cbit.vcell.simdata.DataSetControllerImpl;
+import cbit.vcell.export.server.ExportServiceImpl;
+
+/**
+ * This interface was generated by a SmartGuide.
+ * 
+ */
+public class RpcDataServerImpl extends AbstractRpcServerImpl implements cbit.rmi.event.ExportListener,cbit.rmi.event.DataJobListener {
+	private DataServerImpl dataServerImpl = null;
+	private cbit.vcell.messaging.RpcServerMessaging rpcServerMessaging = null;
+
+/**
+ * This method was created by a SmartGuide.
+ */
+public RpcDataServerImpl (cbit.vcell.messaging.RpcServerMessaging messaging, SessionLog sessionLog) throws FileNotFoundException {
+	super(sessionLog);
+	rpcServerMessaging = messaging;
+
+	Cachetable cacheTable = new Cachetable(MessageConstants.MINUTE_IN_MS * 20);
+	DataSetControllerImpl dataSetControllerImpl = new DataSetControllerImpl(sessionLog, cacheTable, 
+			new File(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty)), 
+			new File(PropertyLoader.getRequiredProperty(PropertyLoader.secondarySimDataDirProperty)));
+	//add dataJobListener
+	dataSetControllerImpl.addDataJobListener(this);
+	
+	ExportServiceImpl exportServiceImpl = new ExportServiceImpl(log);
+	// add export listener
+	exportServiceImpl.addExportListener(this);
+	
+	dataServerImpl = new DataServerImpl(log, dataSetControllerImpl, exportServiceImpl);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/31/2006 8:48:04 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void dataJobMessage(cbit.rmi.event.DataJobEvent event) {
+	try {
+		rpcServerMessaging.publishDataStatus(event);
+	} catch (javax.jms.JMSException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 10:34:11 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void exportMessage(cbit.rmi.event.ExportEvent event) {
+	try {
+		rpcServerMessaging.publishExportStatus(event);
+	} catch (javax.jms.JMSException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/16/2004 1:02:57 PM)
+ * @return java.lang.Object
+ */
+public java.lang.Object getServerImpl() {
+	return dataServerImpl;
+}
+}
Index: src/cbit/vcell/messaging/server/SimulationDispatcher.java
===================================================================
--- src/cbit/vcell/messaging/server/SimulationDispatcher.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/SimulationDispatcher.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,512 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.solver.VCSimulationDataIdentifier;
+import cbit.rmi.event.WorkerEvent;
+import javax.jms.*;
+
+import org.vcell.util.BigString;
+import org.vcell.util.CacheException;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.ExternalDataIdentifier;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.solver.Simulation;
+
+import java.util.Date;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Collections;
+import java.util.Vector;
+
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.field.FieldFunctionArguments;
+import cbit.vcell.modeldb.LocalAdminDbServer;
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.sql.DBCacheTable;
+import cbit.sql.OracleKeyFactory;
+import cbit.sql.OraclePoolingConnectionFactory;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.SimulationDispatcherMessaging;
+import cbit.vcell.messaging.JmsSession;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.xml.XmlHelper;
+import cbit.vcell.xml.XmlParseException;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.WorkerEventMessage;
+import cbit.vcell.messaging.StatusMessage;
+import java.util.HashSet;
+import cbit.vcell.modeldb.ResultSetCrawler;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public class SimulationDispatcher extends AbstractJmsServiceProvider {
+	private Map<User, RpcDbServerProxy> userDbServerMap = null;
+	private ConnectionFactory conFactory = null;
+	private KeyFactory keyFactory = null;
+	private JmsClientMessaging clientMessaging = null;
+	private LocalAdminDbServer adminDbServer = null;
+	
+	private boolean bStop = false;		
+	private SimulationDispatcherMessaging dispatcherMessaging = null;
+	private DBCacheTable simulationMap = null;
+	private Map<KeyValue, User> simUserMap = Collections.synchronizedMap(new HashMap<KeyValue, User>());
+	private Map<KeyValue, FieldDataIdentifierSpec[]> simFieldDataIDMap = Collections.synchronizedMap(new HashMap<KeyValue, FieldDataIdentifierSpec[]>());
+
+	private MessagingDispatcherDbManager dispatcherDbManager = new JmsDispatcherDbManager();
+	protected HashSet<VCSimulationDataIdentifier> resultSetSavedSet = new HashSet<VCSimulationDataIdentifier>();
+	protected ResultSetCrawler rsCrawler = null;	
+
+/**
+ * Scheduler constructor comment.
+ */
+public SimulationDispatcher(int serviceOrdinal, String logdir) throws Exception {	
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID().toString(), 
+			ServiceType.DISPATCH, serviceOrdinal, ManageUtils.getHostName(), new Date(), true);	
+	initLog(logdir);
+
+	log = new StdoutSessionLog(serviceInstanceStatus.getID());
+	
+	conFactory = new OraclePoolingConnectionFactory(log);
+	keyFactory = new OracleKeyFactory();		
+	adminDbServer = new LocalAdminDbServer(conFactory,keyFactory,log);
+	rsCrawler = new ResultSetCrawler(conFactory, adminDbServer, log);	
+
+	dispatcherMessaging = new SimulationDispatcherMessaging(this, conFactory, keyFactory, log);	
+}
+
+
+private void dataMoved(VCSimulationDataIdentifier vcSimDataID, User user, double timepoint) {
+	// called by data mover thread after successful move operations
+	try {		
+		if (!resultSetSavedSet.contains(vcSimDataID)){
+			try {
+				rsCrawler.updateSimResults(user,vcSimDataID);
+				resultSetSavedSet.add(vcSimDataID);
+			} catch (Throwable exc) {
+				log.exception(exc);
+			}
+		}
+	} catch (Throwable e){
+		log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/27/2003 3:15:57 PM)
+ * @return cbit.vcell.server.UserMetaDbServer
+ */
+private RpcDbServerProxy getDbServerProxy(User user) throws JMSException {
+	if (clientMessaging == null) {
+		clientMessaging = new JmsClientMessaging(dispatcherMessaging.getJmsConnection(), log, null);
+	}
+
+	if (userDbServerMap == null) {
+		userDbServerMap = Collections.synchronizedMap(new HashMap<User, RpcDbServerProxy>());
+	}
+		
+	synchronized (userDbServerMap) {
+		RpcDbServerProxy dbServer = (RpcDbServerProxy)userDbServerMap.get(user);
+		
+		if (dbServer == null) {
+			dbServer = new RpcDbServerProxy(user, clientMessaging, log);
+			userDbServerMap.put(user, dbServer);
+		}
+
+		return dbServer;		
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/3/2003 2:56:43 PM)
+ * @return cbit.vcell.server.User
+ * @param simKey cbit.sql.KeyValue
+ */
+public FieldDataIdentifierSpec[] getFieldDataIdentifierSpecs(Simulation sim) throws DataAccessException, JMSException {
+	try {		
+		KeyValue simKey = sim.getKey();
+		log.print("Get FieldDataIdentifierSpec for [" + simKey + "]");	
+		FieldDataIdentifierSpec[] fieldDataIDSs = (FieldDataIdentifierSpec[])simFieldDataIDMap.get(simKey);
+
+		if (fieldDataIDSs != null) {
+			return fieldDataIDSs;
+		}
+
+		FieldFunctionArguments[] fieldFuncArgs =  sim.getMathDescription().getFieldFunctionArguments();
+		if (fieldFuncArgs == null || fieldFuncArgs.length == 0) {
+			return null;
+		}
+		
+		RpcDbServerProxy dbServerProxy = getDbServerProxy(sim.getVersion().getOwner());		
+		ExternalDataIdentifier[] externalDataIDs =
+			dbServerProxy.fieldDataDBOperation(
+					FieldDataDBOperationSpec.createGetExtDataIDsSpec(dbServerProxy.user)
+			).extDataIDArr;
+		if (externalDataIDs != null && externalDataIDs.length != 0 &&
+			fieldFuncArgs != null && fieldFuncArgs.length>0	) {
+			Vector<FieldDataIdentifierSpec> fieldDataIdV = new Vector<FieldDataIdentifierSpec>();
+			for(int j=0;fieldFuncArgs != null && j<fieldFuncArgs.length;j+= 1){
+				for(int i=0;i<externalDataIDs.length;i+= 1){
+					if(externalDataIDs[i].getName().equals(fieldFuncArgs[j].getFieldName())){
+						fieldDataIdV.add(
+								new FieldDataIdentifierSpec(fieldFuncArgs[j],externalDataIDs[i])
+								);
+						break;
+					}
+				}
+			}
+			if(fieldDataIdV.size() > 0){
+				fieldDataIDSs = new FieldDataIdentifierSpec[fieldDataIdV.size()];
+				fieldDataIdV.copyInto(fieldDataIDSs);
+			}
+		}
+
+		if (fieldDataIDSs != null){
+			simFieldDataIDMap.put(simKey, fieldDataIDSs);		
+		}
+		
+		return fieldDataIDSs;
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+		throw new DataAccessException(ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/8/2003 1:34:06 PM)
+ * @return cbit.vcell.solver.Simulation
+ * @param simInfo cbit.vcell.solver.SimulationInfo
+ */
+public Simulation getSimulation(User user, KeyValue simKey) throws JMSException, DataAccessException {
+	if (simulationMap == null) {
+		log.print("Initializaing DBCacheTable!");
+		simulationMap = new DBCacheTable(3600 * 1000);
+	}
+
+	log.print("Get simulation [" + simKey + ","  + user + "]");	
+	Simulation sim = (Simulation)simulationMap.getCloned(simKey);
+
+	if (sim != null) {
+		return sim;
+	}
+
+	RpcDbServerProxy dbServerProxy = getDbServerProxy(user);			
+	BigString simstr = dbServerProxy.getSimulationXML(simKey);	
+
+	if (simstr != null){
+		try {
+			sim = XmlHelper.XMLToSim(simstr.toString());
+		}catch (XmlParseException e){
+			e.printStackTrace(System.out);
+			throw new DataAccessException(e.getMessage());
+		}
+		if (sim != null) {
+			try {
+				simulationMap.putProtected(simKey, sim);
+			} catch (CacheException e) {
+				// if can't cache the simulation, it is ok
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	return sim;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/3/2004 8:34:36 AM)
+ * @return cbit.vcell.messaging.SimulationTask
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationTask getSimulationTask(SimulationJobStatus jobStatus) throws DataAccessException, JMSException {
+	VCSimulationIdentifier vcSimID = jobStatus.getVCSimulationIdentifier();
+	User user = getUser(vcSimID.getSimulationKey(), null);				
+	Simulation sim = getSimulation(user, vcSimID.getSimulationKey());
+	SimulationTask simTask = new SimulationTask(new SimulationJob(sim, jobStatus.getJobIndex(), getFieldDataIdentifierSpecs(sim)), jobStatus.getTaskID());
+
+	return simTask;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/3/2003 2:56:43 PM)
+ * @return cbit.vcell.server.User
+ * @param simKey cbit.sql.KeyValue
+ */
+public User getUser(KeyValue simKey, String username) throws DataAccessException {
+	User user = null;
+
+	synchronized(simUserMap) {
+		user = (User)simUserMap.get(simKey);
+
+		if (user != null && username != null && !user.getName().equals(username)) {
+			throw new DataAccessException("Wrong user [" + user.getName() + "," + username + "] for the simulation [" + simKey + "]");
+		}
+			
+		if (user == null) {
+			if (username != null) {
+				user = adminDbServer.getUser(username);
+			} else {
+				user = adminDbServer.getUserFromSimulationKey(simKey);
+			}
+			if (user != null) {
+				simUserMap.put(simKey, user);
+			}			
+		}
+	}
+		
+	return user;
+}
+
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 1) {
+		System.out.println("Missing arguments: " + SimulationDispatcher.class.getName() + " serviceOrdinal [logdir]");
+		System.exit(1);
+	}
+	
+	try {
+		PropertyLoader.loadProperties();		
+		
+		int serviceOrdinal = Integer.parseInt(args[0]);
+		String logdir = null;
+		if (args.length > 1) {
+			logdir = args[1];
+		}
+		VCMongoMessage.serviceStartup(ServiceName.dispatch, new Integer(serviceOrdinal), args);
+
+		SimulationDispatcher simulationDispatcher = new SimulationDispatcher(serviceOrdinal, logdir);
+		simulationDispatcher.start();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/15/2003 11:34:15 AM)
+ */
+public void onWorkerEventMessage(AdminDatabaseServerXA adminDbXA, java.sql.Connection con, JmsSession statusPublisher, Message receivedMsg) throws JMSException, DataAccessException {
+	WorkerEventMessage workerEventMessage = null;
+	
+	try {
+		workerEventMessage = new WorkerEventMessage(this, receivedMsg);
+	} catch (RuntimeException ex) {
+		// parse error, wrong message
+		log.exception(ex);
+		return;
+	}
+		
+	VCMongoMessage.sendWorkerEvent(workerEventMessage);
+	
+	WorkerEvent workerEvent = workerEventMessage.getWorkerEvent();
+	String hostName = workerEvent.getHostName();
+	String userName = workerEvent.getUserName(); // as the filter of the client
+	int taskID = workerEvent.getTaskID();
+	int jobIndex = workerEvent.getJobIndex();
+	
+	log.print("onWorkerEventMessage[" + workerEvent.getEventTypeID() + "," + workerEvent.getSimulationMessage() + "][simid=" + workerEvent.getVCSimulationDataIdentifier() + ",job=" + jobIndex + "]");
+
+	VCSimulationDataIdentifier vcSimDataID = workerEvent.getVCSimulationDataIdentifier();
+	if (vcSimDataID == null) {
+		return;
+	}		
+	KeyValue simKey = vcSimDataID.getSimulationKey();
+	SimulationJobStatus oldJobStatus = adminDbXA.getSimulationJobStatus(con, simKey, jobIndex);	
+	
+	if (oldJobStatus == null || taskID != oldJobStatus.getTaskID() || oldJobStatus.isDone()){
+		log.print("Outdated message: taskID=" + taskID + "::" + oldJobStatus);
+		return;
+	}	
+
+	SimulationJobStatus newJobStatus = null;
+	
+	if (workerEvent.isAcceptedEvent()) {
+		if (!oldJobStatus.isRunning()) {			
+			newJobStatus = updateDispatchedStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, workerEvent.getSimulationMessage());
+		}
+		
+	} else if (workerEvent.isStartingEvent()) {
+		// only update database when the job event changes from started to runinng. The later progress event will not be recorded.
+		SimulationMessage startMsg = workerEvent.getSimulationMessage();
+		if (oldJobStatus.isQueued() || oldJobStatus.isDispatched()) {
+			newJobStatus = updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, false, startMsg);
+		} else if (oldJobStatus.isRunning()) {
+			newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), oldJobStatus.getVCSimulationIdentifier(), oldJobStatus.getJobIndex(), oldJobStatus.getSubmitDate(), 
+				oldJobStatus.getSchedulerStatus(), oldJobStatus.getTaskID(), startMsg, oldJobStatus.getSimulationQueueEntryStatus(), oldJobStatus.getSimulationExecutionStatus());
+		}
+		
+	} else if (workerEvent.isNewDataEvent()) {
+		if (workerEvent.getTimePoint() != null) {
+			dataMoved(vcSimDataID, workerEvent.getUser(), workerEvent.getTimePoint().doubleValue());
+			newJobStatus = updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, true, workerEvent.getSimulationMessage());
+		}
+			
+	} else if (workerEvent.isProgressEvent()) {
+		newJobStatus = oldJobStatus;
+		if (oldJobStatus.isQueued() || oldJobStatus.isDispatched()) {
+			newJobStatus = updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, false, workerEvent.getSimulationMessage());
+		} else {
+			updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, workerEvent.getSimulationMessage());
+		}
+		
+	} else if (workerEvent.isCompletedEvent()) {			
+		newJobStatus = updateEndStatus(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, hostName, SimulationJobStatus.SCHEDULERSTATUS_COMPLETED, workerEvent.getSimulationMessage());
+
+	} else if (workerEvent.isFailedEvent()) {						
+		SimulationMessage failMsg = workerEvent.getSimulationMessage();
+		newJobStatus = updateEndStatus(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, hostName, SimulationJobStatus.SCHEDULERSTATUS_FAILED, failMsg);	
+			
+	} else if (workerEvent.isWorkerAliveEvent()) {
+		if (oldJobStatus.isRunning()) {
+			updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, workerEvent.getSimulationMessage());
+		}
+	}
+
+	if (workerEvent.isStartingEvent() && newJobStatus != null) {
+		StatusMessage msgForClient = new StatusMessage(newJobStatus, userName, null, null);
+		msgForClient.sendToClient(statusPublisher);
+		log.print("Send status to client: " + msgForClient);
+	} else if (newJobStatus != null && (!newJobStatus.compareEqual(oldJobStatus) || workerEvent.isProgressEvent() || workerEvent.isNewDataEvent())) {		
+		Double progress = workerEvent.getProgress();
+		Double timepoint = workerEvent.getTimePoint();
+		StatusMessage msgForClient = new StatusMessage(newJobStatus, userName, progress, timepoint);
+		msgForClient.sendToClient(statusPublisher);
+		log.print("Send status to client: " + msgForClient);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/9/2003 12:07:28 PM)
+ */
+public final void start() throws JMSException {	
+	log.print("Start PropertyLoader thread...");
+	new PropertyLoaderThread().start();
+
+	while (!bStop) {
+		try {
+			VCSimulationIdentifier vcSimID = dispatcherMessaging.processNextRequest();
+			if (vcSimID != null) {
+				continue;
+			}
+		} catch (Exception ex) {
+			log.exception(ex);
+		}
+		
+		try {
+			Thread.sleep(2 * MessageConstants.SECOND_IN_MS);
+		} catch (Exception ex) {
+			log.exception(ex);
+		}			
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 4:28:05 PM)
+ */
+public final void stop() {
+	log.print(this.getClass().getName() + " ending");
+	bStop = true;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateDispatchedStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateDispatchedStatus(oldJobStatus, adminDbXA, con, computeHost, vcSimID, jobIndex, startMsg);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, VCSimulationIdentifier vcSimID, int jobIndex, String hostName, int status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateEndStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateEndStatus(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, hostName, status, solverMsg);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateLatestUpdateDate[" + vcSimID + "][" + jobIndex + "]");
+	dispatcherDbManager.updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, simulationMessage);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateQueueStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, VCSimulationIdentifier vcSimID, int jobIndex, int queueID, int taskID, boolean firstSubmit) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateQueueStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateQueueStatus(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, queueID, taskID, firstSubmit);		// update SimulationJobTable
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, String hostName, VCSimulationIdentifier vcSimID, int jobIndex, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateExeRunningStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimID, jobIndex, hasData, solverMsg);
+}
+}
Index: src/cbit/vcell/messaging/server/LocalUserMetaDbServerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalUserMetaDbServerMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalUserMetaDbServerMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,1175 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.solver.ode.gui.SimulationStatus;
+import cbit.vcell.field.FieldDataDBOperationResults;
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.export.server.ExportLog;
+import cbit.vcell.modeldb.*;
+import cbit.vcell.mathmodel.*;
+import cbit.vcell.biomodel.BioModelMetaData;
+import cbit.vcell.solver.SolverResultSetInfo;
+import java.rmi.*;
+import org.vcell.util.BigString;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VersionInfo;
+
+import cbit.vcell.server.UserRegistrationOP;
+import cbit.vcell.server.UserRegistrationResults;
+import cbit.vcell.dictionary.DBSpecies;
+import cbit.vcell.dictionary.DBFormalSpecies;
+import cbit.vcell.dictionary.FormalSpeciesType;
+
+
+/**
+ * This type was created in VisualAge.
+ */
+public class LocalUserMetaDbServerMessaging extends java.rmi.server.UnicastRemoteObject implements cbit.vcell.server.UserMetaDbServer {
+	private RpcDbServerProxy dbServerProxy = null;
+	private User user = null;
+	private org.vcell.util.SessionLog log = null;
+
+/**
+ * This method was created in VisualAge.
+ */
+public LocalUserMetaDbServerMessaging(cbit.vcell.messaging.JmsClientMessaging clientMessaging, User argUser, org.vcell.util.SessionLog sessionLog) throws RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortUserMetaDbServer,0));
+	this.user = argUser;
+	this.log = sessionLog;
+	try {
+		this.dbServerProxy = new RpcDbServerProxy(user, clientMessaging, log);
+	} catch (javax.jms.JMSException e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException("JMSException: "+e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VCDocumentInfo curate(org.vcell.util.document.CurateSpec curateSpec) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.curate(curatespec="+curateSpec.toString()+")");
+		return dbServerProxy.curate(curateSpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+public UserRegistrationResults userRegistrationOP(UserRegistrationOP userRegistrationOP) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.userRegistrationOP(...)");
+		return dbServerProxy.userRegistrationOP(userRegistrationOP);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteBioModel(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteBioModel(Key="+key+")");
+		dbServerProxy.deleteBioModel(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public FieldDataDBOperationResults fieldDataDBOperation(FieldDataDBOperationSpec fieldDataDBOperationSpec) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.fieldDataDBOperation(...)");
+		return dbServerProxy.fieldDataDBOperation(fieldDataDBOperationSpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteGeometry(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteGeometry(Key="+key+")");
+		dbServerProxy.deleteGeometry(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteMathModel(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteMathModel(Key="+key+")");
+		dbServerProxy.deleteMathModel(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteResultSetExport(org.vcell.util.document.KeyValue eleKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteResultSetExport(Key="+eleKey+")");
+		dbServerProxy.deleteResultSetExport(eleKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteVCImage(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteVCImage(Key="+key+")");
+		dbServerProxy.deleteVCImage(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteOPResults doTestSuiteOP(cbit.vcell.numericstest.TestSuiteOP tsop) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.doTestSuiteOP("+tsop+")");
+		return dbServerProxy.doTestSuiteOP(tsop);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.ReferenceQueryResult findReferences(org.vcell.util.document.ReferenceQuerySpec rqs) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.findReferences(rqs="+rqs+")");
+		return dbServerProxy.findReferences(rqs);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionable method comment.
+ */
+public org.vcell.util.document.VersionableFamily getAllReferences(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getAllReferences(vType="+vType.getTypeName()+", Key="+key+")");
+		log.alert("LocalUserMetaDbServerMessaging.getAllReferences() can return 'version' objects that aren't viewable to user !!!!!!!!!!!!!!!! ");
+		return dbServerProxy.getAllReferences(vType,key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo getBioModelInfo(org.vcell.util.document.KeyValue bioModelKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelInfo(key="+bioModelKey+")");
+		return dbServerProxy.getBioModelInfo(bioModelKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo[] getBioModelInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelInfos(bAll="+bAll+")");
+		return dbServerProxy.getBioModelInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BioModelMetaData getBioModelMetaData(KeyValue bioModelKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelMetaData(key="+bioModelKey+")");
+		BioModelMetaData bioModelMetaData = dbServerProxy.getBioModelMetaData(bioModelKey);
+		return bioModelMetaData;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BioModelMetaData[] getBioModelMetaDatas(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelMetaDatas(bAll="+bAll+")");
+		BioModelMetaData bioModelMetaDataArray[] = dbServerProxy.getBioModelMetaDatas(bAll);
+		return bioModelMetaDataArray;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getBioModelXML(KeyValue bioModelKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelXML(key="+bioModelKey+")");
+		BigString bioModelXML = dbServerProxy.getBioModelXML(bioModelKey);
+		return bioModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/26/2003 3:26:10 PM)
+ */
+public DBSpecies getBoundSpecies(DBFormalSpecies dbfs) throws DataAccessException{
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBoundSpecies");
+		return dbServerProxy.getBoundSpecies(dbfs);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/20/2003 2:11:12 PM)
+ */
+public DBFormalSpecies[] getDatabaseSpecies(String likeString,boolean isBound,FormalSpeciesType speciesType,int restrictSearch,int rowLimit,boolean bOnlyUser) throws DataAccessException{
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getDatabaseSpecies");
+		return dbServerProxy.getDatabaseSpecies(likeString,isBound,speciesType,restrictSearch,rowLimit,bOnlyUser);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getDictionaryReactions method comment.
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getDictionaryReactions(ReactionQuerySpec reactionQuerySpec) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getDictionaryReactions");
+		return dbServerProxy.getDictionaryReactions(reactionQuerySpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public ExportLog getExportLog(KeyValue simulationKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getExportLog(simulationKey="+simulationKey+")");
+		ExportLog exportLog = dbServerProxy.getExportLog(simulationKey);
+		return exportLog;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public ExportLog[] getExportLogs(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getExportLogs()");
+		ExportLog exportLogs[] = dbServerProxy.getExportLogs(bAll);
+		return exportLogs;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo getGeometryInfo(org.vcell.util.document.KeyValue geoKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getGeometryInfo(key="+geoKey+")");
+		return dbServerProxy.getGeometryInfo(geoKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo[] getGeometryInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getGeometryInfos(bAll="+bAll+")");
+		return dbServerProxy.getGeometryInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getGeometryXML(KeyValue geometryKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getGeometryXML(key="+geometryKey+")");
+		BigString geometryXML = dbServerProxy.getGeometryXML(geometryKey);
+		return geometryXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo getMathModelInfo(org.vcell.util.document.KeyValue mathModelKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelInfo(key="+mathModelKey+")");
+		return dbServerProxy.getMathModelInfo(mathModelKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo[] getMathModelInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelInfos(bAll="+bAll+")");
+		return dbServerProxy.getMathModelInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public MathModelMetaData getMathModelMetaData(KeyValue mathModelKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelMetaData(key="+mathModelKey+")");
+		MathModelMetaData mathModelMetaData = dbServerProxy.getMathModelMetaData(mathModelKey);
+		return mathModelMetaData;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public MathModelMetaData[] getMathModelMetaDatas(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelMetaDatas(bAll="+bAll+")");
+		MathModelMetaData mathModelMetaDataArray[] = dbServerProxy.getMathModelMetaDatas(bAll);
+		return mathModelMetaDataArray;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getMathModelXML(KeyValue mathModelKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelXML(mathModelKey="+mathModelKey+")");
+		BigString xml = dbServerProxy.getMathModelXML(mathModelKey);
+		return xml;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:51:49 PM)
+ * @return cbit.util.Preference
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.Preference[] getPreferences() throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getPreferences()");
+		org.vcell.util.Preference[] preferences = dbServerProxy.getPreferences();
+		return preferences;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getReactionStep method comment.
+ */
+public cbit.vcell.model.ReactionStep getReactionStep(org.vcell.util.document.KeyValue rxID) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getReactionStep()");
+		return dbServerProxy.getReactionStep(rxID);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getReactionStepInfos method comment.
+ */
+public cbit.vcell.model.ReactionStepInfo[] getReactionStepInfos(org.vcell.util.document.KeyValue[] reactionStepKeys) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getReactionStepInfos()");
+		return dbServerProxy.getReactionStepInfos(reactionStepKeys);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public SolverResultSetInfo[] getResultSetInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getResultSetInfos(bAll="+bAll+")");
+		SolverResultSetInfo rsInfos[] = dbServerProxy.getResultSetInfos(bAll);
+		return rsInfos;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/1/2004 11:27:01 AM)
+ * @return cbit.vcell.solver.SolverResultSetInfo
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationStatus[] getSimulationStatus(org.vcell.util.document.KeyValue simulationKeys[]) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationStatus(key="+simulationKeys+")");
+		SimulationStatus simulationStatus[] = dbServerProxy.getSimulationStatus(simulationKeys);
+		return simulationStatus;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/1/2004 11:27:01 AM)
+ * @return cbit.vcell.solver.SolverResultSetInfo
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationStatus getSimulationStatus(org.vcell.util.document.KeyValue simulationKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationStatus(key="+simulationKey+")");
+		SimulationStatus simulationStatus = dbServerProxy.getSimulationStatus(simulationKey);
+		return simulationStatus;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getSimulationXML(KeyValue simKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationXML(simKey="+simKey+")");
+		BigString xml = dbServerProxy.getSimulationXML(simKey);
+		return xml;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteNew getTestSuite(java.math.BigDecimal getThisTS) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getTestSuite("+getThisTS+")");
+		return dbServerProxy.getTestSuite(getThisTS);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteInfoNew[] getTestSuiteInfos() throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getTestSuiteInfos()");
+		return dbServerProxy.getTestSuiteInfos();
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ * @return cbit.vcell.dictionary.ReactionDescription[]
+ * @param reactionQuerySpec cbit.vcell.modeldb.ReactionQuerySpec
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getUserReactionDescriptions(ReactionQuerySpec reactionQuerySpec) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getUserReactionDescriptions()");
+		return dbServerProxy.getUserReactionDescriptions(reactionQuerySpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo getVCImageInfo(org.vcell.util.document.KeyValue imgKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getVCImageInfo(key="+imgKey+")");
+		return dbServerProxy.getVCImageInfo(imgKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo[] getVCImageInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getVCImageInfos(bAll="+bAll+")");
+		return dbServerProxy.getVCImageInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getVCImageXML(KeyValue imageKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationXML(imageKey="+imageKey+")");
+		BigString xml = dbServerProxy.getVCImageXML(imageKey);
+		return xml;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ * @return cbit.vcell.modeldb.VCInfoContainer
+ */
+public VCInfoContainer getVCInfoContainer() throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getVCInfoContainer()");
+		return dbServerProxy.getVCInfoContainer();
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupAddUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key,String addUserToGroup, boolean isHidden) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupAddUser(vType="+vType.getTypeName()+", Key="+key+", userToAdd="+addUserToGroup+", isHidden="+isHidden+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupAddUser(vType,key,addUserToGroup,isHidden);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupRemoveUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key,String userRemoveFromGroup,boolean isHiddenFromOwner) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupRemoveUser(vType="+vType.getTypeName()+", Key="+key+", userRemoveFromGroup="+userRemoveFromGroup+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupRemoveUser(vType,key,userRemoveFromGroup,isHiddenFromOwner);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPrivate(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupSetPrivate(vType="+vType.getTypeName()+", Key="+key+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupSetPrivate(vType,key);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPublic(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupSetPublic(vType="+vType.getTypeName()+", Key="+key+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupSetPublic(vType,key);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:51:49 PM)
+ * @param preferences cbit.util.Preference[]
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void replacePreferences(org.vcell.util.Preference[] preferences) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.replacePreferences()");
+		dbServerProxy.replacePreferences(preferences);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveBioModel(BigString bioModelXML, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveBioModel()");
+		BigString savedBioModelXML = dbServerProxy.saveBioModel(bioModelXML, independentSims);
+		return savedBioModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveBioModelAs(BigString bioModelXML, String newName, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveBioModel(newName="+newName+")");
+		BigString savedBioModelXML = dbServerProxy.saveBioModelAs(bioModelXML,newName,independentSims);
+		return savedBioModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveGeometry(BigString geometryXML) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveGeometry()");
+		BigString savedGeometryXML = dbServerProxy.saveGeometry(geometryXML);
+		return savedGeometryXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveGeometryAs(BigString geometryXML, String newName) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveGeometryAs(newName="+newName+")");
+		BigString savedGeometryXML = dbServerProxy.saveGeometryAs(geometryXML,newName);
+		return savedGeometryXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveMathModel(BigString mathModelXML, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveMathModel()");
+		BigString savedMathModelXML = dbServerProxy.saveMathModel(mathModelXML,independentSims);
+		return savedMathModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveMathModelAs(BigString mathModelXML, String newName, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveMathModel(newName="+newName+")");
+		BigString savedMathModelXML = dbServerProxy.saveMathModelAs(mathModelXML,newName, independentSims);
+		return savedMathModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.BigString saveSimulation(org.vcell.util.BigString simulationXML, boolean bForceIndependent) throws org.vcell.util.DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveSimulation()");
+		BigString savedSimulationXML = dbServerProxy.saveSimulation(simulationXML,bForceIndependent);
+		return savedSimulationXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveVCImage(BigString vcImageXML) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveVCImage()");
+		BigString savedVCImageXML = dbServerProxy.saveVCImage(vcImageXML);
+		return savedVCImageXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveVCImageAs(BigString vcImageXML, String newName) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveVCImage(newName="+newName+")");
+		BigString savedVCImageXML = dbServerProxy.saveVCImageAs(vcImageXML,newName);
+		return savedVCImageXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+}
Index: src/cbit/vcell/messaging/server/RpcServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcServerImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcServerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:12:11 PM)
+ * @author: Fei Gao
+ */
+public interface RpcServerImpl {
+public Object rpc(RpcRequest request) throws Exception;
+}
Index: src/cbit/vcell/messaging/server/RpcRequest.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcRequest.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcRequest.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/13/2003 1:41:34 PM)
+ * @author: Fei Gao
+ */
+public class RpcRequest implements java.io.Serializable {
+	private User user = null;
+	private Object[] args = null;
+	private ServiceType requestedServiceType = null; // refer to "databaseServer", "dataServer", "***";
+	private String methodName = null;	
+/**
+ * SimpleTask constructor comment.
+ * @param argName java.lang.String
+ * @param argEstimatedSizeMB double
+ * @param argUserid java.lang.String
+ */
+public RpcRequest(User user0, ServiceType st, String methodName0, Object[] arglist) {
+	user = user0;
+	this.requestedServiceType = st;
+	methodName = methodName0;
+	this.args = arglist;	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (5/13/2003 1:56:44 PM)
+ * @return java.lang.Object[]
+ */
+public Object[] getArguments() {
+	return args;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (5/13/2003 2:43:42 PM)
+ * @return java.lang.String
+ */
+public String getMethodName() {
+	return methodName;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (12/30/2003 9:16:45 AM)
+ * @return java.lang.String
+ */
+public ServiceType getRequestedServiceType() {
+	return requestedServiceType;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (3/11/2004 8:50:08 AM)
+ * @return java.lang.String
+ */
+public org.vcell.util.document.User getUser() {
+	return user;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (3/11/2004 8:51:06 AM)
+ * @return java.lang.String
+ */
+public java.lang.String getUserName() {
+	if (user == null) {
+		return null;
+	}
+	
+	return user.getName();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/18/2001 5:12:18 PM)
+ * @return java.lang.String
+ */
+public String toString() {
+	return "[" + user + "," + requestedServiceType + "," + methodName + "]";
+}
+}
Index: src/cbit/vcell/messaging/server/AbstractRpcServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractRpcServerProxy.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractRpcServerProxy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.mongodb.VCMongoMessage;
+
+import javax.jms.JMSException;
+
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/13/2003 2:14:50 PM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractRpcServerProxy implements RpcServerProxy {
+	private cbit.vcell.messaging.JmsClientMessaging clientMessaging = null;
+	protected org.vcell.util.document.User user;
+	private java.lang.String queueName = null;
+	protected org.vcell.util.SessionLog log = null;
+
+/**
+ * RpcServerProxy constructor comment.
+ */
+protected AbstractRpcServerProxy(User argUser, JmsClientMessaging clientMessaging0, String queueName0, SessionLog argLog) throws JMSException {
+	super();
+	this.user = argUser;
+	this.clientMessaging = clientMessaging0;
+	this.log = argLog;
+	queueName = queueName0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+public Object rpc(ServiceType serviceType, String methodName, Object[] args, boolean returnRequired) throws Exception {
+	return rpc(serviceType, methodName, args, returnRequired, null, null);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+public Object rpc(ServiceType serviceType, String methodName, Object[] args, boolean returnRequired, String[] specialProperties, Object[] specialValues) throws Exception {
+	RpcRequest request = new RpcRequest(user, serviceType, methodName, args);
+	VCMongoMessage.sendRpcRequestSent(request, clientMessaging.getUserLoginInfo());
+	return clientMessaging.rpc(request, queueName, returnRequired, specialProperties, specialValues);
+}
+}
Index: src/cbit/vcell/messaging/server/LocalSimulationControllerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalSimulationControllerMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalSimulationControllerMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.document.User;
+
+import cbit.vcell.solver.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/4/2003 11:08:14 PM)
+ * @author: Jim Schaff
+ */
+public class LocalSimulationControllerMessaging extends java.rmi.server.UnicastRemoteObject implements cbit.vcell.server.SimulationController {
+	private User fieldUser = null;
+	private org.vcell.util.SessionLog fieldSessionLog = null;
+	private RpcSimServerProxy simServerProxy = null;
+
+/**
+ * MessagingSimulationController constructor comment.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public LocalSimulationControllerMessaging(User user, cbit.vcell.messaging.JmsClientMessaging clientMessaging, org.vcell.util.SessionLog log) throws java.rmi.RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortSimulationController,0));
+	this.fieldUser = user;
+	this.fieldSessionLog = log;
+
+	try {
+		simServerProxy = new RpcSimServerProxy(user, clientMessaging, fieldSessionLog);
+	} catch (javax.jms.JMSException e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException("JMS exception creating SimServerProxy: "+e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void startSimulation(VCSimulationIdentifier vcSimID) {
+	fieldSessionLog.print("LocalSimulationControllerMessaging.startSimulation(" + vcSimID + ")");
+	simServerProxy.startSimulation(vcSimID);
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void stopSimulation(VCSimulationIdentifier vcSimID) {
+	fieldSessionLog.print("LocalSimulationControllerMessaging.stopSimulation(" + vcSimID + ")");
+	simServerProxy.stopSimulation(vcSimID);
+}
+}
Index: src/cbit/vcell/messaging/server/LocalDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalDispatcherDbManager.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalDispatcherDbManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.server.AdminDatabaseServer;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:45:37 PM)
+ * @author: Fei Gao
+ */
+public class LocalDispatcherDbManager extends AbstractDispatcherDbManager {
+/**
+ * NonJmsDispatcherDbDriver constructor comment.
+ */
+public LocalDispatcherDbManager() {
+	super();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus == null || oldJobStatus.isDone()) {	
+			int taskID = 0;
+			VCellServerID serverID = VCellServerID.getSystemServerID();
+			if (oldJobStatus != null) {
+				taskID = oldJobStatus.getTaskID() + 1;
+			}
+			// no job for the same simulation running				
+			// update the job status in the database and local memory
+			SimulationJobStatus newJobStatus = new SimulationJobStatus(serverID, vcSimID, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_DISPATCHED, taskID, startMsg, 
+				new SimulationQueueEntryStatus(null, MessageConstants.PRIORITY_DEFAULT, MessageConstants.QUEUE_ID_NULL), null);
+				
+			if (oldJobStatus == null) {
+				newJobStatus = adminDb.insertSimulationJobStatus(newJobStatus);
+			} else {
+				newJobStatus = adminDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+			}
+			return newJobStatus;
+		}
+		return oldJobStatus;
+	} catch (java.rmi.RemoteException ex) {
+		throw new DataAccessException("updateDispatchedStatus " + ex.getMessage());
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/AbstractJmsWorker.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractJmsWorker.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractJmsWorker.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.document.VCellServerID;
+
+import java.io.FileNotFoundException;
+import java.util.Date;
+import java.util.StringTokenizer;
+
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.Solver;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.xml.XmlParseException;
+import cbit.vcell.solver.SolverEvent;
+import cbit.vcell.messaging.WorkerMessaging;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import static org.vcell.util.MessageConstants.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:30:31 PM)
+ * @author: Jim Schaff
+ */
+public abstract class AbstractJmsWorker extends AbstractJmsServiceProvider implements Worker {
+	protected int maxMemoryMB = 100;
+	protected SimulationTask currentTask = null;
+	protected Solver currentSolver = null;
+	protected boolean bStopped = true;
+	protected WorkerMessaging workerMessaging = null;
+	protected ServiceType serviceType;
+	
+public AbstractJmsWorker(ServiceType wt, int workerOrdinal, int workerMem, String logdir) throws JMSException, FileNotFoundException {
+	serviceType = wt;
+	maxMemoryMB = workerMem;	
+			
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID().toString(), serviceType, workerOrdinal, ManageUtils.getHostName(), new Date(), true);
+	initLog(logdir);
+	
+	log = new StdoutSessionLog(serviceInstanceStatus.getID());
+	workerMessaging = new WorkerMessaging(this, log);
+}
+
+protected abstract void doJob() throws JMSException, SolverException, XmlParseException;
+
+public final String getJobSelector() {
+	String jobSelector = "(" + MessageConstants.MESSAGE_TYPE_PROPERTY + "='" + MessageConstants.MESSAGE_TYPE_SIMULATION_JOB_VALUE + "')";
+	String computeResources =  PropertyLoader.getRequiredProperty(PropertyLoader.htcComputeResources);
+	StringTokenizer st = new StringTokenizer(computeResources, " ,");	
+	jobSelector += " AND ((" + MessageConstants.COMPUTE_RESOURCE_PROPERTY + " IS NULL) OR (" + MessageConstants.COMPUTE_RESOURCE_PROPERTY + " IN (";
+	int count = 0;
+	while (st.hasMoreTokens()) {
+		if (count > 0) {
+			jobSelector = ", ";
+		}
+		jobSelector += "'" + st.nextToken() + "'";
+		count ++;
+	}
+	jobSelector += ")))";
+	
+	return jobSelector;
+}
+
+/**
+ * Invoked when the solver aborts a calculation (abnormal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverAborted(SolverEvent event) {
+	workerMessaging.sendFailed(event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver finishes a calculation (normal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverFinished(SolverEvent event) {
+	workerMessaging.sendCompleted(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverPrinted(SolverEvent event) {
+	if (!isRunning()) {
+		return;
+	}
+	workerMessaging.sendNewData(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverProgress(SolverEvent event) {
+	if (!isRunning()) {
+		return;
+	}
+	workerMessaging.sendProgress(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver begins a calculation.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStarting(SolverEvent event) {
+	workerMessaging.sendStarting(event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stops a calculation, usually because
+ * of a user-initiated stop call.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStopped(SolverEvent event) {		
+	log.print("Caught solverStopped(" + event.getSource() + ")");
+	// Don't send message anymore because the dispatcher will update the database anyway no matter if the worker responds
+	//workerMessaging.sendStopped(event.getProgress(), event.getTimePoint());
+}
+
+public final void start() {
+	bStopped = false;
+	
+	log.print("Start PropertyLoader thread...");
+	new PropertyLoaderThread().start();
+
+	while (!bStopped){
+		currentTask = null;
+		currentSolver = null;
+		
+		try {
+			currentTask = workerMessaging.getNextTask();
+			
+			if (currentTask == null || !(currentTask instanceof SimulationTask)){
+				try {
+					Thread.sleep(MessageConstants.SECOND_IN_MS);
+				} catch (Exception ex) {
+				}
+				continue;				
+			}
+			doJob();			
+		} catch (Exception ex) {			
+			workerMessaging.sendFailed(SimulationMessage.jobFailed(ex.getMessage()));
+		}			
+	}	
+	
+	log.print(serviceInstanceStatus.getSpecID() + " stopped");
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:21:10 PM)
+ */
+public final void stop() {
+	bStopped = true;
+}
+}
Index: src/cbit/vcell/messaging/server/AbstractJmsServiceProvider.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractJmsServiceProvider.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractJmsServiceProvider.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.PrintStream;
+import java.io.FileOutputStream;
+
+import org.vcell.util.MessageConstants.ServiceType;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (1/26/2004 10:08:15 AM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractJmsServiceProvider implements ServiceProvider {
+	protected ServiceInstanceStatus serviceInstanceStatus = null;
+	protected org.vcell.util.SessionLog log = null;
+	
+public AbstractJmsServiceProvider() {
+	super();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/24/2003 1:30:19 PM)
+ * @return cbit.vcell.messaging.admin.VCellService
+ */
+public ServiceInstanceStatus getServiceInstanceStatus() {
+	return serviceInstanceStatus;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (7/15/2003 10:42:52 AM)
+ * @return java.lang.String
+ */
+public String getServiceInstanceID() {
+	return serviceInstanceStatus.getID();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (7/15/2003 10:42:52 AM)
+ * @return java.lang.String
+ */
+public ServiceType getServiceType() {
+	return serviceInstanceStatus.getType();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/26/2004 9:49:08 AM)
+ */
+protected void initLog(String logDirectory) throws FileNotFoundException {
+	if (serviceInstanceStatus == null) {
+		throw new RuntimeException("initLog: serviceInstanceStatus can't be null");		
+	}
+	if (logDirectory != null) {
+		File logdir = new File(logDirectory);
+		if (!logdir.exists()) {
+			throw new RuntimeException("Log directory doesn't exist");
+		}
+			
+		// log file name:
+		// hostname_A_Data_0.log : alpha first data on hostname
+		// hostname_B_Db_0.log : beta first database on hostname
+		// hostname_R_Export_0.log : rel first export on hostname
+		File logfile = new File(logdir, getServiceInstanceID() + ".log");
+		java.io.PrintStream ps = new PrintStream(new FileOutputStream(logfile), true); // don't append, auto flush
+		System.out.println("log file is " + logfile.getAbsolutePath());
+		System.setOut(ps);
+		System.setErr(ps);
+	}	
+}
+}
Index: src/cbit/vcell/messaging/server/RpcServer.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcServer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:03:15 PM)
+ * @author: Fei Gao
+ */
+public interface RpcServer extends ServiceProvider {
+public Object dispatchRPC(RpcRequest request) throws Exception;
+}
Index: src/cbit/vcell/messaging/server/SimulationWorker.java
===================================================================
--- src/cbit/vcell/messaging/server/SimulationWorker.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/SimulationWorker.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.UnknownHostException;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.document.KeyValue;
+
+import cbit.htc.PBSUtils;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.messaging.MessagePropertyNotFoundException;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.solver.SolverStatus;
+import cbit.vcell.solvers.PBSSolver;
+import cbit.vcell.xml.XmlParseException;
+/**
+ * Insert the type's description here.
+ * Creation date: (10/25/2001 4:14:09 PM)
+ * @author: Jim Schaff
+ */
+public class SimulationWorker extends AbstractJmsWorker  {
+/**
+ * SimulationWorker constructor comment.
+ * @param argName java.lang.String
+ * @param argParentNode cbit.vcell.appserver.ComputationalNode
+ * @param argInitialContext javax.naming.Context
+ */
+public SimulationWorker(ServiceType wt, int wo, int wm, String logdir) throws JMSException, DataAccessException, FileNotFoundException, UnknownHostException {
+	super(wt, wo, wm, logdir);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/18/2001 5:06:15 PM)
+ */
+protected void doJob() throws JMSException, SolverException, XmlParseException {	
+	if (currentSolver != null){
+		throw new RuntimeException("previous task incomplete (currentSolver!=null)");
+	}
+	
+	log.print("Worker doing job [" + currentTask.getSimulationJob().getSimulationJobID() + "]");	
+
+	File userdir = new File(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty),currentTask.getUserName());
+	switch (serviceType) {
+		case LOCALCOMPUTE: {
+			doSolverJob(userdir);
+			break;
+		}
+		case PBSCOMPUTE: {
+			doPBSJob(userdir);
+			break;
+		}
+		default: {			
+			throw new RuntimeException("subworker can't be PBSODE or LOCAL");
+		}
+	}
+}
+
+//private void doLsfJob(int workerIndex, File userdir) throws XmlParseException, SolverException, JMSException {
+//	currentSolvers[workerIndex] = new LsfSolver(currentTasks[workerIndex], userdir,log);
+//	currentSolvers[workerIndex].addSolverListener(this);
+//	String jobid = ((LsfSolver)currentSolvers[workerIndex]).submit2Lsf();
+//
+//	// if lsf has problem with dispatching jobs, jobs that have been submitted
+//	// but are not running, will be redispatched after 5 minutes. Then we have duplicate
+//	// jobs or "failed" jobs actually running in LSF.
+//	// to avoid this, kill the job, ask the user to try again later if the jobs
+//	// are not in running status 20 seconds after submission.
+//	if (jobid != null) { 
+//		long t = System.currentTimeMillis();
+//		while (true) {
+//			try {
+//				Thread.sleep(50);
+//			} catch (InterruptedException ex) {
+//			}
+//			
+//			int status = LsfUtils.getJobStatus(jobid);
+//			if (status == LsfConstants.LSF_STATUS_DONE) {
+//				break;
+//			} else if (status == LsfConstants.LSF_STATUS_RUN) {
+//				// check to see if it exits soon after it runs
+//				try {
+//					Thread.sleep(5000);
+//				} catch (InterruptedException ex) {
+//				}
+//				status = LsfUtils.getJobStatus(jobid);
+//				if (status == cbit.htc.LsfConstants.LSF_STATUS_EXITED) {
+//					workerMessaging.sendFailed(workerIndex, "Job [" + jobid + "] exited unexpectedly: " + LsfUtils.getJobExitCode(jobid));					
+//				}
+//				break;
+//			} else if  (status == LsfConstants.LSF_STATUS_EXITED) {
+//				workerMessaging.sendFailed(workerIndex, "Job [" + jobid + "] exited unexpectedly: " + LsfUtils.getJobExitCode(jobid));
+//				break;
+//			} else if (System.currentTimeMillis() - t > 20 * MessageConstants.SECOND) {
+//				String pendingReason = cbit.htc.LsfUtils.getPendingReason(jobid);
+//				LsfUtils.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+//				workerMessaging.sendFailed(workerIndex, "LSF Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")");
+//				break;
+//			}
+//		}
+//	}
+//}
+
+private void doSolverJob(File userdir) throws SolverException {
+	currentSolver = cbit.vcell.solver.SolverFactory.createSolver(log,userdir,currentTask.getSimulationJob(), true);
+	currentSolver.addSolverListener(this);
+	currentSolver.startSolver();
+	
+	while (true){
+		try { 
+			Thread.sleep(5000); 
+		} catch (InterruptedException e) {
+		}
+
+		if (!isRunning()) {
+			log.print(currentTask + " is no longer running.");
+			break;
+		}
+	}
+}
+
+public boolean isRunning() {
+	if (currentSolver == null || currentTask == null) {
+		return false;
+	}	
+	
+	if (serviceType.equals(ServiceType.PBSCOMPUTE)) {
+		return true;
+	}
+	
+	cbit.vcell.solver.SolverStatus solverStatus = currentSolver.getSolverStatus();
+	if (solverStatus != null){
+		if (solverStatus.getStatus() != SolverStatus.SOLVER_STARTING &&
+			solverStatus.getStatus() != SolverStatus.SOLVER_READY &&
+			solverStatus.getStatus() != SolverStatus.SOLVER_RUNNING){
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 3) {
+		System.out.println("Missing arguments: " + SimulationWorker.class.getName() + " {-local|-pbs} serviceOrdinal memorySizeMB [logdir]");
+		System.exit(1);
+	}
+ 		
+	//
+	// Create and install a security manager
+	//
+	try {
+		PropertyLoader.loadProperties();
+		
+		ServiceType workerType = ServiceType.LOCALCOMPUTE;
+		int serviceOrdinal = Integer.parseInt(args[1]);	
+		
+		if (args[0].equalsIgnoreCase("-pbs")) { // submit everything to PBS
+			PBSUtils.checkServerStatus();
+			workerType = ServiceType.PBSCOMPUTE;
+			VCMongoMessage.serviceStartup(ServiceName.pbsWorker, new Integer(serviceOrdinal), args);
+		} else if (args[0].equalsIgnoreCase("-local")) { // run everything locally
+			workerType = ServiceType.LOCALCOMPUTE;
+			VCMongoMessage.serviceStartup(ServiceName.localWorker, new Integer(serviceOrdinal), args);
+		} else {
+			throw new IllegalArgumentException("wrong worker type argument : " + args[0]);
+		}
+		int maxMemoryMB = Integer.parseInt(args[2]);		
+		String logdir = null;
+		if (args.length > 3) {
+			logdir = args[3];
+		}
+		SimulationWorker worker = new SimulationWorker(workerType, serviceOrdinal, maxMemoryMB, logdir);
+		worker.start();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+		System.exit(-1);
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/22/2003 2:49:54 PM)
+ * @param message javax.jms.Message
+ * @exception javax.jms.JMSException The exception description.
+ */
+public void onControlTopicMessage(Message message) throws JMSException {
+	
+	log.print("SimulationWorker::onControlTopicMessage(): " + JmsUtils.toString(message));
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+
+		if (msgType != null && msgType.equals(MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE)) {			
+			Long longkey = (Long)JmsUtils.parseProperty(message, MessageConstants.SIMKEY_PROPERTY, long.class);
+			KeyValue simKey = new KeyValue(longkey + "");
+			int jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+			
+			if (currentSolver != null && currentTask != null && simKey.equals(currentTask.getSimKey()) 
+					&& jobIndex == currentTask.getSimulationJob().getJobIndex()) {
+				currentSolver.stopSolver();
+			}
+		} 	
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+		return;
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/9/2003 8:07:04 AM)
+ */
+private void doPBSJob(File userdir) throws XmlParseException, SolverException, JMSException {
+	currentSolver = new PBSSolver(currentTask, userdir,log);
+	currentSolver.addSolverListener(this);
+	currentSolver.startSolver();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/9/2003 8:07:04 AM)
+ */
+//private void doCondorJob(File userdir) throws XmlParseException, SolverException, JMSException {
+//	currentSolver = new CondorSolver(currentTask, userdir,log);
+//	currentSolver.addSolverListener(this);
+//	String jobid = ((CondorSolver)currentSolver).submit2Condor();
+//
+//	// if condor has problem with dispatching jobs, jobs that have been submitted
+//	// but are not running, will be redispatched after 5 minutes. Then we have duplicate
+//	// jobs or "failed" jobs actually running in Condor.
+//	// to avoid this, kill the job, ask the user to try again later if the jobs
+//	// are not in running status 20 seconds after submission.
+//	if (jobid != null) { 
+//		long t = System.currentTimeMillis();
+//		while (true) {
+//			try {
+//				Thread.sleep(50);
+//			} catch (InterruptedException ex) {
+//			}
+//			
+//			int status = CondorUtils.getJobStatus(jobid);
+//			if (status == CondorConstants.CONDOR_STATUS_COMPLETED){
+//				break;
+//			} else if (status == CondorConstants.CONDOR_STATUS_RUNNING) {
+//				// check to see if it exits soon after it runs
+//				try {
+//					Thread.sleep(5000);
+//				} catch (InterruptedException ex) {
+//				}
+//				status = CondorUtils.getJobStatus(jobid);
+//				if (status == CondorConstants.CONDOR_STATUS_EXITED) {
+//					workerMessaging.sendFailed("Job [" + jobid + "] exited unexpectedly, check Condor");					
+//				}
+//				break;
+//			} else 	if (status == CondorConstants.CONDOR_STATUS_EXITED) {				
+//				workerMessaging.sendFailed("Job [" + jobid + "] exited unexpectedly, check Condor");
+//				break;
+//			} else if (System.currentTimeMillis() - t > 20 * MessageConstants.SECOND) {
+//				String pendingReason = CondorUtils.getPendingReason(jobid);
+//				CondorUtils.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+//				workerMessaging.sendFailed("Condor Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")");
+//				break;
+//			}
+//		}
+//	}
+//}
+
+}
Index: src/cbit/vcell/messaging/server/AbstractRpcServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractRpcServerImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractRpcServerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import javax.jms.JMSException;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+
+import java.lang.reflect.InvocationTargetException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/13/2003 2:07:30 PM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractRpcServerImpl implements RpcServerImpl {
+	protected org.vcell.util.SessionLog log = null;
+
+/**
+ * RpcServerImpl constructor comment.
+ */
+protected AbstractRpcServerImpl(org.vcell.util.SessionLog slog) {
+	super();
+	this.log = slog;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/16/2004 12:30:25 PM)
+ * @return java.lang.Object
+ */
+public abstract Object getServerImpl();
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 5:51:04 PM)
+ * @return java.lang.Object
+ * @param user cbit.vcell.server.User
+ * @param method java.lang.String
+ * @param args java.lang.Object[]
+ */
+public synchronized final Object rpc(RpcRequest request) throws DataAccessException, JMSException, ObjectNotFoundException {
+	String methodName = request.getMethodName();
+	Object[] arguments = request.getArguments();
+	
+	java.lang.reflect.Method methods[] = getServerImpl().getClass().getMethods();
+	java.lang.reflect.Method method = null;
+	for (int i = 0; methods != null && i < methods.length; i ++){
+		if (methods[i].getName().equals(methodName)){
+			method = methods[i];
+			
+			Class[] paramTypes = method.getParameterTypes();
+			if (paramTypes.length != arguments.length) {
+				method = null;
+				continue;
+			}
+
+			// compare types one bye one
+			for (int j = 0; j < paramTypes.length; j ++){
+				// if argument is null, assume type matches
+				if (arguments[j] == null || paramTypes[j].isInstance(arguments[j])) { // if the object is instance of the parameter type, compatible, check next
+					continue;
+				}
+				
+				if (paramTypes[j].isPrimitive()) {	// if not, check if it's primitive type
+					Class c = arguments[j].getClass(); 
+					Class argType = null;
+
+					//unwrap primitive type
+					if (c.equals(Boolean.class)) {
+						argType = Boolean.TYPE;
+					} else if (c.equals(Character.class)) {
+						argType = Character.TYPE;
+					} else if (c.equals(Byte.class)){
+						argType = Byte.TYPE;
+					} else if (c.equals(Short.class)){
+						argType = Short.TYPE;
+					} else if (c.equals(Integer.class)){
+						argType = Integer.TYPE;
+					} else if (c.equals(Long.class)){
+						argType = Long.TYPE;
+					} else if (c.equals(Float.class)){
+						argType = Float.TYPE;
+					} else if (c.equals(Double.class)){
+						argType = Double.TYPE;
+					} else if (c.equals(Void.class)){
+						argType = Void.TYPE;
+					} else {
+						argType = null;
+					}
+
+					if (argType != null && paramTypes[j].equals(argType)) { // if it's primitive type, and the types are equal, compatible, check next
+						continue;
+					}
+				}
+				
+				method = null; // otherwise, these two types are not compatible, break
+				break;				
+			}
+
+			if (method != null) {
+				break;
+			}			
+		}
+	}	
+	
+	try {
+		if (method == null) {
+			String exceptionMessage = "No such method: " + methodName + "(";
+			for (int i = 0; i < arguments.length; i ++) {
+				exceptionMessage += arguments[i].getClass().getName();
+				if (i < arguments.length - 1) {
+					exceptionMessage += ",";
+				}
+			}
+			exceptionMessage += ")";
+			throw new DataAccessException(exceptionMessage);
+		}
+				
+		return method.invoke(getServerImpl(), request.getArguments());
+
+	} catch (InvocationTargetException ex) {
+		log.exception(ex);
+	 	Throwable targetExcepton = ex.getTargetException();
+	 	if (targetExcepton instanceof JMSException) {
+		 	throw (JMSException)targetExcepton;
+	 	} else if (targetExcepton instanceof ObjectNotFoundException) {
+		 	throw (ObjectNotFoundException)targetExcepton;
+	 	} else if (targetExcepton instanceof DataAccessException) {
+		 	throw (DataAccessException)targetExcepton;
+	 	} else {
+		 	throw new RuntimeException(targetExcepton.getMessage());
+	 	}
+	} catch (IllegalAccessException e){
+		log.exception(e);
+		throw new RuntimeException("IllegalAccessException for rpc(method=" + methodName);
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/RpcDbServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDbServerProxy.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDbServerProxy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,723 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.BigString;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VersionableFamily;
+
+import cbit.vcell.solver.ode.gui.SimulationStatus;
+import cbit.vcell.solver.SolverResultSetInfo;
+import cbit.vcell.mathmodel.MathModelMetaData;
+import cbit.vcell.biomodel.BioModelMetaData;
+import cbit.vcell.field.FieldDataDBOperationResults;
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.server.UserRegistrationOP;
+import cbit.vcell.server.UserRegistrationResults;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.modeldb.*;
+import cbit.vcell.messaging.JmsUtils;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @author: Jim Schaff
+ *
+ * stateless database service for any user (should be thread safe ... reentrant)
+ *
+ */
+public class RpcDbServerProxy extends AbstractRpcServerProxy implements cbit.vcell.server.UserMetaDbServer {
+/**
+ * DataServerProxy constructor comment.
+ */
+public RpcDbServerProxy(User argUser, JmsClientMessaging clientMessaging, org.vcell.util.SessionLog log) throws javax.jms.JMSException {
+	super(argUser, clientMessaging, JmsUtils.getQueueDbReq(), log);
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VCDocumentInfo curate(org.vcell.util.document.CurateSpec curateSpec) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	return (org.vcell.util.document.VCDocumentInfo)rpc("curate",new Object[]{user,curateSpec});
+}
+
+
+public UserRegistrationResults userRegistrationOP(UserRegistrationOP userRegistrationOP) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	return (UserRegistrationResults)rpc("userRegistrationOP",new Object[]{user,userRegistrationOP});
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteBioModel(org.vcell.util.document.KeyValue bioModelKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteBioModel",new Object[]{user, bioModelKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public FieldDataDBOperationResults fieldDataDBOperation(FieldDataDBOperationSpec fieldDataDBOperationSpec) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (FieldDataDBOperationResults)rpc("fieldDataDBOperation",new Object[]{user, fieldDataDBOperationSpec});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteGeometry(org.vcell.util.document.KeyValue geometryKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteGeometry",new Object[]{user, geometryKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteMathModel(org.vcell.util.document.KeyValue mathModelKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteMathModel",new Object[]{user, mathModelKey});
+}
+
+
+/**
+* Insert the method's description here.
+* Creation date: (10/22/2003 10:28:00 AM)
+*/
+public void deleteResultSetExport(org.vcell.util.document.KeyValue eleKey) throws org.vcell.util.DataAccessException {
+	rpc("deleteResultSetExport",new Object[]{user, eleKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteVCImage(org.vcell.util.document.KeyValue imageKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteVCImage",new Object[]{user, imageKey});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteOPResults doTestSuiteOP(cbit.vcell.numericstest.TestSuiteOP tsop) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+
+	return (cbit.vcell.numericstest.TestSuiteOPResults ) rpc("doTestSuiteOP",new Object[] {user,tsop});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.ReferenceQueryResult findReferences(org.vcell.util.document.ReferenceQuerySpec rqs) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	return (org.vcell.util.document.ReferenceQueryResult)rpc("findReferences",new Object[]{user,rqs});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.modeldb.VersionableFamily
+ * @param vType cbit.sql.VersionableType
+ * @param key cbit.sql.KeyValue
+ */
+public org.vcell.util.document.VersionableFamily getAllReferences(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (VersionableFamily)rpc("getAllReferences",new Object[]{user, vType,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo getBioModelInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.BioModelInfo)rpc("getBioModelInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo[] getBioModelInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (org.vcell.util.document.BioModelInfo[])rpc("getBioModelInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.biomodel.BioModelMetaData getBioModelMetaData(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BioModelMetaData)rpc("getBioModelMetaData",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.biomodel.BioModelMetaData[] getBioModelMetaDatas(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (BioModelMetaData[])rpc("getBioModelMetaDatas",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getBioModelXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getBioModelXML",new Object[]{user, key});
+}
+
+
+/**
+ * getBoundSpecies method comment.
+ */
+public cbit.vcell.dictionary.DBSpecies getBoundSpecies(cbit.vcell.dictionary.DBFormalSpecies dbfs) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.DBSpecies)rpc("getBoundSpecies",new Object[]{user, dbfs});
+}
+
+
+/**
+ * getDatabaseSpecies method comment.
+ */
+public cbit.vcell.dictionary.DBFormalSpecies[] getDatabaseSpecies(java.lang.String likeString, boolean isBound, cbit.vcell.dictionary.FormalSpeciesType speciesType, int restrictSearch, int rowLimit, boolean bOnlyUser) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.DBFormalSpecies[])rpc("getDatabaseSpecies",new Object[]{user, likeString,new Boolean(isBound),speciesType,new Integer(restrictSearch),new Integer(rowLimit), new Boolean(bOnlyUser)});
+}
+
+
+/**
+ * getDictionaryReactions method comment.
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getDictionaryReactions(ReactionQuerySpec reactionQuerySpec) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.ReactionDescription[])rpc("getDictionaryReactions",new Object[]{user, reactionQuerySpec});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @return cbit.vcell.export.server.ExportLog
+ * @param simKey cbit.sql.KeyValue
+ */
+public cbit.vcell.export.server.ExportLog getExportLog(org.vcell.util.document.KeyValue simulationKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (cbit.vcell.export.server.ExportLog)rpc("getExportLog",new Object[]{user, simulationKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @return cbit.vcell.export.server.ExportLog[]
+ * @param simKey cbit.sql.KeyValue
+ */
+public cbit.vcell.export.server.ExportLog[] getExportLogs(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.export.server.ExportLog[])rpc("getExportLogs",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo getGeometryInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (cbit.vcell.geometry.GeometryInfo)rpc("getGeometryInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo[] getGeometryInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.geometry.GeometryInfo[])rpc("getGeometryInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getGeometryXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getGeometryXML",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo getMathModelInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.MathModelInfo)rpc("getMathModelInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo[] getMathModelInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (org.vcell.util.document.MathModelInfo[])rpc("getMathModelInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.mathmodel.MathModelMetaData getMathModelMetaData(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (MathModelMetaData)rpc("getMathModelMetaData",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return MathModelMetaData[]
+ * @param bAll boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.mathmodel.MathModelMetaData[] getMathModelMetaDatas(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (MathModelMetaData[])rpc("getMathModelMetaDatas",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getMathModelXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getMathModelXML",new Object[]{user, key});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:54:49 PM)
+ * @return cbit.util.Preference
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.Preference[] getPreferences() throws org.vcell.util.DataAccessException {
+	return (org.vcell.util.Preference[])rpc("getPreferences",new Object[]{user});
+}
+
+
+/**
+ * getReactionStep method comment.
+ */
+public cbit.vcell.model.ReactionStep getReactionStep(org.vcell.util.document.KeyValue rxID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.model.ReactionStep)rpc("getReactionStep",new Object[]{user, rxID});
+}
+
+
+/**
+ * getReactionStepInfos method comment.
+ */
+public cbit.vcell.model.ReactionStepInfo[] getReactionStepInfos(org.vcell.util.document.KeyValue[] reactionStepKeys) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.model.ReactionStepInfo[])rpc("getReactionStepInfos",new Object[]{user, reactionStepKeys});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @return cbit.vcell.solver.SolverResultSetInfo
+ * @param simKey cbit.sql.KeyValue
+ */
+public cbit.vcell.solver.SolverResultSetInfo[] getResultSetInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (SolverResultSetInfo[])rpc("getResultSetInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationStatus[] getSimulationStatus(org.vcell.util.document.KeyValue simulationKeys[]) throws DataAccessException, ObjectNotFoundException {
+	return (SimulationStatus[])rpc("getSimulationStatus",new Object[]{simulationKeys});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationStatus getSimulationStatus(org.vcell.util.document.KeyValue simulationKey) throws DataAccessException, ObjectNotFoundException {
+	return (SimulationStatus)rpc("getSimulationStatus",new Object[]{simulationKey});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getSimulationXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getSimulationXML",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteNew getTestSuite(java.math.BigDecimal getThisTS) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+
+	return (cbit.vcell.numericstest.TestSuiteNew ) rpc("getTestSuite",new Object[] {user,getThisTS});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteInfoNew[] getTestSuiteInfos() throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+
+	return (cbit.vcell.numericstest.TestSuiteInfoNew[] ) rpc("getTestSuiteInfos",new Object[] {user});
+}
+
+
+/**
+ * getUserReactionDescriptions method comment.
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getUserReactionDescriptions(ReactionQuerySpec reactionQuerySpec) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.ReactionDescription[])rpc("getUserReactionDescriptions",new Object[]{user, reactionQuerySpec});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo getVCImageInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (cbit.image.VCImageInfo)rpc("getVCImageInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo[] getVCImageInfos(boolean bAll)
+    throws org.vcell.util.DataAccessException {
+    return (cbit.image.VCImageInfo[]) rpc(
+        "getVCImageInfos",
+        new Object[] { user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getVCImageXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getVCImageXML",new Object[]{user, key});
+}
+
+
+/**
+ * getVCInfoContainer method comment.
+ */
+public VCInfoContainer getVCInfoContainer() throws org.vcell.util.DataAccessException {
+	return (VCInfoContainer)rpc("getVCInfoContainer",new Object[]{user});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupAddUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key, java.lang.String addUserToGroup, boolean isHidden) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupAddUser",new Object[]{user, vType,key,addUserToGroup,new Boolean(isHidden)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupRemoveUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key, java.lang.String userRemoveFromGroup, boolean isHiddenFromOwner) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupRemoveUser",new Object[]{user, vType,key,userRemoveFromGroup,new Boolean(isHiddenFromOwner)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPrivate(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupSetPrivate",new Object[]{user, vType,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPublic(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupSetPublic",new Object[]{user, vType,key});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:54:49 PM)
+ * @param preferences cbit.util.Preference[]
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void replacePreferences(org.vcell.util.Preference[] preferences) throws org.vcell.util.DataAccessException {
+	rpc("replacePreferences",new Object[]{user, preferences});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private Object rpc(String methodName, Object[] args) throws org.vcell.util.ObjectNotFoundException, DataAccessException {
+	try {
+		return rpc(ServiceType.DB, methodName, args, true);
+	} catch (org.vcell.util.ObjectNotFoundException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveBioModel(BigString bioModelXML, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveBioModel",new Object[]{user, bioModelXML, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveBioModelAs(BigString bioModelXML, java.lang.String newName, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveBioModelAs",new Object[]{user, bioModelXML, newName, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveGeometry(BigString geometryXML) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveGeometry",new Object[]{user, geometryXML});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveGeometryAs(BigString geometryXML, java.lang.String newName) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveGeometryAs",new Object[]{user, geometryXML, newName});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveMathModel(BigString mathModelXML, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveMathModel",new Object[]{user, mathModelXML, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveMathModelAs(BigString mathModelXML, java.lang.String newName, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveMathModelAs",new Object[]{user, mathModelXML, newName, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.BigString saveSimulation(org.vcell.util.BigString simulationXML, boolean bForceIndependent) throws DataAccessException {
+	return (BigString)rpc("saveSimulation",new Object[]{user, simulationXML, new Boolean(bForceIndependent)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveVCImage(BigString vcImageXML) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveVCImage",new Object[]{user, vcImageXML});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveVCImageAs(BigString vcImageXML, java.lang.String newName) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveVCImageAs",new Object[]{user, vcImageXML, newName});
+}
+}
Index: src/cbit/vcell/messaging/server/JmsRpcServer.java
===================================================================
--- src/cbit/vcell/messaging/server/JmsRpcServer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/JmsRpcServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.util.Date;
+
+import javax.jms.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.RpcServerMessaging;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public abstract class JmsRpcServer extends AbstractJmsServiceProvider implements RpcServer {	
+	protected RpcServerMessaging rpcServerMessaging = null;	
+
+/**
+ * Scheduler constructor comment.
+ */
+public JmsRpcServer(ServiceType serviceType, int serviceOrdinal, String queueName, String filter, String logdir) throws Exception {
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID().toString(), serviceType, serviceOrdinal, ManageUtils.getHostName(), new Date(), true);
+	initLog(logdir);
+	
+	log = new org.vcell.util.StdoutSessionLog(serviceInstanceStatus.getID());	
+	rpcServerMessaging = new RpcServerMessaging(this, queueName, filter, log);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/3/2002 5:41:53 PM)
+ * @return java.lang.Object
+ * @param user cbit.vcell.server.User
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+public final Object dispatchRPC(RpcRequest request) throws Exception {
+	return getRpcServerImpl().rpc(request);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 2:01:52 PM)
+ * @return cbit.vcell.messaging.RpcServerImpl
+ */
+public abstract RpcServerImpl getRpcServerImpl() throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/9/2003 12:07:28 PM)
+ */
+public final void start() throws JMSException {
+	log.print(getClass().getName() + " starting");
+	rpcServerMessaging.startListening();
+	
+	log.print("Start PropertyLoader thread...");
+	new PropertyLoaderThread().start();	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 4:28:05 PM)
+ */
+public final void stop() {
+	log.print(this.getClass().getName() + " ending");
+}
+}
Index: src/cbit/vcell/messaging/server/MessagingDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/MessagingDispatcherDbManager.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/MessagingDispatcherDbManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.sql.Connection;
+
+import org.vcell.util.DataAccessException;
+
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.solver.SimulationMessage;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/23/2004 10:42:53 AM)
+ * @author: Fei Gao
+ */
+public interface MessagingDispatcherDbManager extends DispatcherDbManager {
+	SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+			String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+			VCSimulationIdentifier vcSimID, int jobIndex, String hostName, int status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+			VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateQueueStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDb, Connection con, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int queueID, int taskID, boolean firstSubmit) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, String hostName, 
+			VCSimulationIdentifier vcSimID, int jobIndex, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException;
+}
Index: src/cbit/vcell/messaging/server/RpcSimServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcSimServerProxy.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcSimServerProxy.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.JmsUtils;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @author: Jim Schaff
+ *
+ * stateless database service for any user (should be thread safe ... reentrant)
+ *
+ */
+public class RpcSimServerProxy extends AbstractRpcServerProxy implements cbit.vcell.server.SimulationController {
+/**
+ * DataServerProxy constructor comment.
+ */
+public RpcSimServerProxy(User argUser, JmsClientMessaging clientMessaging, org.vcell.util.SessionLog log) throws javax.jms.JMSException {
+	super(argUser, clientMessaging, JmsUtils.getQueueSimReq(), log);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private Object rpc(String methodName, Object[] args) throws DataAccessException {
+	try {
+		return rpc(ServiceType.DISPATCH, methodName, args, true);
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private void rpcNoWait(String methodName, Object[] args) throws DataAccessException {
+	try {
+		rpc(ServiceType.DISPATCH, methodName, args, false);
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void startSimulation(VCSimulationIdentifier vcSimID) {
+	try {
+		rpcNoWait("startSimulation",new Object[]{vcSimID});
+	}catch (DataAccessException e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void stopSimulation(VCSimulationIdentifier vcSimID) {
+	try {
+		rpcNoWait("stopSimulation",new Object[]{vcSimID});
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/DispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/DispatcherDbManager.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/DispatcherDbManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.document.KeyValue;
+
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.server.AdminDatabaseServer;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.solver.SimulationMessage;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:38:59 PM)
+ * @author: Fei Gao
+ */
+public interface DispatcherDbManager {
+	SimulationJobStatus getSimulationJobStatus(AdminDatabaseServer adminDb, KeyValue simKey, int jobIndex) throws DataAccessException;
+
+
+	SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, String computeHost, 
+			VCSimulationIdentifier vcSimID, int jobIndex, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, VCSimulationIdentifier vcSimID, 
+		int jobIndex, String hostName, int status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, VCSimulationIdentifier vcSimID, 
+			int jobIndex, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServer adminDb, String hostName, 
+			VCSimulationIdentifier vcSimID, int jobIndex, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException;
+}
Index: src/cbit/vcell/messaging/server/JavaSimulationExecutable.java
===================================================================
--- src/cbit/vcell/messaging/server/JavaSimulationExecutable.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/JavaSimulationExecutable.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,353 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import java.io.File;
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+import org.vcell.util.FileUtils;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.ControlMessageCollector;
+import cbit.vcell.messaging.ControlTopicListener;
+import cbit.vcell.messaging.JmsConnection;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsConnectionFactoryImpl;
+import cbit.vcell.messaging.JmsSession;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.messaging.MessagePropertyNotFoundException;
+import cbit.vcell.messaging.WorkerEventMessage;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.Solver;
+import cbit.vcell.solver.SolverEvent;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.solver.SolverFactory;
+import cbit.vcell.solver.SolverListener;
+import cbit.vcell.solver.SolverStatus;
+import cbit.vcell.xml.XmlHelper;
+
+public class JavaSimulationExecutable implements ControlTopicListener, SolverListener  {
+	String[] arguments = null;
+	
+	private boolean bProgress = true;	
+	private SimulationTask simulationTask = null;
+	private Solver solver = null;
+	private long lastMsgTimeStamp = 0;
+
+	private JmsConnection jmsConn = null;
+	private JmsSession workerEventSession = null;
+	
+	private String userDirectory = null;
+	private String inputFile = null;
+	int jobIndex = 0;
+	int taskID = 0;
+	
+	SessionLog log = null;
+	
+	class KeepAliveThread extends Thread {
+		public KeepAliveThread() {
+			super();
+			setName("KeepAliveThread_Compute");
+		}	
+		public void run() {
+			while (true) {
+				try {
+					sleep(MessageConstants.INTERVAL_PING_SERVER);
+				} catch (InterruptedException ex) {
+				}
+		
+				long t = System.currentTimeMillis();
+				if (lastMsgTimeStamp != 0 && t - lastMsgTimeStamp > MessageConstants.INTERVAL_PING_SERVER) {
+					log.print("@@@@Worker:Sending alive message");
+					sendAlive();
+				}
+			}
+		}	
+	}	
+	
+/**
+ * SimulationWorker constructor comment.
+ * @param argName java.lang.String
+ * @param argParentNode cbit.vcell.appserver.ComputationalNode
+ * @param argInitialContext javax.naming.Context
+ */
+public JavaSimulationExecutable(String[] args) {
+	arguments = args;
+}
+
+private void start() {
+	try {		
+		reconnect();
+		
+		if (arguments.length != 6) {
+			throw new RuntimeException("Missing arguments: " + JavaSimulationExecutable.class.getName() + "{alpha|beta|rel} userDir inputFile jobIndex -tid taskID");
+		}
+		
+		int argCount = 0;
+		String serverID = arguments[argCount ++];
+		if (!serverID.equalsIgnoreCase(VCellServerID.getSystemServerID().toString())) {
+			throw new IllegalArgumentException("wrong server id : " + arguments[argCount]);
+		}
+		userDirectory = arguments[argCount ++];
+		inputFile = arguments[argCount ++];
+		jobIndex = Integer.parseInt(arguments[argCount ++]);
+		String tid = arguments[argCount ++];
+		if (tid.equals("-tid")) {
+			taskID = Integer.parseInt(arguments[argCount ++]);
+		} else {
+			throw new IllegalArgumentException("wrong arguments : " + tid);
+		}
+		
+		String xmlString = FileUtils.readFileToString(new File(userDirectory, inputFile));
+		Simulation simulation = XmlHelper.XMLToSim(xmlString);
+		simulationTask = new SimulationTask(new SimulationJob(simulation, jobIndex, null), taskID);
+		
+		log = new StdoutSessionLog(simulationTask.getSimulationJobIdentifier());	
+		
+		log.print("Start keep alive thread");
+		new KeepAliveThread().start();
+		
+		runSimulation();
+		
+		try {
+			if (jmsConn != null) {
+				jmsConn.close();
+			}
+		} catch (Exception ex) {
+			log.exception(ex);
+		}
+	} catch (Throwable ex) {
+		ex.printStackTrace();
+		sendFailed(SimulationMessage.solverAborted(ex.getMessage()));
+	}
+}
+
+protected void reconnect() throws JMSException {
+	JmsConnectionFactory jmsConnectorFactory = new JmsConnectionFactoryImpl();
+	jmsConn = jmsConnectorFactory.createConnection();
+	workerEventSession = jmsConn.getAutoSession();		
+	
+	JmsSession serviceListenTopicSession = jmsConn.getAutoSession();
+	serviceListenTopicSession.setupTopicListener(JmsUtils.getTopicServiceControl(), null, new ControlMessageCollector(this));
+	jmsConn.startConnection();
+}
+
+private void runSimulation() throws SolverException {
+	solver = SolverFactory.createSolver(log, new File(userDirectory), simulationTask.getSimulationJob(), true);
+	solver.addSolverListener(this);
+	solver.startSolver();
+	
+	while (true){
+		try { 
+			Thread.sleep(500); 
+		} catch (InterruptedException e) {
+		}
+
+		cbit.vcell.solver.SolverStatus solverStatus = solver.getSolverStatus();
+		if (solverStatus != null) {
+			if (solverStatus.getStatus() != SolverStatus.SOLVER_STARTING &&
+				solverStatus.getStatus() != SolverStatus.SOLVER_READY &&
+				solverStatus.getStatus() != SolverStatus.SOLVER_RUNNING){
+				break;
+			}
+		}		
+	}
+}
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(String[] args) {	
+	try {
+		PropertyLoader.loadProperties();
+		VCMongoMessage.enabled = false;
+		JavaSimulationExecutable worker = new JavaSimulationExecutable(args);
+		worker.start();
+	} catch (Throwable ex) {
+		ex.printStackTrace();
+	} finally {
+		System.exit(0);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/22/2003 2:49:54 PM)
+ * @param message javax.jms.Message
+ * @exception javax.jms.JMSException The exception description.
+ */
+public void onControlTopicMessage(Message message) throws JMSException {
+	
+	log.print("JavaSimulationExecutable::onControlTopicMessage(): " + JmsUtils.toString(message));
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+
+		if (msgType != null && msgType.equals(MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE)) {			
+			Long longkey = (Long)JmsUtils.parseProperty(message, MessageConstants.SIMKEY_PROPERTY, long.class);
+			KeyValue simKey = new KeyValue(longkey + "");
+			int jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+			
+			if (simKey.equals(simulationTask.getSimKey()) && jobIndex == simulationTask.getSimulationJob().getJobIndex()) {
+				solver.stopSolver();
+			}
+		} 	
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+		return;
+	}
+}
+
+private void sendAlive() {
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendWorkerAlive(" + simulationTask.getSimulationJobIdentifier() + ")");
+		WorkerEventMessage.sendWorkerAlive(workerEventSession, this, simulationTask, ManageUtils.getHostName(), SimulationMessage.MESSAGE_WORKEREVENT_WORKERALIVE);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+private void sendFailed(SimulationMessage failureMessage) {		
+	try {
+		log.print("sendFailure(" + simulationTask.getSimulationJobIdentifier() + "," + failureMessage +")");
+		WorkerEventMessage.sendFailed(workerEventSession, this, simulationTask, ManageUtils.getHostName(), failureMessage);
+	} catch (JMSException ex) {
+        log.exception(ex);
+	}
+}
+
+private void sendNewData(double progress, double timeSec, SimulationMessage simulationMessage) {	
+	try {
+		long t = System.currentTimeMillis();
+		if (bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE) { // don't send data message too frequently
+			log.print("sendNewData(" + simulationTask.getSimulationJobIdentifier() + "," + (progress * 100) + "%," + timeSec + ")");		
+			WorkerEventMessage.sendNewData(workerEventSession, this, simulationTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+		
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = false;
+		}
+	} catch (JMSException e) {
+		e.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+private void sendProgress(double progress, double timeSec, SimulationMessage simulationMessage) {
+	try {
+		long t = System.currentTimeMillis();
+		if (!bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE 
+				|| ((int)(progress * 100)) % 25 == 0) { // don't send progress message too frequently
+			log.print("sendProgress(" + simulationTask.getSimulationJobIdentifier() + "," + (progress * 100) + "%," + timeSec + ")");
+			WorkerEventMessage.sendProgress(workerEventSession, this, simulationTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+			
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = true;
+		}
+	} catch (JMSException e) {
+		log.exception(e);
+	}
+}
+
+private void sendCompleted(double progress, double timeSec, SimulationMessage simulationMessage) {
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendComplete(" + simulationTask.getSimulationJobIdentifier() + ")");
+		WorkerEventMessage.sendCompleted(workerEventSession, this, simulationTask, ManageUtils.getHostName(),  progress, timeSec, simulationMessage);
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+private void sendStarting(SimulationMessage startingMessage) {
+	try {
+		log.print("sendStarting(" + simulationTask.getSimulationJobIdentifier() + ")");
+		WorkerEventMessage.sendStarting(workerEventSession, this, simulationTask, ManageUtils.getHostName(), startingMessage);
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+/**
+ * Invoked when the solver aborts a calculation (abnormal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverAborted(SolverEvent event) {
+	sendFailed(event.getSimulationMessage());
+}
+
+/**
+ * Invoked when the solver finishes a calculation (normal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverFinished(SolverEvent event) {
+	sendCompleted(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverPrinted(SolverEvent event) {
+	// can never get data messages here
+	sendNewData(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverProgress(SolverEvent event) {
+	// can never get progress message here
+	sendProgress(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver begins a calculation.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStarting(SolverEvent event) {
+	sendStarting(event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stops a calculation, usually because
+ * of a user-initiated stop call.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStopped(SolverEvent event) {		
+	log.print("Caught solverStopped(" + event.getSource() + ")");
+	// Don't send message anymore because the dispatcher will update the database anyway no matter if the worker responds
+	//workerMessaging.sendStopped(event.getProgress(), event.getTimePoint());
+}
+
+}
Index: src/cbit/vcell/messaging/server/DatabaseServer.java
===================================================================
--- src/cbit/vcell/messaging/server/DatabaseServer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/DatabaseServer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+
+import static org.vcell.util.MessageConstants.*;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.modeldb.DatabasePolicySQL;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public class DatabaseServer extends JmsRpcServer {
+	private RpcDbServerImpl rpcDbServerImpl = null;
+	private static String filter =  "(" + MESSAGE_TYPE_PROPERTY + "='" + MESSAGE_TYPE_RPC_SERVICE_VALUE  + "') AND (" 
+		+ SERVICE_TYPE_PROPERTY + "='" + ServiceType.DB.getName() + "')";
+
+/**
+ * Scheduler constructor comment.
+ */
+public DatabaseServer(int serviceOrdinal, String logdir) throws Exception {	
+	super(ServiceType.DB, serviceOrdinal, JmsUtils.getQueueDbReq(), filter, logdir);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2003 8:17:51 AM)
+ * @return cbit.vcell.messaging.RpcServerImpl
+ * @param user cbit.vcell.server.User
+ */
+public RpcServerImpl getRpcServerImpl() throws DataAccessException {
+	try {
+		if (rpcDbServerImpl == null) {
+			rpcDbServerImpl = new RpcDbServerImpl(log);
+		}
+
+		return rpcDbServerImpl;
+	} catch (Exception ex) {
+		log.exception(ex);
+		throw new DataAccessException(ex.getMessage());
+	}
+}
+
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 1) {
+		System.out.println("Missing arguments: " + DatabaseServer.class.getName() + " serviceOrdinal [logdir]");
+		System.exit(1);
+	}
+	
+	try {
+		PropertyLoader.loadProperties();
+		DatabasePolicySQL.bSilent = true;
+		
+		int serviceOrdinal = Integer.parseInt(args[0]);
+		String logdir = null;
+		if (args.length > 1) {
+			logdir = args[1];
+		}
+		VCMongoMessage.serviceStartup(ServiceName.database, new Integer(serviceOrdinal), args);
+        DatabaseServer databaseServer = new DatabaseServer(serviceOrdinal, logdir);       
+        databaseServer.start();        
+    } catch (Throwable e) {
+	    e.printStackTrace(System.out); 
+    }
+}
+}
Index: src/cbit/vcell/messaging/server/LocalVCellConnectionMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalVCellConnectionMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalVCellConnectionMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.io.FileNotFoundException;
+import java.net.URL;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+import org.vcell.util.BeanUtils;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+
+import cbit.rmi.event.DataJobListener;
+import cbit.rmi.event.ExportEvent;
+import cbit.rmi.event.ExportListener;
+import cbit.rmi.event.MessageEvent;
+import cbit.rmi.event.PerformanceMonitorEvent;
+import cbit.rmi.event.SimpleMessageService;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.JmsConnection;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsMessageCollector;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.server.DataSetController;
+import cbit.vcell.server.LocalVCellServer;
+import cbit.vcell.server.PerformanceMonitoringFacility;
+import cbit.vcell.server.SimulationController;
+import cbit.vcell.server.URLFinder;
+import cbit.vcell.server.UserLoginInfo;
+import cbit.vcell.server.UserMetaDbServer;
+import cbit.vcell.server.VCellConnection;
+import cbit.vcell.visit.VisitConnectionInfo;
+
+/**
+ * The user's connection to the Virtual Cell.  It is obtained from the VCellServer
+ * after the user has been authenticated.
+ * Creation date: (Unknown)
+ * @author: Jim Schaff.
+ */
+@SuppressWarnings("serial")
+public class LocalVCellConnectionMessaging extends UnicastRemoteObject implements VCellConnection, ExportListener ,DataJobListener{
+	private long MAX_TIME_WITHOUT_POLLING_MS = 10*MessageConstants.MINUTE_IN_MS;
+	private LocalDataSetControllerMessaging dataSetControllerMessaging = null;
+	private LocalSimulationControllerMessaging simulationControllerMessaging = null;
+	private LocalUserMetaDbServerMessaging userMetaDbServerMessaging = null;
+	private SimpleMessageService messageService = null;
+
+	private JmsConnection jmsConn = null;
+	private JmsMessageCollector jmsMessageCollector = null;
+	
+	private UserLoginInfo userLoginInfo;
+	
+	private SessionLog fieldSessionLog = null;
+	private LocalVCellServer fieldLocalVCellServer = null;
+	private String fieldHost = null;
+
+	private JmsClientMessaging dbClientMessaging = null;
+	private JmsClientMessaging dataClientMessaging = null;
+	private JmsClientMessaging simClientMessaging = null;
+	private PerformanceMonitoringFacility performanceMonitoringFacility;
+
+	public LocalVCellConnectionMessaging(UserLoginInfo userLoginInfo, String host, 
+		SessionLog sessionLog, JmsConnectionFactory jmsConnFactory, LocalVCellServer aLocalVCellServer) 
+		throws RemoteException, java.sql.SQLException, FileNotFoundException, javax.jms.JMSException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortVCellConnection,0));
+	this.userLoginInfo = userLoginInfo;
+	this.fieldHost = host;
+	this.fieldSessionLog = sessionLog;
+	this.fieldLocalVCellServer = aLocalVCellServer;
+	jmsConn = jmsConnFactory.createConnection();
+	jmsMessageCollector = new JmsMessageCollector(jmsConn, userLoginInfo.getUser(), fieldSessionLog);
+	
+	messageService = new SimpleMessageService();
+	jmsMessageCollector.addMessageListener(messageService);
+	
+	sessionLog.print("new LocalVCellConnectionMessaging(" + userLoginInfo.getUser().getName() + ")");	
+	fieldLocalVCellServer.getExportServiceImpl().addExportListener(this);
+	fieldLocalVCellServer.getDataSetControllerImpl().addDataJobListener(this);
+	
+	performanceMonitoringFacility = new PerformanceMonitoringFacility(userLoginInfo.getUser(), sessionLog);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/16/2004 10:42:29 AM)
+ */
+public void close() throws java.rmi.RemoteException {
+	try {
+		jmsConn.close();
+	} catch (javax.jms.JMSException ex) {
+		fieldSessionLog.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2006 3:32:25 PM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void dataJobMessage(cbit.rmi.event.DataJobEvent event) {
+	// if it's from one of our jobs, pass it along so it will reach the client
+	if (getUserLoginInfo().getUser().equals(event.getUser())) {
+		messageService.messageEvent(event);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/2/2001 2:59:05 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void exportMessage(ExportEvent event) {
+	// if it's from one of our jobs, pass it along so it will reach the client
+	if (getUserLoginInfo().getUser().equals(event.getUser())) {
+		messageService.messageEvent(event);
+	}
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.server.DataSetController
+ * @exception java.lang.Exception The exception description.
+ */
+public DataSetController getDataSetController() throws RemoteException, DataAccessException {
+	fieldSessionLog.print("LocalVCellConnectionMessaging.getDataSetController()");
+	if (dataSetControllerMessaging == null) {
+		try {
+			dataClientMessaging = new JmsClientMessaging(jmsConn, fieldSessionLog, getUserLoginInfo());
+			dataSetControllerMessaging = new LocalDataSetControllerMessaging(fieldSessionLog, getUserLoginInfo().getUser(), dataClientMessaging);
+			fieldSessionLog.print("new dataClientMessaging=" + dataClientMessaging);
+		} catch (javax.jms.JMSException ex) {
+			fieldSessionLog.exception(ex);
+			throw new DataAccessException(ex.getMessage());
+		}
+	}
+	
+	return dataSetControllerMessaging;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/17/2004 4:34:02 PM)
+ * @return cbit.vcell.messaging.event.SimpleMessageServiceMessaging
+ */
+SimpleMessageService getMessageService() {
+	return messageService;
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.solvers.MathController
+ * @param mathDesc cbit.vcell.math.MathDescription
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationController getSimulationController() throws RemoteException {
+	if (simulationControllerMessaging == null){
+		try {
+			simClientMessaging = new JmsClientMessaging(jmsConn, fieldSessionLog, getUserLoginInfo());
+			simulationControllerMessaging = new LocalSimulationControllerMessaging(getUserLoginInfo().getUser(), simClientMessaging, fieldSessionLog);
+			fieldSessionLog.print("new simClientMessaging=" + simClientMessaging);
+		} catch (DataAccessException ex) {
+			fieldSessionLog.exception(ex);
+			throw new RuntimeException(ex.getMessage());
+		} catch (javax.jms.JMSException ex) {
+			fieldSessionLog.exception(ex);
+			throw new RuntimeException(ex.getMessage());
+		}
+	}
+
+	return simulationControllerMessaging;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/2/01 11:15:49 PM)
+ * @return cbit.vcell.server.URLFinder
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public URLFinder getURLFinder() {
+	try {
+		return new URLFinder(	new URL(PropertyLoader.getRequiredProperty(PropertyLoader.tutorialURLProperty)),
+								new URL(PropertyLoader.getRequiredProperty(PropertyLoader.userGuideURLProperty)));
+	} catch (java.net.MalformedURLException e){
+		fieldSessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+public VisitConnectionInfo createNewVisitConnection() {
+	VisitConnectionInfo visitConnectionInfo = VisitConnectionInfo.createHardCodedVisitConnectionInfo(getUserLoginInfo().getUser());
+	return visitConnectionInfo;
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String
+ */
+public UserLoginInfo getUserLoginInfo() {
+	return userLoginInfo;
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return DBManager
+ * @param userid java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public UserMetaDbServer getUserMetaDbServer() throws RemoteException, DataAccessException {
+	fieldSessionLog.print("LocalVCellConnectionMessaging.getUserMetaDbServer(" + getUserLoginInfo().getUser() + ")");
+	if (userMetaDbServerMessaging == null) {
+		try {
+			dbClientMessaging = new JmsClientMessaging(jmsConn, fieldSessionLog, getUserLoginInfo());
+			userMetaDbServerMessaging = new LocalUserMetaDbServerMessaging(dbClientMessaging, getUserLoginInfo().getUser(), fieldSessionLog);
+			fieldSessionLog.print("new dbClientMessaging=" + dbClientMessaging);
+		} catch (javax.jms.JMSException ex) {
+			fieldSessionLog.exception(ex);
+			throw new DataAccessException(ex.getMessage());
+		}			
+	}
+	return userMetaDbServerMessaging;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/16/2004 11:22:31 AM)
+ */
+public boolean isTimeout() throws java.rmi.RemoteException {
+	return messageService.timeSinceLastPoll() > MAX_TIME_WITHOUT_POLLING_MS;
+}
+
+
+public void sendErrorReport(Throwable exception) throws RemoteException {
+	VCMongoMessage.sendClientException(exception, getUserLoginInfo());
+	BeanUtils.sendErrorReport(exception);
+}
+
+public MessageEvent[] getMessageEvents() throws RemoteException {
+	MessageEvent[] messageEvents = messageService.getMessageEvents();
+	VCMongoMessage.sendClientMessageEventsDelivered(messageEvents, getUserLoginInfo());
+	return messageEvents;
+}
+
+
+public void reportPerformanceMonitorEvent(PerformanceMonitorEvent performanceMonitorEvent) throws RemoteException {
+	performanceMonitoringFacility.performanceMonitorEvent(performanceMonitorEvent);
+	
+}
+
+}
Index: src/cbit/vcell/messaging/SimulationDispatcherMessaging.java
===================================================================
--- src/cbit/vcell/messaging/SimulationDispatcherMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/SimulationDispatcherMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,873 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.StringTokenizer;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.ObjectMessage;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatusInfo;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.server.RpcRequest;
+import cbit.vcell.messaging.server.SimulationDispatcher;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.modeldb.AbstractDBTopLevel;
+import cbit.vcell.modeldb.AdminDatabaseServerXAImpl;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.transaction.JtaDbConnection;
+import cbit.vcell.transaction.JtaOracleConnection;
+import cbit.vcell.transaction.JtaTransactionManager;
+import cbit.vcell.xml.XmlParseException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:45 PM)
+ * @author: Jim Schaff
+ */
+public class SimulationDispatcherMessaging extends JmsServiceProviderMessaging implements ControlTopicListener {
+
+	public static final String METHOD_NAME_STARTSIMULATION = "startSimulation";
+	public static final String METHOD_NAME_STOPSIMULATION = "stopSimulation";
+	
+	private ConnectionFactory conFactory = null;
+	private KeyFactory keyFactory = null;
+		
+	private JmsXAConnection jmsXAConn = null;
+
+	private SimulationDispatcher simDispatcher = null;
+	private JmsXASession mainJobDispatcher = null;
+
+	private AdminDatabaseServerXA jobAdminXA = null;
+	private String jobSelector = null;
+	
+
+	class SimulationMonitorThread extends Thread {
+	
+		public SimulationMonitorThread() {
+			super();
+			setName(simDispatcher.getServiceInstanceID() + "_MT");
+		}
+		
+		public void run() {
+			javax.transaction.TransactionManager tm = new JtaTransactionManager();
+			
+			JtaDbConnection obsoleteJobDbConnection = null;
+			JmsXASession obsoleteJobDispatcher = null;	
+			boolean join = true;
+			SimulationJobStatus jobStatus = null;
+				
+			while (true) {
+				try {
+					obsoleteJobDispatcher = jmsXAConn.getXASession();
+					break;
+					
+				} catch (Exception e) {
+					log.exception(e);
+					try {
+						Thread.sleep(MessageConstants.SECOND_IN_MS);
+					} catch (InterruptedException ex) {
+						log.exception(ex);
+					}
+				}
+			}
+			
+			while (true) { // first while(true);
+				log.print("##MT");
+				while (true) { // second while(true), check one by one
+					try {	
+						
+						//
+						// for first 10 minutes of dispatcher uptime, don't check for obsolete messages.
+						// as a startup transient, let the dispatchers catch up with worker messages before passing
+						// judgement on the health of jobs.
+						//
+						long uptime = System.currentTimeMillis() - VCMongoMessage.getServiceStartupTime();
+						final int UPTIME_WAIT = 1000*60*10;
+						if (uptime < UPTIME_WAIT){
+							try {
+								Thread.sleep(UPTIME_WAIT - uptime);
+							}catch (Exception e){
+							}
+							continue;  // for first 10 minutes of uptime, don't obsolete
+						}
+						
+						obsoleteJobDbConnection = new JtaOracleConnection(conFactory);
+
+						jobStatus = jobAdminXA.getNextObsoleteSimulation(obsoleteJobDbConnection.getConnection(), MessageConstants.INTERVAL_DATABASE_SERVER_FAIL);								
+						if (jobStatus == null) {
+							log.print("##MT OK");
+							break; // no obsolete simulation, no transaction here. go back to sleep
+						}				
+
+						tm.begin();	
+						join = obsoleteJobDbConnection.joinTransaction(tm);
+
+						if (!join) {
+							throw new RuntimeException("##MT: join failed");
+						} else {
+							join = obsoleteJobDispatcher.joinTransaction(tm);
+
+							if (!join) {
+								throw new RuntimeException("##MT: join failed");
+							} else {
+								// too many retries
+								if ((jobStatus.getTaskID() & MessageConstants.TASKID_RETRYCOUNTER_MASK) >= MessageConstants.TASKID_MAX_RETRIES) {							
+									log.print("##MT too many retries " + jobStatus);
+
+									// new job status is failed.
+									SimulationJobStatus	newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), jobStatus.getSubmitDate(),
+										SimulationJobStatus.SCHEDULERSTATUS_FAILED, jobStatus.getTaskID(),
+										SimulationMessage.MESSAGE_JOB_FAILED_TOOMANYRETRIES,
+										jobStatus.getSimulationQueueEntryStatus(), jobStatus.getSimulationExecutionStatus());
+									//update the database
+									jobAdminXA.updateSimulationJobStatus(obsoleteJobDbConnection.getConnection(), jobStatus, newJobStatus);
+									// tell client
+									StatusMessage statusMsg = new StatusMessage(newJobStatus, jobStatus.getVCSimulationIdentifier().getOwner().getName(), null, null);
+									statusMsg.sendToClient(obsoleteJobDispatcher);
+									
+								} else {
+									SimulationTask simTask = simDispatcher.getSimulationTask(jobStatus);
+									
+									log.print("##MT requeued " + simTask);
+
+									// increment taskid, new job status is queued
+									SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), jobStatus.getSubmitDate(), 
+										SimulationJobStatus.SCHEDULERSTATUS_QUEUED, jobStatus.getTaskID() + 1, 
+										SimulationMessage.MESSAGE_JOB_QUEUED_RETRY, jobStatus.getSimulationQueueEntryStatus(), null);
+									
+									//update the database
+									jobAdminXA.updateSimulationJobStatus(obsoleteJobDbConnection.getConnection(), jobStatus, newJobStatus);
+									// send to simulation queue
+									Simulation sim = simTask.getSimulationJob().getSimulation();
+									SimulationTask newSimTask = new SimulationTask(new SimulationJob(sim, newJobStatus.getJobIndex(), simDispatcher.getFieldDataIdentifierSpecs(sim)), newJobStatus.getTaskID());
+									SimulationTaskMessage taskMsg = new SimulationTaskMessage(newSimTask);
+									taskMsg.sendSimulationTask(obsoleteJobDispatcher);
+									// tell client
+									StatusMessage statusMsg = new StatusMessage(newJobStatus, newSimTask.getUserName(), null, null);
+									statusMsg.sendToClient(obsoleteJobDispatcher);
+								}
+								tm.commit();
+								
+								yield();
+								continue;
+							}
+						}
+					} catch (Exception e){
+						log.exception(e);
+						
+						try {
+							tm.rollback();
+						} catch (Exception ex) {
+							log.exception(ex);
+						}
+
+						try {
+							if (obsoleteJobDbConnection != null && AbstractDBTopLevel.isBadConnection(obsoleteJobDbConnection.getConnection(), log)) {
+								obsoleteJobDbConnection.closeOnFailure();
+								obsoleteJobDbConnection = null;
+							}
+						} catch (SQLException sqlex) {
+							log.exception(sqlex);
+						}
+					} finally {
+						try {
+							if (obsoleteJobDbConnection != null) {
+								obsoleteJobDbConnection.close();
+								obsoleteJobDbConnection = null;
+							}
+						} catch (SQLException ex) {
+							log.exception(ex);
+						}
+					}
+				} // second while (true)
+				
+				// start next check after some time
+				try {
+					sleep(MessageConstants.INTERVAL_PING_SERVER);
+				} catch (InterruptedException ex) {
+					log.exception(ex);
+				}
+				
+			} // first while (true);
+		}
+	}
+
+	class DispatchThread extends Thread {
+		public DispatchThread() {
+			super();
+			setName(simDispatcher.getServiceInstanceID() + "_DT");
+		}
+	
+		public void run() {
+			SimulationJobStatus jobStatus = null;
+			SimulationTask simTask = null;
+			boolean foundOne = false;
+			
+			javax.transaction.TransactionManager tm = null;
+			JmsXASession waitingJobDispatcher = null;
+			JtaDbConnection waitingJobDbConnection = null;	
+			SimulationJobStatusInfo[] allActiveJobs = null;
+		
+			while (true) {
+				try {
+					waitingJobDispatcher = jmsXAConn.getXASession();
+					break;
+					
+				} catch (Exception e) {
+					log.exception(e);
+					try {
+						Thread.sleep(MessageConstants.SECOND_IN_MS);
+					} catch (InterruptedException ex) {
+						log.exception(ex);
+					}
+				}
+			}
+			tm = new JtaTransactionManager();
+			boolean join = true;
+			
+			while (true) {
+				foundOne = false;	
+				jobStatus = null;
+				
+				try {			
+					waitingJobDbConnection = new JtaOracleConnection(conFactory);
+					allActiveJobs = jobAdminXA.getActiveJobs(waitingJobDbConnection.getConnection(), getHTCPartitionShareServerIDs());
+					
+					if (allActiveJobs != null && allActiveJobs.length > 0) {				
+						SimulationJobStatusInfo firstQualifiedJob = BatchScheduler.schedule(allActiveJobs, getHTCPartitionMaximumJobs(), 
+							JmsUtils.getMaxOdeJobsPerUser(), JmsUtils.getMaxPdeJobsPerUser(), VCellServerID.getSystemServerID(), log);
+						if (firstQualifiedJob != null) {
+							foundOne = true;					
+							jobStatus = firstQualifiedJob.getSimJobStatus();					
+							Simulation sim = simDispatcher.getSimulation(firstQualifiedJob.getUser(), jobStatus.getVCSimulationIdentifier().getSimulationKey());							
+							simTask = new SimulationTask(new SimulationJob(sim, jobStatus.getJobIndex(), simDispatcher.getFieldDataIdentifierSpecs(sim)), jobStatus.getTaskID());
+							log.print("**DT: going to dispatch " + simTask);
+						}
+					}
+				} catch (Exception ex) {
+					log.exception(ex);
+					allActiveJobs = null;
+					
+					try {
+						if (waitingJobDbConnection != null && AbstractDBTopLevel.isBadConnection(waitingJobDbConnection.getConnection(), log)) {
+							waitingJobDbConnection.closeOnFailure();
+							waitingJobDbConnection = null;
+						}
+					} catch (java.sql.SQLException sqlex) {
+						log.exception(sqlex);
+					}
+				} finally {
+					try {
+						if (waitingJobDbConnection != null) {
+							waitingJobDbConnection.close();
+							waitingJobDbConnection = null;
+						}
+					} catch (SQLException ex) {
+						log.exception(ex);				
+					}			
+				}
+				
+					
+				if (foundOne) {
+					try {
+						// A Distributed Transaction for dispatcher change the status of a waiting job in the database and sends it to simulation queue 							
+						tm.begin();
+						
+						waitingJobDbConnection = new JtaOracleConnection(conFactory);
+						
+						join = waitingJobDbConnection.joinTransaction(tm) && waitingJobDispatcher.joinTransaction(tm);
+
+						if (!join) {
+							throw new RuntimeException("**DT: join failed");
+						} else {
+							double requiredMemMB = simTask.getEstimatedMemorySizeMB();
+							if (requiredMemMB > Double.parseDouble(PropertyLoader.getRequiredProperty(PropertyLoader.limitJobMemoryMB))) {						
+								SimulationJobStatus newJobStatus = simDispatcher.updateEndStatus(jobStatus, jobAdminXA, waitingJobDbConnection.getConnection(), 
+										jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), null, SimulationJobStatus.SCHEDULERSTATUS_FAILED, 
+										SimulationMessage.jobFailed("Simulation [" + simTask.getSimulationInfo().getName() + ", " + jobStatus.getJobIndex() + "] requires approximately " + requiredMemMB + "mb memory. Exceeds current memory limit."));
+								
+								// tell client
+								StatusMessage message = new StatusMessage(newJobStatus, simTask.getUserName(), null, null);
+								message.sendToClient(waitingJobDispatcher);
+							} else {
+								SimulationTaskMessage taskMsg = new SimulationTaskMessage(simTask);
+								// send the job the job queue
+								taskMsg.sendSimulationTask(waitingJobDispatcher);
+								//update database
+								SimulationJobStatus newJobStatus = simDispatcher.updateQueueStatus(jobStatus, jobAdminXA, waitingJobDbConnection.getConnection(), 
+									jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), MessageConstants.QUEUE_ID_SIMULATIONJOB, simTask.getTaskID(), false);						
+								// tell client
+								StatusMessage statusMsg = new StatusMessage(newJobStatus, simTask.getUserName(), null, null);
+								statusMsg.sendToClient(waitingJobDispatcher);
+								
+								log.print("**DT: queued " + simTask);
+							}
+						
+							tm.commit();
+							yield();
+							continue;
+						}
+					} catch (Exception ex) { // transaction exception
+						log.exception(ex);
+						
+						try {
+							tm.rollback();
+						} catch (Exception ex1) {
+							log.exception(ex1);
+						}
+						try {
+							if (waitingJobDbConnection != null && AbstractDBTopLevel.isBadConnection(waitingJobDbConnection.getConnection(), log)) {
+								waitingJobDbConnection.closeOnFailure();
+								waitingJobDbConnection = null;
+							}
+						} catch (SQLException sqlex) {
+							log.exception(sqlex);
+						}						
+					} finally {
+						try {
+							if (waitingJobDbConnection != null) {
+								waitingJobDbConnection.close();
+								waitingJobDbConnection = null;
+							}
+						} catch (java.sql.SQLException ex) {
+							log.exception(ex);
+						}
+					}
+						
+				} // if (foundOne)
+
+				// if there are no messages or no qualified jobs or exceptions, sleep for a while
+				try {
+					if (foundOne) {
+						sleep(100);
+					} else {
+						sleep(1 * MessageConstants.SECOND_IN_MS);
+					}
+				} catch (InterruptedException ex) {
+					log.exception(ex);
+				}
+			} // while(true)
+		
+		}
+	}
+
+	public class StatusThread extends Thread {
+		public StatusThread() {
+			super();
+			setName(simDispatcher.getServiceInstanceID() + "_ST");
+		}
+
+	
+		public void run() {
+			javax.transaction.TransactionManager tm = null;
+			JmsXASession statusReceiver = null;
+			JtaDbConnection statusDbConnection = null;
+			
+			while (true) {
+				try {
+					statusReceiver = jmsXAConn.getXASession();
+					break;			
+				} catch (Exception e) {
+					log.exception(e);
+					try {
+						Thread.sleep(MessageConstants.SECOND_IN_MS);
+					} catch (InterruptedException ex) {
+						log.exception(ex);
+					}
+				}
+			}
+		
+			tm = new JtaTransactionManager();
+			Message recievedMsg = null;
+			boolean join = true;
+			
+			while (true) {
+				try {
+					//log.print("--ST");
+					tm.begin();
+					
+					join = statusReceiver.joinTransaction(tm);
+
+					if (!join) {
+						throw new RuntimeException("--ST: join failed");
+					} else {
+						recievedMsg = statusReceiver.receiveMessage(JmsUtils.getQueueWorkerEvent(), 100);
+
+						if (recievedMsg == null) {
+							try {
+								tm.rollback();
+							} catch (Exception ex) {
+								log.exception(ex);
+							}
+						} else {
+							statusDbConnection = new JtaOracleConnection(conFactory);							
+							join = statusDbConnection.joinTransaction(tm);
+							if (!join) {
+								throw new RuntimeException("--ST: join failed");
+							} else {
+								simDispatcher.onWorkerEventMessage(jobAdminXA, statusDbConnection.getConnection(), statusReceiver, recievedMsg);
+								tm.commit();
+
+								yield();
+								continue;
+							}
+						}
+					}
+
+				} catch (Exception ex) { // transaction error
+					log.exception(ex);
+					try {
+						tm.rollback();
+					} catch (Exception ex1) {
+						log.exception(ex1);
+					}
+
+					try {
+						if (statusDbConnection != null && AbstractDBTopLevel.isBadConnection(statusDbConnection.getConnection(), log)) {
+							statusDbConnection.closeOnFailure();
+							statusDbConnection = null;
+						}
+					} catch (java.sql.SQLException sqlex) {
+						log.exception(sqlex);
+					}
+				} finally {
+					try {
+						if (statusDbConnection != null) {
+							statusDbConnection.close();
+							statusDbConnection = null;
+						}
+					} catch (SQLException ex) {
+						log.exception(ex);
+					}
+				}
+				
+				// if there are no messages or exceptions, sleep for a while
+				try {
+					sleep(5 * MessageConstants.SECOND_IN_MS);
+				} catch (InterruptedException ex) {
+					log.exception(ex);
+				}
+			} // while (true)
+		}
+	}
+
+/**
+ * Client constructor comment.
+ */
+public SimulationDispatcherMessaging(SimulationDispatcher simDispatcher0, ConnectionFactory conFactory0, KeyFactory keyFactory0, SessionLog log0) 
+	throws java.sql.SQLException, JMSException, DataAccessException {
+	super(simDispatcher0, log0);
+	simDispatcher = simDispatcher0;
+	conFactory = conFactory0;
+	keyFactory = keyFactory0;
+	jobAdminXA = new AdminDatabaseServerXAImpl(keyFactory, log);
+		
+	reconnect();
+
+	log.print("Starting dispatch thread..");
+	new DispatchThread().start();	
+
+	log.print("Starting status thread..");
+	new StatusThread().start();
+
+	log.print("Starting monitor thread...");
+	new SimulationMonitorThread().start();		
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void do_failed(Connection con, SimulationJobStatus oldJobStatus, String username, VCSimulationIdentifier vcSimID, 
+		int jobIndex, SimulationMessage failMsg) throws JMSException, DataAccessException, UpdateSynchronizationException {
+	
+	// if the job is in simJob queue, get it out	
+	
+	// update database
+	SimulationJobStatus newJobStatus = simDispatcher.updateEndStatus(oldJobStatus, jobAdminXA, con, vcSimID, jobIndex, null, SimulationJobStatus.SCHEDULERSTATUS_FAILED, failMsg);
+	
+	// tell client
+	StatusMessage message = new StatusMessage(newJobStatus, username, null, null);
+	message.sendToClient(mainJobDispatcher);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void do_start(Connection con, SimulationJobStatus oldJobStatus, SimulationTask simTask, int queueID) 
+	throws JMSException, DataAccessException, XmlParseException {
+	// send to simulation queue, for waiting jobs, only update the database
+	if (queueID == MessageConstants.QUEUE_ID_SIMULATIONJOB) {
+		SimulationTaskMessage taskMsg = new SimulationTaskMessage(simTask);
+		taskMsg.sendSimulationTask(mainJobDispatcher);
+		log.print("do_start(): send job " + simTask.getSimulationJobIdentifier() + " to simJob queue");
+	} else {
+		log.print("do_start(): job " + simTask.getSimulationJobIdentifier() + " pending");
+	}
+
+	// update database
+	VCSimulationIdentifier vcSimID = new VCSimulationIdentifier(simTask.getSimKey(), simTask.getSimulationJob().getSimulation().getVersion().getOwner());
+	SimulationJobStatus newJobStatus = simDispatcher.updateQueueStatus(oldJobStatus, jobAdminXA, con, vcSimID, simTask.getSimulationJob().getJobIndex(), queueID, simTask.getTaskID(), true);
+
+	// tell client
+	if (!newJobStatus.compareEqual(oldJobStatus)) {
+		StatusMessage message = new StatusMessage(newJobStatus, simTask.getUserName(), null, null);
+		message.sendToClient(mainJobDispatcher);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void do_stop(Connection con, SimulationJobStatus oldJobStatus, String username, VCSimulationIdentifier vcSimID, 
+		int jobIndex) throws JMSException, DataAccessException, UpdateSynchronizationException {
+	
+	// if the job is in simJob queue, get it out
+	KeyValue simKey = vcSimID.getSimulationKey();
+	if (oldJobStatus.isQueued()) {
+		String queueName = JmsUtils.getQueueSimJob();
+		String filter =  MessageConstants.USERNAME_PROPERTY + "='" + username + "' AND " + MessageConstants.SIMKEY_PROPERTY + "=" + simKey
+			+ " AND " + MessageConstants.JOBINDEX_PROPERTY + "=" + jobIndex;		
+		log.print("Remove job from " + queueName + " queue [" + filter + "]");	
+		// get the message out
+		mainJobDispatcher.receiveMessage(queueName, filter, 100);
+	}
+	
+	// update database
+	SimulationJobStatus newJobStatus = simDispatcher.updateEndStatus(oldJobStatus, jobAdminXA, con, vcSimID, jobIndex, null, 
+			SimulationJobStatus.SCHEDULERSTATUS_STOPPED, SimulationMessage.MESSAGE_JOB_STOPPED);
+	
+	// tell client
+	if (!newJobStatus.compareEqual(oldJobStatus)) {
+		StatusMessage message = new StatusMessage(newJobStatus, username, null, null);
+		message.sendToClient(mainJobDispatcher);
+	}
+
+	// send stopSimulation to serviceControl topic
+	log.print("send " + MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE + " to " + JmsUtils.getTopicServiceControl() + " topic");
+	Message msg = mainJobDispatcher.createMessage();		
+	msg.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE);
+	msg.setLongProperty(MessageConstants.SIMKEY_PROPERTY, Long.parseLong(simKey + ""));
+	msg.setIntProperty(MessageConstants.JOBINDEX_PROPERTY, jobIndex);
+	mainJobDispatcher.publishMessage(JmsUtils.getTopicServiceControl(), msg);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+public VCSimulationIdentifier processNextRequest() {
+	// A Distributed Transaction for dispatcher sends job to simulation queue directly
+	javax.transaction.TransactionManager tm = new JtaTransactionManager();
+	boolean join = true;
+	JtaDbConnection mainJobDbConnection = null;
+	
+	//log.print("++PNR");
+	
+	try {	
+		tm.begin();
+	
+		join = mainJobDispatcher.joinTransaction(tm);
+		if (!join) {
+			throw new RuntimeException("++PNR: join failed");
+		} else {
+			Message message = mainJobDispatcher.receiveMessage(JmsUtils.getQueueSimReq(), jobSelector, 100);
+			if (message == null) {			
+				try {
+					tm.rollback();
+				} catch (Exception ex) {
+					log.exception(ex);
+				}
+
+				return null;
+			} 
+			
+			if (!(message instanceof ObjectMessage)) {
+				tm.commit(); // ignore the bad messages
+				return null;
+			}
+
+			Object obj = ((ObjectMessage) message).getObject();
+			if (!(obj instanceof RpcRequest)) {
+				tm.commit(); // ignore the bad messages
+				return null;
+			}			
+			RpcRequest request = (RpcRequest)obj;			
+			VCSimulationIdentifier vcSimID = (VCSimulationIdentifier)request.getArguments()[0];
+			User user = request.getUser();
+
+			VCMongoMessage.sendRpcRequestReceived(request);
+			log.print("++PNR: " + request);
+
+			mainJobDbConnection = new JtaOracleConnection(conFactory);	
+			
+			join = mainJobDbConnection.joinTransaction(tm);
+
+			if (!join) {
+				throw new RuntimeException("++PNR: join failed");
+			} else {
+				if (request.getMethodName().equals(METHOD_NAME_STARTSIMULATION)) {
+					startSimulation(mainJobDbConnection.getConnection(), user, vcSimID);
+				} else if (request.getMethodName().equals(METHOD_NAME_STOPSIMULATION)) {
+					stopSimulation(mainJobDbConnection.getConnection(), user, vcSimID);
+				}	
+
+				tm.commit();
+			}
+			
+			return vcSimID;
+		}
+			
+	} catch (Exception e){
+		log.exception(e);
+		
+		try {
+			tm.rollback();
+		} catch (Exception ex) {
+			log.exception(ex);
+		}
+
+		try {
+			if (mainJobDbConnection != null && AbstractDBTopLevel.isBadConnection(mainJobDbConnection.getConnection(), log)) {
+				mainJobDbConnection.closeOnFailure();
+				mainJobDbConnection = null;
+			}
+		} catch (java.sql.SQLException sqlex) {
+			log.exception(sqlex);
+		}
+	} finally {
+		try {
+			if (mainJobDbConnection != null) {
+				mainJobDbConnection.close();
+				mainJobDbConnection = null;
+			}
+		} catch (SQLException ex) {
+			log.exception(ex);
+		}
+	}
+
+	return null;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+protected void reconnect() throws JMSException {
+	// msg filter selector 
+	jobSelector =  MessageConstants.MESSAGE_TYPE_PROPERTY + "='" + MessageConstants.MESSAGE_TYPE_RPC_SERVICE_VALUE  + "' AND " 
+		+ MessageConstants.SERVICE_TYPE_PROPERTY + "='" + simDispatcher.getServiceType() + "'";	
+	
+	super.reconnect();
+	
+	jmsXAConn = jmsConnFactory.createXAConnection();
+	mainJobDispatcher = jmsXAConn.getXASession();		
+	jmsXAConn.startConnection();
+	
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void startSimulation(Connection con, User user, VCSimulationIdentifier vcSimID) throws JMSException, DataAccessException, XmlParseException {
+	if (!user.equals(vcSimID.getOwner())) {
+		log.alert(user + " is not authorized to start simulation " + vcSimID);
+		StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, 0, null, 
+			SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.MESSAGE_JOB_FAILED_NOTAUTHORIZED, null, null), user.getName(), null, null);
+		message.sendToClient(mainJobDispatcher);
+	} else {
+		KeyValue simKey = vcSimID.getSimulationKey();
+		Simulation simulation = null;
+		FieldDataIdentifierSpec[] fdis = null;
+		try {
+			simulation = simDispatcher.getSimulation(user, simKey);
+		} catch (DataAccessException ex) {
+			log.alert("Bad simulation " + vcSimID);
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+				SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.jobFailed("Failed to dispatch simuation: " + ex.getMessage()), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+			return;
+		}
+		if (simulation != null) {
+			if (simulation.getScanCount() > Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.maxJobsPerScan))) {
+				log.alert("Too many simulations (" + simulation.getScanCount() + ") for parameter scan." + vcSimID);
+				StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+					SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.jobFailed("Too many simulations (" + simulation.getScanCount() 
+							+ ") for parameter scan."), null, null), user.getName(), null, null);
+				message.sendToClient(mainJobDispatcher);
+				return;
+			}
+			for (int i = 0; i < simulation.getScanCount(); i++){
+				// right now, we submit a regular task for each scan job...
+				// should get smarter in the future for load balancing, quotas, priorities...
+				SimulationJobStatus oldJobStatus = jobAdminXA.getSimulationJobStatus(con, simKey, i);
+				try {
+					fdis = simDispatcher.getFieldDataIdentifierSpecs(simulation);
+				} catch (DataAccessException ex) {
+					do_failed(con, oldJobStatus, user.getName(), vcSimID, i, SimulationMessage.jobFailed(ex.getMessage()));
+					return;
+				}
+				// if already started by another thread
+				if (oldJobStatus != null && !oldJobStatus.isDone()) {
+					log.alert("Can't start, simulation[" + vcSimID + "] job [" + i + "] is running already");
+				} else {
+					int newTaskID = oldJobStatus == null ? 0 : (oldJobStatus.getTaskID() & MessageConstants.TASKID_USERCOUNTER_MASK) + MessageConstants.TASKID_USERINCREMENT;
+					SimulationTask simTask = new SimulationTask(new SimulationJob(simulation, i, fdis), newTaskID);
+					int queueID = MessageConstants.QUEUE_ID_WAITING;
+					// put all the jobs to waiting first, let dispatch thread decide which to dispatch
+					do_start(con, oldJobStatus, simTask, queueID);
+				}
+			}
+		} else {
+			log.alert("Can't start, simulation [" + vcSimID + "] doesn't exist in database");
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+				SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.jobFailed("Can't start, simulation [" + vcSimID + "] doesn't exist"), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/2/2004 2:16:06 PM)
+ */
+protected void stopService() {	
+	try {
+		if (jmsXAConn != null) {
+			jmsXAConn.close();
+		}
+	} catch (JMSException ex) {
+		log.exception(ex);
+	}
+	super.stopService();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void stopSimulation(java.sql.Connection con, User user, VCSimulationIdentifier vcSimID) throws SQLException, JMSException, DataAccessException {
+	log.print("Stopping simulation");
+	if (!user.equals(vcSimID.getOwner())) {
+		log.alert(user + " is not authorized to stop simulation " + vcSimID);
+		StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, 0, null, 
+			SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.jobFailed("You are not authorized to stop this simulation!"), null, null), user.getName(), null, null);
+		message.sendToClient(mainJobDispatcher);			
+	} else {
+		KeyValue simKey = vcSimID.getSimulationKey();
+		Simulation simulation = null;
+		try {
+			simulation = simDispatcher.getSimulation(user, simKey);
+		} catch (DataAccessException ex) {
+			log.alert("Bad simulation " + vcSimID);
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+				SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.jobFailed(ex.getMessage()), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+			return;
+		}
+		if (simulation != null) {
+			for (int i = 0; i < simulation.getScanCount(); i++){
+				SimulationJobStatus jobStatus = jobAdminXA.getSimulationJobStatus(con, vcSimID.getSimulationKey(), i);
+
+				if (jobStatus != null) {
+					if (!jobStatus.isDone()) {
+						do_stop(con, jobStatus, user.getName(), vcSimID, i);
+					} else {
+						log.alert("Can't stop, simulation [" + vcSimID + "] job [" + i + "] already finished");
+					}			
+				}  else {
+					log.alert("Can't stop, simulation [" + vcSimID + "] job [" + i + "] never ran");
+				}
+			}
+		} else {
+			log.alert("Can't stop, simulation [" + vcSimID + "] doesn't exist in database");
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+				SimulationJobStatus.SCHEDULERSTATUS_FAILED, 0, SimulationMessage.jobFailed("Can't stop, simulation [" + 
+						vcSimID + "] doesn't exist"), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/21/2006 8:59:36 AM)
+ * @return int
+ */
+private static int getHTCPartitionMaximumJobs() {
+	return Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.htcPartitionMaximumJobs));
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/21/2006 9:01:20 AM)
+ * @return cbit.vcell.messaging.db.VCellServerID[]
+ */
+private static VCellServerID[] getHTCPartitionShareServerIDs() {
+	try {
+		String lsfPartitionShareServerIDs = PropertyLoader.getRequiredProperty(PropertyLoader.htcPartitionShareServerIDs);
+		StringTokenizer st = new StringTokenizer(lsfPartitionShareServerIDs, " ,");
+		VCellServerID[] serverIDs = new VCellServerID[st.countTokens() + 1]; // include the current system ServerID
+		serverIDs[0] = VCellServerID.getSystemServerID();
+		
+		int count = 1;
+		while (st.hasMoreTokens()) {			
+			serverIDs[count] = VCellServerID.getServerID(st.nextToken());
+			count ++;			
+		}
+		return serverIDs;
+	} catch (Exception ex) {
+		return null;
+	}
+}
+}
Index: src/cbit/vcell/messaging/QueueListener.java
===================================================================
--- src/cbit/vcell/messaging/QueueListener.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/QueueListener.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/22/2003 2:26:44 PM)
+ * @author: Fei Gao
+ */
+public interface QueueListener {
+/**
+ * Insert the method's description here.
+ * Creation date: (5/22/2003 2:27:23 PM)
+ */
+void onQueueMessage(javax.jms.Message message) throws JMSException;
+}
Index: src/cbit/vcell/messaging/ControlMessageCollector.java
===================================================================
--- src/cbit/vcell/messaging/ControlMessageCollector.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/ControlMessageCollector.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/21/2003 9:26:26 AM)
+ * @author: Fei Gao
+ */
+public class ControlMessageCollector extends TopicListenerImpl {
+	private ControlTopicListener controlTopicListener = null;
+/**
+ * ControlTopicListener constructor comment.
+ * @param jFactory cbit.vcell.messaging.JmsFactory
+ * @param tname java.lang.String
+ * @param selector java.lang.String
+ * @param slog cbit.vcell.server.SessionLog
+ * @exception javax.naming.NamingException The exception description.
+ * @exception javax.jms.JMSException The exception description.
+ */
+public ControlMessageCollector(ControlTopicListener listener) throws javax.jms.JMSException {
+	super();	
+	//super(MessageConstants.SERVER_CONTROL_TOPIC, slog);
+	this.controlTopicListener = listener;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (5/21/2003 9:26:26 AM)
+ * @param message javax.jms.Message
+ */
+public void onTopicMessage(javax.jms.Message message) throws javax.jms.JMSException {
+	if (controlTopicListener != null) {
+		controlTopicListener.onControlTopicMessage(message);
+	}
+}
+}
Index: src/cbit/vcell/messaging/JmsSession.java
===================================================================
--- src/cbit/vcell/messaging/JmsSession.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsSession.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 1:13:29 PM)
+ * @author: Fei Gao
+ */
+public interface JmsSession {
+	// for queue and topic
+	public void close() throws JMSException;
+	public void commit() throws JMSException;
+	public Message createMessage() throws JMSException;
+	public ObjectMessage createObjectMessage(java.io.Serializable obj) throws JMSException;
+	public Message createTextMessage(String text) throws JMSException;
+	public void rollback() throws JMSException;		
+	void setupOnException();
+	void setupSession() throws JMSException;
+	
+	// for queue
+	//public List<?> browseAllMessages(String queueName, String msgSelector) throws JMSException;
+	public Message receiveMessage(String queueName, long timeout) throws JMSException;
+	public Message receiveMessage(String queueName, String selector, long timeout) throws JMSException;
+	public Message queueRequest(Object source, String queueName, Message message, int deliveryMode, long timeout) throws JMSException;
+	public void sendMessage(String queueName, Message message, int deliveryMode, long timeToLive) throws JMSException;	
+	public void sendMessage(Queue queue, Message message, int deliveryMode, long timeToLive) throws JMSException;	
+	public void setPrefetchCount(int pc) throws JMSException;	
+	public void setPrefetchThreshold(int pt) throws JMSException;
+	public void setupQueueListener(String queueName, String msgSelector, MessageListener listener) throws JMSException;
+	
+	// for topic
+	public void publishMessage(String topicName, Message message) throws JMSException;
+	public void publishMessage(Topic topic, Message message) throws JMSException;
+	public Message topicRequest(Object source, String topicName, Message message, long timeout) throws JMSException;
+	public void setupTopicListener(String topicName, String msgSelector, MessageListener listener) throws JMSException;
+}
Index: src/cbit/vcell/messaging/SonicMQJmsProvider.java
===================================================================
--- src/cbit/vcell/messaging/SonicMQJmsProvider.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/SonicMQJmsProvider.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/16/2001 9:54:16 AM)
+ * @author: Jim Schaff
+ */
+public class SonicMQJmsProvider extends AbstractJmsProvider {
+	private String BROKER = "localhost:2506";
+	//private final static int DEFAULT_PREFETCH_COUNT = 3;
+	//private final static int DEFAULT_PREFETCH_THRESHOLD = 1;
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/16/2001 5:04:13 PM)
+ * @param host java.lang.String
+ * @param userid java.lang.String
+ * @param password java.lang.String
+ */
+public SonicMQJmsProvider(String url, String userid, String password) {
+	super(userid,password);
+	BROKER = (url.indexOf(":") >= 0) ? url : url + ":2506";
+}
+
+
+public Connection createConnection() throws JMSException {
+	if (connectionFactory == null) {
+		connectionFactory = new progress.message.jclient.QueueConnectionFactory(BROKER,null,fieldUserid,fieldPassword);
+	}
+
+	return connectionFactory.createConnection();
+}
+
+public XAConnection createXAConnection() throws JMSException {
+	if (xaConnectionFactory == null) {
+		xaConnectionFactory = new progress.message.jclient.xa.XAQueueConnectionFactory(BROKER, null,fieldUserid, fieldPassword);		
+	}
+	
+	return xaConnectionFactory.createXAConnection();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/6/2003 11:52:07 AM)
+ * @return int
+ */
+public int getErrorCode(JMSException ex) {
+	if (progress.message.jclient.ErrorCodes.testException(ex, progress.message.jclient.ErrorCodes.ERR_CONNECTION_DROPPED)) {
+		return JmsErrorCode.ERR_CONNECTION_DROPPED;
+	}
+
+	return JmsErrorCode.ERR_UNKNOWN;
+}
+
+public Connection getConnection(XAConnection xaConnection) throws JMSException {
+	return ((progress.message.jclient.xa.XAConnection)xaConnection).getConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/12/2003 10:26:16 AM)
+ * @param pingInterval int
+ */
+public void setPingInterval(int pingInterval, Connection connection) {
+	((progress.message.jclient.Connection)connection).setPingInterval(pingInterval);
+}
+
+
+public void setPrefetchCount(MessageConsumer qr, int pc) throws JMSException {
+	if (qr != null) {
+		((progress.message.jclient.MessageConsumer)qr).setPrefetchCount(pc);
+	}
+}
+
+
+public void setPrefetchThreshold(MessageConsumer qr, int pt) throws javax.jms.JMSException {
+	if (qr != null) {
+		((progress.message.jclient.MessageConsumer)qr).setPrefetchThreshold(pt);
+	}	
+}
+}
Index: src/cbit/vcell/messaging/JmsSessionImp.java
===================================================================
--- src/cbit/vcell/messaging/JmsSessionImp.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsSessionImp.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,642 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+import javax.jms.Queue;
+
+import org.vcell.util.MessageConstants;
+
+import java.io.Serializable;
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 10:45:11 AM)
+ * @author: Fei Gao
+ */
+public class JmsSessionImp implements JmsSession {
+	/**
+	 * A session is a single-threaded context for producing and consuming messages. 
+	 * You use sessions to create message producers, message consumers, and messages. 
+	 * Sessions serialize the execution of message listeners;
+	 */
+	
+	protected List<MessageProducer> producerList = null;
+	protected List<Destination> destList = null;
+	protected Map<Object, TemporaryQueue> tempQueueMap = null;
+	protected Map<Object, TemporaryTopic> tempTopicMap = null;
+	protected List<MessageConsumer> consumerList = null;
+	protected boolean transactional = false;
+	protected int ackMode = Session.AUTO_ACKNOWLEDGE;
+	protected List<MessageConsumer> listenerList = null;
+
+	protected Session session = null;
+	
+	private JmsConnection vcConn = null;
+	private int prefetchCount = -1; // use default value
+	private int prefetchThreshold = -1; // use default value
+
+/**
+ * JmsSession constructor comment.
+ */
+protected JmsSessionImp() {
+	super();
+}
+
+protected JmsSessionImp(JmsConnection c, boolean transac, int ackMode0) {
+	super();
+	vcConn = c;
+	transactional = transac;
+	ackMode = ackMode0;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/9/2003 11:45:24 AM)
+ * @param queueConn cbit.vcell.messaging.VCellQueueConnection
+ */
+protected final void clearLists() {
+	if (destList != null) {
+		synchronized (destList) {
+			destList.clear();			
+		}
+	}
+	if (tempQueueMap != null) {
+		synchronized (tempQueueMap) {
+			tempQueueMap.clear();			
+		}
+	}	
+	if (tempTopicMap != null) {
+		synchronized (tempTopicMap) {
+			tempTopicMap.clear();			
+		}
+	}	
+	if (producerList != null) {
+		synchronized (producerList) {
+			producerList.clear();			
+		}
+	}
+	if (consumerList != null) {
+		synchronized (consumerList) {
+			consumerList.clear();	
+		}		
+	}
+}
+
+public void close() throws JMSException {
+	synchronized (this) {
+		session.close();	
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 10:55:52 AM)
+ */
+public final void commit() throws JMSException {
+	if (transactional) {
+		synchronized (this) {			
+			session.commit();
+		}
+	} else {
+		throw new JMSException("Commiting back on a non-transactional session");
+	}
+}
+
+public final void rollback() throws JMSException {
+	if (transactional) {
+		synchronized (this) {
+			session.rollback();	
+		}
+	} else {
+		throw new JMSException("Rolling back on a non-transactional session");
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 10:49:27 AM)
+ * @return javax.jms.QueueReceiver
+ * @param queueName java.lang.String
+ */
+protected void closeAConsumer(MessageConsumer mc) throws JMSException {
+	if (consumerList == null) {
+		return;
+	}
+	
+	synchronized(consumerList) {
+		consumerList.remove(mc);	
+	}
+
+	synchronized (mc) {
+		mc.close();
+		mc = null;
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected final MessageConsumer createConsumer(Destination dest, String msgSelector) throws JMSException {
+	synchronized (this) {
+		MessageConsumer qr = session.createConsumer(dest, msgSelector);
+		if (prefetchCount > 0) {
+			vcConn.getJmsProvider().setPrefetchCount(qr, prefetchCount);
+		}
+		if (prefetchThreshold >= 0) {
+			vcConn.getJmsProvider().setPrefetchThreshold(qr, prefetchThreshold);
+		}
+		return qr;
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected final Queue createQueue(String destName) throws JMSException {
+	synchronized (this) {
+		return session.createQueue(destName);		
+	}
+}
+
+protected final Topic createTopic(String topicName) throws JMSException {
+	synchronized (this) {
+		return session.createTopic(topicName);		
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected final MessageProducer createProducer(Destination dest) throws JMSException {	
+	synchronized (this) {
+		return session.createProducer(dest);		
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected  final TemporaryQueue createTempQueue() throws JMSException {
+	//checkConnection();
+	
+	synchronized (this) {
+		return session.createTemporaryQueue();	
+	}	
+}
+
+protected  final TemporaryTopic createTempTopic() throws JMSException {
+	//checkConnection();
+	
+	synchronized (this) {
+		return session.createTemporaryTopic();	
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 10:49:27 AM)
+ * @return javax.jms.QueueReceiver
+ * @param queueName java.lang.String
+ */
+protected final MessageConsumer getConsumer(Destination dest, String msgSelector) throws JMSException {
+	if (dest == null) {
+		return null;
+	}
+	if (consumerList == null) {
+		consumerList = Collections.synchronizedList(new ArrayList<MessageConsumer>());
+	}	
+	
+	synchronized(consumerList) {
+		for (MessageConsumer mc : consumerList) {
+			if (mc == null) {
+				continue;
+			}				
+			if (getDestinationName(mc).equals(getDestinationName(dest)) && 
+					(mc.getMessageSelector() == null && msgSelector == null || mc.getMessageSelector() != null && msgSelector != null && mc.getMessageSelector().equals(msgSelector))) {
+				return mc;
+			}
+		}
+
+		MessageConsumer mc = createConsumer(dest, msgSelector);
+		consumerList.add(mc);
+		return mc;		
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param destName java.lang.String
+ */
+protected final Destination getQueue(String destName) throws JMSException {
+	if (destList == null) {
+		destList = Collections.synchronizedList(new ArrayList<Destination>());
+	}
+
+	synchronized(destList) {	
+		for (Destination dest : destList) {
+			if (dest instanceof Queue && destName.equals(getDestinationName(dest))) {
+				return dest;
+			}
+		}
+
+		Destination dest = createQueue(destName);	
+		destList.add(dest);	
+		return dest;		
+	}
+}
+
+protected final Destination getTopic(String destName) throws JMSException {
+	if (destList == null) {
+		destList = Collections.synchronizedList(new ArrayList<Destination>());
+	}
+
+	synchronized(destList) {	
+		for (Destination dest : destList) {
+			if (dest instanceof Topic && destName.equals(getDestinationName(dest))) {
+				return dest;
+			}
+		}
+
+		Destination dest = createTopic(destName);	
+		destList.add(dest);	
+		return dest;		
+	}
+}
+
+private String getDestinationName(Destination dest) throws JMSException {
+	if (dest == null) {
+		return null;
+	}		
+	return (dest instanceof Queue) ? ((Queue)dest).getQueueName() : ((Topic)dest).getTopicName();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:55:24 AM)
+ * @return java.lang.String
+ * @param dest javax.jms.Destination
+ */
+private String getDestinationName(MessageConsumer mc) throws JMSException {
+	if (mc == null) {
+		return null;
+	}		
+	return (mc instanceof QueueReceiver) ? ((QueueReceiver)mc).getQueue().getQueueName() : ((TopicSubscriber)mc).getTopic().getTopicName();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:55:24 AM)
+ * @return java.lang.String
+ * @param dest javax.jms.Destination
+ */
+private String getDestinationName(MessageProducer mp) throws JMSException {
+	if (mp == null) {
+		return null;
+	}
+		
+	return (mp instanceof QueueSender) ? ((QueueSender)mp).getQueue().getQueueName() : ((TopicPublisher)mp).getTopic().getTopicName();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+protected final MessageProducer getProducer(Destination dest) throws JMSException {
+	if (dest == null) {
+		return null;
+	}	
+	if (producerList == null) {
+		producerList = Collections.synchronizedList(new ArrayList<MessageProducer>());
+	}
+		
+	synchronized(producerList) {	
+		for (MessageProducer mp : producerList) {
+			if (mp == null) {
+				continue;
+			}				
+			if (getDestinationName(dest).equals(getDestinationName(mp))) {
+				return mp;
+			}
+		}
+
+		MessageProducer mp =  createProducer(dest);	
+		producerList.add(mp);
+		return mp;			
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+protected final TemporaryQueue getTempQueue(Object source) throws JMSException {
+	if (tempQueueMap == null) {
+		tempQueueMap = Collections.synchronizedMap(new HashMap<Object, TemporaryQueue>());
+	}
+
+	TemporaryQueue tempQueue = null;
+	synchronized(tempQueueMap) {
+		tempQueue = tempQueueMap.get(source);
+		if (tempQueue == null) {
+			tempQueue = createTempQueue();	
+			tempQueueMap.put(source, tempQueue);	
+		}
+	}
+
+	return tempQueue;
+}
+
+protected final TemporaryTopic getTempTopic(Object source) throws JMSException {
+	if (tempTopicMap == null) {
+		tempTopicMap = Collections.synchronizedMap(new HashMap<Object, TemporaryTopic>());
+	}
+
+	TemporaryTopic tempTopic = null;
+	synchronized(tempTopicMap) {
+		tempTopic = tempTopicMap.get(source);
+		if (tempTopic == null) {
+			tempTopic = createTempTopic();	
+			tempTopicMap.put(source, tempTopic);	
+		}
+	}
+
+	return tempTopic;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/21/2003 1:54:28 PM)
+ */
+public synchronized void setupOnException() {	
+	try {
+		clearLists();
+		setupSession();
+			
+		if (listenerList != null) {
+			List<MessageConsumer> tempList = new ArrayList<MessageConsumer>();
+			tempList.addAll(listenerList);
+			listenerList.clear();
+
+			for (MessageConsumer mc : tempList) {
+				setupListener(mc);
+			}
+			
+			tempList.clear();
+		}
+			
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+public final void setupQueueListener(String queueName, String msgSelector, MessageListener listener) throws JMSException {
+	Destination dest = getQueue(queueName);
+	setupListener(dest, msgSelector, listener);
+}
+
+public final void setupTopicListener(String topicName, String msgSelector, MessageListener listener) throws JMSException {
+	Destination	dest = getTopic(topicName);
+	setupListener(dest, msgSelector, listener);
+}
+
+
+public final void setupListener(Destination dest, String msgSelector, MessageListener listener) throws JMSException {
+	MessageConsumer mc = createConsumer(dest, msgSelector);
+	mc.setMessageListener(listener);	
+
+	if (listenerList == null) {
+		listenerList = Collections.synchronizedList(new ArrayList<MessageConsumer>());
+	}
+
+	synchronized (listenerList) {
+		listenerList.add(mc);
+	}		
+	System.out.println("----Set up Listener:[" + dest + ", " + mc.getMessageSelector() + "]");
+}
+
+public final void setupListener(MessageConsumer mc) throws JMSException {
+	Destination dest = null;
+	String destName = null;
+	if (mc instanceof QueueReceiver) {
+		destName = ((QueueReceiver)mc).getQueue().getQueueName();
+		dest = getQueue(destName);
+	} else {
+		destName = ((TopicSubscriber)mc).getTopic().getTopicName();
+		dest = getTopic(destName);
+	}
+	setupListener(dest, mc.getMessageSelector(), mc.getMessageListener());
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+public synchronized void setupSession() throws JMSException {
+	session = vcConn.getConnection().createSession(transactional, ackMode);
+}
+
+public final Message createMessage() throws JMSException {
+	//checkConnection();
+
+	synchronized (this) {
+		return session.createMessage();	
+	}	
+}
+
+public final ObjectMessage createObjectMessage(Serializable obj) throws JMSException {
+	//checkConnection();
+
+	synchronized (this) {
+		return session.createObjectMessage(obj);			
+	}	
+}
+
+public final Message createTextMessage(String text) throws JMSException {
+	//checkConnection();
+
+	synchronized (this) {
+		return session.createTextMessage(text);			
+	}	
+}
+
+public final Message receiveMessage(String queueName, long timeout) throws JMSException {
+	return receiveMessage(queueName, null, timeout);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+public final Message receiveMessage(String queueName, String selector, long timeout) throws JMSException {
+	//checkConnection();
+	
+	MessageConsumer qr = getConsumer(getQueue(queueName), selector);
+	synchronized (this) {
+		return qr.receive(timeout);			
+	}	
+}
+
+public void sendMessage(String queueName, javax.jms.Message message, int deliveryMode, long timeToLive) throws javax.jms.JMSException {
+	sendMessage((Queue)getQueue(queueName), message, deliveryMode, Message.DEFAULT_PRIORITY, timeToLive);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+private final void sendMessage(Queue queue, Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {
+	//checkConnection();
+	
+	MessageProducer qs = getProducer(queue);	
+	synchronized (this) {
+		qs.send(message, deliveryMode, priority, timeToLive);			
+	}
+}
+
+
+/**
+ * sendMessage method comment.
+ */
+public void sendMessage(Queue queue, javax.jms.Message message, int deliveryMode, long timeToLive) throws javax.jms.JMSException {
+	sendMessage(queue, message, deliveryMode, Message.DEFAULT_PRIORITY, timeToLive);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/16/2003 11:49:46 AM)
+ * @return javax.jms.Message
+ * @param message javax.jms.Message
+ * @exception javax.jms.JMSException The exception description.
+ */
+public final Message queueRequest(Object source, String queueName, Message message, int deliveryMode, long timeout) throws JMSException {
+	//checkConnection();
+
+	Destination tempDest = getTempQueue(source);		
+	message.setJMSReplyTo(tempDest);
+	sendMessage((Queue)getQueue(queueName), message, deliveryMode, Message.DEFAULT_PRIORITY, timeout);
+	
+	String filter = MessageConstants.JMSCORRELATIONID_PROPERTY + "='" + message.getJMSMessageID() + "'";
+	MessageConsumer qr = getConsumer(tempDest, filter);
+	Message reply = null;
+	synchronized (this) {
+		reply = qr.receive(timeout);
+		closeAConsumer(qr);
+	}
+
+	if (reply == null) {
+		System.out.println("Request timed out");
+		deleteTempQueue(source);
+	}
+
+	return reply;
+}
+		
+public final Message topicRequest(Object source, String topicName, Message message, long timeout) throws JMSException {
+	Destination tempDest = getTempTopic(source);		
+	message.setJMSReplyTo(tempDest);
+	MessageConsumer ts = getConsumer(tempDest, null); // since topic messages don't get retained, have to create receiver before publish the messages
+	publishMessage(topicName, message);	 // message id gets set after the message is sent, so can't set filter before publishing the message
+
+	Message reply = null;
+	synchronized (this) {
+		reply = ts.receive(timeout);
+	}
+	if (reply != null) {		
+		String corrID = reply.getJMSCorrelationID();
+		if (corrID != null && corrID.equals(message.getJMSMessageID())) {
+			return reply;
+		}
+	}	
+
+	return null;	
+}
+
+private void deleteTempQueue(Object source) throws JMSException {
+	if (tempQueueMap == null) {
+		return;
+	}
+
+	TemporaryQueue tq = null;
+	synchronized(tempQueueMap) {
+		tq = tempQueueMap.remove(source);	
+	}
+
+	if (tq != null) {
+		tq.delete();
+	}
+}
+
+public final void publishMessage(String topicName, Message message) throws JMSException {
+	publishMessage((Topic)getTopic(topicName), message);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+public final void publishMessage(Topic topic, Message message) throws JMSException {
+	//checkConnection();
+	
+	MessageProducer tp = getProducer(topic);	
+	synchronized (this) {			
+		tp.send(message);
+	}
+}
+
+public void setPrefetchCount(int pc) throws javax.jms.JMSException {
+	prefetchCount = pc;
+}
+
+
+public void setPrefetchThreshold(int pt) throws javax.jms.JMSException {
+	prefetchThreshold = pt;
+}
+}
Index: src/cbit/vcell/messaging/JmsProvider.java
===================================================================
--- src/cbit/vcell/messaging/JmsProvider.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsProvider.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/24/2004 10:31:52 AM)
+ * @author: Fei Gao
+ */
+public interface JmsProvider {
+	public final static String SONICMQ = "SonicMQ";
+	//public final static String JBOSSMQ = "JBossMQ";
+
+	public abstract Connection createConnection() throws JMSException;
+	public abstract XAConnection createXAConnection() throws JMSException;
+	public abstract int getErrorCode(JMSException ex);
+	public abstract Connection getConnection(XAConnection xaConnection) throws JMSException;
+	public boolean isBadConnection(JMSException ex);
+	public abstract void setPingInterval(int pingInterval, Connection connection);
+	public abstract void setPrefetchCount(MessageConsumer qr, int pc) throws JMSException;
+	public abstract void setPrefetchThreshold(MessageConsumer qr, int pt) throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsMessageCollector.java
===================================================================
--- src/cbit/vcell/messaging/JmsMessageCollector.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsMessageCollector.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import cbit.vcell.solver.*;
+import javax.swing.event.EventListenerList;
+
+import org.vcell.util.BigString;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.User;
+
+import cbit.vcell.messaging.admin.ManageConstants;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.rmi.event.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/9/2003 12:05:19 PM)
+ * @author: Fei Gao
+ */
+public class JmsMessageCollector implements ControlTopicListener, MessageCollector {
+	private EventListenerList listenerList = new EventListenerList();	
+	private User user = null;	
+	private JmsConnection jmsConn = null;
+	private SessionLog log = null;
+
+	private long timeSinceLastMessage = System.currentTimeMillis();
+
+/**
+ * ClientStatusMonitor constructor comment.
+ * @param jmsFactory cbit.vcell.messaging.JmsFactory
+ * @param serviceName java.lang.String
+ * @param queueName java.lang.String
+ */
+public JmsMessageCollector(JmsConnection aTopicConn, User user0, SessionLog log0) throws javax.jms.JMSException {
+	jmsConn = aTopicConn;
+	user = user0;
+	log = log0;
+	
+	reconnect();	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/5/2004 9:28:52 AM)
+ * @param listener cbit.rmi.event.MessageListener
+ */
+public void addMessageListener(MessageListener listener) {
+	listenerList.add(MessageListener.class, listener);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/17/2000 11:43:22 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+protected synchronized void fireExportEvent(ExportEvent event) {
+	fireMessageEvent(event);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/17/2000 11:43:22 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+protected synchronized void fireMessageEvent(MessageEvent event) {
+	// Guaranteed to return a non-null array
+	Object[] listeners = listenerList.getListenerList();
+	// Reset the source to allow proper wiring
+	event.setSource(this);
+	// Process the listeners last to first, notifying
+	// those that are interested in this event
+	for (int i = listeners.length - 2; i >= 0; i -= 2) {
+		if (listeners[i] == MessageListener.class) {
+			((MessageListener) listeners[i + 1]).messageEvent(event);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/13/2000 2:44:30 PM)
+ * @param event cbit.rmi.event.JobProgressEvent
+ */
+protected synchronized void fireSimulationJobStatusEvent(SimulationJobStatusEvent event) {
+	fireMessageEvent(event);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 1:05:20 PM)
+ * @return long
+ */
+public long getTimeSinceLastMessage() {
+	return timeSinceLastMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public void onControlTopicMessage(javax.jms.Message message0) throws javax.jms.JMSException {	
+	
+	if (message0 == null) {
+		return;
+	}
+	if(!(message0 instanceof javax.jms.ObjectMessage)){
+		throw new javax.jms.JMSException(this.getClass().getName()+".onControlTopicMessage: unimplemented message class "+message0.getClass().getName());
+	}
+	javax.jms.ObjectMessage message = (javax.jms.ObjectMessage) message0;
+	
+	setTimeSinceLastMessage(System.currentTimeMillis());
+
+	try{
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		if(msgType == null){
+			throw new javax.jms.JMSException(this.getClass().getName()+".onControlTopicMessage: message type NULL for message "+message);
+		}
+		if (msgType.equals(MessageConstants.MESSAGE_TYPE_SIMSTATUS_VALUE)) {
+					
+			StatusMessage statusMessage = new StatusMessage(message);
+			
+			SimulationJobStatus newJobStatus = statusMessage.getJobStatus();
+			if (newJobStatus == null) {
+				return;
+			}
+			
+			VCSimulationIdentifier vcSimID = newJobStatus.getVCSimulationIdentifier();
+			Double progress = statusMessage.getProgress();
+			Double timePoint = statusMessage.getTimePoint();
+			log.print("---onTopicMessage[" + newJobStatus + ", progress=" + progress + ", timepoint=" + timePoint + "]");
+			
+			fireSimulationJobStatusEvent(new SimulationJobStatusEvent(this, vcSimID.getID(), newJobStatus, progress, timePoint));		
+
+		} else if(msgType.equals(MessageConstants.MESSAGE_TYPE_EXPORT_EVENT_VALUE)) {			
+			ExportEvent event = (ExportEvent)((javax.jms.ObjectMessage)message).getObject();
+			log.print("---onTopicMessage[ExportEvent[" + event.getVCDataIdentifier().getID() + "," + event.getProgress() + "]]");
+			fireExportEvent(event);
+		} else if(msgType.equals(MessageConstants.MESSAGE_TYPE_DATA_EVENT_VALUE)){
+			DataJobEvent event = (DataJobEvent)message.getObject();
+			log.print("---onTopicMessage[DataEvent[vcdid=" + event.getVCDataIdentifier().getID() + "," + event.getProgress() + "]]");
+			fireMessageEvent(event);
+		} else if (msgType.equals(ManageConstants.MESSAGE_TYPE_BROADCASTMESSAGE_VALUE)) {
+			fireMessageEvent(new VCellMessageEvent(this, System.currentTimeMillis() + "", new MessageData((BigString)message.getObject()), VCellMessageEvent.VCELL_MESSAGEEVENT_TYPE_BROADCAST));
+		} else{
+			throw new javax.jms.JMSException(this.getClass().getName()+".onControlTopicMessage: Unimplemented message "+message);
+		}
+	}catch(Exception e){
+		if(e instanceof javax.jms.JMSException){throw (javax.jms.JMSException)e;}
+		
+	}
+}
+
+
+/**
+ * onException method comment.
+ */
+private void reconnect() throws javax.jms.JMSException {	
+	JmsSession statusReceiver = jmsConn.getAutoSession();
+	String clientMessageFilter = (user == null ? "" : MessageConstants.USERNAME_PROPERTY + "='" + user.getName() + "' OR ");
+	clientMessageFilter += MessageConstants.USERNAME_PROPERTY + "='All'";
+			
+	statusReceiver.setupTopicListener(JmsUtils.getTopicClientStatus(), clientMessageFilter, new ControlMessageCollector(this));
+	
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/5/2004 9:28:52 AM)
+ * @param listener cbit.rmi.event.MessageListener
+ */
+public void removeMessageListener(MessageListener listener) {}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 1:05:20 PM)
+ * @param newTimeSinceLastMessage long
+ */
+public void setTimeSinceLastMessage(long newTimeSinceLastMessage) {
+	timeSinceLastMessage = newTimeSinceLastMessage;
+}
+
+public void simulationJobStatusChanged(SimulationJobStatusEvent simJobStatusEvent) {
+	// jms message collector doesn't listen for SimulationJobStatusEvent
+}
+
+public void onWorkerEvent(WorkerEvent event) {	
+	// jms message collector doesn't listen for WorkerEvent
+}
+}
Index: src/cbit/vcell/messaging/JmsXASessionImpl.java
===================================================================
--- src/cbit/vcell/messaging/JmsXASessionImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsXASessionImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.xa.XAResource;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 11:36:23 AM)
+ * @author: Fei Gao
+ */
+public class JmsXASessionImpl extends JmsSessionImp implements JmsXASession {
+	private XASession xaSession = null;
+	private JmsXAConnection vcXAConn = null;
+/**
+ * JmsXAQueueSession constructor comment.
+ * @param queueConn javax.jms.QueueConnection
+ * @exception javax.jms.JMSException The exception description.
+ */
+public JmsXASessionImpl(JmsXAConnection xaconn) throws JMSException {
+	super();
+	vcXAConn = xaconn;
+}
+
+@Override
+public void close() throws JMSException {
+	synchronized (this) {
+		session.close();
+		xaSession.close();		
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/28/2003 3:48:42 PM)
+ */
+public boolean joinTransaction(TransactionManager ttmm) throws JMSException {
+	if (vcXAConn.isConnectionDropped()) {
+		return false;
+	}
+
+	try {
+		XAResource xaRes = xaSession.getXAResource();
+		if (xaRes == null || !ttmm.getTransaction().enlistResource(xaRes)) {
+			return false;
+		}
+		return true;		
+	} catch (Exception ex) {
+		throw new JMSException(ex + ":" + ex.getMessage());
+	}
+}
+
+@Override
+public synchronized void setupOnException() {
+	try {
+		clearLists();
+		setupXASession();		
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 12:02:14 PM)
+ * @param queueConnl javax.jms.QueueConnection
+ */
+public synchronized void setupXASession() throws JMSException {	
+	xaSession = vcXAConn.getXAConnection().createXASession();
+	session = xaSession.getSession();
+}
+}
Index: src/cbit/vcell/messaging/JmsXAConnectionImp.java
===================================================================
--- src/cbit/vcell/messaging/JmsXAConnectionImp.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsXAConnectionImp.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+public class JmsXAConnectionImp extends AbstractJmsConnectionImpl implements JmsXAConnection {
+	private XAConnection xaConnection = null;	
+
+	public JmsXAConnectionImp(JmsProvider jmsProvider0) throws JMSException {
+		super(jmsProvider0);
+		setupConnection();
+	}
+	
+	public XAConnection getXAConnection() {
+		return xaConnection;
+	}
+	
+	public JmsXASession getXASession() throws JMSException {
+		JmsXASession session = new JmsXASessionImpl(this);
+		session.setupXASession();
+		synchronized (sessionList) {
+			sessionList.add(session);	
+		}
+		
+		return session;	
+	}
+
+	@Override
+	protected void setupConnection() {
+		xaConnection = null;	
+		while (xaConnection == null) {
+			try {		
+				xaConnection = jmsProvider.createXAConnection();
+				connection = jmsProvider.getConnection(xaConnection);
+				jmsProvider.setPingInterval(JMSCONNECTION_PING_INTERVAL, connection);
+				connection.setExceptionListener(this);
+				System.out.println(this + ": Connection established.");
+	 		} catch (Exception jmse) {
+				System.out.println(this + ": Cannot connect to Message Server [" + jmse.getMessage() + "], Pausing " + JMSCONNECTION_RETRY_INTERVAL/1000 + " seconds before retry.");
+				try {
+					Thread.sleep(JMSCONNECTION_RETRY_INTERVAL);
+				} catch (InterruptedException ie) {
+					ie.printStackTrace(System.out);
+				}
+			}
+		}		
+	}
+}
Index: src/cbit/vcell/messaging/admin/Performance.java
===================================================================
--- src/cbit/vcell/messaging/admin/Performance.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/Performance.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/20/2003 8:28:58 AM)
+ * @author: Fei Gao
+ */
+public abstract class Performance implements java.io.Serializable {
+	protected long freeJavaMemoryBytes = -1;
+	protected long totalJavaMemoryBytes = -1;
+	protected long maxJavaMemoryBytes = -1;	
+/**
+ * PerformanceStatus constructor comment.
+ */
+public Performance() {
+	super();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/28/01 7:04:11 PM)
+ * @return long
+ */
+public long getAvaillableJavaMemoryBytes() {
+
+	double JVM_MEMORY_TRUST_FACTOR = 0.8;
+	long currentJVMUsage = getTotalJavaMemoryBytes()-getFreeJavaMemoryBytes();
+	
+	return (long)(JVM_MEMORY_TRUST_FACTOR*(getMaxJavaMemoryBytes() - currentJVMUsage));
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getFreeJavaMemoryBytes() {
+	return freeJavaMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getMaxJavaMemoryBytes() {
+	return maxJavaMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getTotalJavaMemoryBytes() {
+	return totalJavaMemoryBytes;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/20/2003 8:47:17 AM)
+ * @return java.lang.String[]
+ */
+public abstract Object[] toObjects();
+}
Index: src/cbit/vcell/messaging/admin/LogDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/LogDialog.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/LogDialog.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/3/2003 11:21:06 AM)
+ * @author: Fei Gao
+ */
+public class LogDialog extends javax.swing.JDialog {
+	IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private javax.swing.JPanel ivjJPanel1 = null;
+	private javax.swing.JScrollPane ivjJScrollPane1 = null;
+	private javax.swing.JTextArea ivjLogTextArea = null;
+	private javax.swing.JButton ivjCloseButton = null;
+
+class IvjEventHandler implements java.awt.event.ActionListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			if (e.getSource() == LogDialog.this.getCloseButton()) 
+				connEtoC1(e);
+		};
+	};
+/**
+ * LogDialog constructor comment.
+ */
+public LogDialog() {
+	super();
+	initialize();
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ */
+public LogDialog(java.awt.Dialog owner) {
+	super(owner);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ */
+public LogDialog(java.awt.Dialog owner, String title) {
+	super(owner, title);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Dialog owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Dialog owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public LogDialog(java.awt.Frame owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ */
+public LogDialog(java.awt.Frame owner, String title) {
+	super(owner, title);
+	initialize();
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Frame owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Frame owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * Comment
+ */
+public void closeButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	dispose();
+	return;
+}
+/**
+ * connEtoC1:  (JButton1.action.actionPerformed(java.awt.event.ActionEvent) --> LogDialog.jButton1_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.closeButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * Return the JButton1 property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getCloseButton() {
+	if (ivjCloseButton == null) {
+		try {
+			ivjCloseButton = new javax.swing.JButton();
+			ivjCloseButton.setName("CloseButton");
+			ivjCloseButton.setText("Close");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjCloseButton;
+}
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(new java.awt.BorderLayout());
+			getJDialogContentPane().add(getJScrollPane1(), "Center");
+			getJDialogContentPane().add(getJPanel1(), "South");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+/**
+ * Return the JPanel1 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel1() {
+	if (ivjJPanel1 == null) {
+		try {
+			ivjJPanel1 = new javax.swing.JPanel();
+			ivjJPanel1.setName("JPanel1");
+			ivjJPanel1.setLayout(new java.awt.FlowLayout());
+			getJPanel1().add(getCloseButton(), getCloseButton().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel1;
+}
+/**
+ * Return the JScrollPane1 property value.
+ * @return javax.swing.JScrollPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JScrollPane getJScrollPane1() {
+	if (ivjJScrollPane1 == null) {
+		try {
+			ivjJScrollPane1 = new javax.swing.JScrollPane();
+			ivjJScrollPane1.setName("JScrollPane1");
+			ivjJScrollPane1.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
+			ivjJScrollPane1.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
+			getJScrollPane1().setViewportView(getLogTextArea());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJScrollPane1;
+}
+/**
+ * Return the LogTextArea property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getLogTextArea() {
+	if (ivjLogTextArea == null) {
+		try {
+			ivjLogTextArea = new javax.swing.JTextArea();
+			ivjLogTextArea.setName("LogTextArea");
+			ivjLogTextArea.setLineWrap(true);
+			ivjLogTextArea.setWrapStyleWord(true);
+			ivjLogTextArea.setBounds(0, 0, 160, 120);
+			ivjLogTextArea.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjLogTextArea;
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getCloseButton().addActionListener(ivjEventHandler);
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("LogDialog");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+		setSize(679, 484);
+		setModal(true);
+		setTitle("");
+		setContentPane(getJDialogContentPane());
+		initConnections();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		LogDialog aLogDialog;
+		aLogDialog = new LogDialog();
+		aLogDialog.setModal(true);
+		aLogDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aLogDialog.show();
+		java.awt.Insets insets = aLogDialog.getInsets();
+		aLogDialog.setSize(aLogDialog.getWidth() + insets.left + insets.right, aLogDialog.getHeight() + insets.top + insets.bottom);
+		aLogDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 11:25:33 AM)
+ * @param log java.lang.String
+ */
+public void setFile(java.io.File file) throws java.io.IOException {
+	java.io.FileReader reader = new java.io.FileReader(file);
+	char[] content = new char[10000];
+	String out = "";
+	getLogTextArea().setText(null);	
+	while (true) {
+		int n = reader.read(content, 0, 10000);
+		if (n == -1) {
+			break;
+		} else if (n > 0) {
+			out = new String(content, 0, n);
+			getLogTextArea().append(out);
+		}
+	}
+	reader.close();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 11:25:33 AM)
+ * @param log java.lang.String
+ */
+public void setText(String log) {
+	getLogTextArea().setText(null);
+	getLogTextArea().setText(log);
+}
+/**
+ * 
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private static void getBuilderData() {
+/*V1.1
+**start of data**
+	D0CB838494G88G88GFBFBB0B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135DA8FD09C67F5A7AEF16CD453520912E057CED5D9C9F0CA92F52C0CE9C6E9D557131058CE8815DACDC76EE8EAB5210EDB4B93B555F418E46F0EC3202088594441E35CE0590E11F41C0E3F02630F6E6010C0A0B8F1E7A0AE92DA3865B8D8EECFFB0BC0C8083E777D59DB0EBB30DC0919476E773E7F6F7D5E7B5E777604325FEE321A4CE502E0328A6C6F0CC990822785A17527C33BB82F697D5CE2417077
+	B650B1614F2F9440339B6A1E7EA03738D4783B5BC5D09E05F28614FF836F2F895937DDF6F8C9B2CFB95439BE7D39485A739C1E64739CA26517EDA5707C9550D56061B373FD1C7FD0F5B96327B2BEA71399F8D55866F8F585636D07B6C540F381792BE8FB991EF4811FF4B631F623FF12A19C781EEABE026398466474AC6B3B1FBDAB057FB6251F4039FA2BCBD81FAAA8DF85424DDB041F3CF7921E2D5E19E07B44F8C833DF1F10E459BEABC523E2B0948E5A4540ECA86CF476A9C1CFC81415A0086FA40E77196AA2
+	52DF907640D81B886F51F61CE3845EA3C08F1C647C40D9646F0377FC2032D3FCDFED6F3732F50F5CFCD258D9BBDBF0B4493EEC2768FE7C27E27B8ACCBFEFFE036860C290E51D86F55B003201DE82AA3165965B005EA43A3FB4097BF40FEB1D4A6C2C92F6C7A29DF2C03D2884A4995E1DCE28E13CC1E9C2D18302C075FB295A16E0BDEB916DB7F6477D28CCB26A382EB3873FA66CF962F366C389E432A7632659E32332983545E4C267CECFBA77AD5BCAAC2E1CFBD8B04E1D5A3F4BE2CDB0772616DD16B4B64E9643
+	5CBBED286BE3C457CF433B096103725FA47C726A981F6272B10299ACD7C15D06EA0E0D11DF71357495EC96CAEBBE1FD08E69CFEDB06F2F26EBA832472FE5B719335E9E3F16FFA1FC0FBDFEAD53E779DA7CD01785C471658B211DD61C4EADEE827282CD81BDG3485A86BB44758431327BFA2463C222AF54C056400248A342FAF78BABC2585CD95FB42D1CD8CCFC8C3229A9247E5A9AA30B623C11441780AFEA2417E844CF1DE8ACB2A280514B00CAE4ECA1A24C6E91B6960B1EC23CA24569F826B5644D9F4F434DE
+	8D3E86CFD90CEA9FC48222A645DA507A45A06A643AB884A342G70CE6512B20D725A8D7B5F8FA4B8389C7E130C57AB29E1C9C657214C4CC57C3893416BC0B9FF1D780EB2F837B9380CEF4DA0EFA314B375F1ECD32F9A467104A6F07922FA035B58EF4E22AF5E616018790F910E994F112F8A36DD1FCD08193256DD165D8E66A79D713673B6999357C54B0F370F5C219DFF945A416625F3BCF5CF663030A7156F0BB2313F1A5C62FAA0FF8D17F1F02A12E236C30CCA9C2583AAGCC8A44A4CE57794FC4B6A6FD5DF9
+	24AC57F0D9C54E0EA410775DA2BA4703E48E4BBD1A034A64F2884FA1693A9456BCD2C48A8760A54A6A82A1449A3353C9C56FB3CD7891306BCEB024284E0F045076C4CDD3C363F31A6413B48D0E55D87D8219ABBAB79E093984BE57F2887D2FB28FF62D37CF8D21CDCCA86130C41423F7E17577931B14E4E996965D294C05B54A5FB00D3A1A11EEB01F10B6DDA820CD4BF368DFE8AC30D57CA56EC18D4D024A51C589F9B5E82F5F56E399240D404318E6BBBCF3EA386D4D3F43ED6F5D4547059DE391F32233A37D0B
+	FFECF654D26CFBEAE336C75774091944EB7F94718D0C9F25EBCD9B46F98DE1894379BBE19CA3GE3AFG2555F21CDBE42C673E04813CD311E5AAC6DD3E7B65D25407F4EDCE82970CCE2BD71759FF492F46558DB179517ADF48A8BF59606F266AD0FEEF38F81C17816B59813437164A30320E4A006EE9709A2E1144E25362F5F1419E1D872CB81D9774BD52584BE1C7F9607E375571986B85876E7BA5A897546796D754F33D7C70880F31B64EE488D787F6DA12450E7575F4ADA3750658F1F85EC265BA2B601C69D0
+	17D14FE53AB8EB74736EE8D4198811A3064963C45828B74A33078F43F3B224C6359EB02C85AE3B7AB02E974FA046E6E7F2072B0449E7BB4CFBGE8C383721FE8ABB32C5D86BCBF508210050C77382B966D0EA857CE9FDEC91DD454D9A9D00552350B731A1D58385DCD2A3B707D84574511571DE8E7329215BA66B4CD890F39638669CBBECA4B09A19ED3EDFE4D4556786C57B68B2D4BD74C09E25C870ECE19F7B6D03967B74464BF7243674DB29075FD8DF60C6B3A9B9347F0230C9FE14FD4F852F8E73886E5185E
+	989F8709041F51989F877D1B0347C1D9D0D7F1061F5179917483A9D0FE84E89B5033C0AF8115B4F1CCEC8F57896B44C0BDE188CD42226CDB6174F8AC22D8281FE2656B0A157BA9011F815D2E7878362AE925CCBCF1E55AEFE8D53F7F09ABCF457523D8B86ACBE2179499D0C77D643FBA0DFEB285465A82148D3487085A6E0BEDC5EC5C83CD5CC6174E99EDF47B51A573AF1358282D192E2F2FB906113413BFE3B67AA5957D4C86284BG5A813487C8F0028E01DCCE2EA3A152361E0E880C7DCAA7703A411FF5461F
+	B7501F46F2FD4497DD0531D301A86FB142CB0772D61DF75C013C1DD04E53F9B304178F6552969EC3DC2E41F32AC2AF87C99965486E5B0E3B9DAB61DCABF1D2D4F33767B046ABD48756EB49E30C12EB09E30CD72FA50EB14A2F9D23FC9843F83360751557560EC12A2EA50AC15EA26B7E6E6BC74958512894A52070081A486AFE2C7DDAC8900B744365036D99E298D7B1EB5325A91DB53ACD7D74C4F9E21B720AF01AD0FBCA2F0937A70C4BDBC1DF5E96EECFEF35F0FB1AEA61E7614FDB51FFED02F296D00E0E2517
+	5B925D0B73187E73DBD67BD5EAD7559A1EB5252DB0BF1087E89468D6AB37273F3E362E4F6BDAD84367EDD513E361C9B5B1963E2562B99ED5665489A9DE5FCF2B65FADD4CF2FBB4E996D5C35BBCC77AEB229A14D661E5A769CF6B1275FFDECD06A92A7789BBE2A3A0CD0AF3B240950E5101883B1E229FE8C5BD5D36F35DBD524A73D1FFB90F3EEF92AE30B01CAFA2CD8819ED58761BF60E05F2A85B007A00E4208DED7C4CEFF6609833CAC01475B93C8E1E27BA20373B0F3453C21A0CB8ADE847BC5F311B023E767E
+	DE0C73D85485825008DD05A59EFF5DDF4B575D5D4EB1672BC74C25C0B99DE8EBBB475C7116F84CE53747F03627FDB56668592C3661F87B5B634F6CDB04AF1C0DBF338B5A7819DD8AF55AD96EE38B5BF12D3B211C2773E65A39FFBEF016E338C1CB0E41D6ADB186BB34447E28DBDB5B9FF935353173D99267985C02FDB8948EA873208A4C0CE8D13B2747679D70F50D8D740FF576418BBDC7B74D9B7324CD076FCBF887A198F2D1395B58B37F578F1B28EE7792CCE21FG54BD62C21EFC5A98EB629A3F8B7F6C08DB
+	D27F05957538B788A38D75B9AB6AF12D83D6E33D59E12C379A7A53FDBD739E0F8F721F59AA485FC8CD1A7F5D4776D364264F34FD8F197CDFDE34D039869DF816EA6A1CC4477D417F9A65D57A30ECB6A5995745466BF34767CB7E30B69E5FA96E9826B73A13617BBB44DEB25C9447D61D1FCB785B8DFC0A6F5F5773FBC08E5455F7F0ACB7937F1F8E65CC1D77C4AB47F7CE87374305B65CFB3EDE3E0F1471AEC64B075B121D7958677FFB7E53B95EC9BA475D48E7D09D3F55CEF48C46CA7D5A9BCB286932CE144BFD
+	6D65EB7427E75D371748F793E83F5049FD43504DD3709C92275949569588E90ACA0EB6E0FAD585BC3BF603F2490D186D377374474B017F6DA10E77ED5F7C0A10F53FA7E9BC1C5EC9F513451ED5AFBCE40A6D45310C7B4D033A82CFEEF195108B488FA4FB785E9E3D09EB44939A166F56B4F1E20A5CD67941BD941266E3ECBC10D8CE182C140E71424D77124987C638GFEECE0FC9A8ED13F08F7F80A514D359C37A99E0E5B376BB9EE37F8B8AE1FA33CECA86F55F93B896F00075EF95977067A35E2D66C7BD1641F
+	1D249D3321B567305E81CE1363772FEAB1AFA50BB714B98D6E30DDA81771967D6C073283E884C86E227B5FCB5AFC2F35F20DB91F6D227B22F37C4D886229B3F637E7384B3EEC7433152786927A590317974DD56718BFBC97730742EC2505626119A56469679BB58906155CA5747521F0C80368A234C882A29FB48C87A92E3EE8427A94987791209DC0BB01724E6936F87BB845EB822CF6850292BFA379FC4D4B494FF557727A5F9CFA16B1DFB32E0018E6F1FC4E9FD8C6CCE8CA04B0A94F3F0CF2D4C341A90DB6E5
+	7C8F17912F32B4C958D427B935DC27856761FE8A64819AB9CF6F4C1173582629FEADFFC5F5196347F36102EFC2D5E49903349A968B12EFA574B6D1436E67079B0C63E53139764173A090BDE7BE5D423F1316F66796F7F77338342EF6C58EG73BECE67B9D9196FE3D0E531E1EE8B0F9FD23AF9ECA8107BC89614F300723A793DFF61F79CEF19DF5AAC78FB936766767A174CC28F45593BBDB13CADCCBFEF26FB7DF1AB2E51874B1892388F1D17785895FF7118D071DB1779D80231112E32B1B798460E79505B9614
+	598E285B83A4DC48ADAE873281F9AEF0CC6E942A0464678395904125AA06F8CE772B2664385CE6DA9F175FB2115CA26049FFA3426EA4CF1950F7A81313D1C9477FF7CC25BA2FA76AD522A134B82A6B0335DC57A33017348BDC57BF323F39DA579D8A660C1936292EDDF5DC575997382E43F5A4BE6F85B981B9FA392E27E70C7AC099A70B613AFB59777F5E157A20EB8BF63DA5A43CB747ACC047E2C7832E8F6DA033172FEF3411FC0B07F2BED0D99FBFBF52D65DD356A35A6F8B9F335FBF5EF1BF9A9FEA4416ECFD
+	B4BEB4697CA542EFB270290E8BDB390EBDD0175147F319472D086B120B9097G3900C6009600B6DE64389EB5BB04F56E75FEA55287A0168D579CE6B70515704C00311E864A83927AC15EC0B6A09750C8BF1F67B173DA76C30197EFBF1F32A4371FBF322CEFBF1F37A4766B0FDAD67B754D1644FEBD43E2746BD42FBFDFF59F78E8F8A8297BF87D3A6E389F7B8DG31D32DBF9EC7BFA17C147EF89CE9F59CC79B20EEFFBF47510F8EA10E7C83F0E681ED844A845A8134FB006B372520EE8D7D8EAA8A49AEE0228174
+	EBD4B55B6379863E4717E0CC413BB2C6AB73A63BE36590DB2F724667907E09701B3C71B90471C61EC368063ACCAF778D0B683A58DA7E4070DE52FAAF3EDB2F546FFB77F48E2A1FD3566436D4EBCD1C7BE832A64EFD34DB574E351E33A67F5EFB513A7AFB6F0305495716D6383E1DBFD418584E7F2CF0351DEFA9CCEC67DFA9B45AB965FD1D0D2B6A89DF4A7FC6A11EEBB4FE3FA80645A0598B7B3DC0DD8CBB2F985E976B6EBD0EBEF3CF6720FBFF79D0F2DD7D6C507A3A7A4521443A32962D56556122443AAAADB2
+	6A0A5EAB2F10B82074D2EEF17DA5FE57FC12703A219C51F9479A797DB37592377DFFE844FC42D63D3C1714337572D4635D14AB4E33DAF71F382BF3445FBFE98CBD57003F913DAE29DAE8C214E9B055A12ADEC58ECD5CE03964B4A233EA203CCBBC177C7D86BC872694B534087EFBD5CF1E07FE1174F583D58D72BBEBD5E3659A6B1C9AB45ED9B3A3F8E76DD302FE4010DB15C401FE87BFF64618BB3C85FDB0AF30E5102F6F4B8D784D4518CBB5C40A76212EC1FFCF273BEF4C57B9B8505757619E9CF3778D3BFF6F
+	5367B5B5562D513FFBE030674301FEFF2291E87F2EC60C49BBA57C664BE3586716D644573198D65F9B0DDF3B4F705FB9E48DF23CDDBC03E7617E4198CE8AFC3177F2F83779D6E208E2BBC046F2C11D5F47717EDAB37226201C2A732EB4F39BC857F98FBA11379D4AB9BEAE571BE4BC994E6BE1D50CD09D9FEC625F9A76696DCEB623BF1C07B6BE6D06AC8D131F16B2CCF4B66B5FA620BD7D4EB1572C5F0B7DF007GEA829A81DA7073B1B7B9695DA724217B20E3BD6964F711F43D5D51E61E6F25658F75B2156F1F
+	B6736F9819FE1E6B7E7B6678DC77AB02B1D7EDF546673ACDAB6A4FB863F35DEE1331BE640C4FF5737E4C1E1C481B9465E86CFB7F26E6E30C378F56FA503FF6BE0B79B8323F128FF20BF18D14371D705E855EAB82472378BB0CFBD8CEE6B8945026A83FE261C80C5FAD212F05B27DAD7968E57475197FAED8012789D612CDE2F76F934B463C7A41CFCEA47D8ED1B4C477D1B1943B6B5138B2FD8C57B982FCED084711F9D75077A44BB37AE6C5D9868FB4638E87B06758F1C313E2F14723E3B8FE1437E1156C5C9FAB
+	E6B64E7B7C9FD0CB878820C4CB798C91GG0CAFGGD0CB818294G94G88G88GFBFBB0B620C4CB798C91GG0CAFGG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGGC691GGGG
+**end of data**/
+}
+}
Index: src/cbit/vcell/messaging/admin/ServerManageConsole.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServerManageConsole.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServerManageConsole.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,3125 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_STARTSERVICE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
+
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.FlowLayout;
+import java.awt.Font;
+import java.awt.GridLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.ItemEvent;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.sql.SQLException;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.Vector;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.ObjectMessage;
+import javax.swing.BorderFactory;
+import javax.swing.Box;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JMenuItem;
+import javax.swing.JPanel;
+import javax.swing.JPopupMenu;
+import javax.swing.JProgressBar;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.JTabbedPane;
+import javax.swing.JTable;
+import javax.swing.JTextArea;
+import javax.swing.JTextField;
+import javax.swing.ListSelectionModel;
+import javax.swing.SwingUtilities;
+import javax.swing.Timer;
+
+import org.vcell.util.BigString;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.UserCancelException;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+import org.vcell.util.gui.DateRenderer;
+import org.vcell.util.gui.DialogUtils;
+import org.vcell.util.gui.sorttable.JSortTable;
+
+import com.mongodb.BasicDBObject;
+import com.mongodb.DB;
+import com.mongodb.DBCollection;
+import com.mongodb.DBCursor;
+import com.mongodb.DBObject;
+import com.mongodb.Mongo;
+
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.vcell.messaging.ControlMessageCollector;
+import cbit.vcell.messaging.ControlTopicListener;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.JmsConnection;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsConnectionFactoryImpl;
+import cbit.vcell.messaging.JmsSession;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.messaging.db.SimulationJobTable;
+import cbit.vcell.messaging.server.RpcDbServerProxy;
+import cbit.vcell.messaging.server.RpcSimServerProxy;
+import cbit.vcell.modeldb.AdminDBTopLevel;
+import cbit.vcell.modeldb.DbDriver;
+import cbit.vcell.modeldb.UserTable;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.server.ServerInfo;
+import cbit.vcell.server.UserLoginInfo;
+import cbit.vcell.server.VCellBootstrap;
+import cbit.vcell.server.VCellServer;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.xml.XmlHelper;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/15/2003 4:19:19 PM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class ServerManageConsole extends JFrame implements ControlTopicListener {
+	private VCellBootstrap vcellBootstrap = null;
+	private VCellServer vcellServer = null;
+	private SessionLog log = null;
+	private List<SimpleUserConnection> userList = Collections.synchronizedList(new LinkedList<SimpleUserConnection>());
+	private List<ServiceStatus> serviceConfigList = Collections.synchronizedList(new LinkedList<ServiceStatus>());
+	private List<ServiceInstanceStatus> serviceInstanceStatusList = Collections.synchronizedList(new LinkedList<ServiceInstanceStatus>());
+	private JPanel ivjJFrameContentPane = null;
+	private IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private JmsConnection jmsConn = null;
+	private JmsSession topicSession = null;
+	private JmsConnectionFactory jmsConnFactory = null;
+	private JTabbedPane ivjTabbedPane = null;
+	private JPanel ivjServiceStatusPage = null;
+	private JPanel ivjConfigPage = null;
+	private JSortTable ivjConfigTable = null;
+	private JSortTable ivjServiceStatusTable = null;
+	private JButton ivjStartServiceButton = null;
+	private JButton ivjStopServiceButton = null;
+	private JPanel ivjQueryInputPanel = null;
+	private JSplitPane ivjJSplitPane1 = null;
+	private JPanel ivjQueryPage = null;
+	private JSortTable ivjQueryResultTable = null;
+	private JPanel ivjQueryStatusPanel = null;
+	private JCheckBox ivjQueryCompletedCheck = null;
+	private JCheckBox ivjQueryFailedCheck = null;
+	private JCheckBox ivjQueryRunningCheck = null;
+	private JCheckBox ivjQueryWaitingCheck = null;
+	private JTextField ivjQueryHostField = null;
+	private JTextField ivjQuerySimField = null;
+	private JTextField ivjQueryUserField = null;
+	private JCheckBox ivjQueryAllStatusCheck = null;
+	private JButton ivjQueryGoButton = null;
+	private JButton ivjQueryResetButton = null;
+	private AdminDBTopLevel adminDbTop = null;
+	private List<JCheckBox> statusChecks = new ArrayList<JCheckBox>();
+	private JCheckBox ivjQueryStartDateCheck = null;
+	private JCheckBox ivjQuerySubmitDateCheck = null;
+	private JLabel ivjNumResultsLabel = null;
+	private JLabel ivjNumConfigsLabel = null;
+	private JCheckBox ivjQueryEndDateCheck = null;
+	private DatePanel ivjQueryEndFromDate = null;
+	private DatePanel ivjQueryEndToDate = null;
+	private DatePanel ivjQueryStartFromDate = null;
+	private DatePanel ivjQuerySubmitToDate = null;
+	private DatePanel ivjQueryStartToDate = null;
+	private JPanel ivjQuerySubmitDatePanel = null;
+	private JPanel ivjQueryEndDatePanel = null;
+	private JPanel ivjQueryStartDatePanel = null;
+	private DatePanel ivjQuerySubmitFromDate = null;
+	private JLabel ivjNumServiceLabel = null;
+	private JCheckBox ivjQueryQueuedCheck = null;
+	private JCheckBox ivjQueryStoppedCheck = null;
+	private JCheckBox ivjQueryDispatchedCheck = null;
+	private HashMap<User, RpcDbServerProxy> dbProxyHash = null;
+	private HashMap<User, RpcSimServerProxy> simProxyHash = null;
+	private JButton ivjExitButton = null;
+	private JButton ivjRefreshButton = null;
+	private JButton ivjRemoveFromListButton = null;
+	private JButton ivjSubmitSelectedButton = null;
+	private JTextField ivjQueryServerIDField = null;
+	private JPanel ivjUserConnectionPage = null;
+	private org.vcell.util.gui.sorttable.JSortTable ivjUserConnectionTable = null;
+	private JLabel ivjNumUserConnectionLabel = null;
+	private JPanel ivjBroadcastPanel = null;
+	private JButton ivjMessageResetButton = null;
+	private JButton ivjSendMessageButton = null;
+	private JTextArea ivjBroadcastMessageTextArea = null;
+	private JTextField ivjBroadcastMessageToTextField = null;
+	private JButton ivjNewServiceButton = null;
+	private JButton ivjDeleteServiceButton = null;
+	private JButton ivjModifyServiceButton = null;
+	private JButton ivjRefreshServerManagerButton = null;
+	private JProgressBar ivjProgressBar = null;
+	private JLabel ivjNumSelectedLabel = null;
+	
+	private JButton ivjStopSelectedButton = null;
+	
+	private class IvjEventHandler implements java.awt.event.ActionListener, java.awt.event.ItemListener, java.awt.event.MouseListener, javax.swing.event.ChangeListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getStopServiceButton()) 
+					stopServiceButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getStartServiceButton()) 
+					startServiceButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryGoButton()) 
+					queryGoButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryResetButton()) 
+					queryResetButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getRefreshButton()) 
+					refreshButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getExitButton()) 
+					exitButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getRemoveFromListButton()) 
+					removeFromListButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getSubmitSelectedButton()) 
+					submitSelectedButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getSendMessageButton()) 
+					sendMessageButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getMessageResetButton()) 
+					messageResetButton_ActionEvents();
+				if (e.getSource() == getNewServiceButton()) {
+					newService();
+				}
+				if (e.getSource() == getDeleteServiceButton()) {
+					deleteService();
+				}
+				if (e.getSource() == getModifyServiceButton()) {
+					modifyService();
+				}
+				if (e.getSource() == getRefreshServerManagerButton()) {
+					refreshServerManager();
+				}
+				if (e.getSource() == ServerManageConsole.this.getStopSelectedButton()) { 
+					stopSelectedButton_ActionPerformed(e);
+				}
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};		
+		public void itemStateChanged(java.awt.event.ItemEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getQueryWaitingCheck())
+					queryWaitingCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryQueuedCheck()) 
+					queryQueuedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryFailedCheck()) 
+					queryFailedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryRunningCheck()) 
+					queryRunningCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryStoppedCheck()) 
+					queryStoppedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryCompletedCheck()) 
+					queryCompletedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryAllStatusCheck()) 
+					queryAllStatusCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQuerySubmitDateCheck()) 
+					querySubmitDateCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryStartDateCheck()) 
+					queryStartDateCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryEndDateCheck()) 
+					queryEndDateSubmit_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryDispatchedCheck()) 
+					queryDispatchedCheck_ItemStateChanged(e);
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};
+		public void mouseClicked(java.awt.event.MouseEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getServiceStatusTable()) 
+					serviceStatusTable_MouseClicked(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryResultTable()) 
+					queryResultTable_MouseClicked(e);
+				if (e.getSource() == ServerManageConsole.this.getConfigTable()) {
+					configTable_mouseClicked(e);
+				}
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};
+		public void mouseEntered(java.awt.event.MouseEvent e) {};
+		public void mouseExited(java.awt.event.MouseEvent e) {};
+		public void mousePressed(java.awt.event.MouseEvent e) {};
+		public void mouseReleased(java.awt.event.MouseEvent e) {};
+		public void stateChanged(javax.swing.event.ChangeEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getTabbedPane())
+					tabbedPane_ChangeEvents();
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};
+	};
+
+/**
+ * ServerManageConsole constructor comment.
+ */
+public ServerManageConsole() throws java.io.IOException, java.io.FileNotFoundException, org.jdom.JDOMException, javax.jms.JMSException {
+	super();
+	initialize();
+}
+
+void newService() {	
+	AddNewServiceDialog dialog = new AddNewServiceDialog(this);
+	dialog.setLocationRelativeTo(this);
+	dialog.setVisible(true);
+	
+	if (dialog.isAction()) {
+		ServiceSpec ss = dialog.getServiceSpec();
+		ServiceStatus config = new ServiceStatus(ss, null, ManageConstants.SERVICE_STATUS_NOTRUNNING, "newly created",	null);
+		try {
+			config = adminDbTop.insertServiceStatus(config, true);
+		} catch (Exception e) {
+			e.printStackTrace();
+			javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}
+		refresh();
+	}	
+}
+
+private void deleteService() {
+	int srow = getConfigTable().getSelectedRow();
+	ServiceStatus config = (ServiceStatus)((ServiceStatusTableModel)getConfigTable().getModel()).getValueAt(srow);
+	int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are going to delete " + config + ". Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+	if (n == javax.swing.JOptionPane.NO_OPTION) {
+		return;
+	}
+	
+	try {
+		adminDbTop.deleteServiceStatus(config, true);
+		stopService(config.getServiceSpec());
+	} catch (Exception e) {
+		e.printStackTrace();
+		javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+	refresh();
+}
+
+private void modifyService() {	
+	int srow = getConfigTable().getSelectedRow();
+	ServiceStatus oldConfig = (ServiceStatus)((ServiceStatusTableModel)getConfigTable().getModel()).getValueAt(srow);
+	ServiceSpec oldSpec = oldConfig.getServiceSpec();
+	
+	AddNewServiceDialog dialog = new AddNewServiceDialog(this);
+	dialog.modifyService(oldSpec);
+	dialog.setLocationRelativeTo(this);
+	dialog.setVisible(true);
+	
+	if (dialog.isAction()) {
+		ServiceSpec newSpec = dialog.getServiceSpec();
+		if (newSpec.getMemoryMB() == oldSpec.getMemoryMB() && newSpec.getStartupType() == oldSpec.getStartupType()) {
+			return;
+		}
+		ServiceStatus newConfig = new ServiceStatus(newSpec, null, ManageConstants.SERVICE_STATUS_NOTRUNNING, "newly modified",	null);
+		try {
+			newConfig = adminDbTop.modifyServiceStatus(oldConfig, newConfig, true);
+			stopService(newConfig.getServiceSpec());						
+		} catch (Exception e) {
+			e.printStackTrace();
+			javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}
+		refresh();
+	}
+	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (7/6/2004 1:36:54 PM)
+ */
+private void clearServiceStatusTab() {
+	getServiceStatusTable().clearSelection();
+	getStopServiceButton().setEnabled(false);
+	getStartServiceButton().setEnabled(false);
+}
+
+/**
+ * Comment
+ */
+public void exitButton_ActionPerformed(ActionEvent actionEvent) {
+	dispose();
+	System.exit(0);
+	return;
+}
+
+/**
+ * Return the BroadcastMessageTextArea property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getBroadcastMessageTextArea() {
+	if (ivjBroadcastMessageTextArea == null) {
+		try {
+			ivjBroadcastMessageTextArea = new javax.swing.JTextArea();
+			ivjBroadcastMessageTextArea.setName("BroadcastMessageTextArea");
+			ivjBroadcastMessageTextArea.setLineWrap(true);
+			ivjBroadcastMessageTextArea.setWrapStyleWord(true);
+			ivjBroadcastMessageTextArea.setText("");
+			ivjBroadcastMessageTextArea.setFont(new java.awt.Font("Arial", 1, 12));
+			ivjBroadcastMessageTextArea.setBounds(0, 0, 376, 68);
+			ivjBroadcastMessageTextArea.setMargin(new java.awt.Insets(5, 5, 5, 5));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjBroadcastMessageTextArea;
+}
+
+/**
+ * Return the BroadcastMessageToTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getBroadcastMessageToTextField() {
+	if (ivjBroadcastMessageToTextField == null) {
+		try {
+			ivjBroadcastMessageToTextField = new javax.swing.JTextField();
+			ivjBroadcastMessageToTextField.setName("BroadcastMessageToTextField");
+			ivjBroadcastMessageToTextField.setFont(new java.awt.Font("Arial", 1, 12));
+			ivjBroadcastMessageToTextField.setText("All");
+			ivjBroadcastMessageToTextField.setMargin(new java.awt.Insets(0, 10, 0, 0));
+			ivjBroadcastMessageToTextField.setColumns(59);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjBroadcastMessageToTextField;
+}
+
+/**
+ * Return the BroadcastPanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getBroadcastPanel() {
+	if (ivjBroadcastPanel == null) {
+		try {
+			ivjBroadcastPanel = new javax.swing.JPanel();
+			ivjBroadcastPanel.setName("BroadcastPanel");
+			ivjBroadcastPanel.setPreferredSize(new java.awt.Dimension(495, 500));
+			//ivjBroadcastPanel.setLayout(new java.awt.BorderLayout());
+			ivjBroadcastPanel.setLayout(new javax.swing.BoxLayout(ivjBroadcastPanel, javax.swing.BoxLayout.Y_AXIS));
+			
+			JPanel panel14 = new javax.swing.JPanel();
+			panel14.setPreferredSize(new java.awt.Dimension(610, 270));
+			panel14.setLayout(new java.awt.FlowLayout());			
+			JScrollPane scrollPane5 = new javax.swing.JScrollPane();
+			scrollPane5.setPreferredSize(new java.awt.Dimension(700, 250));
+			scrollPane5.setViewportView(getBroadcastMessageTextArea());			
+			panel14.add(scrollPane5);			
+			getBroadcastPanel().add(panel14);
+			
+			JPanel panel13 = new javax.swing.JPanel();
+			panel13.setLayout(new java.awt.BorderLayout());
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new java.awt.FlowLayout());
+			panel.add(getSendMessageButton(), getSendMessageButton().getName());
+			panel.add(getMessageResetButton(), getMessageResetButton().getName());			
+			panel13.add(panel, "Center");			
+			
+			panel = new javax.swing.JPanel();
+			panel.setLayout(new java.awt.FlowLayout());			
+			panel.add(new javax.swing.JLabel("To:      "));
+			panel.add(getBroadcastMessageToTextField(), getBroadcastMessageToTextField().getName());			
+			panel13.add(panel, "North");			
+			getBroadcastPanel().add(panel13);
+			
+			
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjBroadcastPanel;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:44:01 PM)
+ * @return cbit.vcell.messaging.server.RpcDbServerProxy
+ */
+private RpcDbServerProxy getDbProxy(User user) throws JMSException, DataAccessException, java.rmi.RemoteException {
+	if (dbProxyHash == null) {
+		dbProxyHash = new HashMap<User, RpcDbServerProxy>();
+	}
+
+	RpcDbServerProxy dbProxy = (RpcDbServerProxy)dbProxyHash.get(user);
+
+	if (dbProxy == null) {
+		JmsClientMessaging jmsClientMessaging = new JmsClientMessaging(jmsConn, log, null);		
+		dbProxy = new RpcDbServerProxy(user, jmsClientMessaging, log);
+		dbProxyHash.put(user, dbProxy);
+	}
+	
+	return dbProxy;
+}
+
+
+/**
+ * Return the ExitButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getExitButton() {
+	if (ivjExitButton == null) {
+		try {
+			ivjExitButton = new javax.swing.JButton();
+			ivjExitButton.setText("Exit");
+			ivjExitButton.setForeground(java.awt.Color.red);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjExitButton;
+}
+
+/**
+ * Return the JFrameContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJFrameContentPane() {
+	if (ivjJFrameContentPane == null) {
+		try {
+			ivjJFrameContentPane = new javax.swing.JPanel();
+			ivjJFrameContentPane.setName("JFrameContentPane");
+			ivjJFrameContentPane.setLayout(new java.awt.BorderLayout());
+			getJFrameContentPane().add(getTabbedPane(), "Center");
+			
+			JPanel panel = new javax.swing.JPanel();			
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));
+			panel.add(getExitButton());
+			panel.add(getRefreshButton(), getRefreshButton().getName());
+			
+			final JLabel timeLabel = new JLabel("      ");
+			timeLabel.setFont(new Font(timeLabel.getFont().getName(), Font.BOLD, timeLabel.getFont().getSize()));
+			Box box = Box.createHorizontalBox();
+			box.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createLoweredBevelBorder()));
+			box.add(panel);
+			box.add(Box.createHorizontalGlue());	
+			box.add(timeLabel);
+			box.add(Box.createHorizontalGlue());
+			box.add(getProgressBar());
+			final DateFormat df =  new SimpleDateFormat("HH:mm:ss    EEEE    MMM dd, yyyy");
+	        new Timer(1000,new ActionListener()
+	        {
+	            public void actionPerformed(ActionEvent e)
+	            {
+	                timeLabel.setText(df.format(new Date()));
+	            }
+	        }).start();			
+			
+			getJFrameContentPane().add(box, "North");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJFrameContentPane;
+}
+
+private JProgressBar getProgressBar() {
+	if (ivjProgressBar == null) {
+		ivjProgressBar = new JProgressBar();
+	}
+	return ivjProgressBar;
+}
+/**
+ * Return the JPanel3 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryInputPanel() {
+	if (ivjQueryInputPanel == null) {
+		try {
+			ivjQueryInputPanel = new javax.swing.JPanel();
+			ivjQueryInputPanel.setName("JPanel3");
+			ivjQueryInputPanel.setLayout(new javax.swing.BoxLayout(ivjQueryInputPanel, javax.swing.BoxLayout.Y_AXIS));
+			ivjQueryInputPanel.setBounds(0, 0, 160, 120);
+			
+			JPanel panel4 = new javax.swing.JPanel();
+			panel4.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label3 = new javax.swing.JLabel("Simulation ID");
+			label3.setMaximumSize(new java.awt.Dimension(70, 14));
+			label3.setPreferredSize(new java.awt.Dimension(70, 14));
+			label3.setMinimumSize(new java.awt.Dimension(70, 14));
+			label3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);			
+			panel4.add(label3);
+			panel4.add(getQuerySimField(), getQuerySimField().getName());			
+			ivjQueryInputPanel.add(panel4);
+			
+			
+			JPanel panel9 = new javax.swing.JPanel();
+			panel9.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new javax.swing.JLabel("Compute Host");
+			label.setMaximumSize(new java.awt.Dimension(70, 14));
+			label.setPreferredSize(new java.awt.Dimension(70, 14));
+			label.setMinimumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);			
+			panel9.add(label);
+			panel9.add(getQueryHostField(), getQueryHostField().getName());			
+			ivjQueryInputPanel.add(panel9);
+			
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));
+			
+			label = new javax.swing.JLabel("Server ID");
+			label.setMaximumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
+			label.setPreferredSize(new java.awt.Dimension(70, 14));
+			label.setMinimumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			
+			panel.add(label);
+			panel.add(getQueryServerIDField(), getQueryServerIDField().getName());
+			
+			ivjQueryInputPanel.add(panel);
+			
+			panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			label = new javax.swing.JLabel("User ID");
+			label.setMaximumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
+			label.setPreferredSize(new java.awt.Dimension(70, 14));
+			label.setMinimumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);			
+			panel.add(label);
+			panel.add(getQueryUserField(), getQueryUserField().getName());			
+			ivjQueryInputPanel.add(panel);
+			
+			ivjQueryInputPanel.add(getQueryStatusPanel(), getQueryStatusPanel().getName());
+			ivjQueryInputPanel.add(getQuerySubmitDatePanel(), getQuerySubmitDatePanel().getName());
+			ivjQueryInputPanel.add(getQueryStartDatePanel(), getQueryStartDatePanel().getName());
+			ivjQueryInputPanel.add(getQueryEndDatePanel(), getQueryEndDatePanel().getName());
+			
+			JPanel panel15 = new javax.swing.JPanel();
+			panel15.setLayout(new java.awt.FlowLayout());
+			panel15.add(getQueryGoButton(), getQueryGoButton().getName());
+			panel15.add(getQueryResetButton(), getQueryResetButton().getName());		
+			ivjQueryInputPanel.add(panel15);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryInputPanel;
+}
+
+/**
+ * Return the JSplitPane1 property value.
+ * @return javax.swing.JSplitPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JSplitPane getJSplitPane1() {
+	if (ivjJSplitPane1 == null) {
+		try {
+			ivjJSplitPane1 = new javax.swing.JSplitPane(javax.swing.JSplitPane.HORIZONTAL_SPLIT);
+			ivjJSplitPane1.setName("JSplitPane1");
+			ivjJSplitPane1.setDividerSize(2);
+			ivjJSplitPane1.setLastDividerLocation(1);
+			ivjJSplitPane1.setComponentOrientation(java.awt.ComponentOrientation.UNKNOWN);
+			ivjJSplitPane1.setDividerLocation(220);
+
+			JScrollPane scrollPane3 = new javax.swing.JScrollPane();
+			scrollPane3.setViewportView(getQueryInputPanel());			
+			getJSplitPane1().add(scrollPane3, "left");
+						
+			JPanel panel7 = new javax.swing.JPanel();
+			panel7.setLayout(new java.awt.BorderLayout());			
+			JPanel panel8 = new javax.swing.JPanel();
+			panel8.setLayout(new java.awt.BorderLayout());
+			JPanel textPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
+			textPanel.add(getNumResultsLabel());
+			textPanel.add(new JLabel(" returned    "));
+			textPanel.add(getNumSelectedLabel());
+			textPanel.add(new JLabel(" selected "));
+			panel8.add(textPanel, "West");
+			JPanel panel = new JPanel();
+			panel.add(getStopSelectedButton());
+			panel.add(getSubmitSelectedButton());
+			panel.add(getRemoveFromListButton());
+			panel8.add(panel, "East");			
+			panel7.add(panel8, "North");			
+			panel7.add(getQueryResultTable().getEnclosingScrollPane(), "Center");			
+			getJSplitPane1().add(panel7, "right");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJSplitPane1;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/5/2006 10:07:25 AM)
+ * @return java.lang.String
+ */
+private String getLocalVCellBootstrapUrl() {
+	String rmiHost = "ms3.vcell.uchc.edu";
+	int rmiPort = PropertyLoader.getIntProperty(PropertyLoader.rmiPortRegistry, 1099);
+	return "//" + rmiHost + ":" + rmiPort + "/VCellBootstrapServer";
+}
+
+
+/**
+ * Return the MessageResetButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getMessageResetButton() {
+	if (ivjMessageResetButton == null) {
+		try {
+			ivjMessageResetButton = new javax.swing.JButton();
+			ivjMessageResetButton.setName("MessageResetButton");
+			ivjMessageResetButton.setText("Reset");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjMessageResetButton;
+}
+
+
+/**
+ * Return the NumResultsLabel property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumResultsLabel() {
+	if (ivjNumResultsLabel == null) {
+		try {
+			ivjNumResultsLabel = new javax.swing.JLabel();
+			ivjNumResultsLabel.setText("0");
+			ivjNumResultsLabel.setForeground(java.awt.Color.red);
+			ivjNumResultsLabel.setFont(new Font(ivjNumResultsLabel.getFont().getName(), Font.BOLD, ivjNumResultsLabel.getFont().getSize()));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumResultsLabel;
+}
+
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumSelectedLabel() {
+	if (ivjNumSelectedLabel == null) {
+		try {
+			ivjNumSelectedLabel = new javax.swing.JLabel();
+			ivjNumSelectedLabel.setText("0");
+			ivjNumSelectedLabel.setForeground(java.awt.Color.blue);
+			ivjNumSelectedLabel.setFont(new Font(ivjNumSelectedLabel.getFont().getName(), Font.BOLD, ivjNumSelectedLabel.getFont().getSize()));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumSelectedLabel;
+}
+
+/**
+ * Return the NumServiceLabel property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumServiceLabel() {
+	if (ivjNumServiceLabel == null) {
+		try {
+			ivjNumServiceLabel = new javax.swing.JLabel();
+			ivjNumServiceLabel.setName("NumServiceLabel");
+			ivjNumServiceLabel.setPreferredSize(new java.awt.Dimension(100, 14));
+			ivjNumServiceLabel.setText("0");
+			ivjNumServiceLabel.setMaximumSize(new java.awt.Dimension(100, 14));
+			ivjNumServiceLabel.setForeground(java.awt.Color.red);
+			ivjNumServiceLabel.setMinimumSize(new java.awt.Dimension(100, 14));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumServiceLabel;
+}
+
+/**
+ * Return the TotalUserConnectionLabel property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumUserConnectionLabel() {
+	if (ivjNumUserConnectionLabel == null) {
+		try {
+			ivjNumUserConnectionLabel = new javax.swing.JLabel();
+			ivjNumUserConnectionLabel.setName("NumUserConnectionLabel");
+			ivjNumUserConnectionLabel.setText("0");
+			ivjNumUserConnectionLabel.setForeground(java.awt.Color.red);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumUserConnectionLabel;
+}
+
+/**
+ * Return the QueryAllCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryAllStatusCheck() {
+	if (ivjQueryAllStatusCheck == null) {
+		try {
+			ivjQueryAllStatusCheck = new javax.swing.JCheckBox();
+			ivjQueryAllStatusCheck.setName("QueryAllStatusCheck");
+			ivjQueryAllStatusCheck.setSelected(true);
+			ivjQueryAllStatusCheck.setFont(new java.awt.Font("Arial", 1, 12));
+			ivjQueryAllStatusCheck.setText("All");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryAllStatusCheck;
+}
+
+/**
+ * Return the JCheckBox7 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryCompletedCheck() {
+	if (ivjQueryCompletedCheck == null) {
+		try {
+			ivjQueryCompletedCheck = new javax.swing.JCheckBox();
+			ivjQueryCompletedCheck.setName("QueryCompletedCheck");
+			ivjQueryCompletedCheck.setSelected(true);
+			ivjQueryCompletedCheck.setText("Completed");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryCompletedCheck;
+}
+
+/**
+ * Return the QueryDispatchedCheckBox property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryDispatchedCheck() {
+	if (ivjQueryDispatchedCheck == null) {
+		try {
+			ivjQueryDispatchedCheck = new javax.swing.JCheckBox();
+			ivjQueryDispatchedCheck.setName("QueryDispatchedCheck");
+			ivjQueryDispatchedCheck.setSelected(true);
+			ivjQueryDispatchedCheck.setText("Dispatched");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryDispatchedCheck;
+}
+
+/**
+ * Return the QueryEndDateCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryEndDateCheck() {
+	if (ivjQueryEndDateCheck == null) {
+		try {
+			ivjQueryEndDateCheck = new javax.swing.JCheckBox();
+			ivjQueryEndDateCheck.setName("QueryEndDateCheck");
+			ivjQueryEndDateCheck.setText("End Between");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndDateCheck;
+}
+
+/**
+ * Return the QueryEndDatePanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryEndDatePanel() {
+	if (ivjQueryEndDatePanel == null) {
+		try {
+			ivjQueryEndDatePanel = new javax.swing.JPanel();
+			ivjQueryEndDatePanel.setName("QueryEndDatePanel");
+			ivjQueryEndDatePanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder()));
+			ivjQueryEndDatePanel.setLayout(new GridLayout(3, 0));
+			getQueryEndDatePanel().add(getQueryEndDateCheck(), getQueryEndDateCheck().getName());
+			getQueryEndDatePanel().add(getQueryEndFromDate(), getQueryEndFromDate().getName());
+			getQueryEndDatePanel().add(getQueryEndToDate(), getQueryEndToDate().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndDatePanel;
+}
+
+/**
+ * Return the DatePanel3 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryEndFromDate() {
+	if (ivjQueryEndFromDate == null) {
+		try {
+			ivjQueryEndFromDate = new DatePanel();
+			ivjQueryEndFromDate.setName("QueryEndFromDate");
+			ivjQueryEndFromDate.setLayout(new FlowLayout());
+			ivjQueryEndFromDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndFromDate;
+}
+
+/**
+ * Return the QueryEndToDate property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryEndToDate() {
+	if (ivjQueryEndToDate == null) {
+		try {
+			ivjQueryEndToDate = new DatePanel();
+			ivjQueryEndToDate.setName("QueryEndToDate");
+			ivjQueryEndToDate.setLayout(new FlowLayout());
+			ivjQueryEndToDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndToDate;
+}
+
+/**
+ * Return the JCheckBox4 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryFailedCheck() {
+	if (ivjQueryFailedCheck == null) {
+		try {
+			ivjQueryFailedCheck = new javax.swing.JCheckBox();
+			ivjQueryFailedCheck.setName("QueryFailedCheck");
+			ivjQueryFailedCheck.setSelected(true);
+			ivjQueryFailedCheck.setText("Failed");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryFailedCheck;
+}
+
+/**
+ * Return the JButton1 property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getQueryGoButton() {
+	if (ivjQueryGoButton == null) {
+		try {
+			ivjQueryGoButton = new javax.swing.JButton();
+			ivjQueryGoButton.setName("QueryGoButton");
+			ivjQueryGoButton.setText("Go!");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryGoButton;
+}
+
+/**
+ * Return the JTextField2 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQueryHostField() {
+	if (ivjQueryHostField == null) {
+		try {
+			ivjQueryHostField = new javax.swing.JTextField();
+			ivjQueryHostField.setName("QueryHostField");
+			ivjQueryHostField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryHostField;
+}
+
+/**
+ * Return the QueryPage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryPage() {
+	if (ivjQueryPage == null) {
+		try {
+			ivjQueryPage = new javax.swing.JPanel();
+			ivjQueryPage.setName("QueryPage");
+			ivjQueryPage.setLayout(new java.awt.BorderLayout());
+			getQueryPage().add(getJSplitPane1(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryPage;
+}
+
+
+/**
+ * Return the JCheckBox2 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryQueuedCheck() {
+	if (ivjQueryQueuedCheck == null) {
+		try {
+			ivjQueryQueuedCheck = new javax.swing.JCheckBox();
+			ivjQueryQueuedCheck.setName("QueryQueuedCheck");
+			ivjQueryQueuedCheck.setSelected(true);
+			ivjQueryQueuedCheck.setText("Queued");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryQueuedCheck;
+}
+
+/**
+ * Return the JButton2 property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getQueryResetButton() {
+	if (ivjQueryResetButton == null) {
+		try {
+			ivjQueryResetButton = new javax.swing.JButton();
+			ivjQueryResetButton.setName("QueryResetButton");
+			ivjQueryResetButton.setText("Reset");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryResetButton;
+}
+
+/**
+ * Return the QueryResultTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private JSortTable getQueryResultTable() {
+	if (ivjQueryResultTable == null) {
+		try {
+			ivjQueryResultTable = new JSortTable();
+			ivjQueryResultTable.setName("QueryResultTable");
+			ivjQueryResultTable.setModel(new JobTableModel());
+			ivjQueryResultTable.disableUneditableForeground();
+			
+			final JPopupMenu popup = new JPopupMenu();
+			JMenuItem viewMongoMenuItem = new JMenuItem("View Mongo Log Info...");
+		    popup.add(viewMongoMenuItem);
+
+		    viewMongoMenuItem.addActionListener(new ActionListener() {
+				public void actionPerformed(ActionEvent e) {
+					try {
+						Number simID = (Number)ivjQueryResultTable.getModel().getValueAt(ivjQueryResultTable.getSelectedRow(), JobTableModel.columnIndex_SimID);
+						String userid = (String)ivjQueryResultTable.getModel().getValueAt(ivjQueryResultTable.getSelectedRow(), JobTableModel.columnIndex_UserID);
+						System.out.println("----- user="+userid+" simID="+simID);
+						String mongoDbHost = PropertyLoader.getRequiredProperty(PropertyLoader.mongodbHost);
+						int mongoDbPort = Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.mongodbPort)); // default 27017
+						Mongo m = new Mongo(mongoDbHost,mongoDbPort);
+						String mongoDbDatabaseName = PropertyLoader.getRequiredProperty(PropertyLoader.mongodbDatabase);
+						DB db = m.getDB(mongoDbDatabaseName);
+						String mongoDbLoggingCollectionName = PropertyLoader.getRequiredProperty(PropertyLoader.mongodbLoggingCollection);
+						DBCollection dbCollection = db.getCollection(mongoDbLoggingCollectionName);
+
+						BasicDBObject query = new BasicDBObject();
+
+						query.put(VCMongoMessage.MongoMessage_simId, simID.intValue()+"");
+
+						DBCursor cur = dbCollection.find(query);
+						TreeMap<String, Integer> mapKeyToColumnIndex = new TreeMap<String, Integer>();
+						Vector<DBObject> dbObjV = new Vector<DBObject>();
+						while(cur.hasNext()) {
+							DBObject dbObject = cur.next();
+							dbObjV.add(dbObject);
+						    Set<String> keys = dbObject.keySet();
+						    Iterator<String> iter = keys.iterator();
+						    while(iter.hasNext()){
+						    	String key = iter.next();
+						    	Integer columnIndex = mapKeyToColumnIndex.get(key);
+						    	if(columnIndex == null){
+						    		columnIndex = mapKeyToColumnIndex.size();
+						    		mapKeyToColumnIndex.put(key, columnIndex);
+						    	}
+						    }
+						}
+						int msgTimeColumnIndex = -1;
+						if(mapKeyToColumnIndex.size()>0){
+							String[] columnNames = new String[mapKeyToColumnIndex.size()];
+							Iterator<String> keyIter = mapKeyToColumnIndex.keySet().iterator();
+							while(keyIter.hasNext()){
+								String key = keyIter.next();
+								int columnIndex = mapKeyToColumnIndex.get(key);
+								columnNames[columnIndex] = key;
+								if(key.equals(VCMongoMessage.MongoMessage_msgTime)){
+									msgTimeColumnIndex = columnIndex;
+								}
+							}
+//							//Ask which columns to view
+//							Object[][] colrowdata = new Object[columnNames.length][1];
+//							for (int i = 0; i < colrowdata.length; i++) {
+//								colrowdata[i][0] = columnNames[i];
+//							}
+//							int[] showcolArr =
+//									DialogUtils.showComponentOKCancelTableList(ServerManageConsole.this, "Select Columns to View...", new String[] {"Column Names"}, colrowdata, ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
+							
+							Object[][] rowData = new Object[dbObjV.size()][columnNames.length];
+							for (int i = 0; i < rowData.length; i++) {
+								DBObject dbObj = dbObjV.get(i);
+								Set<String> keys = dbObj.keySet();
+							    Iterator<String> iter = keys.iterator();
+							    while(iter.hasNext()){
+							    	String key = iter.next();
+							    	rowData[i][mapKeyToColumnIndex.get(key)] = dbObj.get(key);
+							    }
+							}
+							//sort by msgtime
+							final int msgTimeColumnIndexFinal = msgTimeColumnIndex;
+							if(msgTimeColumnIndex != -1){
+								Arrays.sort(rowData, new Comparator<Object[]>() {
+									public int compare(Object[] o1, Object[] o2) {
+										Long o1Long = (Long)o1[msgTimeColumnIndexFinal];
+										Long o2Long = (Long)o2[msgTimeColumnIndexFinal];
+										int result = (int)(o2Long-o1Long);
+										return result;
+									}
+								});
+							}
+							DialogUtils.showComponentOptionsTableList(ServerManageConsole.this, "Mongo Log Info ("+rowData.length+") "+userid+" "+simID, columnNames, rowData, ListSelectionModel.SINGLE_SELECTION,null,null,null,null,false);
+						}else{
+							DialogUtils.showWarningDialog(ServerManageConsole.this, "No Mongo Log Info found for simID="+simID.intValue());
+						}
+					}  catch (UserCancelException uce) {
+						//ignore
+					}catch (Exception e1) {
+						e1.printStackTrace();
+					}
+
+				}
+			});
+
+			ivjQueryResultTable.addMouseListener( new MouseAdapter() {
+			    public void mouseReleased(MouseEvent e) 
+			    { 
+			        if (e.isPopupTrigger()) 
+			        { 
+			            JTable source = (JTable)e.getSource(); 
+			            int row = source.rowAtPoint( e.getPoint() ); 
+			            int column = source.columnAtPoint( e.getPoint() ); 
+			 
+			            if (! source.isRowSelected(row)) 
+			                source.changeSelection(row, column, false, false); 
+			 
+			            popup.show(e.getComponent(), e.getX(), e.getY()); 
+			        } 
+			    } 
+			}); 
+
+
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryResultTable;
+}
+
+
+/**
+ * Return the JCheckBox1 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryRunningCheck() {
+	if (ivjQueryRunningCheck == null) {
+		try {
+			ivjQueryRunningCheck = new javax.swing.JCheckBox();
+			ivjQueryRunningCheck.setName("QueryRunningCheck");
+			ivjQueryRunningCheck.setSelected(true);
+			ivjQueryRunningCheck.setText("Running");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryRunningCheck;
+}
+
+/**
+ * Return the QueryServerIDField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQueryServerIDField() {
+	if (ivjQueryServerIDField == null) {
+		try {
+			ivjQueryServerIDField = new javax.swing.JTextField();
+			ivjQueryServerIDField.setName("QueryServerIDField");
+			ivjQueryServerIDField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryServerIDField;
+}
+
+
+/**
+ * Return the JTextField1 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQuerySimField() {
+	if (ivjQuerySimField == null) {
+		try {
+			ivjQuerySimField = new javax.swing.JTextField();
+			ivjQuerySimField.setName("QuerySimField");
+			ivjQuerySimField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySimField;
+}
+
+/**
+ * Return the QueryStartDateCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryStartDateCheck() {
+	if (ivjQueryStartDateCheck == null) {
+		try {
+			ivjQueryStartDateCheck = new javax.swing.JCheckBox();
+			ivjQueryStartDateCheck.setName("QueryStartDateCheck");
+			ivjQueryStartDateCheck.setText("Start Between");
+			ivjQueryStartDateCheck.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartDateCheck;
+}
+
+/**
+ * Return the QueryStartDatePanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryStartDatePanel() {
+	if (ivjQueryStartDatePanel == null) {
+		try {
+			ivjQueryStartDatePanel = new javax.swing.JPanel();
+			ivjQueryStartDatePanel.setName("QueryStartDatePanel");
+			ivjQueryStartDatePanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder()));
+			ivjQueryStartDatePanel.setLayout(new java.awt.GridLayout(3, 0));
+			getQueryStartDatePanel().add(getQueryStartDateCheck(), getQueryStartDateCheck().getName());
+			getQueryStartDatePanel().add(getQueryStartFromDate(), getQueryStartFromDate().getName());
+			getQueryStartDatePanel().add(getQueryStartToDate(), getQueryStartToDate().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartDatePanel;
+}
+
+/**
+ * Return the DatePanel2 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryStartFromDate() {
+	if (ivjQueryStartFromDate == null) {
+		try {
+			ivjQueryStartFromDate = new DatePanel();
+			ivjQueryStartFromDate.setName("QueryStartFromDate");
+			ivjQueryStartFromDate.setLayout(new FlowLayout());
+			ivjQueryStartFromDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartFromDate;
+}
+
+/**
+ * Return the DatePanel1 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryStartToDate() {
+	if (ivjQueryStartToDate == null) {
+		try {
+			ivjQueryStartToDate = new DatePanel();
+			ivjQueryStartToDate.setName("QueryStartToDate");
+			ivjQueryStartToDate.setLayout(new FlowLayout());
+			ivjQueryStartToDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartToDate;
+}
+
+/**
+ * Return the QueryStatusPanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryStatusPanel() {
+	if (ivjQueryStatusPanel == null) {
+		try {
+			ivjQueryStatusPanel = new javax.swing.JPanel();
+			ivjQueryStatusPanel.setName("QueryStatusPanel");
+			ivjQueryStatusPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), "Status"));
+			ivjQueryStatusPanel.setLayout(new java.awt.GridLayout(0, 2));
+			getQueryStatusPanel().add(getQueryWaitingCheck(), getQueryWaitingCheck().getName());
+			getQueryStatusPanel().add(getQueryQueuedCheck(), getQueryQueuedCheck().getName());
+			getQueryStatusPanel().add(getQueryDispatchedCheck(), getQueryDispatchedCheck().getName());
+			getQueryStatusPanel().add(getQueryRunningCheck(), getQueryRunningCheck().getName());
+			getQueryStatusPanel().add(getQueryCompletedCheck(), getQueryCompletedCheck().getName());
+			getQueryStatusPanel().add(getQueryFailedCheck(), getQueryFailedCheck().getName());
+			getQueryStatusPanel().add(getQueryStoppedCheck(), getQueryStoppedCheck().getName());
+			getQueryStatusPanel().add(getQueryAllStatusCheck(), getQueryAllStatusCheck().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStatusPanel;
+}
+
+/**
+ * Return the JCheckBox6 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryStoppedCheck() {
+	if (ivjQueryStoppedCheck == null) {
+		try {
+			ivjQueryStoppedCheck = new javax.swing.JCheckBox();
+			ivjQueryStoppedCheck.setName("QueryStoppedCheck");
+			ivjQueryStoppedCheck.setSelected(true);
+			ivjQueryStoppedCheck.setText("Stopped");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStoppedCheck;
+}
+
+/**
+ * Return the QuerySubmitDateCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQuerySubmitDateCheck() {
+	if (ivjQuerySubmitDateCheck == null) {
+		try {
+			ivjQuerySubmitDateCheck = new javax.swing.JCheckBox();
+			ivjQuerySubmitDateCheck.setName("QuerySubmitDateCheck");
+			ivjQuerySubmitDateCheck.setSelected(true);
+			ivjQuerySubmitDateCheck.setText("Submit Between");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitDateCheck;
+}
+
+/**
+ * Return the QuerySubmitDatePanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQuerySubmitDatePanel() {
+	if (ivjQuerySubmitDatePanel == null) {
+		try {
+			ivjQuerySubmitDatePanel = new javax.swing.JPanel();
+			ivjQuerySubmitDatePanel.setName("QuerySubmitDatePanel");
+			ivjQuerySubmitDatePanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder()));
+			ivjQuerySubmitDatePanel.setLayout(new java.awt.GridLayout(3, 0));
+			getQuerySubmitDatePanel().add(getQuerySubmitDateCheck(), getQuerySubmitDateCheck().getName());
+			getQuerySubmitDatePanel().add(getQuerySubmitFromDate(), getQuerySubmitFromDate().getName());
+			getQuerySubmitDatePanel().add(getQuerySubmitToDate(), getQuerySubmitToDate().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitDatePanel;
+}
+
+/**
+ * Return the DatePanel1 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQuerySubmitFromDate() {
+	if (ivjQuerySubmitFromDate == null) {
+		try {
+			ivjQuerySubmitFromDate = new DatePanel();
+			ivjQuerySubmitFromDate.setName("QuerySubmitFromDate");
+			ivjQuerySubmitFromDate.setLayout(new FlowLayout());
+			ivjQuerySubmitFromDate.setEnabled(true);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitFromDate;
+}
+
+/**
+ * Return the QuerySubmitToDate property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQuerySubmitToDate() {
+	if (ivjQuerySubmitToDate == null) {
+		try {
+			ivjQuerySubmitToDate = new DatePanel();
+			ivjQuerySubmitToDate.setName("QuerySubmitToDate");
+			ivjQuerySubmitToDate.setLayout(new FlowLayout());
+			ivjQuerySubmitToDate.setEnabled(true);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitToDate;
+}
+
+/**
+ * Return the JTextField3 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQueryUserField() {
+	if (ivjQueryUserField == null) {
+		try {
+			ivjQueryUserField = new javax.swing.JTextField();
+			ivjQueryUserField.setName("QueryUserField");
+			ivjQueryUserField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryUserField;
+}
+
+/**
+ * Return the JCheckBox3 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryWaitingCheck() {
+	if (ivjQueryWaitingCheck == null) {
+		try {
+			ivjQueryWaitingCheck = new javax.swing.JCheckBox();
+			ivjQueryWaitingCheck.setName("QueryWaitingCheck");
+			ivjQueryWaitingCheck.setSelected(true);
+			ivjQueryWaitingCheck.setText("Waiting");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryWaitingCheck;
+}
+
+/**
+ * Return the RefreshButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getRefreshButton() {
+	if (ivjRefreshButton == null) {
+		try {
+			ivjRefreshButton = new javax.swing.JButton();
+			ivjRefreshButton.setName("RefreshButton");
+			ivjRefreshButton.setText("Refresh");
+			ivjRefreshButton.setForeground(java.awt.Color.blue);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjRefreshButton;
+}
+
+/**
+ * Return the RemoveFromListButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getRemoveFromListButton() {
+	if (ivjRemoveFromListButton == null) {
+		try {
+			ivjRemoveFromListButton = new javax.swing.JButton();
+			ivjRemoveFromListButton.setName("RemoveFromListButton");
+			ivjRemoveFromListButton.setText("Remove From List");
+			ivjRemoveFromListButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjRemoveFromListButton;
+}
+
+
+/**
+ * Return the RemoveFromListButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getSubmitSelectedButton() {
+	if (ivjSubmitSelectedButton == null) {
+		try {
+			ivjSubmitSelectedButton = new javax.swing.JButton();
+			ivjSubmitSelectedButton.setName("SubmitSelected");
+			ivjSubmitSelectedButton.setText("Submit selected jobs");
+			ivjSubmitSelectedButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSubmitSelectedButton;
+}
+
+private javax.swing.JButton getStopSelectedButton() {
+	if (ivjStopSelectedButton == null) {
+		try {
+			ivjStopSelectedButton = new javax.swing.JButton();
+			ivjStopSelectedButton.setText("Stop selected jobs");
+			ivjStopSelectedButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStopSelectedButton;
+}
+
+/**
+ * Return the SendMessageButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getSendMessageButton() {
+	if (ivjSendMessageButton == null) {
+		try {
+			ivjSendMessageButton = new javax.swing.JButton();
+			ivjSendMessageButton.setName("SendMessageButton");
+			ivjSendMessageButton.setText("Send");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSendMessageButton;
+}
+
+/**
+ * Return the ServicePage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getServiceStatusPage() {
+	if (ivjServiceStatusPage == null) {
+		try {
+			ivjServiceStatusPage = new javax.swing.JPanel();
+			ivjServiceStatusPage.setName("ServiceStatusPage");
+			ivjServiceStatusPage.setLayout(new java.awt.BorderLayout());
+			
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new javax.swing.JLabel("Total Services:");
+			label.setForeground(java.awt.Color.red);			
+			panel.add(label);
+			panel.add(getNumServiceLabel());
+			ivjServiceStatusPage.add(panel, "North");
+			
+			ivjServiceStatusPage.add(getServiceStatusTable().getEnclosingScrollPane(), "Center");
+			
+			JPanel panel6 = new javax.swing.JPanel();
+			panel6.setLayout(new java.awt.FlowLayout());
+			panel6.add(getStartServiceButton(), getStartServiceButton().getName());
+			panel6.add(getStopServiceButton(), getStopServiceButton().getName());	
+	
+			ivjServiceStatusPage.add(panel6, "South");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjServiceStatusPage;
+}
+
+/**
+ * Return the ServiceStatusTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+private JSortTable getConfigTable() {
+	if (ivjConfigTable == null) {
+		try {
+			ivjConfigTable = new JSortTable();
+			ivjConfigTable.setModel(new ServiceStatusTableModel());
+			ivjConfigTable.disableUneditableForeground();
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjConfigTable;
+}
+
+/**
+ * Return the ServiceStatusTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private JSortTable getServiceStatusTable() {
+	if (ivjServiceStatusTable == null) {
+		try {
+			ivjServiceStatusTable = new JSortTable();
+			ivjServiceStatusTable.setModel(new ServiceInstanceStatusTableModel());
+			ivjServiceStatusTable.disableUneditableForeground();
+			//ivjServiceStatusTable.setBounds(0, 0, 200, 200);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjServiceStatusTable;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:44:01 PM)
+ * @return cbit.vcell.messaging.server.RpcsimServerProxy
+ */
+private RpcSimServerProxy getSimProxy(User user) throws JMSException, DataAccessException, java.rmi.RemoteException {
+	if (simProxyHash == null) {
+		simProxyHash = new HashMap<User, RpcSimServerProxy>();
+	}
+
+	RpcSimServerProxy simProxy = (RpcSimServerProxy)simProxyHash.get(user);
+
+	if (simProxy == null) {
+		JmsClientMessaging jmsClientMessaging = new JmsClientMessaging(jmsConn, log, null);		
+		simProxy = new RpcSimServerProxy(user, jmsClientMessaging, log);
+		simProxyHash.put(user, simProxy);
+	}
+	
+	return simProxy;
+}
+
+/**
+ * Return the StartServiceButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getStartServiceButton() {
+	if (ivjStartServiceButton == null) {
+		try {
+			ivjStartServiceButton = new javax.swing.JButton();
+			ivjStartServiceButton.setName("StartServiceButton");
+			ivjStartServiceButton.setText("Start Service");
+			ivjStartServiceButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStartServiceButton;
+}
+
+/**
+ * Return the StopServiceButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getStopServiceButton() {
+	if (ivjStopServiceButton == null) {
+		try {
+			ivjStopServiceButton = new javax.swing.JButton();
+			ivjStopServiceButton.setName("StopServiceButton");
+			ivjStopServiceButton.setText("Stop Service");
+			ivjStopServiceButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStopServiceButton;
+}
+
+/**
+ * Return the JTabbedPane1 property value.
+ * @return javax.swing.JTabbedPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTabbedPane getTabbedPane() {
+	if (ivjTabbedPane == null) {
+		try {
+			ivjTabbedPane = new javax.swing.JTabbedPane();
+			ivjTabbedPane.setName("TabbedPane");			
+			ivjTabbedPane.insertTab("Configurations", null, getConfigPage(), "services in the database", 0);
+			ivjTabbedPane.insertTab("Runtime Services", null, getServiceStatusPage(), "realtime services", 1);
+			ivjTabbedPane.insertTab("Active Users", null, getUserConnectionPage(), "Connected users", 2);
+			ivjTabbedPane.insertTab("Query", null, getQueryPage(), "query simulation status", 3);
+			ivjTabbedPane.insertTab("Broadcast Message", null, getBroadcastPanel(), "send broadcast message", 4);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjTabbedPane;
+}
+
+/**
+ * Return the ServicePage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getConfigPage() {
+	if (ivjConfigPage == null) {
+		try {
+			ivjConfigPage = new javax.swing.JPanel();
+			ivjConfigPage.setName("ConfigurationPage");
+			ivjConfigPage.setLayout(new BorderLayout());
+			
+			JPanel panel = new JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new JLabel("Total services : ");
+			label.setForeground(Color.red);			
+			panel.add(label);
+			panel.add(getNumConfigsLabel());			
+			ivjConfigPage.add(panel, "North");
+			
+			ivjConfigPage.add(getConfigTable().getEnclosingScrollPane(), "Center");
+			
+			Box box = Box.createHorizontalBox();
+			box.add(Box.createHorizontalGlue());
+			box.add(getNewServiceButton());
+			box.add(getModifyServiceButton());
+			box.add(getDeleteServiceButton());
+			box.add(Box.createHorizontalGlue());
+			box.add(getRefreshServerManagerButton());
+			ivjConfigPage.add(box, "South");
+			
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjConfigPage;
+}
+
+private JButton getNewServiceButton() {
+	if (ivjNewServiceButton == null) {
+		ivjNewServiceButton = new JButton("New");
+	}
+	return ivjNewServiceButton;
+}
+
+private JButton getDeleteServiceButton() {
+	if (ivjDeleteServiceButton == null) {
+		ivjDeleteServiceButton = new JButton("Delete");
+		ivjDeleteServiceButton.setEnabled(false);
+	}
+	return ivjDeleteServiceButton;
+}
+
+private JButton getRefreshServerManagerButton() {
+	if (ivjRefreshServerManagerButton == null) {
+		ivjRefreshServerManagerButton = new JButton("Refresh Server Manager");
+		ivjRefreshServerManagerButton.setEnabled(true);
+	}
+	return ivjRefreshServerManagerButton;
+}
+
+private JButton getModifyServiceButton() {
+	if (ivjModifyServiceButton == null) {
+		ivjModifyServiceButton = new JButton("Modify");
+		ivjModifyServiceButton.setEnabled(false);
+	}
+	return ivjModifyServiceButton;
+}
+
+private javax.swing.JLabel getNumConfigsLabel() {
+	if (ivjNumConfigsLabel == null) {
+		try {
+			ivjNumConfigsLabel = new javax.swing.JLabel();
+			ivjNumConfigsLabel.setName("NumConfigsLabel");
+			ivjNumConfigsLabel.setPreferredSize(new java.awt.Dimension(100, 14));
+			ivjNumConfigsLabel.setText("0");
+			ivjNumConfigsLabel.setMaximumSize(new java.awt.Dimension(100, 14));
+			ivjNumConfigsLabel.setForeground(java.awt.Color.red);
+			ivjNumConfigsLabel.setMinimumSize(new java.awt.Dimension(100, 14));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumConfigsLabel;
+}
+
+
+/**
+ * Return the UserConnectionPage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getUserConnectionPage() {
+	if (ivjUserConnectionPage == null) {
+		try {
+			ivjUserConnectionPage = new javax.swing.JPanel();
+			ivjUserConnectionPage.setName("UserConnectionPage");
+			ivjUserConnectionPage.setLayout(new java.awt.BorderLayout());
+			
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new javax.swing.JLabel("Total Active Users:");
+			label.setForeground(java.awt.Color.red);			
+			panel.add(label);
+			panel.add(getNumUserConnectionLabel(), getNumUserConnectionLabel().getName());			
+			getUserConnectionPage().add(panel, "North");
+			
+			getUserConnectionPage().add(getUserConnectionTable().getEnclosingScrollPane(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjUserConnectionPage;
+}
+
+/**
+ * Return the UserConnectionTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+private JSortTable getUserConnectionTable() {
+	if (ivjUserConnectionTable == null) {
+		try {
+			ivjUserConnectionTable = new JSortTable();
+			ivjUserConnectionTable.setModel(new UserConnectionTableModel());
+			ivjUserConnectionTable.disableUneditableForeground();
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjUserConnectionTable;
+}
+
+
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	 exception.printStackTrace(System.out);
+}
+
+
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getStopServiceButton().addActionListener(ivjEventHandler);
+	getStartServiceButton().addActionListener(ivjEventHandler);
+	getTabbedPane().addChangeListener(ivjEventHandler);
+	getQueryWaitingCheck().addItemListener(ivjEventHandler);
+	getQueryQueuedCheck().addItemListener(ivjEventHandler);
+	getQueryFailedCheck().addItemListener(ivjEventHandler);
+	getQueryRunningCheck().addItemListener(ivjEventHandler);
+	getQueryStoppedCheck().addItemListener(ivjEventHandler);
+	getQueryCompletedCheck().addItemListener(ivjEventHandler);
+	getQueryAllStatusCheck().addItemListener(ivjEventHandler);
+	getQueryGoButton().addActionListener(ivjEventHandler);
+	getQueryResetButton().addActionListener(ivjEventHandler);
+	getServiceStatusTable().addMouseListener(ivjEventHandler);
+	getQueryResultTable().addMouseListener(ivjEventHandler);
+	getConfigTable().addMouseListener(ivjEventHandler);
+	getQuerySubmitDateCheck().addItemListener(ivjEventHandler);
+	getQueryStartDateCheck().addItemListener(ivjEventHandler);
+	getQueryEndDateCheck().addItemListener(ivjEventHandler);
+	getQueryDispatchedCheck().addItemListener(ivjEventHandler);
+	getRefreshButton().addActionListener(ivjEventHandler);
+	getExitButton().addActionListener(ivjEventHandler);
+	getRemoveFromListButton().addActionListener(ivjEventHandler);
+	getSubmitSelectedButton().addActionListener(ivjEventHandler);
+	getSendMessageButton().addActionListener(ivjEventHandler);
+	getMessageResetButton().addActionListener(ivjEventHandler);
+	getNewServiceButton().addActionListener(ivjEventHandler);
+	getDeleteServiceButton().addActionListener(ivjEventHandler);
+	getModifyServiceButton().addActionListener(ivjEventHandler);
+	getRefreshServerManagerButton().addActionListener(ivjEventHandler);
+	getStopSelectedButton().addActionListener(ivjEventHandler);
+}
+
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		try {
+			log = new StdoutSessionLog("Console");
+			setTitle("Virtual Cell Management Console -- " + VCellServerID.getSystemServerID());
+			reconnect();
+			
+			try {
+				KeyFactory keyFactory = new cbit.sql.OracleKeyFactory();	
+				DbDriver.setKeyFactory(keyFactory);
+				ConnectionFactory conFactory = new cbit.sql.OraclePoolingConnectionFactory(log);
+				adminDbTop = new AdminDBTopLevel(conFactory,log);
+			} catch (SQLException e) {
+				e.printStackTrace();
+			} catch (IllegalAccessException e) {
+				e.printStackTrace();
+			} catch (InstantiationException e) {
+				e.printStackTrace();
+			} catch (ClassNotFoundException e) {
+				e.printStackTrace();
+			}		
+		} catch (JMSException ex) {
+		}	
+		// user code end
+		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+		setSize(1200, 700);
+		add(getJFrameContentPane());
+		
+		statusChecks.add(getQueryWaitingCheck());
+		statusChecks.add(getQueryQueuedCheck());
+		statusChecks.add(getQueryDispatchedCheck());
+		statusChecks.add(getQueryRunningCheck());
+		statusChecks.add(getQueryCompletedCheck());
+		statusChecks.add(getQueryStoppedCheck());
+		statusChecks.add(getQueryFailedCheck());
+
+		DateRenderer dateRenderer = new DateRenderer();
+		dateRenderer.disableUneditableForeground();
+		getQueryResultTable().setDefaultRenderer(Date.class, dateRenderer);
+		getQueryResultTable().setDefaultRenderer(Long.class, dateRenderer);
+		getConfigTable().setDefaultRenderer(Date.class, dateRenderer);
+		getServiceStatusTable().setDefaultRenderer(Date.class, dateRenderer);
+		initConnections();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}	
+	// user code end
+}
+
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {		
+		PropertyLoader.loadProperties();
+		
+		javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());
+		ServerManageConsole aServerManageConsole = new ServerManageConsole();		
+
+		aServerManageConsole.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		java.awt.Insets insets = aServerManageConsole.getInsets();
+		aServerManageConsole.setSize(aServerManageConsole.getWidth() + insets.left + insets.right, aServerManageConsole.getHeight() + insets.top + insets.bottom);
+		aServerManageConsole.setLocation(200, 200);		
+		aServerManageConsole.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JFrame");
+		exception.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void messageResetButton_ActionEvents() {
+	getBroadcastMessageTextArea().setText("The Virtual Cell is going to reboot in 5 minutes due to technical requirements. Please save your work and logout." 
+		+ " We are sorry for any inconvenience." 
+		+ " If you have any questions, please contact the Virtual Cell at VCell_Support@uchc.edu.");
+	getBroadcastMessageToTextField().setText("All");
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/10/2003 2:27:25 PM)
+ * @param service cbit.vcell.messaging.admin.VCellService
+ */
+private void onArrivingService(ServiceInstanceStatus arrivingService) {
+	if (arrivingService.getType().equals(ServiceType.SERVERMANAGER)) {
+		serviceInstanceStatusList.add(0, arrivingService);
+	} else {
+		boolean bDefined = false;
+		List<ServiceInstanceStatus> tempList = new ArrayList<ServiceInstanceStatus>(serviceInstanceStatusList);
+		for (int i = 0; i < tempList.size(); i ++) {
+			ServiceInstanceStatus sis = tempList.get(i);
+			if (sis.getSpecID().equals(arrivingService.getSpecID())) {
+				if (sis.isRunning()) {
+					serviceInstanceStatusList.add(arrivingService);
+				} else {
+					serviceInstanceStatusList.set(i, arrivingService);
+				}
+				bDefined = true;
+				break;
+			} 
+		}
+		if (!bDefined) {
+			serviceInstanceStatusList.add(arrivingService);
+		}
+	}
+	showServices(serviceInstanceStatusList);
+}
+
+
+/**
+ * onMessage method comment.
+ */
+public void onControlTopicMessage(Message message) {		
+	try {
+		log.print("onMessage [" + JmsUtils.toString(message) + "]");	
+		String msgType = (String)JmsUtils.parseProperty(message, ManageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		
+		if (msgType == null) {
+			return;
+		}
+		
+		if (msgType.equals(ManageConstants.MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE) && message instanceof ObjectMessage) {			
+			Object obj = ((ObjectMessage)message).getObject();			
+			if (obj instanceof ServiceInstanceStatus) {
+				final ServiceInstanceStatus serviceInfo = (ServiceInstanceStatus)obj;
+				SwingUtilities.invokeLater(new Runnable() {
+					public void run() {
+						onArrivingService(serviceInfo);
+					}
+				});
+			}
+		}		
+	} catch (Exception ex) {
+		log.exception(ex);
+	}	
+}
+
+public SimpleJobStatus getReturnedSimulationJobStatus(int selectedRow) {	
+	return (SimpleJobStatus)((JobTableModel)getQueryResultTable().getModel()).getValueAt(selectedRow);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void pingAll(int waitingTimeSec) {
+	try {
+		Message msg = topicSession.createMessage();			
+		msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE);		
+		log.print("sending ping message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);			
+		try {
+			Thread.sleep(waitingTimeSec * MessageConstants.SECOND_IN_MS);
+		} catch (InterruptedException ex) {
+			log.exception(ex);
+		}		
+	} catch (Exception ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/3/2003 8:00:07 AM)
+ */
+private void query() {	
+	boolean bOtherConditions = false;
+	
+	getRemoveFromListButton().setEnabled(false);
+	getSubmitSelectedButton().setEnabled(false);
+	getStopSelectedButton().setEnabled(false);
+	StringBuffer conditions = new StringBuffer();
+	String text = getQuerySimField().getText();
+	if (text != null && text.trim().length() > 0) {
+		try {
+			bOtherConditions = true;
+			int simID = Integer.parseInt(text);
+			conditions.append(SimulationJobTable.table.simRef.getQualifiedColName() + "=" + simID);
+		} catch (NumberFormatException ex) {
+		}
+	}
+
+	text = getQueryHostField().getText();
+	if (text != null && text.trim().length() > 0) {
+		bOtherConditions = true;
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("lower(" + SimulationJobTable.table.computeHost.getQualifiedColName() + ")='" + text.toLowerCase() + "'");
+	}
+
+	text = getQueryServerIDField().getText();
+	if (text != null && text.trim().length() > 0) {
+		bOtherConditions = true;
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("lower(" + SimulationJobTable.table.serverID.getQualifiedColName() + ")='" + text.toLowerCase() + "'");
+	}
+		
+	text = getQueryUserField().getText();
+	if (text != null && text.trim().length() > 0) {
+		bOtherConditions = true;
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append(UserTable.table.userid.getQualifiedColName() + "='" + text + "'");
+	}
+
+	StringBuffer status = new StringBuffer();
+	int index = 0;	
+	if (!getQueryAllStatusCheck().isSelected()) {
+		Iterator<JCheckBox> iter = statusChecks.iterator();
+		for (; iter.hasNext() ; index ++) {
+			JCheckBox box = iter.next();	
+			if (box.isSelected()) {
+				if (status.length() > 0) {
+					status.append(" OR ");
+				}					
+				status.append(SimulationJobTable.table.schedulerStatus.getQualifiedColName() + "=" + index);		
+			}
+		}			
+	}
+
+	if (status.length() > 0) {
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + status + ")");
+	}
+
+	java.text.SimpleDateFormat df = new java.text.SimpleDateFormat("MM/dd/yyyy", java.util.Locale.US);
+	
+	if (getQuerySubmitDateCheck().isSelected()) {
+		bOtherConditions = true;
+		String d1 = df.format(getQuerySubmitFromDate().getDate());
+		String d2 = df.format(getQuerySubmitToDate().getDate());
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + SimulationJobTable.table.submitDate.getQualifiedColName() 
+			+ " BETWEEN to_date('" + d1 + " 00:00:00', 'mm/dd/yyyy HH24:MI:SS') AND to_date('" + d2 + " 23:59:59', 'mm/dd/yyyy HH24:MI:SS'))");		
+	}
+	
+	if (getQueryStartDateCheck().isSelected()) {
+		bOtherConditions = true;
+		String d1 = df.format(getQueryStartFromDate().getDate());
+		String d2 = df.format(getQueryStartToDate().getDate());
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + SimulationJobTable.table.startDate.getQualifiedColName() 
+			+ " BETWEEN to_date('" + d1 + "00:00:00', 'mm/dd/yyyy HH24:MI:SS') AND to_date('" + d2 + " 23:59:59', 'mm/dd/yyyy HH24:MI:SS'))");		
+	}
+		
+	if (getQueryEndDateCheck().isSelected()) {
+		bOtherConditions = true;
+		String d1 = df.format(getQueryEndFromDate().getDate());
+		String d2 = df.format(getQueryEndToDate().getDate());
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + SimulationJobTable.table.endDate.getQualifiedColName() 
+			+ " BETWEEN to_date('" + d1 + "00:00:00', 'mm/dd/yyyy HH24:MI:SS') AND to_date('" + d2 + " 23:59:59', 'mm/dd/yyyy HH24:MI:SS'))");		
+	}
+	
+	if (getQueryCompletedCheck().isSelected() && !bOtherConditions) {
+		int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are gonna get all the completed simulation jobs in the database, which is gonna be huge . Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+		if (n == javax.swing.JOptionPane.NO_OPTION) {
+			getNumResultsLabel().setText("0");
+			getNumSelectedLabel().setText("0");
+			((JobTableModel)getQueryResultTable().getModel()).setData(null);			
+			return;
+		}
+	}
+	
+	try {
+		List<SimpleJobStatus> resultList = adminDbTop.getSimulationJobStatus(conditions.toString(), true);
+		getNumResultsLabel().setText("" + resultList.size());
+		getNumSelectedLabel().setText("0");
+		((JobTableModel)getQueryResultTable().getModel()).setData(resultList);
+	} catch (Exception ex) {
+		getNumResultsLabel().setText("Query failed, please try again!");
+		((JobTableModel)getQueryResultTable().getModel()).setData(null);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void queryAllStatusCheck_ItemStateChanged(ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryCompletedCheck_ItemStateChanged(ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryDispatchedCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryEndDateSubmit_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	if (itemEvent.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+		getQueryEndFromDate().setEnabled(true);
+		getQueryEndToDate().setEnabled(true);
+	} else {
+		getQueryEndFromDate().setEnabled(false);
+		getQueryEndToDate().setEnabled(false);
+	}
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryFailedCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryGoButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	query();
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryQueuedCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+private void submitSelectedButton_ActionPerformed(ActionEvent e) {
+	int srows[] = getQueryResultTable().getSelectedRows();
+	if (srows==null || srows.length==0) {
+		return;
+	}
+	final String SUBMIT_JOBS_OPTION = "submit jobs";
+	final String CANCEL_OPTION = "cancel";
+	String response = DialogUtils.showWarningDialog(this, "Are you sure you want to submit "+srows.length+" simulation job(s)? (see console for progress printed to stdout)", new String[] { SUBMIT_JOBS_OPTION, CANCEL_OPTION }, CANCEL_OPTION);
+	if (response.equals(SUBMIT_JOBS_OPTION)){
+		for (int i = 0; i < srows.length; i++) {
+			int selectedRow = srows[i];
+			SimpleJobStatus jobStatus = getReturnedSimulationJobStatus(selectedRow);
+			String statusString = "["+ jobStatus.getVCSimulationIdentifier() + ", " + jobStatus.getStatusMessage() + "]";
+			if (jobStatus.isDone()) {
+				log.print("Submitting job (" + (i+1) + " of " + srows.length + ") : " + statusString);
+				resubmitSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+			} else {
+				log.print("Submitting job ("+(i+1)+" of "+srows.length+") : " + statusString + ", is still running, skipping...");
+			}
+		}
+	}
+}
+
+private void stopSelectedButton_ActionPerformed(ActionEvent e) {
+	int srows[] = getQueryResultTable().getSelectedRows();
+	if (srows==null || srows.length==0) {
+		return;
+	}
+	final String STOP_JOBS_OPTION = "stop jobs";
+	final String CANCEL_OPTION = "cancel";
+	String response = DialogUtils.showWarningDialog(this, "Are you sure you want to stop "
+			+srows.length+" simulation job(s)? (see console for progress printed to stdout)", 
+			new String[] { STOP_JOBS_OPTION, CANCEL_OPTION }, CANCEL_OPTION);
+	if (response.equals(STOP_JOBS_OPTION)){
+		for (int i = 0; i < srows.length; i++) {
+			int selectedRow = srows[i];
+			SimpleJobStatus jobStatus = getReturnedSimulationJobStatus(selectedRow);
+			String statusString = "["+ jobStatus.getVCSimulationIdentifier() + ", " + jobStatus.getStatusMessage() + "]";
+			if (!jobStatus.isDone()) {
+				log.print("Stopping job ("+(i+1)+" of "+srows.length+") : "+statusString);	
+				stopSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+			} else {
+				log.print("***Stopping job ("+(i+1)+" of "+srows.length+") : "+statusString + ", is already finished, skipping");
+			}
+		}
+	}
+}
+
+/**
+ * Comment
+ */
+public void queryResetButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	getQuerySimField().setText(null);
+	getQueryHostField().setText(null);
+	getQueryUserField().setText(null);
+	getQueryAllStatusCheck().setSelected(true);
+	getQueryStartFromDate().reset();
+	getQueryStartToDate().reset();
+	getQueryEndFromDate().reset();	
+	getQueryEndToDate().reset();
+	getQuerySubmitFromDate().reset();
+	getQuerySubmitToDate().reset();
+	getQuerySubmitDateCheck().setSelected(true);
+	getQueryStartDateCheck().setSelected(false);
+	getQueryEndDateCheck().setSelected(false);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryResultTable_MouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	int srow = getQueryResultTable().getSelectedRow();
+	if (srow < 0) {
+		getRemoveFromListButton().setEnabled(false);
+		getSubmitSelectedButton().setEnabled(false);
+		getStopSelectedButton().setEnabled(false);
+		return;
+	}
+	if (mouseEvent.getClickCount() == 1) {
+		getRemoveFromListButton().setEnabled(true);
+		getSubmitSelectedButton().setEnabled(true);
+		getStopSelectedButton().setEnabled(true);
+		getNumSelectedLabel().setText("" + getQueryResultTable().getSelectedRowCount());
+	} else if (mouseEvent.getClickCount() == 2) {
+		SimulationJobStatusDetailDialog dialog = new SimulationJobStatusDetailDialog(this, getQueryResultTable().getRowCount(), srow);
+		dialog.setLocationRelativeTo(this);
+		dialog.setVisible(true);
+	}
+}
+
+public void configTable_mouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	int srow = getConfigTable().getSelectedRow();
+	if (srow < 0) {
+		getDeleteServiceButton().setEnabled(false);
+		getModifyServiceButton().setEnabled(false);
+	}
+	
+	getDeleteServiceButton().setEnabled(true);
+	getModifyServiceButton().setEnabled(true);
+	
+	if (mouseEvent.getClickCount() == 2) {
+		modifyService();
+	}
+}
+
+/**
+ * Comment
+ */
+public void queryRunningCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryStartDateCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	if (itemEvent.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+		getQueryStartFromDate().setEnabled(true);
+		getQueryStartToDate().setEnabled(true);
+	} else {
+		getQueryStartFromDate().setEnabled(false);
+		getQueryStartToDate().setEnabled(false);
+	}	
+	return;
+}
+
+/**
+ * Comment
+ */
+public void queryStoppedCheck_ItemStateChanged(ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void querySubmitDateCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	if (itemEvent.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+		getQuerySubmitFromDate().setEnabled(true);
+		getQuerySubmitToDate().setEnabled(true);
+	} else {
+		getQuerySubmitFromDate().setEnabled(false);
+		getQuerySubmitToDate().setEnabled(false);
+	}
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryWaitingCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+private void reconnect() throws JMSException {
+	jmsConnFactory = new JmsConnectionFactoryImpl();
+	
+	jmsConn = jmsConnFactory.createConnection();
+	
+	topicSession = jmsConn.getAutoSession();
+	JmsSession listenSession = jmsConn.getAutoSession();
+	String filter = MESSAGE_TYPE_PROPERTY + " NOT IN " 
+		+ "('" + MESSAGE_TYPE_IAMALIVE_VALUE + "'" 
+		+ ",'" + MESSAGE_TYPE_ISSERVICEALIVE_VALUE + "'" 
+		+ ",'" + MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_STARTSERVICE_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_STOPSERVICE_VALUE + "'"
+		+ ")";
+	listenSession.setupTopicListener(JmsUtils.getTopicDaemonControl(), filter, new ControlMessageCollector(this));
+	jmsConn.startConnection();
+}
+private String VCellDBAdminpassword;
+private void refresh () {
+	int count = getServiceStatusTable().getRowCount();
+	boolean bAll = false;
+	if (count == 0) {
+		bAll = true;
+	}
+	int tabIndex = getTabbedPane().getSelectedIndex();
+	if (tabIndex == 0 || tabIndex == 1) {
+		final int waitingTimeSec = 5;
+		
+		Thread t = new Thread(new Runnable() {
+			public void run() {
+				getProgressBar().setMaximum(waitingTimeSec);
+				getProgressBar().setMinimum(0);
+				SwingUtilities.invokeLater(new Runnable() {
+					public void run() {
+						getProgressBar().setIndeterminate(true);
+						getRefreshButton().setEnabled(false);
+					}			
+				});									
+			}
+		});
+		t.setName("Refresh Thread");
+		t.start();
+		
+		try {
+			serviceConfigList = adminDbTop.getAllServiceStatus(true);
+		} catch (Exception e) {			
+			e.printStackTrace();
+			javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}	
+		
+		showConfigs(serviceConfigList);
+		getModifyServiceButton().setEnabled(false);
+		getDeleteServiceButton().setEnabled(false);
+		
+		if (!bAll && tabIndex == 0) {		
+			Thread t1 = new Thread(new Runnable() {
+				public void run() {
+					SwingUtilities.invokeLater(new Runnable() {
+						public void run() {
+							getProgressBar().setIndeterminate(false);
+							getProgressBar().setValue(waitingTimeSec);
+							getRefreshButton().setEnabled(true);
+						}			
+					});					
+				}
+			});			
+			t1.setName("Refresh Thread");
+			t1.start();			
+		} else {		
+			((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).setData(null);
+			serviceInstanceStatusList.clear();
+			
+			for (int i = 0; i < serviceConfigList.size(); i ++) {
+				ServiceSpec ss = serviceConfigList.get(i).getServiceSpec();
+				serviceInstanceStatusList.add(new ServiceInstanceStatus(ss.getServerID(), ss.getType(), ss.getOrdinal(), null, null, false));
+			}
+			
+			showServices(serviceInstanceStatusList);
+			Thread pingThread = new Thread(new Runnable() {
+				public void run() {			
+					pingAll(waitingTimeSec);	
+					SwingUtilities.invokeLater(new Runnable() {
+						public void run() {
+							getProgressBar().setIndeterminate(false);
+							getProgressBar().setValue(waitingTimeSec);
+							getRefreshButton().setEnabled(true);
+						}			
+					});					
+				}
+			});
+			pingThread.setName("Refresh Thread");
+			pingThread.start();
+		}		
+	} else if (tabIndex == 2) {
+		userList.clear();
+		try {
+			if (vcellBootstrap == null) {
+				vcellBootstrap = (VCellBootstrap) java.rmi.Naming.lookup(getLocalVCellBootstrapUrl());
+				String clearTextPassword = null;
+				if(VCellDBAdminpassword == null){
+					clearTextPassword = DialogUtils.showInputDialog0(this, "Enter VCell DB Administrator password", "AdminPassword");
+				}
+				vcellServer = vcellBootstrap.getVCellServer(new User(PropertyLoader.ADMINISTRATOR_ACCOUNT,new KeyValue(PropertyLoader.ADMINISTRATOR_ID)), new UserLoginInfo.DigestedPassword(clearTextPassword));
+				//everything OK, save cache password
+				VCellDBAdminpassword = clearTextPassword;
+			}		
+			
+			ServerInfo serverInfo = vcellServer.getServerInfo();
+			User[] users = serverInfo.getConnectedUsers();
+			for (int i = 0; i < users.length; i ++) {
+				userList.add(new SimpleUserConnection(users[i], new Date()));
+			}
+		} catch (Exception ex) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Exception:" + ex.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}
+		showUsers(userList);
+	}
+		
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void refreshButton_ActionPerformed(ActionEvent actionEvent) {
+	refresh();
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void removeFromListButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	int[] indexes = getQueryResultTable().getSelectedRows();
+	((JobTableModel)getQueryResultTable().getModel()).removeRowsAt(indexes);
+	getNumResultsLabel().setText("" + getQueryResultTable().getRowCount());
+	getNumSelectedLabel().setText("0");
+	return;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:32:52 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public void resubmitSimulation(String userid, KeyValue simKey) {
+	try {
+		User user = adminDbTop.getUser(userid, true);
+		RpcDbServerProxy dbProxy = getDbProxy(user);
+		BigString simxml = dbProxy.getSimulationXML(simKey);
+		if (simxml == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		Simulation sim = XmlHelper.XMLToSim(simxml.toString());
+		if (sim == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		RpcSimServerProxy simProxy = getSimProxy(user);
+		simProxy.startSimulation(sim.getSimulationInfo().getAuthoritativeVCSimulationIdentifier());		
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Resubmitting simulation failed:" + ex.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void sendMessageButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	try {
+		int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are going to send message to " + getBroadcastMessageToTextField().getText() + ". Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+		if (n == javax.swing.JOptionPane.NO_OPTION) {
+			return;
+		}	
+		
+		Message msg = topicSession.createObjectMessage(new BigString(getBroadcastMessageTextArea().getText()));
+		String username = getBroadcastMessageToTextField().getText();
+
+		if (username.equalsIgnoreCase("All")) {
+			username = "All";
+		}
+			
+		msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_BROADCASTMESSAGE_VALUE);
+		msg.setStringProperty(MessageConstants.USERNAME_PROPERTY, username);
+		
+		log.print("sending broadcast message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicClientStatus(), msg);		
+
+	} catch (Exception ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void serverManageConsole_WindowClosed(java.awt.event.WindowEvent windowEvent) {
+	try {
+		dispose();
+		if (jmsConn != null) {
+			jmsConn.close();
+		}
+	} catch (JMSException ex) {
+		log.exception(ex);
+	} finally {
+ 		System.exit(0);	
+ 	}	
+}
+
+/**
+ * Comment
+ */
+public void serverStatusTable_MouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	}
+
+
+/**
+ * Comment
+ */
+public void serviceStatusTable_MouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	int selectedCount = getServiceStatusTable().getSelectedRowCount();
+	int[] selectedRows = getServiceStatusTable().getSelectedRows();
+	if (selectedRows == null || selectedCount < 1) {
+		return;
+	}
+
+	getStopServiceButton().setEnabled(false);
+	getStartServiceButton().setEnabled(false);
+
+	for (int i = 0; i < selectedCount; i ++){	
+		int row = selectedRows[i];
+		ServiceInstanceStatus serviceInstanceStatus = (ServiceInstanceStatus)((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).getValueAt(row);		
+		if (serviceInstanceStatus.isRunning()) {
+			getStopServiceButton().setEnabled(true);
+		} else {
+			//getStartServiceButton().setEnabled(true);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/31/2005 1:20:48 PM)
+ * @return cbit.vcell.messaging.admin.SimpleJobStatus
+ */
+public void setSelectedReturnedSimulationJobStatus(int selectedRow) {	
+	getQueryResultTable().setRowSelectionInterval(selectedRow, selectedRow);
+}
+
+
+/**
+ * Method generated to support the promotion of the userConnectionTableModel attribute.
+ * @param arg1 cbit.vcell.messaging.admin.sorttable.SortTableModel
+ */
+public void setUserConnectionTableModel(org.vcell.util.gui.sorttable.SortTableModel arg1) {
+	getUserConnectionTable().setModel(arg1);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/17/2004 1:21:46 PM)
+ * @param serviceList0 java.util.List
+ */
+private void showServices(final List<ServiceInstanceStatus> serviceList0) {
+	SwingUtilities.invokeLater(new Runnable() {
+		public void run() {
+			((ServiceInstanceStatusTableModel)(getServiceStatusTable().getModel())).setData(serviceList0);
+			getNumServiceLabel().setText(serviceList0.size() + "");
+		}
+	});
+}
+
+private void showConfigs(List<ServiceStatus> configList0) {
+	((ServiceStatusTableModel)(getConfigTable().getModel())).setData(configList0);
+	getNumConfigsLabel().setText(configList0.size() + "");
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/17/2004 1:21:46 PM)
+ * @param serviceList0 java.util.List
+ */
+private void showUsers(List<SimpleUserConnection> userList0) {
+	((UserConnectionTableModel)(getUserConnectionTable().getModel())).setData(userList0);
+	getNumUserConnectionLabel().setText(userList0.size() + "");
+}
+
+/**
+ * Comment
+ */
+public void startServiceButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	startServices();
+	return;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/20/2003 1:15:33 PM)
+ */
+private void startServices() {
+//	try
+//	} catch (Exception ex) {
+//		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+//	}
+}
+
+/**
+ * Comment
+ */
+public void stopServiceButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	stopServices();
+	return;
+}
+
+private void refreshServerManager() {
+	try {
+		int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are going to refresh server manager. Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+		if (n == javax.swing.JOptionPane.NO_OPTION) {
+			return;
+		}			
+		Message msg = topicSession.createMessage();
+			
+		msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE);
+			
+		log.print("sending refresh server manager message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);			
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/20/2003 1:15:33 PM)
+ */
+private void stopServices() {
+	try {
+		int selectedCount = getServiceStatusTable().getSelectedRowCount();
+		int[] selectedRows = getServiceStatusTable().getSelectedRows();
+		if (selectedRows == null || selectedCount < 1) {
+			return;
+		}
+
+		for (int i = 0; i < selectedCount; i ++){					
+			int row = selectedRows[i];
+			ServiceInstanceStatus serviceInstanceStatus = (ServiceInstanceStatus)((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).getValueAt(row);		
+			if (!serviceInstanceStatus.isRunning()) {
+				continue;
+			}			
+			
+			sendStopMessage(serviceInstanceStatus.getID());		
+		}
+		refresh();
+		clearServiceStatusTab();
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}	
+}
+
+private void sendStopMessage(String serviceInstanceID) throws JMSException {
+	Message msg = topicSession.createMessage();
+	
+	msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE);
+	msg.setStringProperty(ManageConstants.SERVICE_ID_PROPERTY, serviceInstanceID);
+	
+	log.print("sending stop service message [" + JmsUtils.toString(msg) + "]");		
+	topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);		
+}
+
+private void stopService(ServiceSpec ss) {
+	try {	
+		int count = getServiceStatusTable().getRowCount();
+		for (int i = 0; i < count; i ++){					
+			ServiceInstanceStatus serviceInstanceStatus = (ServiceInstanceStatus)((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).getValueAt(i);
+			if (!serviceInstanceStatus.isRunning() || !serviceInstanceStatus.getSpecID().equals(ss.getID())) {
+				continue;
+			}
+			
+			sendStopMessage(serviceInstanceStatus.getID());
+		}
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:32:52 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public void stopSimulation(String userid, KeyValue simKey) {
+	try {
+		User user = adminDbTop.getUser(userid, true);
+		RpcDbServerProxy dbProxy = getDbProxy(user);
+		BigString simxml = dbProxy.getSimulationXML(simKey);
+		if (simxml == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		cbit.vcell.solver.Simulation sim = cbit.vcell.xml.XmlHelper.XMLToSim(simxml.toString());
+		if (sim == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		cbit.vcell.messaging.server.RpcSimServerProxy simProxy = getSimProxy(user);
+		simProxy.stopSimulation(sim.getSimulationInfo().getAuthoritativeVCSimulationIdentifier());		
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Resubmitting simulation failed:" + ex.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void tabbedPane_ChangeEvents() {    
+    switch (getTabbedPane().getSelectedIndex()) {
+        case 0 :
+        case 1 :
+        case 2 :
+        	if (!getProgressBar().isIndeterminate()) {
+        		getRefreshButton().setEnabled(true);
+        	}
+            break;
+            
+        case 3 :
+            getRefreshButton().setEnabled(false);
+            break;
+        case 4:
+        	ivjBroadcastMessageTextArea.setText("Dear User,\n\n" 
+					+ "VCell is shutting down for update in 5 minutes. Please save your work and logout.\n\n"
+					+ "We are sorry for the inconvenience. Please come back in 15 minutes.\n\n\n"
+					+ "VCell team\n" 
+					+ new Date());	
+        	break;
+    }
+
+    return;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/29/2003 4:57:15 PM)
+ */
+private void updateChecks(java.awt.event.ItemEvent event) {
+	if (event.getSource() == getQueryAllStatusCheck()) {
+		if (event.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+			getQueryWaitingCheck().setSelected(true);
+			getQueryQueuedCheck().setSelected(true);
+			getQueryDispatchedCheck().setSelected(true);
+			getQueryRunningCheck().setSelected(true);
+			getQueryCompletedCheck().setSelected(true);
+			getQueryFailedCheck().setSelected(true);
+			getQueryStoppedCheck().setSelected(true);
+		}
+	} else if (event.getStateChange() == java.awt.event.ItemEvent.DESELECTED) {
+		if (getQueryAllStatusCheck().isSelected())
+			getQueryAllStatusCheck().setSelected(false);		 
+	}
+}
+}
Index: src/cbit/vcell/messaging/admin/JobTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/JobTableModel.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/JobTableModel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.util.Comparator;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/28/2003 1:38:32 PM)
+ * @author: Fei Gao
+ */
+public class JobTableModel extends VCellSortTableModel<ComparableObject> {
+	public final static int columnIndex_UserID = 0;
+	public final static int columnIndex_SimID = 1;
+	private final static int columnIndex_JobIndex = 2;
+	private final static int columnIndex_SolverType = 3;
+	private final static int columnIndex_Status = 4;
+	private final static int columnIndex_ComputeHost = 5;
+	private final static int columnIndex_ServerID = 6;
+	private final static int columnIndex_TaskID = 7;
+	private final static int columnIndex_SubmitDate = 8;
+	private final static int columnIndex_StartDate = 9;
+	private final static int columnIndex_EndDate = 10;
+	private final static int columnIndex_ElapsedTime = 11;
+
+/**
+ * JobTableModel constructor comment.
+ */
+public JobTableModel() {
+	super(new String[]{"User ID", "Sim ID", "Job Index", "Solver Type", "Status", "Compute Host", "Server ID", "Task ID", "Submit Date", "Start Date", "End Date", "Elapsed (h:m:s)"});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2003 2:14:05 PM)
+ * @return java.lang.Class
+ * @param columnIndex int
+ */
+public Class getColumnClass(int columnIndex) {
+	if (columnIndex == columnIndex_SimID || columnIndex == columnIndex_TaskID || columnIndex == columnIndex_JobIndex) {
+		return Number.class;
+	} else if (columnIndex == columnIndex_SubmitDate || columnIndex == columnIndex_StartDate || columnIndex == columnIndex_EndDate) {
+		return Date.class;
+	} else if (columnIndex == columnIndex_ElapsedTime){
+		return Long.class;
+	} else {		
+		return String.class;
+	}
+}
+
+/**
+ * getValueAt method comment.
+ */
+public Object getValueAt(int row, int col) {
+	ComparableObject jobStatus = getValueAt(row);
+	Object[] values = jobStatus.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+
+}
Index: src/cbit/vcell/messaging/admin/AddNewServiceDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/AddNewServiceDialog.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/AddNewServiceDialog.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.awt.Color;
+
+import javax.swing.*;
+
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/22/2003 3:43:58 PM)
+ * @author: Fei Gao
+ */
+public class AddNewServiceDialog extends javax.swing.JDialog {
+	private javax.swing.JButton ivjNewButton = null;
+	private javax.swing.JButton ivjCancelButton = null;
+	private javax.swing.JComboBox ivjOrdinalCombo = null;
+	private javax.swing.JTextField ivjSiteField = null;
+	private javax.swing.JComboBox ivjTypeCombo = null;	
+	private javax.swing.JComboBox ivjStartupCombo = null;
+	private javax.swing.JTextField ivjMemoryMBField = null;
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private JPanel ivjMainPanel = null;
+	public boolean action = false;
+	IvjEventHandler ivjEventHandler = new IvjEventHandler();
+
+class IvjEventHandler implements java.awt.event.ActionListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			if (e.getSource() == AddNewServiceDialog.this.getNewButton()) 
+				connEtoC1(e);
+			if (e.getSource() == AddNewServiceDialog.this.getCancelButton()) 
+				connEtoC2(e);
+		}
+	};
+/**
+ * AddNewServiceDialog constructor comment.
+ */
+public AddNewServiceDialog() {
+	super();
+	initialize();
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ */
+public AddNewServiceDialog(java.awt.Dialog owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ */
+public AddNewServiceDialog(java.awt.Dialog owner, String title) {
+	super(owner, title);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Dialog owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Dialog owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public AddNewServiceDialog(java.awt.Frame owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ */
+public AddNewServiceDialog(java.awt.Frame owner, String title) {
+	super(owner, title);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Frame owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Frame owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * Comment
+ */
+public void newButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {	
+	if (getTypeCombo().getSelectedIndex() < 0 
+			|| getOrdinalCombo().getSelectedItem() == null || getStartupCombo().getSelectedIndex() < 0
+			|| getMemoryMBField().getText().length() == 0) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Some fields are missing!", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		return;
+	}
+	
+	try {
+		int ordinal = Integer.parseInt("" + getOrdinalCombo().getSelectedItem());
+	} catch (NumberFormatException ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Ordinal must be a number!", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		return;
+	}
+	
+	action = true;
+	dispose();
+	return;
+}
+/**
+ * Comment
+ */
+public void cancelButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	action = false;
+	dispose();
+	return;
+}
+
+/**
+ * connEtoC1:  (AddNewAddButton.action.actionPerformed(java.awt.event.ActionEvent) --> AddNewServiceDialog.addNewAddButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.newButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * connEtoC2:  (AddNewCancelButton.action.actionPerformed(java.awt.event.ActionEvent) --> AddNewServiceDialog.addNewCancelButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC2(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.cancelButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * Return the AddNewAddButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getNewButton() {
+	if (ivjNewButton == null) {
+		try {
+			ivjNewButton = new javax.swing.JButton();
+			ivjNewButton.setText("New");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNewButton;
+}
+
+/**
+ * Return the AddNewCancelButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getCancelButton() {
+	if (ivjCancelButton == null) {
+		try {
+			ivjCancelButton = new javax.swing.JButton();
+			ivjCancelButton.setText("Cancel");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjCancelButton;
+}
+
+/**
+ * Return the AddNewLogFileField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getMemoryMBField() {
+	if (ivjMemoryMBField == null) {
+		try {
+			ivjMemoryMBField = new javax.swing.JTextField();
+			ivjMemoryMBField.setText("100");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjMemoryMBField;
+}
+
+/**
+ * Return the AddNewServiceNameField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JComboBox getOrdinalCombo() {
+	if (ivjOrdinalCombo == null) {
+		try {
+			ivjOrdinalCombo = new javax.swing.JComboBox();
+			for (int i = 0; i < 20; i ++) {
+				ivjOrdinalCombo.addItem(i);
+			}
+			ivjOrdinalCombo.setSelectedIndex(-1);
+			ivjOrdinalCombo.setEditable(true);
+			
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjOrdinalCombo;
+}
+
+private javax.swing.JTextField getSiteField() {
+	if (ivjSiteField == null) {
+		try {
+			ivjSiteField = new javax.swing.JTextField();
+			ivjSiteField.setText(VCellServerID.getSystemServerID().toString());
+			ivjSiteField.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSiteField;
+}
+
+private javax.swing.JComboBox getStartupCombo() {
+	if (ivjStartupCombo == null) {
+		try {
+			ivjStartupCombo = new javax.swing.JComboBox();
+			for (int i = 0; i < ManageConstants.SERVICE_STARTUP_TYPES.length; i ++) {
+				ivjStartupCombo.addItem(ManageConstants.SERVICE_STARTUP_TYPES[i]);
+			}			
+			ivjStartupCombo.setSelectedIndex(0);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStartupCombo;
+}
+
+private javax.swing.JComboBox getTypeCombo() {
+	if (ivjTypeCombo == null) {
+		try {
+			ivjTypeCombo = new javax.swing.JComboBox();
+			for (ServiceType st : ServiceType.values()) {
+				if (!st.equals(ServiceType.SERVERMANAGER)) {
+					ivjTypeCombo.addItem(st);
+				}
+			}			
+			ivjTypeCombo.setSelectedIndex(-1);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjTypeCombo;
+}
+
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(new java.awt.BorderLayout());
+			
+			JPanel panel3 = new JPanel(new java.awt.FlowLayout());
+			panel3.add(getNewButton());
+			panel3.add(getCancelButton());
+			
+			getJDialogContentPane().add(panel3, "South");
+			getJDialogContentPane().add(getMainPanel(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+
+/**
+ * Return the JPanel4 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getMainPanel() {
+	if (ivjMainPanel == null) {
+		try {
+			ivjMainPanel = new javax.swing.JPanel();
+			ivjMainPanel.setLayout(new java.awt.GridLayout(5, 2));
+			ivjMainPanel.add(new JLabel("Site"));
+			ivjMainPanel.add(getSiteField());
+			ivjMainPanel.add(new JLabel("Type"));
+			ivjMainPanel.add(getTypeCombo());
+			ivjMainPanel.add(new JLabel("Ordinal"));
+			ivjMainPanel.add(getOrdinalCombo());
+			ivjMainPanel.add(new JLabel("Startup Type"));
+			ivjMainPanel.add(getStartupCombo());
+			ivjMainPanel.add(new JLabel("Memory MB"));
+			ivjMainPanel.add(getMemoryMBField());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjMainPanel;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/22/2003 4:07:31 PM)
+ * @return cbit.vcell.messaging.admin.VCellServiceConfig
+ */
+public ServiceSpec getServiceSpec() {
+	String site = getSiteField().getText();
+	ServiceType stype = (ServiceType)getTypeCombo().getSelectedItem();
+	int ordinal = 0;
+	try {
+		ordinal = Integer.parseInt("" + getOrdinalCombo().getSelectedItem());
+	} catch (NumberFormatException ex) {
+		throw new RuntimeException("Ordinal must be a number!");		
+	}
+	int startup = getStartupCombo().getSelectedIndex();
+	int memoryMB = Integer.parseInt(getMemoryMBField().getText());
+
+	return new ServiceSpec(site, stype, ordinal, startup, memoryMB);
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getNewButton().addActionListener(ivjEventHandler);
+	getCancelButton().addActionListener(ivjEventHandler);
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setTitle("Add new service");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
+		setSize(471, 225);
+		setModal(true);
+		setResizable(false);
+		setContentPane(getJDialogContentPane());
+		initConnections();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+
+public void modifyService(ServiceSpec ss) {
+	this.setTitle("Modify Service");
+	getNewButton().setText("Modify");	 
+	getSiteField().setText(ss.getServerID());
+	getSiteField().setEditable(false);
+	getSiteField().setBackground(Color.white);
+	getTypeCombo().setSelectedItem(ss.getType());
+	getTypeCombo().setEnabled(false);
+	getTypeCombo().setBackground(Color.white);
+	getOrdinalCombo().setSelectedItem(ss.getOrdinal());
+	getOrdinalCombo().setEnabled(false);
+	getOrdinalCombo().setBackground(Color.white);
+	getStartupCombo().setSelectedIndex(ss.getStartupType());
+	getMemoryMBField().setText(ss.getMemoryMB() + "");
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/22/2003 5:10:29 PM)
+ * @return boolean
+ */
+public boolean isAction() {
+	return action;
+}
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		AddNewServiceDialog aAddNewServiceDialog;
+		aAddNewServiceDialog = new AddNewServiceDialog();
+		aAddNewServiceDialog.setModal(true);
+		aAddNewServiceDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aAddNewServiceDialog.setVisible(true);
+		java.awt.Insets insets = aAddNewServiceDialog.getInsets();
+		aAddNewServiceDialog.setSize(aAddNewServiceDialog.getWidth() + insets.left + insets.right, aAddNewServiceDialog.getHeight() + insets.top + insets.bottom);
+		aAddNewServiceDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceStatus.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceStatus.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.io.Serializable;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.Compare;
+import org.vcell.util.Matchable;
+
+import cbit.htc.PbsJobID;
+
+import static cbit.vcell.messaging.admin.ManageConstants.*;
+
+public class ServiceStatus implements ComparableObject, Matchable, Serializable {
+	private ServiceSpec serviceSpec = null;
+	private Date date = null;
+	private int status;
+	private String statusMsg;
+	private PbsJobID pbsJobId;
+	
+	public ServiceStatus(ServiceSpec ss, Date d, int s, String sm, PbsJobID pbsJobID) {
+		super();
+		this.serviceSpec = ss;
+		this.date = d;
+		this.status = s;
+		this.statusMsg = sm;
+		this.pbsJobId = pbsJobID;
+	}
+
+	public Date getDate() {
+		return date;
+	}
+
+	public ServiceSpec getServiceSpec() {
+		return serviceSpec;
+	}
+
+	public int getStatus() {
+		return status;
+	}
+
+	public String getStatusMsg() {
+		return statusMsg;
+	}
+	
+	public boolean isRunning() {
+		return status == ManageConstants.SERVICE_STATUS_RUNNING;
+	}
+	public Object[] toObjects(){
+		return new Object[]{serviceSpec.getServerID(), serviceSpec.getType(), serviceSpec.getOrdinal(), 
+				SERVICE_STARTUP_TYPES[serviceSpec.getStartupType()], serviceSpec.getMemoryMB(), date, SERVICE_STATUSES[status], statusMsg, pbsJobId};		
+	}
+
+	public boolean equals(Object obj) {
+		if (obj instanceof Matchable) {
+			return compareEqual((Matchable)obj);
+		}
+		return false;
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof ServiceStatus) {
+			ServiceStatus ss = (ServiceStatus)obj;
+		
+			if (!serviceSpec.compareEqual(ss.serviceSpec)) {
+				return false;
+			}
+			if (!date.equals(ss.date)) {
+				return false;
+			}
+			if (status != ss.status) {
+				return false;
+			}
+			if (!statusMsg.equals(ss.statusMsg)) {
+				return false;
+			}
+			if (!Compare.isEqualOrNull(pbsJobId, ss.pbsJobId)) {
+				return false;
+			}
+			return true;
+		}
+		return false;
+	}
+
+	public PbsJobID getPbsJobId() {
+		return pbsJobId;
+	}
+	
+	public String toString() {
+		return serviceSpec.toString();
+	}
+}
Index: src/cbit/vcell/messaging/admin/UserConnectionTimeCellRenderer.java
===================================================================
--- src/cbit/vcell/messaging/admin/UserConnectionTimeCellRenderer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/UserConnectionTimeCellRenderer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+/**
+ * Insert the type's description here.
+ * Creation date: (4/5/2006 9:48:52 AM)
+ * @author: Fei Gao
+ */
+public class UserConnectionTimeCellRenderer extends javax.swing.table.DefaultTableCellRenderer {
+/**
+ * UserConnectionTimeCellRenderer constructor comment.
+ */
+public UserConnectionTimeCellRenderer() {
+	super();
+}
+
+
+	/**
+	 *  This method is sent to the renderer by the drawing table to
+	 *  configure the renderer appropriately before drawing.  Return
+	 *  the Component used for drawing.
+	 *
+	 * @param	table		the JTable that is asking the renderer to draw.
+	 *				This parameter can be null.
+	 * @param	value		the value of the cell to be rendered.  It is
+	 *				up to the specific renderer to interpret
+	 *				and draw the value.  eg. if value is the
+	 *				String "true", it could be rendered as a
+	 *				string or it could be rendered as a check
+	 *				box that is checked.  null is a valid value.
+	 * @param	isSelected	true is the cell is to be renderer with
+	 *				selection highlighting
+	 * @param	row	        the row index of the cell being drawn.  When
+	 *				drawing the header the rowIndex is -1.
+	 * @param	column	        the column index of the cell being drawn
+	 */
+public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+	super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
+	if (value != null) {
+		int connTime = ((Integer)value).intValue()/1000;
+		int hour = connTime/3600;
+		int min = (connTime - hour * 3600) / 60;
+		int sec = connTime - hour * 3600 - min * 60;
+		setText("" + (hour < 10 ? "0" : "") + hour + " : " + (min < 10 ? "0" : "") + min + " : " + (sec < 10 ? "0" : "") + sec);
+	}
+	return this;
+}
+}
Index: src/cbit/vcell/messaging/admin/GatherInfoDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/GatherInfoDialog.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/GatherInfoDialog.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,428 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/22/2003 4:11:19 PM)
+ * @author: Fei Gao
+ */
+public class GatherInfoDialog extends javax.swing.JDialog {
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private javax.swing.JLabel ivjJLabel16 = null;
+	private javax.swing.JLabel ivjJLabel18 = null;
+	private javax.swing.JPanel ivjJPanel18 = null;
+	private javax.swing.JPanel ivjJPanel19 = null;
+	private javax.swing.JPanel ivjJPanel20 = null;
+	private java.awt.FlowLayout ivjJPanel20FlowLayout = null;
+	private javax.swing.JPanel ivjJPanel21 = null;
+	private javax.swing.JProgressBar ivjProgressBar = null;
+	public int max;
+/**
+ * GatherInfoDialog constructor comment.
+ */
+public GatherInfoDialog() {
+	super();
+	initialize();
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ */
+public GatherInfoDialog(java.awt.Dialog owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ */
+public GatherInfoDialog(java.awt.Dialog owner, String title) {
+	super(owner, title);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Dialog owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Dialog owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public GatherInfoDialog(java.awt.Frame owner, int max0) {
+	super(owner);
+	max = max0;
+	initialize();
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ */
+public GatherInfoDialog(java.awt.Frame owner, String title) {
+	super(owner, title);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Frame owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Frame owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * connEtoC1:  (GatherInfoDialog.initialize() --> GatherInfoDialog.gatherInfoDialog_Initialize()V)
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1() {
+	try {
+		// user code begin {1}
+		// user code end
+		this.gatherInfoDialog_Initialize();
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * Comment
+ */
+public void gatherInfoDialog_Initialize() {
+	getProgressBar().setMaximum(max);
+	return;
+}
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(new javax.swing.BoxLayout(getJDialogContentPane(), javax.swing.BoxLayout.X_AXIS));
+			getJDialogContentPane().add(getJPanel18(), getJPanel18().getName());
+			getJDialogContentPane().add(getJPanel19(), getJPanel19().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+/**
+ * Return the JLabel16 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel16() {
+	if (ivjJLabel16 == null) {
+		try {
+			ivjJLabel16 = new javax.swing.JLabel();
+			ivjJLabel16.setName("JLabel16");
+			ivjJLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/planet.gif")));
+			ivjJLabel16.setText("");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel16;
+}
+/**
+ * Return the JLabel18 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel18() {
+	if (ivjJLabel18 == null) {
+		try {
+			ivjJLabel18 = new javax.swing.JLabel();
+			ivjJLabel18.setName("JLabel18");
+			ivjJLabel18.setText("Please wait while we gather information for you");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel18;
+}
+/**
+ * Return the JPanel18 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel18() {
+	if (ivjJPanel18 == null) {
+		try {
+			ivjJPanel18 = new javax.swing.JPanel();
+			ivjJPanel18.setName("JPanel18");
+			ivjJPanel18.setLayout(new java.awt.FlowLayout());
+			getJPanel18().add(getJLabel16(), getJLabel16().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel18;
+}
+/**
+ * Return the JPanel19 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel19() {
+	if (ivjJPanel19 == null) {
+		try {
+			ivjJPanel19 = new javax.swing.JPanel();
+			ivjJPanel19.setName("JPanel19");
+			ivjJPanel19.setLayout(new java.awt.BorderLayout());
+			getJPanel19().add(getJPanel20(), "North");
+			getJPanel19().add(getJPanel21(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel19;
+}
+/**
+ * Return the JPanel20 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel20() {
+	if (ivjJPanel20 == null) {
+		try {
+			ivjJPanel20 = new javax.swing.JPanel();
+			ivjJPanel20.setName("JPanel20");
+			ivjJPanel20.setLayout(getJPanel20FlowLayout());
+			getJPanel20().add(getJLabel18(), getJLabel18().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel20;
+}
+/**
+ * Return the JPanel20FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel20FlowLayout() {
+	java.awt.FlowLayout ivjJPanel20FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel20FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel20FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel20FlowLayout;
+}
+/**
+ * Return the JPanel21 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel21() {
+	if (ivjJPanel21 == null) {
+		try {
+			ivjJPanel21 = new javax.swing.JPanel();
+			ivjJPanel21.setName("JPanel21");
+			ivjJPanel21.setLayout(new java.awt.BorderLayout());
+			getJPanel21().add(getProgressBar(), "North");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel21;
+}
+/**
+ * Return the ProgressBar property value.
+ * @return javax.swing.JProgressBar
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JProgressBar getProgressBar() {
+	if (ivjProgressBar == null) {
+		try {
+			ivjProgressBar = new javax.swing.JProgressBar();
+			ivjProgressBar.setName("ProgressBar");
+			ivjProgressBar.setMaximum(100);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjProgressBar;
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("GatherInfoDialog");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
+		setTitle("Gather Info");
+		setSize(400, 84);
+		setModal(true);
+		setResizable(false);
+		setContentPane(getJDialogContentPane());
+		initConnections();
+		connEtoC1();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}	
+	// user code end
+}
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		GatherInfoDialog aGatherInfoDialog;
+		aGatherInfoDialog = new GatherInfoDialog();
+		aGatherInfoDialog.setModal(true);
+		aGatherInfoDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aGatherInfoDialog.show();
+		java.awt.Insets insets = aGatherInfoDialog.getInsets();
+		aGatherInfoDialog.setSize(aGatherInfoDialog.getWidth() + insets.left + insets.right, aGatherInfoDialog.getHeight() + insets.top + insets.bottom);
+		aGatherInfoDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/22/2003 4:15:20 PM)
+ * @param value int
+ */
+public void setValue(int value) {
+	getProgressBar().setValue(value);
+}
+/**
+ * 
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private static void getBuilderData() {
+/*V1.1
+**start of data**
+	D0CB838494G88G88GD9FBB0B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135DB8DD49C57F5CE9D522313239EABADCE08A327D4F69A94D3D529F162B81C9CD22B2E1C5093056044CE712952D2D7CE649C3B25290E43E906BF8B2CBFE4C936D2E1FBADE39BD9E88101EC04100C7891A02D8496C82C508A18E587F658591D556CG0B0420773DB7F7F6181D8589C91CF34F1BF75FFB775DF75FFD77FEEFF660F63F13D814173F1B63720AB86D6F13BC0ECBBB46F1FBBE0E9FC5DE7D0799
+	A51C616FDD201D5CB4DF88E58734595C99A525DC5C0DE2283B201EB614D172A6BC6F62D6F4BB0F42C30CF92A216D597EE73C734F7303A11CE7B32D9775ED05F2BB509070C8197CA1197F2D3E3D9ABFCE63A36565F35C528A52273E2FCC633D84FD0A015781642AE07DD5A81982DFE828577A393E1444657CC8495FC66498E4A2E5EAE3B7E9250DFBA5AF71G190B27FA12B155D07782114597F027159AA89B3BFD23A7065D22EA1F9896A4496E97C2A1FED48C0C5AF90FDF8CB4B434732AD7D0BA83A3F22B48CBB2
+	590C320F085C15FD45D48E47E5034CA44A7B528419EB881E43C04BBEC23EF31270B742F361410C123203383E639FB6EA7ABB2FFF174BBC6CAF5C91E3FDF587593ADC87A36B5BA8BD177FC73A977F4B931BA7C0DBAA50BA209C205D1599A5F5C07B288F94719FC1F9522D3648FE3F9CB8998CB6CB9E652C6C91A4F8EEE800960DF7DE9816958F4731FD9E6D2B3450E7BEE26346EFF99C33C9D2AD6EF97279D5DC56A3DF4E5FECE1132C246B790ECAE68BCFE544A6EC6ED5B1670E2B1C6B13F3676E630CF3D7BE7BF4
+	C111455C9DCFBEDD102049C9B64C1DD5C9763A086EF5BABC67E97E4178BBA85FF6A842E77E79956AB324DE8DED710750B71C5BD197C7618A2E3466AB16F6C8787B25791B8EB19DCA6DE6DD52691C0DF633AEBF27FC075D2C4B40A46A620236B4A066DF1BBD643C16D7E514B481B90102C04B001201522A50474E71D5B769E35D3C22B60F0B12C7D0B8B6F6337B8DA805302A701D01104A8706050B3CA272EEC988F1DA1FD2B73101FB4E38BDEE627B43B0C73B909094DE9565GC8677D02AAA8A15667ED77CE52C7
+	91E8EB2F8827DC657DC18E65FE605E85254407548BC18F2F8A119E2C5D6EA6FBB241DF8409A0G1E19DD6A84E22F75307ECDC04555E80715D45E99C18988D2C303C316FD6341DE32924ED9CD6C7C8FB4F61441F3DDB55A38FA047016C3BDC517335E7D3AC1CE2BB8CC546715A9BCE3DBA6C9CCDEDB0DBE73DBA77ACC6B363F61AA1F3E4F52E7D241FF332B192F64D61B4F4E9EAA1368456A8FCCB8EF719CEF57F43A79D8711DC54DD1F0137D18FD3FBECA762A3C86FC98E82886ED3CEF5846FC36198F896825DD8A
+	B8186009D81C6919C1ED13276B1DC56B619A3415E752E9E16FBBC5EC0E9BF40E1BDD7B2D923349CE8F49C3420490D0DB0520907040C3C8EB5B6BA13E261D5391D99F73B6658761DC3740C18A697CF28FB9FB3C2AAA22FBDC95FA84D505749AE92F24F305465D41C8C84039EABDA47E4A13F02E757E759EF2A60665C0C0201B238F515A9B681994A4418FCA3748638115711B8432D7BEE1CA0B892D422B9CB95352B809AF8C932C663710B5A8229F361C04A8AE27061C57AC9D5390CA849E41B6EB214C2A4133B779
+	9E1E3D72EBAB393441E03ED56EC878463D790D07595968BE9CB9FBCC27A3A3563A9F2331C16307182E775417C2E906A74C57FF61A5F202A0BF8EE879E174756F0E10F60CA71A1337481244CC295B7821D1A2BBA4DC9D97A08C1340F5C6375B43232F1B5AAEEAB6E46D0F0C929BCA0618D7DACBEC38AD0C18AF65B033DF3AD6E6EBF6E06BBAFF1568C8F15998BF41076D21C97017060653A67CF54AC9ECC266F255A24E7A7DE5326EF828A7832D29453D7969B644D9713EA42E7817198531F0E4D6AD53052B0B6CCD
+	4A17A78B18DD5F9DA3F3B6C1DBF79D5A546EB5467A132110BCAC52B4235963B92FF16F986FDF3D2FC1B9A2AAA135938ED798ED3741CB74A5F9C8E3EBF9796370D64DBE9E18F7B9D0816D7FG650B81D1855B0857040A834C06FF61FE9B4AD113EF8CF69ABADEC44C33E2D713367674D5AB38465901FCAB8C3AE407B7BFD333C92E41B66BFF76DCFE8E900BCDE71C84F7F59C81ACFFA4BA7E87B5DE1CD6A6C04970086CA26BC8BEE246A9D3141FFA440CD372DC08D352212D7AE34C212BFD641C46C3FDB550DA2075
+	C05CA7F0B77A8477ABA856F28BE0144EGC007GAF754C89CA0895468AD89C516A9F0D95E19C61B0C6B7064D783371133976F01A6AEC5C6928F1F6D3FD5AB40E2DFB3B1F1C2DF8E8DB8D3496A89B2838BE23249C28239E571EB2F6FC21353711205FAB37G2F834EF00BB94E925DA906F15373678559CB01986FF14ACB04FA0A4E1B39C4F8E9D0FFC6677DE5BF6165C23D74A872B6D0DEB9549B0FE2BE9DF711185D2D57E7E9BD2857B73B96039B66A3B2575CBD315D71B90C391B6D4B77FC3173ED1A4FBA5FBE69
+	334E37693E1D0C8FB20CA89B5BB3FD736763AC1FD5BEFE0B6A7D549BBB286CD0C888D1C7E965D5DEEB7B8FF58FE711174F819057563C0B8B05CB34BEED2A5CD2234F39579FFB7D6F782D577F3E1F447010BC2E8C8B66B5D67A776AED918F6ED485BFD1C74B35F43C4AAB23C2140D9A69F85696EBFC1BBF169D59DA271C449E9EE1049F17E00B64105095542EA740DFF71478FCBCBDAFA436459F45187ED3A709A72A28CA44EE3B9B483B1877D4F854726337A7C94E9B018B8ECC57939406390D8DC456FD179023B8
+	21AE81AD85CA86CAEFC0595F69A7B27C320717F49D7E299F5FE3549D43FEFF68A7B6D70410F80DE6F06C7B66E55437D56F5BD0CE7000161D41D8AA753BG8CE258E9354B081D1C47581DE79A4AE53A0C071D645EE8C87776BEB16011A7C19C39892AA1FBEB5760392E5E0E4EF36D03DD6786DB9CDDBDEDDA7ECA1CB43EA32AFF6D9ECB5CC5A86998BB5B29DA193B677EBCA663A7170DB2CA6F177273E248485146F20D119C48704877AF21ED6A20CDEAA43C97AE6DB61D7B159C0B692CFDDF3F311D785301B96DE7
+	673493DD5FADB0364F4EE9AFB20CE76B7A717B08FBF2FF3C1A139E0D0B797EACC5DB4FB3DA39AC7B2BF941672F95307D496EA7F1D7D546852DFE194CB542CBA1C1774B7FBAC07659823791E710180DB6380A357E25479133BDBAC0F2F9875407004247B117BFB8CE7AAE03FA72F14CDFDE75A0149779B1ADF335F9C4D5D6E86A82E637A24389D327981722D23C7BCDF07A59DE253E9FCB86243F5320FA17FB8C8EFCAFCF30A64B81E9179677AE6B071B517EA90FFF0BFB6CCFDB73374430FF7AF1E6770DDAD971EF
+	DF4D0B64777F19A436ADBB11D1D28F6482D20116GA51EC05B6428C4C71241E1C1A7D5159F76D24409AB3BA88A1391B6899CECEDAF3A4CEBCBB9914901EBCFC463B8064D8E8C12FD4BBA4130D9114E2F237C178CFC06593EBF00983670530C926F2728F752B8112947D136ED5ADE7D6DB871EF9D5F526059839D835ABD677894E9CF87D99B0036B6814E832AEBC259EFCD6EE7B63130C71BE7D440780273F16158F9E8F378A65ECF05892EF74B2AAA7B09FC643F91A636D665A0E5EA6F9DE8AED444D12F4A3AEA7C
+	F743446FA5E1043299B6AA3CC2F85D30AECF9362254F8FA02EDA5204F828EA107012211E26739AA8AF936A1BF45E8F870C1806743D9DBC135CE405E5FFB9E70E225B10EF46CC915C54B695FB3F9CD38B6F5705A9FAB783BB77CE85353C5EBFC55E8B48A3A3A1C1770B4129D21D57996A16C3A271C4968B77DDA17DA5FECA9E077ECBCE123DB9FC85F3DE99546B00DCC0C1C210C75751BE778F6CDDE03D3B38C3FE229F0B20B5750C9758EF609DE5B9D69AB467D8B24F5E660C12CAA05627D1346A538A6DCEA0F6C6
+	7B2F60EFA5C160A5B563EFA567BB089D22E3FB339CF6300533783E628A6640754D985F57D119FBDB601E86545102F7727087989B137FFA85177B34751DFCFD6F0D7C21966D5E589249391C7F39FCA6E74C07F24A9EFE1036454AF1E95A78EC039CBA0E6A7950A0662672D654BD05A73A3B202E82AD85E2FDD5917BBE24773D57C763A154F300363661D99B3A32385FCF820B9C774DDB9E4762F6AB0D4F65EDACEE67697C3314DFED60B3DF79396EAB0D50165806F97B7D6B444F8ACFC1AC862A876A868A82ADBD25
+	672A29EAEE01FBE82F9CF44041168CD798A6FFF61A48CF84D929C06B01B681EDED073BEEBB4ABFF10D5C71E361047332CC91AA812B3C9890941A8694F8D4B59B2E9CB45B303EBD92639C6D31F2E2051B7E7E57EEFE0FF11872036D6677980F73789E63F350165D0EBEB3A51A676F68084C696A08B5FF01C46769B067646D149F57E14E497779B0A7A7C0DBEE874EFFFA00537D2947701CF565CE5F05237D773F6F6A9C5ABB3B6B317346116B56774DE3572D6F5BA72F4FFF1F6E3C9E7B7DF6777568775BCB26E36B
+	F66F7442B9ADE15A9A03FCFDBA9A03BCB8ED0DC1D6CEC7E310B49A9F07BAA196F6A2867914C78C1250093EE3F7133BC22ADE2F2775F5FABD0D1FEFFF49385B7721E7671D63F6FFBBE1EBDFC6F340CB20EF61E934477F79509E9527F13DA59261B920BE2473F6D31E8A75841D77B5DFAC1D49386D1A0C5B33CBCA4CB9901F5D0EED98BE7945E0B49E7A2D0ECFD2E18D19C039C025E7609930E363995267A20FFDAA4EC42F13497EF508E29F876F866C73F1AA9DA73A0DF760B8CDE65299FC3770CDB1DA1F9F68D828
+	5081B99D28954869E0981969D36343BEC1C7ACFDDEBE9E41E2072BB55EA1832F06E12FD31299FB11F962C0EE028371593E20D51F55503E4601786C0DA14C39D9405BFD9671D96D61B93F195879C935216114A4CFEA688CB14E409062B347D944ADCB294CB828AF87CAB90B98E71AC70C13FE96B15B5AAB4677893603DD166F93B6DD3916DFF8CE3B471E0BE02D8D322DC0FBD7B09263DD815DD9B67F2B1EE24DEFDD67F07E9B270C3F63246E389173BE9D2F4D1BE218FF63233FABE0F6FCDEC4BB66C0FBE5975A71
+	F97B9C1C4B6C58AC135F496660DC7B985A515305F6F40D91194B211E82145E05F66C73219D33F55E0C043C32EE9CBF9DA063FB21AE8145F5E35F1EA076DD2E772DD3C85FCC28EF84AA7C8CE3C8595062B063C70B9CB7FC4B63989E61A86EA97B4C0CB5CBA83F62B3B3567CF35D6F6B20ADC1DF6F1F704679F301DFFAFE7E9849B064508C713FF2685B8464811A86DA8614F49EB164519B95DCEC8C495CA1829C356FB1BCC41FD4138E6B34FA3605EECC1F9F4D129836895AF77700BF823582F9FAD017FBEEAC781B
+	D5DB5872B7AB265746A8BCF9F37B7B4AA247550EAD4EAF7E191E21389E33DFE4D37E329E33DF384750AF16C39B570BFE6172996777GBF5CBB3FDF30F11F174CFAAFB50CCB34104174FB091E5D14DEB36EFF057257741AF17FBD81447D1950D6FF8175F6864D73AF3F9019F37505D873A751F8306602F97E3FE3F16202F97E8685674F06360E0BB87F2BBC275BE20761B9E1686E637EEF5F55B998BECB20B9AD99567BE7BA6F814ADB833CDF65A17E95E7E2E370604C4298FCEA469A034F4EC4E3703899EB8C7E45
+	19E88C3E1F664475206BCB9791F3FE03FEDFD0588731238FF92F0908C3EDFD98C3B2E6E32F6959D96BBB4F3F4CDA5FF97EFDF67E5F98DF1C0DF5A7E2FB7D2B3108EF7D5A706C9D3B7BFE36742E4E416C9F72211FDDA8C0DE58E774B3463BDF42BBC42B3EF7B5815CBBEF9F1E4B5F85489DAADE2FF3B229A76975A5812BB5117EF74EEEFFE5B9471D7A8E0D2DDD8E22BD566A76F861AA5AE3233E5ED58AD97FDEA7569F2375EA3D5E245C4E9E93398B5B6352ED4D31105D989E65BFB0FC5F53A7FAD4AF63170537C5
+	789D82099D9C5EC90EFA08AD44E1B940FE336D22B1239B5664F2621DA855CBFF4F03834FFEDF9EA46901E3771EF745795ECB337B53937AFDE635135D6756C21985C46E344517C81F0E00ED9EB9B91A0D19BE7B9B8D773AFAF62F2B114D77BAA23B9BE4B39D92747B1267923B43CDC3396C923BD3B39DB8E5BE9D12AE99F5C82EA1F709EEC59ED504D02819D7B826478B0AD10FD4CD7E86A8196D7E118C57E4AC731E02B2A0CC5A0C3FE5F77A79D12193B62402FCCEC082E94581BBBC1E9758978A957B2B48F6052A
+	0292DC9AD57B28B8327F40814C553F11906364421CF57DF8AF2875636F76D2BF5E8BE67C246FC3D0CF854A6C477D968244EF4E490ACA7E49C37BDED1B03EB7AFFB27A9FFA7E7FD175A584F6C34773255FBF32F0C779347E53C272685D167B86025DEC61D0B2F623DA967B26A7C71D552375285B1904865C21D5FD2483D3DC5A05FE261F958D6C53EEB337A0D5930ED1ADE36906A253AB0AE3C9C056FEEAE767DE111636A7D46F1492E0563B143ED7FC977B14DE546413F277CF41799874779515E4FC0DB6395FC97
+	7FF2A1717FC42827822D875A8434F5A023249C289E28FBG71411642796EBB6C92EC3E6F78E5AB3BC883EC1D1F9B08DEAF9B77E4944E3DB9FBE6AEF25C362B0B3B0FFC0B7AE67C00F99F9E217C448173BEB4DE45FDC8063652C1743B5F0CDB4D2F8EB27BAC990C36934BFDDD740CAF9FE473B0D91B7C1C7E1C9708BCFF51FF77315303F7F58E6607390531F1EAC1514258FBEB11B576FE3DA89AFB3FD9E40D3D5FAAB2E2EF465B2F49D5740F5A983F220864E276FE71AC9F00D09F79C6B20E464694583FB503BA1E
+	11914F2C537DE3755548BEFE4F705CFC756E6F69653BBA87DBF37E84D9F38E2C37F8886DF0E6826DD0B604B1FF04FE6B47CB62E800FC2B41E1DE7D1ABC972F2CA229C143ABDCF0BE3C42467FF1022C554F07C57F38DF7B162D1A4E7F94D0479062857704ED9ED9F3B1CB7B84A9EB2A2BB976BF164F8F7642A1CDFE11ABD239AD6C33FC9B39CC41AAC28A775E306C370BEE3FFDFC42EF675D2ADD0070EAA7FE645161C17F93C30FF91F5A33BF1FAB6A64360C0802646921G41411552DA2B909AD644A07976C065DE
+	F71094D88510E1340AFD93F34C416D247D90D89071D739992E40416DB208BBA5CAC2A052345D50F4613CC36536B349GC52A20FEACCC7ECFAACF65AA6DF6574596C112ECFCB0A8094374EB9CDBC8D0A68445C5810CAB82E0D4EEE79428A1733D9AD4392AEEC960C302ED1297D55B24973431CD8AB676353ACD8413A9FEA69B1EECF02C98DEB9B0EB7CC6EF539706E3FE6767F133FD8A3BA3F8056543101B1EC7602FF3E35EFB02BF44457E9E2C474FCB124ACB3E13818F79B62CF9CA95A27760301B488FE19F2DD1
+	3B6B537F999BB30C79FFD0CB8788FD131210B094GG68BBGGD0CB818294G94G88G88GD9FBB0B6FD131210B094GG68BBGG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGGEA94GGGG
+**end of data**/
+}
+}
Index: src/cbit/vcell/messaging/admin/SimpleUserConnection.java
===================================================================
--- src/cbit/vcell/messaging/admin/SimpleUserConnection.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/SimpleUserConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.document.User;
+/**
+ * Insert the type's description here.
+ * Creation date: (4/5/2006 9:39:11 AM)
+ * @author: Fei Gao
+ */
+public class SimpleUserConnection implements ComparableObject {
+	private User user = null;
+	private Date connectedTime = null;
+	private int elapsedTime = 0;
+
+/**
+ * SimpleUserConnection constructor comment.
+ */
+public SimpleUserConnection(User arg_user, Date arg_connectedTime) {
+	super();
+	user = arg_user;
+	connectedTime = arg_connectedTime;
+	elapsedTime = (int)(System.currentTimeMillis() - connectedTime.getTime());
+}
+
+
+/**
+ * toObjects method comment.
+ */
+public java.lang.Object[] toObjects() {
+	return new Object[] {user.getName(), connectedTime, new Integer(elapsedTime)};
+}
+}
Index: src/cbit/vcell/messaging/admin/ManageUtils.java
===================================================================
--- src/cbit/vcell/messaging/admin/ManageUtils.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ManageUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.net.UnknownHostException;
+import java.util.StringTokenizer;
+
+import org.vcell.util.Executable;
+import org.vcell.util.PropertyLoader;
+
+import cbit.vcell.resource.ResourceUtil;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/11/2003 11:41:43 AM)
+ * @author: Fei Gao
+ */
+public class ManageUtils {
+	private static java.text.SimpleDateFormat dateTimeFormatter = new java.text.SimpleDateFormat(" yyyy_MM_dd 'at' HH-mm-ss", java.util.Locale.US);
+
+/**
+ * ManageUtils constructor comment.
+ */
+public ManageUtils() {
+	super();
+}
+
+public static String getHostName() {
+	try {
+		String hostname = cbit.vcell.messaging.admin.ManageUtils.getLocalHostName();
+		StringTokenizer st = new StringTokenizer(hostname, ".");
+		hostname = st.nextToken(); // abbr hostname
+		return hostname;
+	} catch (UnknownHostException ex) {
+		ex.printStackTrace();
+		return "UnknownHost";
+	}	 
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/26/2001 5:49:02 PM)
+ * @return boolean
+ * @param file java.io.File
+ * @param archiveDirectory java.io.File
+ */
+public static void archiveByDateAndTime(String fileName, String arcDir) {
+	try {
+		if (fileName == null) {
+			return;
+		}
+		
+		java.io.File archiveDirectory = null;
+		java.io.File file = new java.io.File(fileName);
+			
+		if (arcDir == null) {
+			archiveDirectory = new java.io.File("." + java.io.File.separator);
+		} else {
+			archiveDirectory = new java.io.File(arcDir);
+		}
+		
+		archiveDirectory.mkdir(); // in case it isn't there...
+		if (file.exists()) {
+			String archivedName = file.getName() + dateTimeFormatter.format(new java.util.Date());
+			file.renameTo(new java.io.File(archiveDirectory, archivedName));
+		}
+	} catch (Throwable exc) {
+		exc.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.server.ProcessStatus
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public static ServerPerformance getDaemonPerformance() {
+	try {
+		String PROGRAM = null;
+		try {
+			PROGRAM = System.getProperty(org.vcell.util.PropertyLoader.serverStatisticsProperty);
+		} catch (Exception e){
+			throw new RuntimeException("required System property \""+org.vcell.util.PropertyLoader.serverStatisticsProperty+"\" not defined");
+		}
+
+		long memoryBytes = -1;
+		float fractionCPU = 0.9999999f;
+		long javaFreeMemoryBytes = Runtime.getRuntime().freeMemory();
+		long javaTotalMemoryBytes = Runtime.getRuntime().totalMemory();
+		long maxJavaMemoryBytes = -1;
+		try {
+			maxJavaMemoryBytes = Long.parseLong(PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty));
+		}catch (NumberFormatException e){
+			System.out.println("error reading property '"+org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty+"', "+e.getMessage());
+		}
+		try {
+			Executable executable = new Executable(new String[]{PROGRAM});
+			executable.start();
+			String stdout = executable.getStdoutString();
+			java.util.StringTokenizer tokens = new java.util.StringTokenizer(stdout);
+			memoryBytes = Long.parseLong(tokens.nextToken());
+			int cpuPercent = Integer.parseInt (tokens.nextToken());
+			fractionCPU = cpuPercent/100.0f;
+		} catch (Exception e) {
+			e.printStackTrace(System.out);
+		}
+
+		return new ServerPerformance(fractionCPU,memoryBytes,javaFreeMemoryBytes,javaTotalMemoryBytes,maxJavaMemoryBytes);
+	} catch (Throwable e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/25/2003 8:43:41 AM)
+ * @return java.lang.String
+ * @param keyword java.lang.String
+ */
+public static String getEnvVariable(String keyword, org.vcell.util.SessionLog log) {
+	String value = null;
+	String[] command = null;
+	
+	if (ResourceUtil.bWindows) {
+		command = new String[]{"cmd.exe", "/c" , "echo %" + keyword + "%"};
+	} else {
+		command = new String[]{"echo", "$" + keyword};
+	}
+	
+	try {
+		Executable exe = new Executable(command);
+		exe.start();
+		value = exe.getStdoutString().trim();
+	} catch (Exception e) {
+		log.exception(e);
+	}
+	
+	return value;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 9:32:25 AM)
+ * @return java.lang.String
+ */
+public static String getFullLocalHostName() throws java.net.UnknownHostException {
+	java.net.InetAddress inet = java.net.InetAddress.getLocalHost();	
+	String hostName = java.net.InetAddress.getByName(inet.getHostAddress()).getHostName();
+	return hostName;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 9:32:25 AM)
+ * @return java.lang.String
+ */
+public static String getLocalHostName() throws java.net.UnknownHostException {
+	String hostName = java.net.InetAddress.getLocalHost().getHostName();
+	if (hostName != null) {
+		hostName = hostName.toLowerCase();
+	}
+	return hostName;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/4/2003 7:38:11 AM)
+ * @return java.lang.String
+ */
+public static String readLog(java.io.File file) throws java.io.IOException {
+	java.io.FileReader reader = new java.io.FileReader(file);
+	char[] content = new char[10000];
+	String out = "";
+	while (true) {
+		int n = reader.read(content, 0, 10000);
+		if (n == -1) {
+			break;
+		} else
+			if (n > 0) {
+				out += new String(content, 0, n);
+			}
+	}
+	reader.close();
+	return out;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceSpec.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceSpec.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceSpec.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_STARTUP_TYPES;
+import java.io.Serializable;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.Matchable;
+import org.vcell.util.MessageConstants.ServiceType;
+
+
+public class ServiceSpec implements Matchable, Serializable, ComparableObject {
+	private String serverID;
+	private ServiceType type;
+	private int ordinal;
+	private int startupType;
+	private int memoryMB;	
+	
+	public ServiceSpec(String sID, ServiceType t, int o, int st, int mm) {
+		super();
+		this.serverID = sID;
+		this.type = t;
+		this.ordinal = o;
+		this.startupType = st;
+		this.memoryMB = mm;
+	}
+	
+	public int getMemoryMB() {
+		return memoryMB;
+	}
+
+	public int getOrdinal() {
+		return ordinal;
+	}
+
+	public String getServerID() {
+		return serverID;
+	}
+
+	public ServiceType getType() {
+		return type;
+	}
+	
+	public String toString() {
+		return "[" + serverID + "," + type + "," + ordinal + "," + ManageConstants.SERVICE_STARTUP_TYPES[startupType] + "," + memoryMB + "M]";
+	}
+
+	public int getStartupType() {
+		return startupType;
+	}
+
+	public String getID() {
+		return getServiceID(serverID, type, ordinal);
+	}
+	public static String getServiceID(String serverID, ServiceType type, int ordinal) {
+		return serverID.charAt(0) + "_" + type.getName() + "_" + ordinal;
+	}
+	
+	public Object[] toObjects() {
+		return new Object[] {serverID, type, ordinal, SERVICE_STARTUP_TYPES[startupType], memoryMB};
+	}
+		
+	public boolean equals(Object obj) {
+		if (obj instanceof Matchable) {
+			return compareEqual((Matchable)obj);
+		}
+		return false;
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof ServiceSpec) {
+			ServiceSpec ss = (ServiceSpec)obj;
+		
+			if (!serverID.equals(ss.serverID)) {
+				return false;
+			}
+			if (!type.equals(ss.type)) {
+				return false;
+			}
+			if (ordinal != ss.ordinal) {
+				return false;
+			}			
+			return true;
+		}		
+		return false;
+	}
+}
Index: src/cbit/vcell/messaging/admin/ServicePerformance.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServicePerformance.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServicePerformance.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * This type was created in VisualAge.
+ */
+public class ServicePerformance extends Performance {
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServicePerformance() {		
+}
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServicePerformance(long aFreeJavaMemoryBytes, long aTotalJavaMemoryBytes, long aMaxJavaMemoryBytes) {		
+	this.freeJavaMemoryBytes = aFreeJavaMemoryBytes;
+	this.totalJavaMemoryBytes = aTotalJavaMemoryBytes;
+	this.maxJavaMemoryBytes = aMaxJavaMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public Object[] toObjects() {
+	return new Object[] {		
+		new Long(getFreeJavaMemoryBytes()), new Long(getTotalJavaMemoryBytes()), new Long(getMaxJavaMemoryBytes())
+	};
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public String toString() {
+	return "ServicePerformanceStatus: "+ "JVM Memory (free="+getFreeJavaMemoryBytes() 
+		+", total="+getTotalJavaMemoryBytes()+", max="+getMaxJavaMemoryBytes()+") bytes";
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceInstanceStatusTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceInstanceStatusTableModel.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceInstanceStatusTableModel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.util.Comparator;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/19/2003 10:46:32 AM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class ServiceInstanceStatusTableModel extends VCellSortTableModel<ComparableObject> {
+
+public ServiceInstanceStatusTableModel() {
+	super(new String[]{"Site", "Type", "Ordinal", "Host", "Start Date", "Running"});
+}
+
+public Class<?> getColumnClass(int columnIndex) {
+	if (columnIndex == 0 || columnIndex == 3) {
+		return String.class;
+	}		
+	if (columnIndex == 1) {
+		return ServiceType.class;
+	}
+	if (columnIndex == 5) {
+		return Boolean.class;
+	}
+	if (columnIndex == 2) {
+		return Number.class;
+	}
+	if (columnIndex == 4) {
+		return Date.class;
+	}
+	return Object.class;
+}
+
+public Object getValueAt(int row, int col) {
+	ComparableObject status = getValueAt(row);
+	Object[] values = status.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+}
Index: src/cbit/vcell/messaging/admin/UserConnectionDateRenderer.java
===================================================================
--- src/cbit/vcell/messaging/admin/UserConnectionDateRenderer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/UserConnectionDateRenderer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+/**
+ * Insert the type's description here.
+ * Creation date: (7/8/2004 2:17:40 PM)
+ * @author: Fei Gao
+ */
+public class UserConnectionDateRenderer extends javax.swing.table.DefaultTableCellRenderer {
+/**
+ * DateRenderer constructor comment.
+ */
+public UserConnectionDateRenderer() {
+	super();
+}
+	/**
+	 *  This method is sent to the renderer by the drawing table to
+	 *  configure the renderer appropriately before drawing.  Return
+	 *  the Component used for drawing.
+	 *
+	 * @param	table		the JTable that is asking the renderer to draw.
+	 *				This parameter can be null.
+	 * @param	value		the value of the cell to be rendered.  It is
+	 *				up to the specific renderer to interpret
+	 *				and draw the value.  eg. if value is the
+	 *				String "true", it could be rendered as a
+	 *				string or it could be rendered as a check
+	 *				box that is checked.  null is a valid value.
+	 * @param	isSelected	true is the cell is to be renderer with
+	 *				selection highlighting
+	 * @param	row	        the row index of the cell being drawn.  When
+	 *				drawing the header the rowIndex is -1.
+	 * @param	column	        the column index of the cell being drawn
+	 */
+public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+	super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
+	if (value == null) {
+		return this;
+	}
+	
+	java.text.SimpleDateFormat ddtf = new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss", java.util.Locale.US);
+	
+	setText(ddtf.format(value));
+	return this;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServerManagerDaemon.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServerManagerDaemon.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServerManagerDaemon.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import static cbit.vcell.messaging.admin.ManageConstants.*;
+import java.io.*;
+import java.sql.SQLException;
+import java.util.*;
+import javax.jms.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ExecutableException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.htc.PBSUtils;
+import cbit.htc.PbsJobID;
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.vcell.messaging.*;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.modeldb.AdminDBTopLevel;
+import cbit.vcell.modeldb.DbDriver;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/7/2003 1:53:27 PM)
+ * @author: Fei Gao
+ */
+public class ServerManagerDaemon implements ControlTopicListener {
+	private org.vcell.util.SessionLog log = null;
+	private JmsConnection jmsConn = null;
+	private JmsConnectionFactory jmsConnFactory = null;
+	private boolean stopped = false;
+	private List<ServiceInstanceStatus> serviceAliveList = Collections.synchronizedList(new ArrayList<ServiceInstanceStatus>());
+	private List<ServiceStatus> serviceList = Collections.synchronizedList(new ArrayList<ServiceStatus>());
+	private JmsSession topicSession = null;
+	private JmsSession listenSession = null;
+	
+	ServiceInstanceStatus serviceInstanceStatus = null;
+	
+	private ConnectionFactory conFactory = null;
+	private KeyFactory keyFactory = null;
+	private AdminDBTopLevel adminDbTop = null;	
+
+/**
+ * ServerManagerMessaging constructor comment.
+ */
+public ServerManagerDaemon() throws IOException, SQLException, javax.jms.JMSException {
+	super();	
+	
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID().toString(), ServiceType.SERVERMANAGER, 0, ManageUtils.getHostName(), new Date(), true); 
+	log = new StdoutSessionLog(serviceInstanceStatus.getID());
+	try {
+		conFactory = new cbit.sql.OraclePoolingConnectionFactory(log);
+	} catch (ClassNotFoundException e) {
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	} catch (IllegalAccessException e) {
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	} catch (InstantiationException e) {
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	}
+	keyFactory = new cbit.sql.OracleKeyFactory();	
+	DbDriver.setKeyFactory(keyFactory);
+	adminDbTop = new AdminDBTopLevel(conFactory,log);
+	
+	reconnect();
+}
+
+private void reconnect() throws JMSException {
+	jmsConnFactory = new JmsConnectionFactoryImpl();
+	
+	jmsConn = jmsConnFactory.createConnection();
+	topicSession = jmsConn.getAutoSession();
+	
+	listenSession = jmsConn.getAutoSession();
+	listenSession.setupTopicListener(JmsUtils.getTopicDaemonControl(), getMessageFilter(), new ControlMessageCollector(this));
+	jmsConn.startConnection();	
+}
+
+private void startAllServices() throws JMSException, SQLException, DataAccessException {
+	log.print("Starting all the services");
+	serviceList = Collections.synchronizedList(adminDbTop.getAllServiceStatus(true));	
+	
+	pingAll();	
+
+	Iterator<ServiceStatus> iter = serviceList.iterator();
+	while (iter.hasNext()) {
+		ServiceStatus service = iter.next();		
+		if (service.getServiceSpec().getStartupType() == SERVICE_STARTUPTYPE_AUTOMATIC) {			
+			boolean alive = false;
+			ServiceInstanceStatus foundSis = null; 
+			Iterator<ServiceInstanceStatus> aliveIter = serviceAliveList.iterator();
+			while (aliveIter.hasNext()) {
+				ServiceInstanceStatus sis = aliveIter.next();
+				if (sis.getSpecID().equals(service.getServiceSpec().getID())) {
+					if (alive) { // there are more than instances for the same service
+						if (foundSis.getStartDate().compareTo(sis.getStartDate()) > 0) { // kill the service with earlier start date
+							stopService(sis);
+						} else {
+							stopService(foundSis);
+							foundSis = sis;
+						}
+					} else {
+						alive = true;
+						foundSis = sis;
+					}
+				}
+			}
+			
+			if (!alive) {
+				try {
+					startAService(service);
+				} catch (Exception ex) {
+					ex.printStackTrace();
+				}
+			}
+		}
+	}	
+}
+
+private void stopService(ServiceInstanceStatus sis) {
+	try {			
+		Message msg = topicSession.createMessage();
+			
+		msg.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_STOPSERVICE_VALUE);
+		msg.setStringProperty(SERVICE_ID_PROPERTY, sis.getID());
+		
+		log.print("sending stop service message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);		
+		
+	} catch (Exception ex) {
+		ex.printStackTrace();
+	}	
+}
+
+private void startAService(ServiceStatus service) throws UpdateSynchronizationException, SQLException {
+	log.print("starting service " + service);
+	AdminDBTopLevel.TransactionalServiceOperation tso = new AdminDBTopLevel.TransactionalServiceOperation() {
+		public ServiceStatus doOperation(ServiceStatus oldStatus) throws Exception {
+			PbsJobID jobid = submit2PBS(oldStatus);
+			ServiceStatus newServiceStatus = null;
+			if (jobid == null) {
+				newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_FAILED, "unknown pbs exception",	jobid);
+			} else {
+				long t = System.currentTimeMillis();
+				int status;
+				while (true) {
+					try {
+						Thread.sleep(1000);
+					} catch (InterruptedException ex) {
+					}
+					
+					status = PBSUtils.getJobStatus(jobid);
+					if (PBSUtils.isJobExiting(status)){
+						// should never happen
+						newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_FAILED, "exit immediately after submit", jobid);	
+						break;
+					} else if (PBSUtils.isJobRunning(status)) {						
+						newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_RUNNING, "running", jobid);	
+						break;
+					} else if (System.currentTimeMillis() - t > 30 * MessageConstants.SECOND_IN_MS) {
+						String pendingReason = PBSUtils.getPendingReason(jobid);
+						PBSUtils.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+						newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_FAILED, 
+								"PBS Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")",
+								jobid);						
+						break;
+					}
+				}
+			} 			
+			return newServiceStatus;
+		}
+	};
+	
+	adminDbTop.updateServiceStatus(service, tso, true);
+}	
+
+private PbsJobID submit2PBS(ServiceStatus service) throws IOException, ExecutableException {
+	killService(service);
+	
+	String executable = PropertyLoader.getRequiredProperty(PropertyLoader.serviceSubmitScript);
+	
+	ServiceType type = service.getServiceSpec().getType();
+	int ordinal = service.getServiceSpec().getOrdinal();
+	String cmdArguments = VCellServerID.getSystemServerID().toString().toLowerCase() + " " 
+		+ type.getName() + " " + ordinal + " " + service.getServiceSpec().getMemoryMB(); // site, type, ordinal, memory
+	
+	File sub_file = File.createTempFile("service", ".pbs.sub");
+	log.print("PBS sub file  for service " + service.getServiceSpec() + " is " + sub_file.getAbsolutePath());
+	return PBSUtils.submitServiceJob((String)null, service.getServiceSpec().getID(), sub_file.getAbsolutePath(), executable, cmdArguments, 1, service.getServiceSpec().getMemoryMB());
+}
+/**
+ * This method was created in VisualAge.
+ * @return int
+ */
+private java.lang.String getMessageFilter() {
+	return MESSAGE_TYPE_PROPERTY + " NOT IN (" 
+		+ "'" + MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE + "'" 
+		+ ")";
+//		+ " OR (" + ManageConstants.MESSAGE_TYPE_PROPERTY + "='" + ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE + "'"
+//		+ " AND " + ManageConstants.SERVER_NAME_PROPERTY + " IS NOT NULL"
+//		+ ")";
+}
+
+/**
+ * onMessage method comment.
+ */
+public void onControlTopicMessage(Message message) {
+	try {		
+		log.print("onMessage [" + JmsUtils.toString(message) + "]");		
+			
+		String msgType = (String)JmsUtils.parseProperty(message, MESSAGE_TYPE_PROPERTY, String.class);
+		
+		if (msgType.equals(MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE)) {
+			Message reply = topicSession.createObjectMessage(serviceInstanceStatus);
+			reply.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE);
+			reply.setStringProperty(SERVICE_ID_PROPERTY, serviceInstanceStatus.getID());
+			topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), reply);			
+			log.print("sending reply [" + JmsUtils.toString(reply) + "]");			
+		} else if (msgType.equals(MESSAGE_TYPE_IAMALIVE_VALUE)) {
+			on_iamalive(message);			
+		} else if (msgType.equals(MESSAGE_TYPE_STARTSERVICE_VALUE)) {
+		} else if (msgType.equals(MESSAGE_TYPE_STOPSERVICE_VALUE)) {
+			on_stopservice(message);
+		} else if (msgType.equals(MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE)) {
+			synchronized (this) {
+				notify();
+			}						
+		}
+	} catch (Exception ex) {
+		log.exception(ex);
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 4:47:40 PM)
+ * @param args java.lang.String[]
+ */
+public static void main(String[] args) {	
+	try {
+		if (args.length > 1) {
+			System.out.println("Missing arguments: " + ServerManagerDaemon.class.getName() + " [logdir]");
+			System.exit(1);
+		}
+		
+		if (args.length == 1) {
+			File logdir = new File(args[0]);
+			if (!logdir.exists()) {
+				throw new RuntimeException("Log directory doesn't exist");
+			}
+				
+			// log file name:
+			// hostname_A_Data_0.log : alpha first data on hostname
+			// hostname_B_Db_0.log : beta first database on hostname
+			// hostname_R_Export_0.log : rel first export on hostname
+			File logfile = new File(logdir, "ServerManager_" + ManageUtils.getHostName() + ".log");
+			java.io.PrintStream ps = new PrintStream(new FileOutputStream(logfile), true); // don't append
+			System.setOut(ps);
+			System.setErr(ps);			
+		}
+		org.vcell.util.PropertyLoader.loadProperties();
+		VCMongoMessage.serviceStartup(ServiceName.serverManager, new Integer(0), args);
+		new ServerManagerDaemon().start();		
+	} catch (Throwable exc) {
+		exc.printStackTrace(System.out);
+		System.exit(1);
+	}
+}
+
+private void on_iamalive(Message message) throws JMSException  {
+	Object obj = ((ObjectMessage)message).getObject();			
+	if (obj instanceof ServiceInstanceStatus) {
+		ServiceInstanceStatus status = (ServiceInstanceStatus)obj;			
+		serviceAliveList.add(status);			
+	}
+}
+
+/**
+* This method was created in VisualAge.
+* @return int
+*/
+private void on_stopservice(Message message) throws JMSException {
+	try {
+		String serviceID = (String)JmsUtils.parseProperty(message, SERVICE_ID_PROPERTY, String.class);
+		
+		if (serviceID != null) {
+			if (serviceID.equals(serviceInstanceStatus.getID())) { // stop myself
+				System.exit(0);
+			}
+			Iterator<ServiceStatus> iter = serviceList.iterator();
+			while (iter.hasNext()) {
+				ServiceStatus service = iter.next();		
+				if (service.getServiceSpec().getID().equals(serviceID)) {
+					PbsJobID pbsJobId = service.getPbsJobId();
+					if (pbsJobId != null && PBSUtils.isJobRunning(pbsJobId)) {
+						try {
+							Thread.sleep(5 * MessageConstants.SECOND_IN_MS); // wait 5 seconds
+						} catch (InterruptedException ex) {							
+						}					
+						// if the service is not stopped, kill it from PBS
+						if (PBSUtils.isJobRunning(pbsJobId)) {
+							PBSUtils.killJob(pbsJobId);
+						}
+					}
+					break;
+				}
+			}
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+* onMessage method comment.
+*/
+private boolean ping(ServiceSpec service) throws JMSException {
+	Message msg = topicSession.createMessage();
+		
+	msg.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_ISSERVICEALIVE_VALUE);
+	msg.setStringProperty(SERVICE_ID_PROPERTY, service.getID());
+
+	log.print("sending ping message [" + JmsUtils.toString(msg) + "]");
+	
+	Message reply = topicSession.topicRequest(this, JmsUtils.getTopicDaemonControl(), msg, ManageConstants.INTERVAL_PING_RESPONSE);
+
+	log.print("got reply message [" + JmsUtils.toString(reply) + "]");
+
+	if (reply == null) {
+		return false;
+	} else {
+		try {
+			String msgType = (String)JmsUtils.parseProperty(reply, MESSAGE_TYPE_PROPERTY, String.class);
+			if (!msgType.equals(MESSAGE_TYPE_IAMALIVE_VALUE)) {
+				return false;
+			}
+		} catch (MessagePropertyNotFoundException ex) {
+			log.exception(ex);
+			return false;
+		}
+	}
+		
+	return true;
+}
+
+
+/**
+* onMessage method comment.
+*/
+private void pingAll() throws JMSException {
+	
+	serviceAliveList.clear();
+	
+	Message msg = topicSession.createMessage();
+		
+	msg.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_ISSERVICEALIVE_VALUE);
+
+	log.print("sending ping message [" + JmsUtils.toString(msg) + "]");
+	
+	topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);
+
+	try {
+		Thread.sleep(INTERVAL_PING_RESPONSE);
+	} catch (InterruptedException ex) {
+		ex.printStackTrace();
+	}
+}
+
+private void killService(ServiceStatus service) {
+	if (service.getPbsJobId() != null) {
+		PBSUtils.killJob(service.getPbsJobId());
+	}
+}
+/**
+* Insert the method's description here.
+* Creation date: (8/7/2003 5:12:22 PM)
+*/
+public void start() {
+	while (!stopped) {			
+		try {
+			startAllServices();
+		} catch (Throwable exc) {
+			log.exception(exc);
+		}		
+		try {
+			synchronized (this) {			
+				wait(INTERVAL_PING_SERVICE);
+			}
+		} catch (InterruptedException exc) {
+		}			
+	}
+}
+}
Index: src/cbit/vcell/messaging/admin/ManageConstants.java
===================================================================
--- src/cbit/vcell/messaging/admin/ManageConstants.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ManageConstants.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import org.vcell.util.MessageConstants;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/8/2003 10:23:15 AM)
+ * @author: Fei Gao
+ */
+public interface ManageConstants {
+	public static final long INTERVAL_PING_SERVICE = 10 * MessageConstants.MINUTE_IN_MS; // in minutes
+	public static final long INTERVAL_PING_RESPONSE = 10 * MessageConstants.SECOND_IN_MS; // in milliseconds
+
+	public static final String MESSAGE_TYPE_PROPERTY = MessageConstants.MESSAGE_TYPE_PROPERTY;
+	public static final String MESSAGE_TYPE_ISSERVICEALIVE_VALUE	= "IsServiceAlive";
+	public static final String MESSAGE_TYPE_IAMALIVE_VALUE	= "IAmAlive";		
+	public static final String MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE	= "AskPerformance";
+	public static final String MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE	= "RefreshServerManager";
+	public static final String MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE	= "ReplyPerformance";
+	public static final String MESSAGE_TYPE_STARTSERVICE_VALUE	= "StartService";
+	public static final String MESSAGE_TYPE_STOPSERVICE_VALUE	= "StopService";
+
+	public static final String MESSAGE_TYPE_BROADCASTMESSAGE_VALUE	= "BroadcastMessage";
+	public static final String BROADCASTMESSAGE_CONTENT_PROPERTY = "BroadcastMessageContent";
+
+	public static final String FILE_NAME_PROPERTY = "FileName";
+	public static final String FILE_LENGTH_PROPERTY = "FileLength";
+	
+	public static final int SERVICE_STARTUPTYPE_AUTOMATIC = 0;	// restart it if the service is dead 
+	public static final int SERVICE_STARTUPTYPE_MANUAL = 1;
+	
+	public static final String[] SERVICE_STARTUP_TYPES = {"automatic", "manual"};
+
+	public static final int SERVICE_STATUS_RUNNING = 0;	// restart it if the service is dead 
+	public static final int SERVICE_STATUS_NOTRUNNING = 1;	// restart it if the service is dead
+	public static final int SERVICE_STATUS_FAILED = 2; 	
+
+	public static final String[] SERVICE_STATUSES = {"running", "not running", "failed"};
+	
+	public static final String SERVICE_ID_PROPERTY	= "ServiceID";
+	
+	public static final String SERVERID_RELEASE = "REL";
+	public static final String SERVERID_ALPHA = "ALPHA";
+	public static final String SERVERID_BETA = "BETA";
+	
+	public static final String AllSites[] = {SERVERID_ALPHA, SERVERID_BETA, SERVERID_RELEASE};	
+}
Index: src/cbit/vcell/messaging/admin/SimulationJobStatusDetailDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/SimulationJobStatusDetailDialog.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/SimulationJobStatusDetailDialog.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,1727 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import javax.swing.BorderFactory;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (3/29/2004 1:36:39 PM)
+ * @author: Fei Gao
+ */
+public class SimulationJobStatusDetailDialog extends javax.swing.JDialog {
+	private static java.text.SimpleDateFormat dateTimeFormatter = new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss", java.util.Locale.US);
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private javax.swing.JLabel ivjJLabel1 = null;
+	private javax.swing.JLabel ivjJLabel2 = null;
+	private javax.swing.JLabel ivjJLabel3 = null;
+	private javax.swing.JLabel ivjJLabel4 = null;
+	private javax.swing.JLabel ivjJLabel5 = null;
+	private javax.swing.JLabel ivjJLabel6 = null;
+	private javax.swing.JPanel ivjJPanel1 = null;
+	private javax.swing.JPanel ivjJPanel2 = null;
+	private javax.swing.JPanel ivjJPanel3 = null;
+	private javax.swing.JScrollPane ivjJScrollPane1 = null;
+	private javax.swing.JTextField ivjComputeHostTextField = null;
+	private javax.swing.JTextField ivjEndDateTextField = null;
+	private javax.swing.JTextField ivjSimIDTextField = null;
+	private javax.swing.JTextField ivjStartDateTextField = null;
+	private javax.swing.JTextArea ivjStatusMessageTextArea = null;
+	private javax.swing.JTextField ivjSubmitDateTextField = null;
+	private javax.swing.JTextField ivjUserTextField = null;
+	private javax.swing.JPanel ivjJPanel4 = null;
+	private javax.swing.JPanel ivjJPanel5 = null;
+	private javax.swing.JPanel ivjJPanel6 = null;
+	private javax.swing.JPanel ivjJPanel7 = null;
+	private javax.swing.JPanel ivjJPanel8 = null;
+	private javax.swing.JPanel ivjJPanel9 = null;
+	private javax.swing.JButton ivjCloseButton = null;
+	IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private javax.swing.JPanel ivjJPanel10 = null;
+	private javax.swing.JPanel ivjJPanel11 = null;
+	private java.awt.GridLayout ivjJPanel11GridLayout = null;
+	private javax.swing.JScrollPane ivjJScrollPane2 = null;
+	private javax.swing.JTextArea ivjSolverDescTextArea = null;
+	private java.awt.BorderLayout ivjJDialogContentPaneBorderLayout = null;
+	private java.awt.GridLayout ivjJPanel1GridLayout = null;
+	private java.awt.GridLayout ivjJPanel2GridLayout = null;
+	private java.awt.GridLayout ivjJPanel3GridLayout = null;
+	private java.awt.FlowLayout ivjJPanel4FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel5FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel6FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel7FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel8FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel9FlowLayout = null;
+	private javax.swing.JButton ivjResubmitButton = null;
+	private javax.swing.JButton ivjStopButton = null;
+	private SimpleJobStatus jobStatus = null;
+	private ServerManageConsole smConsole = null;
+	private javax.swing.JPanel ivjJPanel12 = null;
+	private java.awt.FlowLayout ivjJPanel12FlowLayout = null;
+	private javax.swing.JPanel ivjJPanel13 = null;
+	private java.awt.FlowLayout ivjJPanel13FlowLayout = null;
+	private int currentSelected = -1;
+	private int totalNumber = 0;
+	private javax.swing.JButton ivjNextButton = null;
+	private javax.swing.JButton ivjPrevButton = null;
+	private javax.swing.JLabel ivjJLabel7 = null;
+	private javax.swing.JLabel ivjJLabel8 = null;
+	private javax.swing.JPanel ivjJPanel14 = null;
+	private java.awt.FlowLayout ivjJPanel14FlowLayout = null;
+	private javax.swing.JPanel ivjJPanel15 = null;
+	private java.awt.FlowLayout ivjJPanel15FlowLayout = null;
+	private javax.swing.JTextField ivjServerIDTextField = null;
+	private javax.swing.JTextField ivjTaskIDTextField = null;
+	private javax.swing.JTextField ivjJobIndexTextField = null;
+
+class IvjEventHandler implements java.awt.event.ActionListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getCloseButton()) 
+				connEtoC1(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getStopButton()) 
+				connEtoC2(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getResubmitButton()) 
+				connEtoC3(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getNextButton()) 
+				connEtoC5(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getPrevButton()) 
+				connEtoC6(e);
+		};
+	};
+
+/**
+ * SimulationJobStatusDetailDialog constructor comment.
+ */
+public SimulationJobStatusDetailDialog() {
+	super();
+	initialize();
+}
+
+/**
+ * SimulationJobStatusDetailDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public SimulationJobStatusDetailDialog(ServerManageConsole console, int total, int selected) {
+	super(console, true);
+	smConsole = console;
+	totalNumber = total;
+	currentSelected = selected;
+	setStatus();
+	initialize();
+}
+
+
+/**
+ * Comment
+ */
+public void closeButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	dispose();
+	return;
+}
+
+
+/**
+ * connEtoC1:  (CloseButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.closeButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.closeButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC2:  (StopButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.stopButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC2(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.stopButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC3:  (ResubmitButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.resubmitButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC3(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.resubmitButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC4:  (SimulationJobStatusDetailDialog.initialize() --> SimulationJobStatusDetailDialog.simulationJobStatusDetailDialog_Initialize()V)
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC4() {
+	try {
+		// user code begin {1}
+		// user code end
+		this.simulationJobStatusDetailDialog_Initialize();
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC5:  (NextButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.nextButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC5(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.nextButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC6:  (PrevButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.prevButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC6(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.prevButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * Return the CloseButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getCloseButton() {
+	if (ivjCloseButton == null) {
+		try {
+			ivjCloseButton = new javax.swing.JButton();
+			ivjCloseButton.setName("CloseButton");
+			ivjCloseButton.setText("Close");
+			ivjCloseButton.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjCloseButton;
+}
+
+/**
+ * Return the JTextField5 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getComputeHostTextField() {
+	if (ivjComputeHostTextField == null) {
+		try {
+			ivjComputeHostTextField = new javax.swing.JTextField();
+			ivjComputeHostTextField.setName("ComputeHostTextField");
+			ivjComputeHostTextField.setEditable(false);
+			ivjComputeHostTextField.setColumns(18);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjComputeHostTextField;
+}
+
+/**
+ * Return the JTextField6 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getEndDateTextField() {
+	if (ivjEndDateTextField == null) {
+		try {
+			ivjEndDateTextField = new javax.swing.JTextField();
+			ivjEndDateTextField.setName("EndDateTextField");
+			ivjEndDateTextField.setEditable(false);
+			ivjEndDateTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjEndDateTextField;
+}
+
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(getJDialogContentPaneBorderLayout());
+			getJDialogContentPane().add(getJPanel1(), "North");
+			getJDialogContentPane().add(getJPanel10(), "South");
+			getJDialogContentPane().add(getJPanel11(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+
+/**
+ * Return the JDialogContentPaneBorderLayout property value.
+ * @return java.awt.BorderLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.BorderLayout getJDialogContentPaneBorderLayout() {
+	java.awt.BorderLayout ivjJDialogContentPaneBorderLayout = null;
+	try {
+		/* Create part */
+		ivjJDialogContentPaneBorderLayout = new java.awt.BorderLayout();
+		ivjJDialogContentPaneBorderLayout.setVgap(5);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJDialogContentPaneBorderLayout;
+}
+
+/**
+ * Return the JLabel1 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel1() {
+	if (ivjJLabel1 == null) {
+		try {
+			ivjJLabel1 = new javax.swing.JLabel();
+			ivjJLabel1.setName("JLabel1");
+			ivjJLabel1.setText("User ID");
+			ivjJLabel1.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel1.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel1.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel1;
+}
+
+/**
+ * Return the JLabel2 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel2() {
+	if (ivjJLabel2 == null) {
+		try {
+			ivjJLabel2 = new javax.swing.JLabel();
+			ivjJLabel2.setName("JLabel2");
+			ivjJLabel2.setText("Sim ID");
+			ivjJLabel2.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel2.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel2.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel2;
+}
+
+/**
+ * Return the JLabel3 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel3() {
+	if (ivjJLabel3 == null) {
+		try {
+			ivjJLabel3 = new javax.swing.JLabel();
+			ivjJLabel3.setName("JLabel3");
+			ivjJLabel3.setText("Compute Host");
+			ivjJLabel3.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel3.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel3.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel3;
+}
+
+/**
+ * Return the JLabel4 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel4() {
+	if (ivjJLabel4 == null) {
+		try {
+			ivjJLabel4 = new javax.swing.JLabel();
+			ivjJLabel4.setName("JLabel4");
+			ivjJLabel4.setText("Submit Date");
+			ivjJLabel4.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel4.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel4.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel4.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel4;
+}
+
+/**
+ * Return the JLabel5 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel5() {
+	if (ivjJLabel5 == null) {
+		try {
+			ivjJLabel5 = new javax.swing.JLabel();
+			ivjJLabel5.setName("JLabel5");
+			ivjJLabel5.setText("Start Date");
+			ivjJLabel5.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel5.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel5.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel5.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel5;
+}
+
+/**
+ * Return the JLabel6 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel6() {
+	if (ivjJLabel6 == null) {
+		try {
+			ivjJLabel6 = new javax.swing.JLabel();
+			ivjJLabel6.setName("JLabel6");
+			ivjJLabel6.setText("End Date");
+			ivjJLabel6.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel6.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel6.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel6.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel6;
+}
+
+/**
+ * Return the JLabel7 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel7() {
+	if (ivjJLabel7 == null) {
+		try {
+			ivjJLabel7 = new javax.swing.JLabel();
+			ivjJLabel7.setName("JLabel7");
+			ivjJLabel7.setText("Server ID");
+			ivjJLabel7.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel7.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel7.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel7.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel7;
+}
+
+/**
+ * Return the JLabel8 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel8() {
+	if (ivjJLabel8 == null) {
+		try {
+			ivjJLabel8 = new javax.swing.JLabel();
+			ivjJLabel8.setName("JLabel8");
+			ivjJLabel8.setText("Task ID");
+			ivjJLabel8.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel8.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel8.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel8.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel8;
+}
+
+/**
+ * Return the JobIndexTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getJobIndexTextField() {
+	if (ivjJobIndexTextField == null) {
+		try {
+			ivjJobIndexTextField = new javax.swing.JTextField();
+			ivjJobIndexTextField.setName("JobIndexTextField");
+			ivjJobIndexTextField.setEditable(false);
+			ivjJobIndexTextField.setColumns(4);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJobIndexTextField;
+}
+
+/**
+ * Return the JPanel1 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel1() {
+	if (ivjJPanel1 == null) {
+		try {
+			ivjJPanel1 = new javax.swing.JPanel();
+			ivjJPanel1.setName("JPanel1");
+			ivjJPanel1.setLayout(getJPanel1GridLayout());
+			getJPanel1().add(getJPanel2(), getJPanel2().getName());
+			getJPanel1().add(getJPanel3(), getJPanel3().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel1;
+}
+
+
+/**
+ * Return the JPanel10 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel10() {
+	if (ivjJPanel10 == null) {
+		try {
+			ivjJPanel10 = new javax.swing.JPanel();
+			ivjJPanel10.setName("JPanel10");
+			ivjJPanel10.setLayout(new java.awt.GridLayout());
+			getJPanel10().add(getJPanel12(), getJPanel12().getName());
+			getJPanel10().add(getJPanel13(), getJPanel13().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel10;
+}
+
+/**
+ * Return the JPanel11 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel11() {
+	if (ivjJPanel11 == null) {
+		try {
+			ivjJPanel11 = new javax.swing.JPanel();
+			ivjJPanel11.setName("JPanel11");
+			ivjJPanel11.setLayout(getJPanel11GridLayout());
+			getJPanel11().add(getJScrollPane2(), getJScrollPane2().getName());
+			getJPanel11().add(getJScrollPane1(), getJScrollPane1().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel11;
+}
+
+
+/**
+ * Return the JPanel11GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel11GridLayout() {
+	java.awt.GridLayout ivjJPanel11GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel11GridLayout = new java.awt.GridLayout(0, 1);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel11GridLayout;
+}
+
+
+/**
+ * Return the JPanel12 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel12() {
+	if (ivjJPanel12 == null) {
+		try {
+			ivjJPanel12 = new javax.swing.JPanel();
+			ivjJPanel12.setName("JPanel12");
+			ivjJPanel12.setLayout(getJPanel12FlowLayout());
+			getJPanel12().add(getStopButton(), getStopButton().getName());
+			getJPanel12().add(getResubmitButton(), getResubmitButton().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel12;
+}
+
+/**
+ * Return the JPanel12FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel12FlowLayout() {
+	java.awt.FlowLayout ivjJPanel12FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel12FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel12FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel12FlowLayout;
+}
+
+/**
+ * Return the JPanel13 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel13() {
+	if (ivjJPanel13 == null) {
+		try {
+			ivjJPanel13 = new javax.swing.JPanel();
+			ivjJPanel13.setName("JPanel13");
+			ivjJPanel13.setLayout(getJPanel13FlowLayout());
+			getJPanel13().add(getPrevButton(), getPrevButton().getName());
+			getJPanel13().add(getNextButton(), getNextButton().getName());
+			getJPanel13().add(getCloseButton(), getCloseButton().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel13;
+}
+
+/**
+ * Return the JPanel13FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel13FlowLayout() {
+	java.awt.FlowLayout ivjJPanel13FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel13FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel13FlowLayout.setAlignment(java.awt.FlowLayout.RIGHT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel13FlowLayout;
+}
+
+
+/**
+ * Return the JPanel14 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel14() {
+	if (ivjJPanel14 == null) {
+		try {
+			ivjJPanel14 = new javax.swing.JPanel();
+			ivjJPanel14.setName("JPanel14");
+			ivjJPanel14.setLayout(getJPanel14FlowLayout());
+			getJPanel14().add(getJLabel7(), getJLabel7().getName());
+			getJPanel14().add(getServerIDTextField(), getServerIDTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel14;
+}
+
+
+/**
+ * Return the JPanel14FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel14FlowLayout() {
+	java.awt.FlowLayout ivjJPanel14FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel14FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel14FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel14FlowLayout;
+}
+
+
+/**
+ * Return the JPanel15 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel15() {
+	if (ivjJPanel15 == null) {
+		try {
+			ivjJPanel15 = new javax.swing.JPanel();
+			ivjJPanel15.setName("JPanel15");
+			ivjJPanel15.setLayout(getJPanel15FlowLayout());
+			getJPanel15().add(getJLabel8(), getJLabel8().getName());
+			getJPanel15().add(getTaskIDTextField(), getTaskIDTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel15;
+}
+
+
+/**
+ * Return the JPanel15FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel15FlowLayout() {
+	java.awt.FlowLayout ivjJPanel15FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel15FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel15FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel15FlowLayout;
+}
+
+
+/**
+ * Return the JPanel1GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel1GridLayout() {
+	java.awt.GridLayout ivjJPanel1GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel1GridLayout = new java.awt.GridLayout(0, 2);
+		ivjJPanel1GridLayout.setHgap(2);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel1GridLayout;
+}
+
+/**
+ * Return the JPanel2 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel2() {
+	if (ivjJPanel2 == null) {
+		try {
+			ivjJPanel2 = new javax.swing.JPanel();
+			ivjJPanel2.setName("JPanel2");
+			ivjJPanel2.setLayout(getJPanel2GridLayout());
+			getJPanel2().add(getJPanel4(), getJPanel4().getName());
+			getJPanel2().add(getJPanel5(), getJPanel5().getName());
+			getJPanel2().add(getJPanel6(), getJPanel6().getName());
+			getJPanel2().add(getJPanel14(), getJPanel14().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel2;
+}
+
+/**
+ * Return the JPanel2GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel2GridLayout() {
+	java.awt.GridLayout ivjJPanel2GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel2GridLayout = new java.awt.GridLayout(0, 1);
+		ivjJPanel2GridLayout.setVgap(3);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel2GridLayout;
+}
+
+/**
+ * Return the JPanel3 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel3() {
+	if (ivjJPanel3 == null) {
+		try {
+			ivjJPanel3 = new javax.swing.JPanel();
+			ivjJPanel3.setName("JPanel3");
+			ivjJPanel3.setLayout(getJPanel3GridLayout());
+			getJPanel3().add(getJPanel7(), getJPanel7().getName());
+			getJPanel3().add(getJPanel8(), getJPanel8().getName());
+			getJPanel3().add(getJPanel9(), getJPanel9().getName());
+			getJPanel3().add(getJPanel15(), getJPanel15().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel3;
+}
+
+/**
+ * Return the JPanel3GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel3GridLayout() {
+	java.awt.GridLayout ivjJPanel3GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel3GridLayout = new java.awt.GridLayout(0, 1);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel3GridLayout;
+}
+
+/**
+ * Return the JPanel4 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel4() {
+	if (ivjJPanel4 == null) {
+		try {
+			ivjJPanel4 = new javax.swing.JPanel();
+			ivjJPanel4.setName("JPanel4");
+			ivjJPanel4.setLayout(getJPanel4FlowLayout());
+			getJPanel4().add(getJLabel1(), getJLabel1().getName());
+			getJPanel4().add(getUserTextField(), getUserTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel4;
+}
+
+
+/**
+ * Return the JPanel4FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel4FlowLayout() {
+	java.awt.FlowLayout ivjJPanel4FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel4FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel4FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel4FlowLayout;
+}
+
+
+/**
+ * Return the JPanel5 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel5() {
+	if (ivjJPanel5 == null) {
+		try {
+			ivjJPanel5 = new javax.swing.JPanel();
+			ivjJPanel5.setName("JPanel5");
+			ivjJPanel5.setLayout(getJPanel5FlowLayout());
+			getJPanel5().add(getJLabel2(), getJLabel2().getName());
+			getJPanel5().add(getSimIDTextField(), getSimIDTextField().getName());
+			getJPanel5().add(getJobIndexTextField(), getJobIndexTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel5;
+}
+
+/**
+ * Return the JPanel5FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel5FlowLayout() {
+	java.awt.FlowLayout ivjJPanel5FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel5FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel5FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel5FlowLayout;
+}
+
+
+/**
+ * Return the JPanel6 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel6() {
+	if (ivjJPanel6 == null) {
+		try {
+			ivjJPanel6 = new javax.swing.JPanel();
+			ivjJPanel6.setName("JPanel6");
+			ivjJPanel6.setLayout(getJPanel6FlowLayout());
+			getJPanel6().add(getJLabel3(), getJLabel3().getName());
+			getJPanel6().add(getComputeHostTextField(), getComputeHostTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel6;
+}
+
+
+/**
+ * Return the JPanel6FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel6FlowLayout() {
+	java.awt.FlowLayout ivjJPanel6FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel6FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel6FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel6FlowLayout;
+}
+
+
+/**
+ * Return the JPanel7 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel7() {
+	if (ivjJPanel7 == null) {
+		try {
+			ivjJPanel7 = new javax.swing.JPanel();
+			ivjJPanel7.setName("JPanel7");
+			ivjJPanel7.setLayout(getJPanel7FlowLayout());
+			getJPanel7().add(getJLabel4(), getJLabel4().getName());
+			getJPanel7().add(getSubmitDateTextField(), getSubmitDateTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel7;
+}
+
+
+/**
+ * Return the JPanel7FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel7FlowLayout() {
+	java.awt.FlowLayout ivjJPanel7FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel7FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel7FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel7FlowLayout;
+}
+
+
+/**
+ * Return the JPanel8 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel8() {
+	if (ivjJPanel8 == null) {
+		try {
+			ivjJPanel8 = new javax.swing.JPanel();
+			ivjJPanel8.setName("JPanel8");
+			ivjJPanel8.setLayout(getJPanel8FlowLayout());
+			getJPanel8().add(getJLabel5(), getJLabel5().getName());
+			getJPanel8().add(getStartDateTextField(), getStartDateTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel8;
+}
+
+
+/**
+ * Return the JPanel8FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel8FlowLayout() {
+	java.awt.FlowLayout ivjJPanel8FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel8FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel8FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel8FlowLayout;
+}
+
+
+/**
+ * Return the JPanel9 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel9() {
+	if (ivjJPanel9 == null) {
+		try {
+			ivjJPanel9 = new javax.swing.JPanel();
+			ivjJPanel9.setName("JPanel9");
+			ivjJPanel9.setLayout(getJPanel9FlowLayout());
+			getJPanel9().add(getJLabel6(), getJLabel6().getName());
+			getJPanel9().add(getEndDateTextField(), getEndDateTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel9;
+}
+
+
+/**
+ * Return the JPanel9FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel9FlowLayout() {
+	java.awt.FlowLayout ivjJPanel9FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel9FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel9FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel9FlowLayout;
+}
+
+
+/**
+ * Return the JScrollPane1 property value.
+ * @return javax.swing.JScrollPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JScrollPane getJScrollPane1() {
+	if (ivjJScrollPane1 == null) {
+		try {
+			ivjJScrollPane1 = new javax.swing.JScrollPane();
+			ivjJScrollPane1.setName("JScrollPane1");
+			ivjJScrollPane1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), "Status Message"));
+			getJScrollPane1().setViewportView(getStatusMessageTextArea());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJScrollPane1;
+}
+
+/**
+ * Return the JScrollPane2 property value.
+ * @return javax.swing.JScrollPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JScrollPane getJScrollPane2() {
+	if (ivjJScrollPane2 == null) {
+		try {
+			ivjJScrollPane2 = new javax.swing.JScrollPane();
+			ivjJScrollPane2.setName("JScrollPane2");
+			ivjJScrollPane2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), "Solver Description"));
+			getJScrollPane2().setViewportView(getSolverDescTextArea());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJScrollPane2;
+}
+
+/**
+ * Return the NextButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getNextButton() {
+	if (ivjNextButton == null) {
+		try {
+			ivjNextButton = new javax.swing.JButton();
+			ivjNextButton.setName("NextButton");
+			ivjNextButton.setText("Next");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNextButton;
+}
+
+
+/**
+ * Return the PrevButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getPrevButton() {
+	if (ivjPrevButton == null) {
+		try {
+			ivjPrevButton = new javax.swing.JButton();
+			ivjPrevButton.setName("PrevButton");
+			ivjPrevButton.setText("Previous");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjPrevButton;
+}
+
+
+/**
+ * Return the ResubmitButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getResubmitButton() {
+	if (ivjResubmitButton == null) {
+		try {
+			ivjResubmitButton = new javax.swing.JButton();
+			ivjResubmitButton.setName("ResubmitButton");
+			ivjResubmitButton.setToolTipText("For Admin Use");
+			ivjResubmitButton.setText("Re-Submit");
+			ivjResubmitButton.setForeground(java.awt.Color.blue);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjResubmitButton;
+}
+
+/**
+ * Return the ServerIDTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getServerIDTextField() {
+	if (ivjServerIDTextField == null) {
+		try {
+			ivjServerIDTextField = new javax.swing.JTextField();
+			ivjServerIDTextField.setName("ServerIDTextField");
+			ivjServerIDTextField.setEditable(false);
+			ivjServerIDTextField.setColumns(18);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjServerIDTextField;
+}
+
+
+/**
+ * Return the JTextField2 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getSimIDTextField() {
+	if (ivjSimIDTextField == null) {
+		try {
+			ivjSimIDTextField = new javax.swing.JTextField();
+			ivjSimIDTextField.setName("SimIDTextField");
+			ivjSimIDTextField.setEditable(false);
+			ivjSimIDTextField.setColumns(12);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSimIDTextField;
+}
+
+/**
+ * Return the JTextArea1 property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getSolverDescTextArea() {
+	if (ivjSolverDescTextArea == null) {
+		try {
+			ivjSolverDescTextArea = new javax.swing.JTextArea();
+			ivjSolverDescTextArea.setName("SolverDescTextArea");
+			ivjSolverDescTextArea.setRows(0);
+			ivjSolverDescTextArea.setBackground(java.awt.Color.white);
+			ivjSolverDescTextArea.setBounds(0, 0, 1, 1);
+			ivjSolverDescTextArea.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSolverDescTextArea;
+}
+
+/**
+ * Return the JTextField4 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getStartDateTextField() {
+	if (ivjStartDateTextField == null) {
+		try {
+			ivjStartDateTextField = new javax.swing.JTextField();
+			ivjStartDateTextField.setName("StartDateTextField");
+			ivjStartDateTextField.setEditable(false);
+			ivjStartDateTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStartDateTextField;
+}
+
+/**
+ * Return the JTextArea1 property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getStatusMessageTextArea() {
+	if (ivjStatusMessageTextArea == null) {
+		try {
+			ivjStatusMessageTextArea = new javax.swing.JTextArea();
+			ivjStatusMessageTextArea.setName("StatusMessageTextArea");
+			ivjStatusMessageTextArea.setLineWrap(true);
+			ivjStatusMessageTextArea.setWrapStyleWord(true);
+			ivjStatusMessageTextArea.setRows(0);
+			ivjStatusMessageTextArea.setBounds(0, 1, 1, 3);
+			ivjStatusMessageTextArea.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStatusMessageTextArea;
+}
+
+/**
+ * Return the StopButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getStopButton() {
+	if (ivjStopButton == null) {
+		try {
+			ivjStopButton = new javax.swing.JButton();
+			ivjStopButton.setName("StopButton");
+			ivjStopButton.setToolTipText("For Admin Use");
+			ivjStopButton.setText("Stop");
+			ivjStopButton.setForeground(java.awt.Color.red);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStopButton;
+}
+
+/**
+ * Return the JTextField3 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getSubmitDateTextField() {
+	if (ivjSubmitDateTextField == null) {
+		try {
+			ivjSubmitDateTextField = new javax.swing.JTextField();
+			ivjSubmitDateTextField.setName("SubmitDateTextField");
+			ivjSubmitDateTextField.setEditable(false);
+			ivjSubmitDateTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSubmitDateTextField;
+}
+
+/**
+ * Return the TaskIDTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getTaskIDTextField() {
+	if (ivjTaskIDTextField == null) {
+		try {
+			ivjTaskIDTextField = new javax.swing.JTextField();
+			ivjTaskIDTextField.setName("TaskIDTextField");
+			ivjTaskIDTextField.setEditable(false);
+			ivjTaskIDTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjTaskIDTextField;
+}
+
+/**
+ * Return the JTextField1 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getUserTextField() {
+	if (ivjUserTextField == null) {
+		try {
+			ivjUserTextField = new javax.swing.JTextField();
+			ivjUserTextField.setName("UserTextField");
+			ivjUserTextField.setEditable(false);
+			ivjUserTextField.setColumns(18);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjUserTextField;
+}
+
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+
+
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getCloseButton().addActionListener(ivjEventHandler);
+	getStopButton().addActionListener(ivjEventHandler);
+	getResubmitButton().addActionListener(ivjEventHandler);
+	getNextButton().addActionListener(ivjEventHandler);
+	getPrevButton().addActionListener(ivjEventHandler);
+}
+
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("SimulationJobStatusDetailDialog");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+		setSize(561, 428);
+		setTitle("Simulation Status");
+		setContentPane(getJDialogContentPane());
+		initConnections();
+		connEtoC4();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		SimulationJobStatusDetailDialog aSimulationJobStatusDetailDialog;
+		aSimulationJobStatusDetailDialog = new SimulationJobStatusDetailDialog();
+		aSimulationJobStatusDetailDialog.setModal(true);
+		aSimulationJobStatusDetailDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aSimulationJobStatusDetailDialog.show();
+		java.awt.Insets insets = aSimulationJobStatusDetailDialog.getInsets();
+		aSimulationJobStatusDetailDialog.setSize(aSimulationJobStatusDetailDialog.getWidth() + insets.left + insets.right, aSimulationJobStatusDetailDialog.getHeight() + insets.top + insets.bottom);
+		aSimulationJobStatusDetailDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void nextButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	currentSelected ++;
+	setStatus();
+}
+
+
+/**
+ * Comment
+ */
+public void prevButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	currentSelected --;
+	setStatus();
+}
+
+
+/**
+ * Comment
+ */
+public void resubmitButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	int n = javax.swing.JOptionPane.showConfirmDialog(this, "Are you sure you would like to resubmit this simulation?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+	if (n == javax.swing.JOptionPane.YES_OPTION) {	
+		resubmitSimulation();
+		getResubmitButton().setEnabled(false);
+		getStopButton().setEnabled(true);
+	}		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:15:52 PM)
+ */
+public void resubmitSimulation() {
+	smConsole.resubmitSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:05:24 PM)
+ */
+public void setStatus() {
+	jobStatus = smConsole.getReturnedSimulationJobStatus(currentSelected);
+	setTitle("Simulation Status [" + jobStatus.getUserID() + "," + jobStatus.getVCSimulationIdentifier().getSimulationKey() + "]");
+	getUserTextField().setText(jobStatus.getUserID());
+	getSimIDTextField().setText(jobStatus.getVCSimulationIdentifier().getSimulationKey() + "");
+	getJobIndexTextField().setText(jobStatus.getJobIndex() + "");
+	getComputeHostTextField().setText(jobStatus.getComputeHost());
+	getSubmitDateTextField().setText(jobStatus.getSubmitDate() == null ? "" : dateTimeFormatter.format(jobStatus.getSubmitDate()));
+	getStartDateTextField().setText(jobStatus.getStartDate() == null ? "" : dateTimeFormatter.format(jobStatus.getStartDate()));
+	getEndDateTextField().setText(jobStatus.getEndDate() == null ? "" : dateTimeFormatter.format(jobStatus.getEndDate()));
+	getServerIDTextField().setText(jobStatus.getEndDate() == null ? "" : jobStatus.getServerID());
+	getTaskIDTextField().setText(jobStatus.getTaskID() == null ? "" : jobStatus.getTaskID() + "");
+	getSolverDescTextArea().setText(jobStatus.getSolverDescriptionVCML());
+	getSolverDescTextArea().setCaretPosition(0);
+	getStatusMessageTextArea().setText(jobStatus.getStatusMessage());
+	getStatusMessageTextArea().setCaretPosition(0);
+	getStopButton().setEnabled(false);
+	getResubmitButton().setEnabled(false);
+	if (jobStatus.isDone()) {
+		getResubmitButton().setEnabled(true);		
+	} else {
+		getStopButton().setEnabled(true);
+	}
+	
+	if (currentSelected <= 0) {
+		getPrevButton().setEnabled(false);
+	} else {
+		getPrevButton().setEnabled(true);
+	}
+
+	if (currentSelected >= totalNumber - 1) {
+		getNextButton().setEnabled(false);
+	} else {
+		getNextButton().setEnabled(true);
+	}
+	smConsole.setSelectedReturnedSimulationJobStatus(currentSelected);
+}
+
+
+/**
+ * Comment
+ */
+public void simulationJobStatusDetailDialog_Initialize() {
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void stopButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	int n = javax.swing.JOptionPane.showConfirmDialog(this, "Are you sure you would like to stop this simulation?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+	if (n == javax.swing.JOptionPane.YES_OPTION) {	
+		stopSimulation();
+		getStopButton().setEnabled(false);
+		getResubmitButton().setEnabled(true);
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:15:42 PM)
+ */
+public void stopSimulation() {
+	smConsole.stopSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+}
+}
Index: src/cbit/vcell/messaging/admin/UserConnectionTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/UserConnectionTableModel.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/UserConnectionTableModel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.util.Comparator;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+/**
+ * Insert the type's description here.
+ * Creation date: (2/27/2006 10:21:21 AM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class UserConnectionTableModel extends VCellSortTableModel<ComparableObject> {
+	private final static int columnIndex_UserID = 0;
+	//private final static int columnIndex_ElapsedTime = 2;
+	//private final static int columnIndex_ConnectedTime = 1;
+
+/**
+ * UserConnectionTableModel constructor comment.
+ */
+public UserConnectionTableModel() {
+	super(new String[]{"User ID"});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2003 2:14:05 PM)
+ * @return java.lang.Class
+ * @param columnIndex int
+ */
+public Class<?> getColumnClass(int columnIndex) {
+	if (columnIndex == columnIndex_UserID) {
+		return String.class;
+	}
+
+	return null;
+}
+
+
+	/**
+	 * Returns an attribute value for the cell at <I>columnIndex</I>
+	 * and <I>rowIndex</I>.
+	 *
+	 * @param	rowIndex	the row whose value is to be looked up
+	 * @param	columnIndex 	the column whose value is to be looked up
+	 * @return	the value Object at the specified cell
+	 */
+public Object getValueAt(int row, int col) {
+	ComparableObject userconn = getValueAt(row);
+	Object[] values = userconn.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+}
Index: src/cbit/vcell/messaging/admin/ServerPerformance.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServerPerformance.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServerPerformance.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * This type was created in VisualAge.
+ */
+public class ServerPerformance extends Performance {
+	
+	private float fractionFreeCPU = 0.0f;
+	private long freeMemoryBytes = -1;
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServerPerformance() {		
+}
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServerPerformance(float aFractionFreeCPU, long aFreeMemoryBytes, long aFreeJavaMemoryBytes, long aTotalJavaMemoryBytes, long aMaxJavaMemoryBytes) {		
+	this.fractionFreeCPU = aFractionFreeCPU;
+	this.freeMemoryBytes = aFreeMemoryBytes;
+	this.freeJavaMemoryBytes = aFreeJavaMemoryBytes;
+	this.totalJavaMemoryBytes = aTotalJavaMemoryBytes;
+	this.maxJavaMemoryBytes = aMaxJavaMemoryBytes;	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/28/01 7:04:11 PM)
+ * @return long
+ */
+public long getAvaillableJavaMemoryBytes() {
+
+	double JVM_MEMORY_TRUST_FACTOR = 0.8;
+	long currentJVMUsage = getTotalJavaMemoryBytes()-getFreeJavaMemoryBytes();
+	
+	return (long)(JVM_MEMORY_TRUST_FACTOR*(getMaxJavaMemoryBytes() - currentJVMUsage));
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public float getFractionFreeCPU() {
+	return fractionFreeCPU;
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getFreeMemoryBytes() {
+	return freeMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public Object[] toObjects() {
+	return new Object[] {		
+		(new Double(getFractionFreeCPU()*100.0)),
+		new Long(getFreeMemoryBytes()),
+		new Long(getFreeJavaMemoryBytes()), new Long(getTotalJavaMemoryBytes()),  new Long(getMaxJavaMemoryBytes())
+	};
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public String toString() {
+	return "ServerPerformanceStatus: "+					
+			"FreeMemory="+getFreeMemoryBytes()+" bytes, "+
+			"FreeCPU="+(getFractionFreeCPU()*100.0)+"%\n"+
+			"JVM Memory (free="+getFreeJavaMemoryBytes()+", total="+getTotalJavaMemoryBytes()+", max="+getMaxJavaMemoryBytes()+") bytes";
+}
+}
Index: src/cbit/vcell/messaging/admin/SimpleJobStatus.java
===================================================================
--- src/cbit/vcell/messaging/admin/SimpleJobStatus.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/SimpleJobStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import java.math.BigDecimal;
+
+import org.vcell.util.ComparableObject;
+
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.solver.SolverTaskDescription;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/3/2003 10:39:26 AM)
+ * @author: Fei Gao
+ */
+public class SimpleJobStatus implements ComparableObject {
+	private String userID = null;
+	private SimulationJobStatus jobStatus = null;
+	private SolverTaskDescription solverTaskDesc = null;
+	private Long elapsedTime = null;
+
+/**
+ * SimpleJobStatus constructor comment.
+ */
+public SimpleJobStatus(String user, SimulationJobStatus arg_jobStatus, SolverTaskDescription arg_solverTaskDesc) {	
+	super();
+	this.userID = user;
+	this.jobStatus = arg_jobStatus;
+	this.solverTaskDesc = arg_solverTaskDesc;
+	this.elapsedTime = null;
+	if (getStartDate()!=null){
+		if (getEndDate()!=null){
+			this.elapsedTime = ((getEndDate().getTime()-getStartDate().getTime()));
+		}else if (jobStatus.isRunning()){
+			this.elapsedTime = ((System.currentTimeMillis()-getStartDate().getTime()));
+		}
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getComputeHost() {
+	if (jobStatus == null) {
+		return null;
+	}	
+	return jobStatus.getComputeHost();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.util.Date
+ */
+public java.util.Date getEndDate() {
+	if (jobStatus == null) {
+		return null;
+	}
+	return jobStatus.getEndDate();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public Integer getJobIndex() {
+	if (jobStatus == null || jobStatus.getServerID() == null) {
+		return null;
+	}	
+	return new Integer(jobStatus.getJobIndex());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getServerID() {
+	if (jobStatus == null || jobStatus.getServerID() == null) {
+		return null;
+	}	
+	return jobStatus.getServerID().toString();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/8/2004 1:29:11 PM)
+ * @return java.lang.String
+ */
+public String getSolverDescriptionVCML() {
+	if (solverTaskDesc == null) {
+		return "Error: Null Solver Description";
+	}
+	return solverTaskDesc.getVCML();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.util.Date
+ */
+public java.util.Date getStartDate() {
+	if (jobStatus == null) {
+		return null;
+	}
+	return jobStatus.getStartDate();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 2:47:11 PM)
+ * @return java.lang.String
+ */
+public String getStatusMessage() {
+	return jobStatus.getSimulationMessage().getDisplayMessage();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.util.Date
+ */
+public java.util.Date getSubmitDate() {
+	return jobStatus.getSubmitDate();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public Integer getTaskID() {
+	if (jobStatus == null || jobStatus.getServerID() == null) {
+		return null;
+	}	
+	return new Integer(jobStatus.getTaskID());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getUserID() {
+	return userID;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 2:54:17 PM)
+ * @return cbit.sql.KeyValue
+ */
+public VCSimulationIdentifier getVCSimulationIdentifier() {
+	return jobStatus.getVCSimulationIdentifier();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:21:23 PM)
+ * @return boolean
+ */
+public boolean isDone() {
+	return jobStatus.isDone();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/7/2004 8:53:02 AM)
+ * @return boolean
+ */
+public boolean isRunning() {
+	return jobStatus.isRunning();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/3/2003 10:45:39 AM)
+ * @return java.lang.String[]
+ */
+public Object[] toObjects() {	
+	return new Object[] {userID,  new BigDecimal(getVCSimulationIdentifier().getSimulationKey().toString()), getJobIndex(), 
+		solverTaskDesc == null || solverTaskDesc.getSolverDescription() == null ? "" : solverTaskDesc.getSolverDescription().getDisplayLabel(), 		
+		getStatusMessage(), getComputeHost(), getServerID(), getTaskID(), getSubmitDate(), getStartDate(), getEndDate(),
+		elapsedTime};
+}
+}
Index: src/cbit/vcell/messaging/admin/SolverTaskDescriptionRenderer.java
===================================================================
--- src/cbit/vcell/messaging/admin/SolverTaskDescriptionRenderer.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/SolverTaskDescriptionRenderer.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+/**
+ * Insert the type's description here.
+ * Creation date: (7/8/2004 2:26:27 PM)
+ * @author: Fei Gao
+ */
+public class SolverTaskDescriptionRenderer extends javax.swing.table.DefaultTableCellRenderer {
+/**
+ * SolverTaskDescriptionRenderer constructor comment.
+ */
+public SolverTaskDescriptionRenderer() {
+	super();
+}
+
+
+	/**
+	 *  This method is sent to the renderer by the drawing table to
+	 *  configure the renderer appropriately before drawing.  Return
+	 *  the Component used for drawing.
+	 *
+	 * @param	table		the JTable that is asking the renderer to draw.
+	 *				This parameter can be null.
+	 * @param	value		the value of the cell to be rendered.  It is
+	 *				up to the specific renderer to interpret
+	 *				and draw the value.  eg. if value is the
+	 *				String "true", it could be rendered as a
+	 *				string or it could be rendered as a check
+	 *				box that is checked.  null is a valid value.
+	 * @param	isSelected	true is the cell is to be renderer with
+	 *				selection highlighting
+	 * @param	row	        the row index of the cell being drawn.  When
+	 *				drawing the header the rowIndex is -1.
+	 * @param	column	        the column index of the cell being drawn
+	 */
+public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+	super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
+	setText(value.toString());
+	setToolTipText(value.toString());
+	return this;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceInstanceStatus.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceInstanceStatus.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceInstanceStatus.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.io.Serializable;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.Matchable;
+import org.vcell.util.MessageConstants.ServiceType;
+
+
+public class ServiceInstanceStatus implements Matchable, Serializable, ComparableObject {
+	private String serverID;
+	private ServiceType type;
+	private int ordinal;
+	private Date startDate;
+	private String hostname;	
+	private boolean bRunning = false;
+		
+	public ServiceInstanceStatus(String sID, ServiceType t, int o, String h, Date d, boolean br) {
+		super();
+		this.serverID = sID;
+		this.type = t;
+		this.ordinal = o;
+		hostname = h;
+		startDate = d;
+		this.bRunning = br;
+	}
+	
+	public int getOrdinal() {
+		return ordinal;
+	}
+
+	public String getServerID() {
+		return serverID;
+	}
+
+	public ServiceType getType() {
+		return type;
+	}
+	
+	public String toString() {
+		return "[" + serverID + "," + type + "," + ordinal + "," + "," + hostname + "," + startDate + "," + bRunning + "]";
+	}
+
+	public String getID() {
+		return getSpecID() + "_" + hostname + "_" + startDate.getTime();
+	}
+	
+	public String getSpecID() {
+		return ServiceSpec.getServiceID(serverID, type, ordinal);
+	}
+	
+	public Object[] toObjects() {
+		return new Object[] {serverID, type, ordinal, hostname, startDate, bRunning};
+	}
+		
+	public boolean equals(Object obj) {
+		if (obj instanceof Matchable) {
+			return compareEqual((Matchable)obj);
+		}
+		return false;
+	}
+	
+	public int hashCode() {
+		return getID().hashCode();
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof ServiceInstanceStatus) {
+			ServiceInstanceStatus ss = (ServiceInstanceStatus)obj;
+		
+			if (!serverID.equals(ss.serverID)) {
+				return false;
+			}
+			if (!type.equals(ss.type)) {
+				return false;
+			}
+			if (ordinal != ss.ordinal) {
+				return false;
+			}		
+			if (!hostname.equals(ss.hostname)) {
+				return false;
+			}
+			if (!startDate.equals(ss.startDate)) {
+				return false;
+			}
+			return true;
+		}		
+		return false;
+	}
+
+	public boolean isRunning() {
+		return bRunning;
+	}
+
+	public void setRunning(boolean running) {
+		bRunning = running;
+	}
+
+	public Date getStartDate() {
+		return startDate;
+	}
+}
Index: src/cbit/vcell/messaging/admin/DatePanel.java
===================================================================
--- src/cbit/vcell/messaging/admin/DatePanel.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/DatePanel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.util.Date;
+
+import javax.swing.JLabel;
+import javax.swing.JTextField;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/29/2003 2:51:26 PM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class DatePanel extends javax.swing.JPanel {
+	private javax.swing.JComboBox ivjDayCombo = null;
+	private javax.swing.JComboBox ivjMonthCombo = null;
+	private javax.swing.JComboBox ivjYearCombo = null;
+	private IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private java.util.Calendar currcal = null;
+
+	private class IvjEventHandler implements java.awt.event.ItemListener {
+		public void itemStateChanged(java.awt.event.ItemEvent e) {
+			if (e.getSource() == DatePanel.this.getMonthCombo()) 
+				monthCombo_ItemEvent();
+			if (e.getSource() == DatePanel.this.getYearCombo()) 
+				yearCombo_ItemEvent();
+		}
+	};
+/**
+ * DatePanel constructor comment.
+ */
+public DatePanel() {
+	super();
+	initialize();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/29/2003 3:04:18 PM)
+ */
+private void changeMonth() {
+	int month = Integer.parseInt((String)getMonthCombo().getSelectedItem());
+	int year = Integer.parseInt((String)getYearCombo().getSelectedItem());
+	java.util.GregorianCalendar cal = new java.util.GregorianCalendar(year, month - 1, 1);
+	getDayCombo().removeAllItems();
+
+	int maxday = cal.getActualMaximum(java.util.Calendar.DAY_OF_MONTH);
+	for (int i = 1; i <= maxday; i++){
+		getDayCombo().addItem(i + "");	
+	}
+}
+/**
+ * Comment
+ */
+public void datePanel_Initialize() {
+	currcal = new java.util.GregorianCalendar();
+	int currYear = currcal.get(java.util.Calendar.YEAR);
+	for (int i = -10; i <= 0; i ++) {
+		getYearCombo().addItem((i + currYear) + "");
+	}
+	for (int i = 1; i <= 12; i ++) {
+		getMonthCombo().addItem(i + "");
+	}
+	reset();	
+	return;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/29/2003 3:17:06 PM)
+ * @return java.util.Date
+ */
+public Date getDate() {
+	int month = Integer.parseInt((String)getMonthCombo().getSelectedItem());
+	int day  = Integer.parseInt((String)getDayCombo().getSelectedItem());
+	int year = Integer.parseInt((String)getYearCombo().getSelectedItem());
+
+	java.util.GregorianCalendar calendar = new java.util.GregorianCalendar(year, month - 1, day);
+	return new Date(calendar.getTimeInMillis());
+}
+
+/**
+ * Return the JComboBox2 property value.
+ * @return javax.swing.JComboBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JComboBox getDayCombo() {
+	if (ivjDayCombo == null) {
+		try {
+			ivjDayCombo = new javax.swing.JComboBox();
+			ivjDayCombo.setName("DayCombo");
+			ivjDayCombo.setToolTipText("Day");
+			JTextField tf = new JTextField(4);
+			ivjDayCombo.setPreferredSize(tf.getPreferredSize());
+			ivjDayCombo.setEditable(true);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjDayCombo;
+}
+/**
+ * Return the JComboBox1 property value.
+ * @return javax.swing.JComboBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JComboBox getMonthCombo() {
+	if (ivjMonthCombo == null) {
+		try {
+			ivjMonthCombo = new javax.swing.JComboBox();
+			ivjMonthCombo.setName("MonthCombo");
+			ivjMonthCombo.setToolTipText("Month");
+			ivjMonthCombo.setEditable(true);
+			JTextField tf = new JTextField(4);
+			ivjMonthCombo.setPreferredSize(tf.getPreferredSize());
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjMonthCombo;
+}
+/**
+ * Return the JComboBox3 property value.
+ * @return javax.swing.JComboBox
+ */
+private javax.swing.JComboBox getYearCombo() {
+	if (ivjYearCombo == null) {
+		try {
+			ivjYearCombo = new javax.swing.JComboBox();
+			ivjYearCombo.setName("YearCombo");
+			ivjYearCombo.setToolTipText("Year");
+			JTextField tf = new JTextField(6);
+			ivjYearCombo.setPreferredSize(tf.getPreferredSize());
+			ivjYearCombo.setEditable(true);
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjYearCombo;
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("DatePanel");
+		setLayout(new GridBagLayout());
+		GridBagConstraints gbc = new GridBagConstraints();
+		gbc.gridx = 0;
+		gbc.gridy = 0;
+		gbc.weightx = 1.0;
+		gbc.anchor = GridBagConstraints.LINE_START;
+		gbc.fill = GridBagConstraints.HORIZONTAL;
+		add(getMonthCombo(), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 1;
+		gbc.gridy = 0;
+		add(new JLabel("/"), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 2;
+		gbc.gridy = 0;
+		gbc.weightx = 1.0;
+		gbc.anchor = GridBagConstraints.LINE_START;
+		gbc.fill = GridBagConstraints.HORIZONTAL;
+		add(getDayCombo(), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 3;
+		gbc.gridy = 0;
+		add(new JLabel("/"), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 4;
+		gbc.gridy = 0;
+		gbc.weightx = 1;
+		gbc.anchor = GridBagConstraints.LINE_START;
+		gbc.fill = GridBagConstraints.HORIZONTAL;
+		add(getYearCombo(), gbc);
+		
+		datePanel_Initialize();
+		getMonthCombo().addItemListener(ivjEventHandler);
+		getYearCombo().addItemListener(ivjEventHandler);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+/**
+ * Comment
+ */
+private void monthCombo_ItemEvent() {
+	changeMonth();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (9/3/2003 8:02:44 AM)
+ */
+public void reset() {
+	for (int i = 1; i <= currcal.getActualMaximum(java.util.Calendar.DAY_OF_MONTH); i ++) {
+		getDayCombo().addItem(i + "");
+	}
+	getYearCombo().setSelectedItem(currcal.get(java.util.Calendar.YEAR) + "");
+	getMonthCombo().setSelectedItem((currcal.get(java.util.Calendar.MONTH) + 1) + "");
+	getDayCombo().setSelectedItem(currcal.get(java.util.Calendar.DATE) + "");	
+}
+
+@Override
+public void setEnabled(boolean enabled) {
+	getYearCombo().setEnabled(enabled);
+	getMonthCombo().setEnabled(enabled);
+	getDayCombo().setEnabled(enabled);
+	super.setEnabled(enabled);
+}
+/**
+ * Comment
+ */
+private void yearCombo_ItemEvent() {
+	changeMonth();
+	return;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceStatusTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceStatusTableModel.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceStatusTableModel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.util.Comparator;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/19/2003 2:24:48 PM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class ServiceStatusTableModel extends VCellSortTableModel<ComparableObject> {
+/**
+ * ServiceStatusTableModel constructor comment.
+ */
+public ServiceStatusTableModel() {
+	super(new String[] {"Site", "Type", "Ordinal", "Startup Type", "MemoryMB", "Date", "Status", "Status Message", "PBS Job ID"});
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2003 2:14:05 PM)
+ * @return java.lang.Class
+ * @param columnIndex int
+ */
+public Class<?> getColumnClass(int columnIndex) {
+	if (columnIndex == 5) {
+		return Date.class;
+	} else if (columnIndex == 2 || columnIndex == 4) {
+		return Number.class;
+	} else if (columnIndex == 1) {
+		return ServiceType.class;
+	} else {
+		return String.class;
+	}
+}
+/**
+ * getValueAt method comment.
+ */
+public Object getValueAt(int row, int col) {	
+	ComparableObject serviceStatus = getValueAt(row);
+	Object[] values = serviceStatus.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+}
Index: src/cbit/vcell/messaging/RpcServerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/RpcServerMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/RpcServerMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+
+import java.io.Serializable;
+import cbit.rmi.event.ExportEvent;
+import cbit.vcell.messaging.server.RpcServer;
+import cbit.vcell.messaging.server.RpcRequest;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/15/2003 10:08:03 AM)
+ * @author: Fei Gao
+ */
+public class RpcServerMessaging extends JmsServiceProviderMessaging implements QueueListener, ControlTopicListener {
+	private JmsSession clientRequestReceiver = null;
+	private String queueName = null;
+	private String msgSelector = null;
+
+/**
+ * RpcMessaging constructor comment.
+ * @param argJmsFactory cbit.vcell.messaging.JmsFactory
+ * @param slog cbit.vcell.server.SessionLog
+ */
+public RpcServerMessaging(RpcServer rpcServer, String qname, String selector, SessionLog log0) throws javax.jms.JMSException {
+	super(rpcServer, log0);
+	queueName = qname;
+	msgSelector = selector;
+
+	reconnect();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public void onQueueMessage(Message message) {
+	try {
+		long t = System.currentTimeMillis();
+		
+		if (message == null) {
+			try {
+				clientRequestReceiver.rollback(); // no message so far
+			} catch (Exception ex) {
+				log.exception(ex);
+			}			
+			return;
+		}
+			
+		log.print("onClientRequestMessage[" + JmsUtils.toString(message) + "]");
+		if (!(message instanceof ObjectMessage)) {
+			clientRequestReceiver.commit(); // ignore the bad messages
+			return;
+		}
+
+		Object obj = ((ObjectMessage) message).getObject();
+		if (!(obj instanceof RpcRequest)) {
+			clientRequestReceiver.commit(); // ignore the bad messages
+			return;
+		}
+		
+		RpcRequest request = (RpcRequest)obj;	
+		log.print(request + "");
+			
+		java.io.Serializable returnValue = null;
+		try {
+			returnValue = (Serializable) ((RpcServer)jmsServiceProvider).dispatchRPC(request);
+		} catch (Exception ex) {
+			log.exception(ex);
+			returnValue = ex; // if exception occurs, send client the exception
+		}
+
+		if (returnValue != null && returnValue.getClass().isArray()) {
+			Class<?> componentClass = returnValue.getClass().getComponentType();
+			if (!componentClass.isPrimitive() && !Serializable.class.isAssignableFrom(componentClass)) {
+				returnValue = new ClassCastException("Not serializable:" + componentClass);
+			}
+		}
+		t = System.currentTimeMillis() - t;
+
+		// if client is not waiting any more, why bother sending the reply. Plus the temporary queue
+		// has been deleted if client has timed out.
+		long clientTimeoutMS = Long.parseLong(org.vcell.util.PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.vcellClientTimeoutMS)); 
+		if (t < clientTimeoutMS) {		
+			Queue replyTo = (Queue)message.getJMSReplyTo();
+			if (replyTo != null) {
+				Message replyMessage = clientRequestReceiver.createObjectMessage(returnValue);
+				replyMessage.setStringProperty(MessageConstants.METHOD_NAME_PROPERTY, request.getMethodName());
+				replyMessage.setJMSCorrelationID(message.getJMSMessageID());
+				
+				clientRequestReceiver.sendMessage(replyTo, replyMessage, DeliveryMode.NON_PERSISTENT, clientTimeoutMS);
+				
+				if (returnValue == null) {
+					log.print("sendClientResponse[null]");
+				} else {
+					log.print("sendClientResponse[" + returnValue.getClass() + "@" + Integer.toHexString(returnValue.hashCode()) + "]");
+				}			
+			}
+		}
+		
+		clientRequestReceiver.commit();		//commit
+			
+	} catch (JMSException e) {
+		log.exception(e);
+		
+		// roll it back if fail
+		try {
+			clientRequestReceiver.rollback();
+		} catch (Exception ex) {
+			log.exception(ex);
+		}		
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+public void publishDataStatus(cbit.rmi.event.DataJobEvent event) throws JMSException  {
+	try {
+		JmsSession dataSession = jmsConn.getAutoSession();
+		Message rpcMessage = dataSession.createObjectMessage(event);
+		rpcMessage.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_DATA_EVENT_VALUE);
+		rpcMessage.setStringProperty(MessageConstants.USERNAME_PROPERTY, event.getUser().getName());
+		
+		dataSession.publishMessage(JmsUtils.getTopicClientStatus(), rpcMessage);
+		log.print("publishing data status: " + event);		
+		jmsConn.closeSession(dataSession);
+			
+	} catch (Exception e){
+		log.exception(e);
+		throw new JMSException("RpcServerMessaging.publishExportStatus(): " + e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+public void publishExportStatus(ExportEvent event) throws JMSException  {
+	try {
+		JmsSession exportSession = jmsConn.getAutoSession();
+		Message rpcMessage = exportSession.createObjectMessage(event);
+		rpcMessage.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_EXPORT_EVENT_VALUE);
+		rpcMessage.setStringProperty(MessageConstants.USERNAME_PROPERTY, event.getUser().getName());
+		
+		exportSession.publishMessage(JmsUtils.getTopicClientStatus(), rpcMessage);
+		log.print("publishing export status: " + event);		
+		jmsConn.closeSession(exportSession);
+			
+	} catch (Exception e){
+		log.exception(e);
+		throw new JMSException("RpcServerMessaging.publishExportStatus(): " + e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+protected void reconnect() throws JMSException {
+	super.reconnect();
+	
+	clientRequestReceiver = jmsConn.getTransactedSession(); // transactional	
+	int servicePrefetchCount = Integer.parseInt(PropertyLoader.getProperty(PropertyLoader.jmsServicePrefetchCount, "-1"));
+	if (servicePrefetchCount > 0) {
+		log.print("servicePrefetchCount=" + servicePrefetchCount);
+		clientRequestReceiver.setPrefetchCount(servicePrefetchCount); // get messages one by one
+	}
+	clientRequestReceiver.setupQueueListener(queueName, msgSelector, new QueueMessageCollector(this));
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+public void startListening() throws JMSException {
+	log.print("I am starting to take requests!");
+	jmsConn.startConnection();
+}
+}
Index: src/cbit/vcell/messaging/BatchScheduler.java
===================================================================
--- src/cbit/vcell/messaging/BatchScheduler.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/BatchScheduler.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import java.util.Hashtable;
+
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.db.SimulationJobStatusInfo;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/11/2006 9:32:17 AM)
+ * @author: Jim Schaff
+ */
+public class BatchScheduler {
+/**
+ * BatchScheduler constructor comment.
+ */
+public BatchScheduler() {
+	super();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/11/2006 9:32:58 AM)
+ */
+public static SimulationJobStatusInfo schedule(SimulationJobStatusInfo[] allActiveJobs, int globalPdeQuota, int userQuotaOde, int userQuotaPde, VCellServerID systemID, SessionLog log) {
+	Hashtable<User, Integer> userPdeRunningJobs = new Hashtable<User, Integer>();
+	Hashtable<User, Integer> userOdeRunningJobs = new Hashtable<User, Integer>();
+
+	cbit.vcell.messaging.db.SimulationJobStatus jobStatus = null;
+	int runningPDEs = 0;
+	for (int i = 0; i < allActiveJobs.length; i++){
+		jobStatus = allActiveJobs[i].getSimJobStatus();
+
+		if (!jobStatus.isActive()) {
+			continue;
+		}
+		
+		if (jobStatus.isWaiting()) {
+			continue;  // we only do statistics on running jobs;
+		}
+		
+		if (allActiveJobs[i].isPDE()) {
+			runningPDEs ++; // running PDE jobs
+		}
+		
+		if (jobStatus.getServerID().equals(systemID)) { // the number of running jobs on this site
+			User user = allActiveJobs[i].getUser();
+			if(allActiveJobs[i].isPDE()) {
+				Integer numUserPdeJobs = userPdeRunningJobs.get(user);
+				if (numUserPdeJobs == null) {
+					userPdeRunningJobs.put(user, 1);
+				} else {
+					userPdeRunningJobs.put(user, numUserPdeJobs.intValue() + 1);
+				}
+			} else {
+				Integer numUserOdeJobs = userOdeRunningJobs.get(user);
+				if (numUserOdeJobs == null) {
+					userOdeRunningJobs.put(user, 1);
+				} else {
+					userOdeRunningJobs.put(user, numUserOdeJobs.intValue() + 1);
+				}
+			}
+		}
+	}	
+	for (int i = 0; i < allActiveJobs.length; i++){
+		jobStatus = allActiveJobs[i].getSimJobStatus();
+			
+		if (!jobStatus.isWaiting()) {
+			continue; // ignore non-waiting job
+		}
+			
+		if (!jobStatus.getServerID().equals(systemID)) {
+			continue; // doesn't belong
+		}
+		
+		User user = allActiveJobs[i].getUser();
+		if (allActiveJobs[i].isPDE() && runningPDEs >= globalPdeQuota) {
+			log.print("Global PDE quota reached [" + jobStatus.getVCSimulationIdentifier() + "]");
+			continue; // global LSF quota violated
+		}							
+
+		if(allActiveJobs[i].isPDE()) {
+			Object numUserPdeJobs = userPdeRunningJobs.get(user);
+			if (numUserPdeJobs != null) {
+				if (((Integer)numUserPdeJobs).intValue() >= userQuotaPde) {
+					//log.print("User PDE quota reached [" + jobStatus.getVCSimulationIdentifier() + "]");
+					continue; // user PDE quota reached
+				}
+			}
+		} else {
+			Object numUserOdeJobs = userOdeRunningJobs.get(user);
+			if (numUserOdeJobs != null) {
+				if (((Integer)numUserOdeJobs).intValue() >= userQuotaOde) {
+					log.print("User ODE quota reached [" + jobStatus.getVCSimulationIdentifier() + "]");
+					continue; // user ODE quota reached
+				}
+			}
+		}	
+
+		return allActiveJobs[i];		
+	}
+
+	return null;
+}
+}
Index: src/cbit/vcell/messaging/JmsConnectionFactoryImpl.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnectionFactoryImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnectionFactoryImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/24/2003 11:35:47 AM)
+ * @author: Fei Gao
+ */
+public class JmsConnectionFactoryImpl implements JmsConnectionFactory {
+	private JmsProvider jmsProvider = null;
+
+public JmsConnectionFactoryImpl() throws JMSException {
+	super();
+	jmsProvider = JmsProviderFactory.getJmsProvider();
+}
+
+public JmsConnectionFactoryImpl(JmsProvider jmsProvider0) {
+	super();
+	jmsProvider = jmsProvider0;
+}
+
+public JmsConnectionFactoryImpl(String provider, String url, String userid, String password) throws JMSException {
+	super();
+	jmsProvider = JmsProviderFactory.getJmsProvider(provider, url, userid, password);
+}
+
+public JmsConnection createConnection() throws JMSException {
+	return new JmsConnectionImpl(jmsProvider);
+}
+
+public JmsXAConnection createXAConnection() throws JMSException {
+	return new JmsXAConnectionImp(jmsProvider);
+}
+}
Index: src/cbit/vcell/messaging/MessagePropertyNotFoundException.java
===================================================================
--- src/cbit/vcell/messaging/MessagePropertyNotFoundException.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/MessagePropertyNotFoundException.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+/**
+ * Insert the type's description here.
+ * Creation date: (2/9/2004 11:29:16 AM)
+ * @author: Fei Gao
+ */
+public class MessagePropertyNotFoundException extends Exception {
+/**
+ * MessagePropertyNotFound constructor comment.
+ */
+public MessagePropertyNotFoundException() {
+	super();
+}
+
+
+/**
+ * MessagePropertyNotFound constructor comment.
+ * @param s java.lang.String
+ */
+public MessagePropertyNotFoundException(String s) {
+	super(s);
+}
+}
Index: src/cbit/vcell/messaging/ControlTopicListener.java
===================================================================
--- src/cbit/vcell/messaging/ControlTopicListener.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/ControlTopicListener.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/22/2003 2:43:23 PM)
+ * @author: Fei Gao
+ */
+public interface ControlTopicListener {
+void onControlTopicMessage(javax.jms.Message message) throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsXASession.java
===================================================================
--- src/cbit/vcell/messaging/JmsXASession.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsXASession.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+import javax.transaction.TransactionManager;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 1:13:29 PM)
+ * @author: Fei Gao
+ */
+public interface JmsXASession extends JmsSession {
+	void setupXASession() throws JMSException;
+	boolean joinTransaction(TransactionManager tm) throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsClientMessaging.java
===================================================================
--- src/cbit/vcell/messaging/JmsClientMessaging.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsClientMessaging.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+
+import cbit.vcell.messaging.server.RpcRequest;
+import cbit.vcell.server.UserLoginInfo;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:45 PM)
+ * @author: Fei Gao
+ */
+public class JmsClientMessaging {
+
+	private JmsSession responseRequestor = null;
+	private JmsConnection queueConn = null;
+	private UserLoginInfo userLoginInfo = null;
+
+	private SessionLog log = null;
+	private long timeSinceLastMessage = System.currentTimeMillis();
+
+/**
+ * Client constructor comment.
+ */
+public JmsClientMessaging(JmsConnection queueConn0, SessionLog log0, UserLoginInfo userLoginInfo) throws JMSException {
+	log = log0;
+	queueConn = queueConn0;
+	this.userLoginInfo = userLoginInfo;
+	reconnect();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 12:08:02 PM)
+ * @return long
+ */
+public long getTimeSinceLastMessage() {
+	return timeSinceLastMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+private void reconnect() throws JMSException {
+	responseRequestor = queueConn.getAutoSession();
+	queueConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ * Since clientMessaging only send messages, we don't consider onException() because that's asynchronized. 
+ */
+public synchronized Object rpc(RpcRequest request, String queueName, boolean returnRequired, String[] specialProperties, Object[] specialValues) throws Exception {
+	return rpc(request, queueName, returnRequired, specialProperties, specialValues, true);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ * Since clientMessaging only send messages, we don't consider onException() because that's asynchronized. 
+ */
+private synchronized Object rpc(RpcRequest request, String queueName, boolean returnRequired, String[] specialProperties, Object[] specialValues, boolean bEnableRetry) throws Exception {
+	ServiceType serviceType = request.getRequestedServiceType();
+	String methodName = request.getMethodName();
+	
+	try {		
+		ObjectMessage rpcMessage = responseRequestor.createObjectMessage(request);
+		rpcMessage.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY,MessageConstants.MESSAGE_TYPE_RPC_SERVICE_VALUE);
+		rpcMessage.setStringProperty(MessageConstants.SERVICE_TYPE_PROPERTY,serviceType.getName());
+		if (specialValues != null) {
+			for (int i = 0; i < specialValues.length; i ++) {
+				rpcMessage.setObjectProperty(specialProperties[i], specialValues[i]);
+			}
+		}
+
+		log.print("Sending request[" + serviceType + "," + methodName + "] to " + queueName);
+		setTimeSinceLastMessage(System.currentTimeMillis());
+		if (returnRequired) {
+			long clientTimeoutMS = Long.parseLong(org.vcell.util.PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.vcellClientTimeoutMS)); 
+			Message msg = responseRequestor.queueRequest(this, queueName, rpcMessage, DeliveryMode.PERSISTENT, clientTimeoutMS); 
+		
+			if (msg == null || !(msg instanceof ObjectMessage)) {
+				throw new JMSException("Server is temporarily not responding, please try again later. If problem persists, contact VCell_Support@uchc.edu. (server=" + serviceType + ", method=" + methodName +")");
+			} else {				
+				String methodResponseName = (String)JmsUtils.parseProperty(msg, MessageConstants.METHOD_NAME_PROPERTY, String.class);				
+				if (methodResponseName != null && methodResponseName.equals(methodName)){
+					log.print("server responded to RPC call (server=" + serviceType + ", method=" + methodName + ")");
+					Object returnValue = ((ObjectMessage)msg).getObject();
+					if (returnValue instanceof Exception){
+						throw (Exception)returnValue;
+					} else {
+						return returnValue;
+					}
+				} else {
+					return rpc(request, queueName, returnRequired, specialProperties, specialValues, false); // try again
+				}			
+			} 
+		} else {			
+			responseRequestor.sendMessage(queueName, rpcMessage, DeliveryMode.PERSISTENT, 0); // never expires
+			log.print("(service=" + serviceType + ", method=" + methodName + "), but no return is required");
+			return null;
+		}
+	} catch (JMSException e){
+		log.print("ClientMessaging.rpc() failed " + e.getMessage());
+		// if the connection is dropped, will retry
+		if (queueConn.isBadConnection(e) && bEnableRetry) {
+			log.print("ClientMessaging.rpc() retrying ");
+			return rpc(request, queueName, returnRequired, specialProperties, specialValues, false);
+		} else {
+			throw e;
+		}
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 12:08:02 PM)
+ * @param newTimeSinceLastMessage long
+ */
+public void setTimeSinceLastMessage(long newTimeSinceLastMessage) {
+	timeSinceLastMessage = newTimeSinceLastMessage;
+}
+
+
+public UserLoginInfo getUserLoginInfo() {
+	return userLoginInfo;
+}
+
+
+}
Index: src/cbit/vcell/messaging/StatusMessage.java
===================================================================
--- src/cbit/vcell/messaging/StatusMessage.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/StatusMessage.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+
+import cbit.vcell.messaging.db.SimulationJobStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/5/2004 12:35:20 PM)
+ * @author: Fei Gao
+ */
+public class StatusMessage {
+	private SimulationJobStatus jobStatus = null;
+	private Double timePoint = null;
+	private Double progress = null;
+
+	private static final String SIMULATION_STATUS_PROGRESS_PROPERTY	= "SimulationStatusProgress";
+	private static final String SIMULATION_STATUS_TIMEPOINT_PROPERTY = "SimulationStatusTimePoint";
+	
+	private java.lang.String userName = null;
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public StatusMessage(SimulationJobStatus jobStatus0, String userName0, Double progress0, Double timepoint0) {
+	jobStatus = jobStatus0;
+	userName = userName0;
+	progress = progress0;
+	timePoint = timepoint0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public StatusMessage(Message message) throws JMSException {
+	parseMessage(message);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:17:03 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ */
+public SimulationJobStatus getJobStatus() {
+	return jobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:17:03 PM)
+ * @return java.lang.Double
+ */
+public java.lang.Double getProgress() {
+	return progress;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:56:45 PM)
+ * @return cbit.vcell.solver.SimulationInfo
+ */
+public SimulationJobStatus getSimulationJobStatus() {
+	return jobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:17:03 PM)
+ * @return java.lang.Double
+ */
+public java.lang.Double getTimePoint() {
+	return timePoint;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/9/2004 10:24:41 AM)
+ * @return java.lang.String
+ */
+public java.lang.String getUserName() {
+	return userName;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:19:48 PM)
+ * @param message javax.jms.Message
+ */
+private void parseMessage(Message message) throws JMSException {
+	if (message == null) {
+		throw new RuntimeException("Null message");
+	}
+
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		if (msgType != null && !msgType.equals(MessageConstants.MESSAGE_TYPE_SIMSTATUS_VALUE)) {
+			throw new RuntimeException("Wrong message");
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		ex.printStackTrace(System.out);
+		throw new RuntimeException("Wrong message");
+	}
+			
+	if (!(message instanceof ObjectMessage)) {
+		throw new IllegalArgumentException("Expecting object message.");
+	}
+
+	Object obj = ((ObjectMessage)message).getObject();
+	if (!(obj instanceof SimulationJobStatus)) {
+		throw new IllegalArgumentException("Expecting " + SimulationJobStatus.class.getName() + " in message.");
+	}
+
+	jobStatus = (SimulationJobStatus)obj;
+	try {
+		progress = (Double)JmsUtils.parseProperty(message, SIMULATION_STATUS_PROGRESS_PROPERTY, double.class);
+	} catch (MessagePropertyNotFoundException ex) {
+		//ex.printStackTrace(System.out);
+		//it's ok
+	}
+	
+	try {
+		timePoint = (Double)JmsUtils.parseProperty(message, SIMULATION_STATUS_TIMEPOINT_PROPERTY, double.class);
+	} catch (MessagePropertyNotFoundException ex) {
+		//ex.printStackTrace(System.out);
+		//it's ok
+	}
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 1:59:04 PM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+public void sendToClient(JmsSession session) throws JMSException {
+	Message message = toMessage(session);
+	session.publishMessage(JmsUtils.getTopicClientStatus(), message);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 1:59:04 PM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+private Message toMessage(JmsSession session) throws JMSException {
+	Message message = session.createObjectMessage(jobStatus);
+	message.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_SIMSTATUS_VALUE);
+	message.setStringProperty(MessageConstants.USERNAME_PROPERTY, userName);
+	if (progress != null) {
+		message.setDoubleProperty(SIMULATION_STATUS_PROGRESS_PROPERTY, progress.doubleValue());
+	}
+	if (timePoint != null) {
+		message.setDoubleProperty(SIMULATION_STATUS_TIMEPOINT_PROPERTY, timePoint.doubleValue());
+	}
+
+	return message;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/13/2004 9:55:17 AM)
+ * @return java.lang.String
+ */
+public String toString() {
+	return "StatusMessage [" + jobStatus.getSimulationMessage().getDisplayMessage() + "," + progress + "," + timePoint + "]";
+}
+}
Index: src/cbit/vcell/messaging/AbstractJmsProvider.java
===================================================================
--- src/cbit/vcell/messaging/AbstractJmsProvider.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/AbstractJmsProvider.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/16/2001 9:49:37 AM)
+ * @author: Jim Schaff
+ */
+public abstract class AbstractJmsProvider implements JmsProvider {
+	protected String fieldUserid;
+	protected String fieldPassword;	
+
+	protected XAConnectionFactory xaConnectionFactory = null;
+	protected ConnectionFactory connectionFactory = null;	
+	
+/**
+ * JmsFactory constructor comment.
+ */
+protected AbstractJmsProvider(String userid, String password) {
+	super();
+	this.fieldUserid = userid;
+	this.fieldPassword = password;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/6/2003 11:51:19 AM)
+ * @return int
+ */
+public boolean isBadConnection(JMSException ex) {
+	if (getErrorCode(ex) == JmsErrorCode.ERR_CONNECTION_DROPPED) {
+		return true;
+	}
+
+	return false;
+}
+}
Index: src/cbit/vcell/messaging/JmsConnectionImpl.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnectionImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnectionImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (6/6/2003 11:16:18 AM)
+ * @author: Fei Gao
+ */
+public class JmsConnectionImpl extends AbstractJmsConnectionImpl {
+
+	protected JmsConnectionImpl(JmsProvider argJmsProvider) throws JMSException {
+		super(argJmsProvider);
+		setupConnection();
+	}
+
+	protected void setupConnection() {
+		connection = null;	
+		// Wait for a connection.
+		while (connection == null) {		
+			try {						
+				connection = jmsProvider.createConnection();
+				connection.setExceptionListener(this);
+				jmsProvider.setPingInterval(JMSCONNECTION_PING_INTERVAL, connection);
+				System.out.println(this + ": Connection established.");
+			} catch (Exception jmse) {		
+				System.out.println(this + ": Cannot connect to Message Server [" + jmse.getMessage() + "], Pausing " + JMSCONNECTION_RETRY_INTERVAL/1000 + " seconds before retry.");
+				try {
+					Thread.sleep(JMSCONNECTION_RETRY_INTERVAL);
+				} catch (InterruptedException ie) {
+					ie.printStackTrace(System.out);
+				}
+			}
+		}		
+	} 
+}
Index: src/cbit/vcell/messaging/JmsProviderFactory.java
===================================================================
--- src/cbit/vcell/messaging/JmsProviderFactory.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsProviderFactory.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.JMSException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/24/2004 2:54:42 PM)
+ * @author: Fei Gao
+ */
+public class JmsProviderFactory {
+/**
+ * JmsProviderFactory constructor comment.
+ */
+public JmsProviderFactory() {
+	super();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/16/2001 4:48:25 PM)
+ * @return cbit.vcell.appserver.JmsFactory
+ * @param jmsProvider java.lang.String
+ * @param host java.lang.String
+ * @param userid java.lang.String
+ * @param password java.lang.String
+ */
+public static JmsProvider getJmsProvider() throws JMSException {
+	return getJmsProvider(JmsUtils.getJmsProvider(), JmsUtils.getJmsUrl(), JmsUtils.getJmsUserID(), JmsUtils.getJmsPassword());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/16/2001 4:48:25 PM)
+ * @return cbit.vcell.appserver.JmsFactory
+ * @param jmsProvider java.lang.String
+ * @param host java.lang.String
+ * @param userid java.lang.String
+ * @param password java.lang.String
+ */
+public static JmsProvider getJmsProvider(String provider, String url, String userid, String password) throws JMSException {
+	if (provider.equalsIgnoreCase(JmsProvider.SONICMQ)){
+		return new SonicMQJmsProvider(url,userid,password);	 
+	} else {
+		throw new IllegalArgumentException("unexpected jmsProvider '" + provider + "', expecting " + JmsProvider.SONICMQ);// + " or " + JBOSSMQ);
+	}
+}
+}
Index: src/cbit/vcell/messaging/JmsErrorCode.java
===================================================================
--- src/cbit/vcell/messaging/JmsErrorCode.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/messaging/JmsErrorCode.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (6/6/2003 11:39:44 AM)
+ * @author: Fei Gao
+ */
+public interface JmsErrorCode {
+	public static final int ERR_UNKNOWN = -1;
+	
+	public static final int ERR_CAN_NOT_INSTANTIATE_CLASS = 0;            
+	public static final int ERR_CHANNEL_ACTIVE  = 1;            
+	public static final int ERR_CHANNEL_ALREADY_ESTABLISHED = 2;            
+	public static final int ERR_CHANNEL_DUPLICATE = 3;            
+	public static final int ERR_CHANNEL_DUPLICATE_DETECT_UNSUPPORTED = 4;            
+	public static final int ERR_CHANNEL_FATAL_DUP_DETECT_EXCEPTION = 5;            
+	public static final int ERR_CHANNEL_ID_ALREADY_EXISTS = 6;            
+	public static final int ERR_CHANNEL_IMPLICITLY_CANCELLED = 7;            
+	public static final int ERR_CHANNEL_INTERNAL_ERROR = 8;            
+	public static final int ERR_CHANNEL_INVALID_DECRYPTION_KEY = 9;	            
+	public static final int ERR_CHANNEL_INVALID_KEY_TYPE = 10;	            
+	public static final int ERR_CHANNEL_IO_ERROR = 11;	            
+	public static final int ERR_CHANNEL_JCE_UNAVAILABLE = 12;	            
+	public static final int ERR_CHANNEL_RECOVER_FILE_UNREADABLE = 13;	            
+	public static final int ERR_CHANNEL_RETRY_TIMEOUT = 14;	            
+	public static final int ERR_CHANNEL_TIMEOUT = 15;	            
+	public static final int ERR_CHANNEL_TRANSFER_CLOSED = 16;	            
+	public static final int ERR_CHANNEL_UUID_IN_USE = 17;	            
+	public static final int ERR_CLASS_ACCESS_ERROR = 18;	            
+	public static final int ERR_CLASS_CAST_ERROR = 19;	            
+	public static final int ERR_CLASS_NOT_FOUND = 20;	            
+	public static final int ERR_CONNECTION_DROPPED = 21;	            
+	public static final int ERR_CONNECTION_LIMIT_EXCEEDED = 22;	            
+	public static final int ERR_EXCEPTION_IN_INIT = 23;	            
+	public static final int ERR_EXTERNAL_AUTNENTICATION_FAILED = 24;	            
+	public static final int ERR_FLOW_CONTROL_EXCEPTION = 25;	            
+	public static final int ERR_GENERAL_SECURITY_ERR = 26;	            
+	public static final int ERR_GUARANTEE_NOT_AUTHORIZED = 27;	            
+	public static final int ERR_INTEGRITY_FAILED = 28;	            
+	public static final int ERR_JMS_OBJECT_CLOSED = 29;	            
+	public static final int ERR_LINKAGE_ERROR = 30;	            
+	public static final int ERR_MESSAGELISTENER_RUNTIME_EXCEPTION = 31;
+	public static final int ERR_NONREPUDIATION_FAILED = 32;	            
+	public static final int ERR_PRIVACY_FAILED = 33; 	            
+	public static final int ERR_PUBLISH_NOT_AUTHORIZED = 34;	            
+	public static final int ERR_REQUEST_NOSUB_FOR_SUBJECT = 35;	            
+	public static final int ERR_SECURITY_ERROR = 36; 	            
+	public static final int ERR_STORE = 37; 	            
+	public static final int ERR_STORE_INIT = 38;	            
+	public static final int ERR_STORE_SIZE_EXCEEDED = 39;	            
+	public static final int ERR_SUBSCRIBE_NOT_AUTHORIZED = 40; 	            
+	public static final int ERR_THREAD_INTERRUPTED = 41;	            
+	public static final int ERR_TOO_LARGE_FOR_QUEUE = 42;	            
+	public static final int ERR_TXN_ACCESS_VIOLATION = 43;	            
+	public static final int ERR_TXN_IDLE_TIMEOUT = 44;	            
+	public static final int ERR_TXN_NOT_FOUND = 45;	            
+	public static final int ERR_TXN_SEQUENCE_ERR = 46;	            
+	public static final int ERR_WRONG_SUBJECT_ADDR = 47;	            
+	public static final int ERROR = 48;	            
+	public static final int TXN_DATABASE_EXCEPTION = 49;	            
+	public static final int TXN_INDEX_ALREADY_EXISTS = 50;	            
+	public static final int TXN_INDICES_NOT_SUPPORTED = 51;	            
+	public static final int TXN_INVALID_DATA  = 52;	
+}
Index: src/cbit/vcell/field/FieldUtilities.java
===================================================================
--- src/cbit/vcell/field/FieldUtilities.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/field/FieldUtilities.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -19,16 +19,8 @@
 
 import org.vcell.util.document.ExternalDataIdentifier;
 
-import cbit.vcell.math.Equation;
-import cbit.vcell.math.FastSystem;
-import cbit.vcell.math.Function;
-import cbit.vcell.math.JumpProcess;
-import cbit.vcell.math.MathDescription;
 import cbit.vcell.math.MathException;
 import cbit.vcell.math.MathFunctionDefinitions;
-import cbit.vcell.math.SubDomain;
-import cbit.vcell.math.VarIniCondition;
-import cbit.vcell.math.Variable;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.Expression.FunctionFilter;
 import cbit.vcell.parser.ExpressionException;
@@ -147,71 +139,5 @@
 		}
 	}
 
-	public static void substituteFieldFuncNames(MathDescription mathDesc, Hashtable<String, ExternalDataIdentifier> oldFieldFuncArgsNameNewID) throws MathException, ExpressionException{
-		FieldUtilities.substituteFieldFuncNames(
-				oldFieldFuncArgsNameNewID, collectFieldFuncAndExpressions(mathDesc));
-	}
 
-	public static FieldFunctionArguments[] getFieldFunctionArguments(MathDescription mathDesc) throws MathException, ExpressionException {
-		return collectFieldFuncAndExpressions(mathDesc).keySet().toArray(new FieldFunctionArguments[0]);
-	}
-
-	private static Hashtable<FieldFunctionArguments, Vector<Expression>> collectFieldFuncAndExpressions(MathDescription mathDesc) throws MathException, ExpressionException {
-		// make sure each field only added once
-		Hashtable<FieldFunctionArguments, Vector<Expression>> fieldFuncArgsExpHash =
-			new Hashtable<FieldFunctionArguments, Vector<Expression>>();
-		Enumeration<SubDomain> enum1 = mathDesc.getSubDomains();
-		
-		Enumeration<Variable> mathDescEnumeration = mathDesc.getVariables();
-		while (mathDescEnumeration.hasMoreElements()){
-			Variable variable = mathDescEnumeration.nextElement();
-			if(variable instanceof Function){
-				Function function = (Function)variable;
-				FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,function.getExpression());
-			}
-		}
-		// go through each subdomain
-		while (enum1.hasMoreElements()){
-			SubDomain subDomain = enum1.nextElement();
-			// go through each equation
-			Enumeration<Equation> enum_equ = subDomain.getEquations();
-			while (enum_equ.hasMoreElements()){
-				Equation equation = (Equation)enum_equ.nextElement();
-				Vector<Expression> exs = equation.getExpressions(mathDesc);
-
-				// go through each expresson
-				for (int i = 0; i < exs.size(); i ++) {
-					Expression exp = (Expression)exs.get(i);
-					FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,exp);
-				}
-			}
-			// go through each Fast System
-			FastSystem fastSystem = subDomain.getFastSystem();
-			if(fastSystem != null){
-				Expression[] fsExprArr = fastSystem.getExpressions();
-				for (int i = 0; i < fsExprArr.length; i ++) {
-					FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,fsExprArr[i]);
-				}
-			}
-			// go through each Jump Process
-			for (JumpProcess jumpProcess : subDomain.getJumpProcesses()){
-				Expression[] jpExprArr = jumpProcess.getExpressions();
-				for (int i = 0; i < jpExprArr.length; i ++) {
-					FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,jpExprArr[i]);
-				}
-			}
-			// go through VarInitConditions
-			for (VarIniCondition varInitCond : subDomain.getVarIniConditions()){
-				Expression[] vicExprArr =
-					new Expression[] {varInitCond.getIniVal(),varInitCond.getVar().getExpression()};
-				for (int i = 0; i < vicExprArr.length; i ++) {
-					FieldUtilities.addFieldFuncArgsAndExpToCollection(fieldFuncArgsExpHash,vicExprArr[i]);
-				}
-			}
-		}
-		
-		return fieldFuncArgsExpHash;
-	}
-
-
 }
Index: src/cbit/vcell/field/FieldDataIdentifierSpec.java
===================================================================
--- src/cbit/vcell/field/FieldDataIdentifierSpec.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/field/FieldDataIdentifierSpec.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -10,7 +10,6 @@
 
 package cbit.vcell.field;
 
-import org.vcell.util.Matchable;
 import org.vcell.util.document.ExternalDataIdentifier;
 
 import cbit.vcell.parser.ExpressionException;
@@ -21,7 +20,7 @@
  * Creation date: (9/18/2006 12:55:46 PM)
  * @author: Jim Schaff
  */
-public class FieldDataIdentifierSpec implements java.io.Serializable, Matchable  {
+public class FieldDataIdentifierSpec implements java.io.Serializable  {
 	private FieldFunctionArguments fieldFuncArgs;
 	private ExternalDataIdentifier extDataID;
 
@@ -92,14 +91,4 @@
 		&&
 		getExternalDataIdentifier().equals(fdiSpec.getExternalDataIdentifier());
 }
-
-public boolean compareEqual(Matchable obj) {
-	if (obj instanceof FieldDataIdentifierSpec){
-		FieldDataIdentifierSpec other = (FieldDataIdentifierSpec)obj;
-		if (other.toCSVString().equals(toCSVString())){
-			return true;
-		}
-	}
-	return false;
 }
-}
Index: src/cbit/vcell/mongodb/VCMongoDbDriver.java
===================================================================
--- src/cbit/vcell/mongodb/VCMongoDbDriver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/mongodb/VCMongoDbDriver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -5,7 +5,6 @@
 import java.util.Arrays;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
-import org.vcell.util.NullSessionLog;
 import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 import org.vcell.util.StdoutSessionLog;
@@ -22,16 +21,12 @@
 
 public class VCMongoDbDriver implements Runnable {
 	
-	public static boolean bQuiet = false;
-	
 	private static VCMongoDbDriver mongoDriverSingleton = null;
 
 	private Mongo m = null;
 	private SessionLog log = new StdoutSessionLog("mongoDbDriver");
-	private NullSessionLog nullSessionLog = new NullSessionLog();
 	private ConcurrentLinkedQueue<VCMongoMessage> messageOutbox = new ConcurrentLinkedQueue<VCMongoMessage>();
 	private boolean processing = false;
-	private Thread messageProcessingThread = null;
 
 	public static VCMongoDbDriver getInstance(){
 		if (mongoDriverSingleton == null){
@@ -49,18 +44,15 @@
 	}
 	
 	public SessionLog getSessionLog(){
-		if(bQuiet){
-			return nullSessionLog;
-		}
 		return log;
 	}
 	
-	private synchronized void sendMessages() {
+	private void sendMessages() {
     	VCMongoMessage[] queuedMessages = messageOutbox.toArray(new VCMongoMessage[0]);
    		
    		if (queuedMessages!=null && queuedMessages.length>0){
    			try {
-	   			// remove the messages whether the save is successful or not.
+	   			// remove the messages whether the save is sucessfull or not.
 	   			messageOutbox.removeAll(Arrays.asList(queuedMessages));
 	 
 	   			// create DBObjects for each message (to send to MongoDB)
@@ -89,11 +81,11 @@
 	        	String errorString = writeResult.getError();////???????
 	        	if (errorString !=null && errorString.length()>0){
 	        		for (VCMongoMessage message : queuedMessages){
-	        			getSessionLog().alert("VCMongoMessage failedToSend : "+message);
+	        			log.alert("VCMongoMessage failedToSend : "+message);
 	        		}
 	        	}else{
 		    		for (VCMongoMessage message : queuedMessages){
-		    			getSessionLog().alert("VCMongoMessage sent : "+message);
+		    			log.alert("VCMongoMessage sent : "+message);
 		    		}
 	        	}
 //   			} catch (MongoException e){
@@ -112,10 +104,10 @@
    					m = null;
    				}
    				final int minutesToWaitUponFailure = 20;
-   				getSessionLog().alert("MongoDB failure ... waiting "+minutesToWaitUponFailure+" minutes before trying to connect again");
+   				log.alert("MongoDB failure ... waiting "+minutesToWaitUponFailure+" minutes before trying to connect again");
    				for (VCMongoMessage msg : queuedMessages){
    					try {
-   						getSessionLog().alert("MongoDB failure: discarding message: "+msg);
+   						log.alert("MongoDB failure: discarding message: "+msg);
    					}catch (Exception e4){
    						e4.printStackTrace(System.out);
    					}
@@ -130,12 +122,12 @@
     
     public void run()
     {
-		getSessionLog().print("Starting MongoDB Thread");
+		log.print("Starting MongoDB Thread");
         while(processing && VCMongoMessage.enabled) {
             try {
                 sendMessages();
                 try {
-                	int sleepTimeMS = Integer.parseInt(PropertyLoader.getProperty(PropertyLoader.mongodbThreadSleepMS,"2000"));
+                	int sleepTimeMS = Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.mongodbThreadSleepMS));
 					Thread.sleep(sleepTimeMS);
 				} catch (InterruptedException e) {
 				}
@@ -143,7 +135,7 @@
 				e.printStackTrace(System.out);
 			}
         }
-        getSessionLog().print("Ended MongoDB Thread");
+        log.print("Ended MongoDB Thread");
     }
 
 
@@ -152,7 +144,7 @@
         if(!processing )
         {
             processing = true;
-            messageProcessingThread = new Thread(this,"MongoDB Process Thread");
+            Thread messageProcessingThread = new Thread(this,"MongoDB Process Thread");
             messageProcessingThread.setDaemon(true);
             messageProcessingThread.start();
         }
@@ -168,25 +160,18 @@
         return processing;
     }
     
-    public void addMessage(VCMongoMessage message)
+    public synchronized void addMessage(VCMongoMessage message)
     {
-//    	getSessionLog().print("VCMongoMessage queued : "+message);
     	messageOutbox.add(message);
+    	log.print("VCMongoMessage queued : "+message);
     	if (!IsProcessing()){
     		startProcessing();
     	}
     }
     
-    public void flush() {
-    	if (!processing){
-    		return;
-    	}
-    	if (this.messageProcessingThread!=null){
-    		this.messageProcessingThread.interrupt();
-    	}
-        sendMessages();
-    }
-    
+
+
+
 	/**
 	 * @param args
 	 */
@@ -228,5 +213,6 @@
 		}
 	}
 
+	
 
 }
Index: src/cbit/vcell/mongodb/VCMongoMessage.java
===================================================================
--- src/cbit/vcell/mongodb/VCMongoMessage.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/mongodb/VCMongoMessage.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -8,21 +8,15 @@
 
 import org.vcell.util.document.VCellServerID;
 
+import cbit.htc.PbsJobID;
 import cbit.rmi.event.MessageEvent;
 import cbit.rmi.event.SimulationJobStatusEvent;
 import cbit.rmi.event.WorkerEvent;
-import cbit.vcell.message.VCDestination;
-import cbit.vcell.message.VCMessage;
-import cbit.vcell.message.VCRpcRequest;
-import cbit.vcell.message.messages.MessageConstants;
-import cbit.vcell.message.messages.StatusMessage;
-import cbit.vcell.message.messages.WorkerEventMessage;
-import cbit.vcell.message.server.cmd.CommandService.CommandOutput;
-import cbit.vcell.message.server.dispatcher.SimulationStateMachine;
-import cbit.vcell.message.server.htc.HtcJobID;
+import cbit.vcell.messaging.WorkerEventMessage;
 import cbit.vcell.messaging.db.SimulationExecutionStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+import cbit.vcell.messaging.server.RpcRequest;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.server.UserLoginInfo;
 import cbit.vcell.solver.SimulationJob;
@@ -50,9 +44,7 @@
 		simData,
 		export,
 		database,
-		serverManager,
-		solverPreprocessor,
-		solverPostprocessor
+		serverManager
 	};
 	
 	private static ServiceName serviceName = ServiceName.unknown;
@@ -76,12 +68,6 @@
 	public final static String MongoMessage_msgtype_exception							= "exception";
 	public final static String MongoMessage_msgtype_clientConnect						= "clientConnect";
 	public final static String MongoMessage_msgtype_clientTimeout						= "clientTimeout";
-	public final static String MongoMessage_msgtype_jmsMessageReceived					= "jmsMessageReceived";
-	public final static String MongoMessage_msgtype_jmsMessageSent						= "jmsMessageSent";
-	public final static String MongoMessage_msgtype_commandServiceCall					= "pbsCall";
-	public final static String MongoMessage_msgtype_infoMsg								= "infoMsg";
-	public final static String MongoMessage_msgtype_obsoleteJob							= "obsoleteJob";
-	public final static String MongoMessage_msgtype_zombieJob							= "zombieJob";
 	public final static String MongoMessage_msgTime				= "msgTime";
 	public final static String MongoMessage_msgTimeNice			= "msgTimeNice";
 	
@@ -120,13 +106,11 @@
 	public final static String MongoMessage_solverEventType		= "solverEventType";
 	public final static String MongoMessage_simComputeResource	= "simComputeResource";
 	public final static String MongoMessage_simEstMemory		= "simEstMemory";
-	public final static String MongoMessage_htcJobID			= "htcJobID";
-	public final static String MongoMessage_htcWorkerMsg		= "htcWorkerMsg";
+	public final static String MongoMessage_pbsJobID			= "pbsJobID";
+	public final static String MongoMessage_pbsWorkerMsg		= "pbsWorkerMsg";
 	public final static String MongoMessage_rpcRequestMethod	= "rpcMethod";
 	public final static String MongoMessage_rpcRequestArgs		= "rpcArgs";
 	public final static String MongoMessage_rpcRequestService	= "rpcService";
-	public final static String MongoMessage_rpcRequestDelay		= "rpcDelay";
-	public final static String MongoMessage_rpcServiceTime		= "rpcServiceTime";
 	public final static String MongoMessage_userName			= "user";
 	public final static String MongoMessage_host				= "host";
 	public final static String MongoMessage_serviceName			= "serviceName";
@@ -143,16 +127,7 @@
 	public final static String MongoMessage_osName				= "osName";
 	public final static String MongoMessage_osVersion			= "osVersion";
 	public final static String MongoMessage_vcSoftwareVersion	= "vcSoftwareVersion";
-	public final static String MongoMessage_destination			= "destination";
-	public final static String MongoMessage_jmsMessage			= "jmsMessage";
-	public final static String MongoMessage_shellCmd			= "shellCmd";
-	public final static String MongoMessage_cmdString			= "cmdString";
-	public final static String MongoMessage_elapsedTimeMS		= "elapsedTimeMS";
-	public final static String MongoMessage_stdout				= "stdout";
-	public final static String MongoMessage_stderr				= "stderr";
-	public final static String MongoMessage_exitCode			= "exitCode";
-	public final static String MongoMessage_info				= "info";
-	public final static String MongoMessage_simStateMachineDump = "simStateMachine";
+
 	private BasicDBObject doc = null;
 	
 	VCMongoMessage(BasicDBObject doc){
@@ -218,23 +193,6 @@
 		dbObject.put(MongoMessage_host,java.net.InetAddress.getLocalHost().getHostName());
 	}
 
-	public static void sendInfo(String infoString) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
-	
-			addHeader(dbObject,MongoMessage_msgtype_infoMsg);
-			
-			dbObject.put(MongoMessage_info, infoString);
-							
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e); 
-		}
-	}
-
 	public static void sendClientConnectionNew(UserLoginInfo userLoginInfo) {
 		if (!enabled){
 			return;
@@ -291,31 +249,6 @@
 							
 			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
 		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
-		}
-	}
-
-
-	public static void sendException(Throwable exception) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
-	
-			addHeader(dbObject,MongoMessage_msgtype_exception);
-			
-			ByteArrayOutputStream bos = new ByteArrayOutputStream();
-			PrintWriter pw = new PrintWriter(bos);
-			exception.printStackTrace(pw);
-			pw.close();
-			String stack = bos.toString();
-
-			dbObject.put(MongoMessage_exceptionMessage,exception.getMessage());
-			dbObject.put(MongoMessage_exceptionStack,stack);
-			
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
 			VCMongoDbDriver.getInstance().getSessionLog().exception(e); 
 		}
 	}
@@ -373,46 +306,6 @@
 		}
 	}
 
-	public static void sendZombieJob(SimulationJobStatus jobStatus, String failureMessage, HtcJobID htcJobID) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
-
-			addHeader(dbObject,MongoMessage_msgtype_zombieJob);
-
-			dbObject.put(MongoMessage_info,failureMessage);
-			dbObject.put(MongoMessage_htcJobID,htcJobID.toDatabase());
-			
-			addObject(dbObject,jobStatus);
-			
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
-		}
-	}
-
-	public static void sendObsoleteJob(SimulationJobStatus jobStatus, String failureMessage, SimulationStateMachine simStateMachine) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
-
-			addHeader(dbObject,MongoMessage_msgtype_obsoleteJob);
-
-			dbObject.put(MongoMessage_info,failureMessage);
-			dbObject.put(MongoMessage_simStateMachineDump,simStateMachine.show());
-			
-			addObject(dbObject,jobStatus);
-			
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
-		}
-	}
-
 	public static void sendSimJobStatusInsert(SimulationJobStatus newSimulationJobStatus,SimulationJobStatus updatedSimulationJobStatus) {
 		if (!enabled){
 			return;
@@ -523,7 +416,7 @@
 
 			addHeader(dbObject,MongoMessage_msgtype_workerEventMessage);
 
-			addObject(dbObject,workerEventMessage.getWorkerEvent());
+			addObject(dbObject,workerEventMessage);
 				
 			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
 		} catch (Exception e){
@@ -531,7 +424,7 @@
 		}
 	}
 
-	public static void sendPBSWorkerMessage(SimulationTask simulationTask, HtcJobID htcJobID, String htcWorkerMsg) {
+	public static void sendPBSWorkerMessage(SimulationTask simulationTask, PbsJobID pbsJobID, String pbsWorkerMsg) {
 		if (!enabled){
 			return;
 		}
@@ -540,9 +433,9 @@
 
 			addHeader(dbObject,MongoMessage_msgtype_workerEventMessage);
 
-			dbObject.put(MongoMessage_htcWorkerMsg, htcWorkerMsg);
-			if (htcJobID!=null){
-				dbObject.put(MongoMessage_htcJobID, htcJobID.toDatabase());
+			dbObject.put(MongoMessage_pbsWorkerMsg, pbsWorkerMsg);
+			if (pbsJobID!=null){
+				dbObject.put(MongoMessage_pbsJobID, pbsJobID.getID());
 			}
 	
 			addObject(dbObject,simulationTask);
@@ -552,69 +445,15 @@
 			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
 		}
 	}
-	
-	public static void sendJmsMessageReceived(VCMessage vcMessage,	VCDestination vcDestination) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
 
-			addHeader(dbObject,MongoMessage_msgtype_jmsMessageReceived);
 
-			dbObject.put(MongoMessage_destination, vcDestination.getName());
-
-			addObject(dbObject, vcMessage);
-			
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
-		}
-	}
-
-	public static void sendJmsMessageSent(VCMessage vcMessage,	VCDestination vcDestination) {
+	public static void sendRpcRequestReceived(RpcRequest rpcRequest) {
 		if (!enabled){
 			return;
 		}
 		try {
 			BasicDBObject dbObject = new BasicDBObject();
 
-			addHeader(dbObject,MongoMessage_msgtype_jmsMessageSent);
-
-			dbObject.put(MongoMessage_destination, vcDestination.getName());
-
-			addObject(dbObject, vcMessage);
-			
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
-		}
-	}
-
-	public static void sendCommandServiceCall(CommandOutput commandOutput) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
-
-			addHeader(dbObject,MongoMessage_msgtype_commandServiceCall);
-
-			addObject(dbObject, commandOutput);
-			
-			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
-		} catch (Exception e){
-			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
-		}
-	}
-
-	public static void sendRpcRequestProcessed(VCRpcRequest rpcRequest) {
-		if (!enabled){
-			return;
-		}
-		try {
-			BasicDBObject dbObject = new BasicDBObject();
-
 			addHeader(dbObject,MongoMessage_msgtype_rpcRequestReceived);
 
 			addObject(dbObject,rpcRequest);
@@ -625,7 +464,7 @@
 		}
 	}
 
-	public static void sendRpcRequestSent(VCRpcRequest rpcRequest, UserLoginInfo userLoginInfo) {
+	public static void sendRpcRequestSent(RpcRequest rpcRequest, UserLoginInfo userLoginInfo) {
 		if (!enabled){
 			return;
 		}
@@ -719,29 +558,6 @@
 		dbObject.put(MongoMessage_clientInfo, dbObjectClientInfo);
 	}
 	
-	private static void addObject(BasicDBObject dbObject, CommandOutput commandOutput){
-		if (commandOutput == null){
-			return;
-		}
-		BasicDBObject dbObjectShellCmd = new BasicDBObject();
-		
-		if (commandOutput.getCommandStrings()!=null){
-			dbObjectShellCmd.put(MongoMessage_cmdString, commandOutput.getCommand());
-		}
-		dbObjectShellCmd.put(MongoMessage_elapsedTimeMS, commandOutput.getElapsedTimeMS());
-		if (commandOutput.getStandardOutput()!=null){
-			dbObjectShellCmd.put(MongoMessage_stdout, commandOutput.getStandardOutput());
-		}
-		if (commandOutput.getStandardError()!=null){
-			dbObjectShellCmd.put(MongoMessage_stderr, commandOutput.getStandardError());
-		}
-		if (commandOutput.getExitStatus()!=null){
-			dbObjectShellCmd.put(MongoMessage_exitCode, commandOutput.getExitStatus());
-		}
-		
-		dbObject.put(MongoMessage_shellCmd, dbObjectShellCmd);
-	}
-	
 	private static void addObject(BasicDBObject dbObject, SimulationJobStatusEvent simJobStatusEvent){
 		addObject(dbObject, simJobStatusEvent.getSimulationMessage());
 		addObject(dbObject, simJobStatusEvent.getJobStatus());
@@ -756,7 +572,7 @@
 		}			
 	}
 	
-	private static void addObject(BasicDBObject dbObject, VCRpcRequest rpcRequest){
+	private static void addObject(BasicDBObject dbObject, RpcRequest rpcRequest){
 		dbObject.put(MongoMessage_rpcRequestArgs,Arrays.asList(rpcRequest.getArguments()).toString());
 		for (Object arg : rpcRequest.getArguments()){
 			//
@@ -773,14 +589,8 @@
 		dbObject.put(MongoMessage_rpcRequestMethod,rpcRequest.getMethodName());
 		dbObject.put(MongoMessage_rpcRequestService,rpcRequest.getRequestedServiceType().getName());
 		dbObject.put(MongoMessage_userName,rpcRequest.getUserName());
-		if (rpcRequest.getRequestTimestampMS()!=null && rpcRequest.getBeginProcessingTimestampMS()!=null){
-			dbObject.put(MongoMessage_rpcRequestDelay,rpcRequest.getBeginProcessingTimestampMS().longValue() - rpcRequest.getRequestTimestampMS().longValue());
-		}
-		if (rpcRequest.getBeginProcessingTimestampMS()!=null && rpcRequest.getEndProcessingTimestampMS()!=null){
-			dbObject.put(MongoMessage_rpcServiceTime,rpcRequest.getEndProcessingTimestampMS().longValue() - rpcRequest.getBeginProcessingTimestampMS().longValue());
-		}
 	}
-		
+	
 	private static void addObject(BasicDBObject dbObject, SimulationTask simulationTask){
 		dbObject.put(MongoMessage_simId,simulationTask.getSimulationJob().getVCDataIdentifier().getSimulationKey().toString());
 		dbObject.put(MongoMessage_jobIndex, simulationTask.getSimulationJob().getJobIndex());
@@ -790,31 +600,6 @@
 	}
 	
 
-	private static void addObject(BasicDBObject dbObject, VCMessage message){
-		Object objectContent = message.getObjectContent();
-		if (objectContent instanceof WorkerEvent){
-			addObject(dbObject, (WorkerEvent)objectContent);
-		}else if (objectContent instanceof SimulationJobStatus){
-			addObject(dbObject, (SimulationJobStatus)objectContent);
-		}
-		dbObject.put(MongoMessage_jmsMessage, message.show());
-		if (message.propertyExists(MessageConstants.SIMKEY_PROPERTY)){
-			dbObject.put(MongoMessage_simId,String.valueOf(message.getLongProperty(MessageConstants.SIMKEY_PROPERTY)));
-		}
-		if (message.propertyExists(MessageConstants.JOBINDEX_PROPERTY)){
-			dbObject.put(MongoMessage_jobIndex, message.getIntProperty(MessageConstants.JOBINDEX_PROPERTY));
-		}
-		if (message.propertyExists(MessageConstants.TASKID_PROPERTY)){
-			dbObject.put(MongoMessage_taskId, message.getIntProperty(MessageConstants.TASKID_PROPERTY));
-		}
-		if (message.propertyExists(MessageConstants.USERNAME_PROPERTY)){
-			dbObject.put(MongoMessage_userName, message.getStringProperty(MessageConstants.USERNAME_PROPERTY));
-		}
-		if (message.propertyExists(MessageConstants.SIMULATION_STATUS_PROGRESS_PROPERTY)){
-			dbObject.put(MongoMessage_simProgress, message.getDoubleProperty(MessageConstants.SIMULATION_STATUS_PROGRESS_PROPERTY));
-		}
-	}
-	
 	private static void addObject(BasicDBObject dbObject, WorkerEventMessage workerEventMessage){
 		WorkerEvent workerEvent = workerEventMessage.getWorkerEvent();
 		dbObject.put(MongoMessage_computeHost, workerEvent.getHostName());
@@ -829,22 +614,6 @@
 		dbObject.put(MongoMessage_simTime,workerEvent.getTimePoint());
 	}
 	
-	private static void addObject(BasicDBObject dbObject, WorkerEvent workerEvent){
-		dbObject.put(MongoMessage_computeHost, workerEvent.getHostName());
-		dbObject.put(MongoMessage_simId,workerEvent.getVCSimulationDataIdentifier().getSimulationKey().toString());
-		dbObject.put(MongoMessage_jobIndex, workerEvent.getJobIndex());
-		dbObject.put(MongoMessage_taskId, workerEvent.getTaskID());
-		if (workerEvent.getHtcJobID()!=null){
-			dbObject.put(MongoMessage_htcJobID, workerEvent.getHtcJobID().toDatabase());
-		}
-		//workerEvent.getEventTypeID();
-		//workerEvent.getMessageData();
-		//workerEvent.getMessageSource();
-		addObject(dbObject, workerEvent.getSimulationMessage());
-		dbObject.put(MongoMessage_simProgress,workerEvent.getProgress());
-		dbObject.put(MongoMessage_simTime,workerEvent.getTimePoint());
-	}
-	
 	private static void addObject(BasicDBObject dbObject, SolverEvent solverEvent){
 		AbstractSolver solver = (AbstractSolver)solverEvent.getSource();
 		dbObject.put(MongoMessage_simProgress,solverEvent.getProgress());
@@ -861,7 +630,7 @@
 		dbObject.put(MongoMessage_simId,newSimulationJobStatus.getVCSimulationIdentifier().getSimulationKey().toString());
 		dbObject.put(MongoMessage_taskId, newSimulationJobStatus.getTaskID());
 		dbObject.put(MongoMessage_jobIndex, newSimulationJobStatus.getJobIndex());
-		dbObject.put(MongoMessage_schedulerStatus, newSimulationJobStatus.getSchedulerStatus().getDescription());
+		dbObject.put(MongoMessage_schedulerStatus, newSimulationJobStatus.getSchedulerStatusDescription());
 		dbObject.put(MongoMessage_serverId, newSimulationJobStatus.getServerID().toString());
 		if (newSimulationJobStatus.getTimeDateStamp()!=null){
 			dbObject.put(MongoMessage_simJobStatusTimeStamp,newSimulationJobStatus.getTimeDateStamp().getTime());
@@ -893,8 +662,8 @@
 			dbObject.put(MongoMessage_latestUpdateTime, simExeStatus.getLatestUpdateDate().getTime());
 			dbObject.put(MongoMessage_latestUpdateTimeNice, simExeStatus.getLatestUpdateDate().toString());
 		}
-		if (simExeStatus.getHtcJobID()!=null){
-			dbObject.put(MongoMessage_htcJobID, simExeStatus.getHtcJobID().toDatabase());
+		if (simExeStatus.getPbsJobID()!=null){
+			dbObject.put(MongoMessage_pbsJobID, simExeStatus.getPbsJobID().getID());
 		}
 	}
 	
@@ -905,8 +674,8 @@
 		DetailedState detailedState = simMessage.getDetailedState();
 		dbObject.put(MongoMessage_simMessageState,detailedState.name());
 		dbObject.put(MongoMessage_simMessageMsg,simMessage.getDisplayMessage());
-		if (simMessage.getHtcJobId()!=null){
-			dbObject.put(MongoMessage_htcJobID,simMessage.getHtcJobId().toDatabase());
+		if (simMessage.getPbsJobId()!=null){
+			dbObject.put(MongoMessage_pbsJobID,simMessage.getPbsJobId().getID());
 		}
 	}
 
@@ -918,13 +687,9 @@
 			dbObject.put(MongoMessage_simQueueEntryDate,simQueueEntryStatus.getQueueDate().getTime());
 			dbObject.put(MongoMessage_simQueueEntryDateNice,simQueueEntryStatus.getQueueDate().toString());
 		}
-		dbObject.put(MongoMessage_simQueueEntryId,simQueueEntryStatus.getQueueID().name());
+		dbObject.put(MongoMessage_simQueueEntryId,simQueueEntryStatus.getQueueID());
 		dbObject.put(MongoMessage_simQueueEntryPriority,simQueueEntryStatus.getQueuePriority());
 	}
 
-	public static void flush() {
-		VCMongoDbDriver.getInstance().flush();
-	}
 
-
 }
\ No newline at end of file
Index: src/cbit/vcell/transaction/JtaTransactionManager.java
===================================================================
--- src/cbit/vcell/transaction/JtaTransactionManager.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/JtaTransactionManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+import javax.transaction.*;
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/21/2003 12:53:42 PM)
+ * @author: Fei Gao
+ */
+public class JtaTransactionManager implements TransactionManager, UserTransaction {
+   
+    
+    
+    public static final int DEFAULT_TRANSACTION_TIMEOUT = 30;
+    
+    
+    private Map bindings = Collections.synchronizedMap(new HashMap());
+    
+    
+    private Map timeouts = Collections.synchronizedMap(new HashMap());   
+    
+/**
+ * Insert the method's description here.
+ * Creation date: (7/25/2003 12:27:18 PM)
+ */
+public JtaTransactionManager() {}
+/**
+ * Create a new transaction and associate it with the current thread.
+ *
+ * @exception NotSupportedException Thrown if the thread is already
+ * associated with a transaction and the Transaction Manager
+ * implementation does not support nested transactions.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void begin() throws NotSupportedException, SystemException {
+
+	Transaction currentTransaction = getTransaction();
+	if (currentTransaction != null) {
+		throw new NotSupportedException();
+	}
+
+	currentTransaction = new JtaTransactionImpl(this);
+	bindings.put(Thread.currentThread(), currentTransaction);	
+}
+/**
+ * Complete the transaction associated with the current thread. When this
+ * method completes, the thread becomes associated with no transaction.
+ * If the commit is terminated with an exception, the rollback should be
+ * called, to do a proper clean-up.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void commit() throws	RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {
+
+	Thread currentThread = Thread.currentThread();
+	Transaction currentTransaction = (Transaction) bindings.get(currentThread);
+	if (currentTransaction == null) {
+		throw new IllegalStateException();
+	}
+
+	timeouts.remove(currentThread);
+
+	try {
+		currentTransaction.commit();
+	} finally {
+		bindings.remove(currentThread);
+		currentTransaction = null;
+	}
+
+}
+/**
+ * Obtain the status of the transaction associated with the current thread.
+ *
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ * @return The transaction status. If no transaction is associated with
+ * the current thread, this method returns the Status.NoTransaction value.
+ */
+public int getStatus() throws SystemException {
+
+	Transaction currentTransaction = getTransaction();
+	if (currentTransaction == null) {
+		return Status.STATUS_NO_TRANSACTION;
+	}
+
+	return currentTransaction.getStatus();
+
+}
+/**
+ * Get the transaction object that represents the transaction context of
+ * the calling thread.
+ *
+ * @return the Transaction object representing the transaction associated
+ * with the calling thread.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public Transaction getTransaction() throws SystemException {
+	return (Transaction) bindings.get(Thread.currentThread());
+}
+/**
+ * Resume the transaction context association of the calling thread with
+ * the transaction represented by the supplied Transaction object. When
+ * this method returns, the calling thread is associated with the
+ * transaction context specified.
+ *
+ * @param tobj The Transaction object that represents the transaction to
+ * be resumed.
+ * @exception InvalidTransactionException Thrown if the parameter
+ * transaction object contains an invalid transaction.
+ * @exception IllegalStateException Thrown if the thread is already
+ * associated with another transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void resume(Transaction tobj) throws InvalidTransactionException, IllegalStateException, SystemException {
+
+	if (getTransaction() != null) {
+		throw new IllegalStateException();
+	}
+
+	if (tobj == null) {
+		throw new InvalidTransactionException();
+	}
+
+	bindings.put(Thread.currentThread(), tobj);
+
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void rollback() throws SecurityException, IllegalStateException, SystemException {
+
+	Thread currentThread = Thread.currentThread();
+	Transaction currentTransaction = (Transaction) bindings.remove(currentThread);
+	if (currentTransaction == null) {
+		throw new IllegalStateException();
+	}
+
+	timeouts.remove(currentThread);
+
+	currentTransaction.rollback();
+	currentTransaction = null;
+}
+/**
+ * Modify the transaction associated with the current thread such that
+ * the only possible outcome of the transaction is to roll back the
+ * transaction.
+ *
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void setRollbackOnly() throws IllegalStateException, SystemException {
+
+	Transaction currentTransaction = getTransaction();
+	if (currentTransaction == null) {
+		throw new IllegalStateException();
+	}
+
+	currentTransaction.setRollbackOnly();
+
+}
+/**
+ * Modify the value of the timeout value that is associated with the
+ * transactions started by the current thread with the begin method.
+ * <p>
+ * If an application has not called this method, the transaction service
+ * uses some default value for the transaction timeout.
+ *
+ * @param seconds The value of the timeout in seconds. If the value is
+ * zero, the transaction service restores the default value.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void setTransactionTimeout(int seconds) throws SystemException {
+	timeouts.put(Thread.currentThread(), new Integer(seconds));
+}
+/**
+ * Suspend the transaction currently associated with the calling thread
+ * and return a Transaction object that represents the transaction
+ * context being suspended. If the calling thread is not associated with
+ * a transaction, the method returns a null object reference. When this
+ * method returns, the calling thread is associated with no transaction.
+ *
+ * @return Transaction object representing the suspended transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public Transaction suspend() throws SystemException {
+
+	Transaction currentTransaction = getTransaction();
+
+	if (currentTransaction != null) {
+		Thread currentThread = Thread.currentThread();
+		bindings.remove(currentThread);
+		timeouts.remove(currentThread);
+	}
+
+	return currentTransaction;
+
+}
+}
Index: src/cbit/vcell/transaction/JtaDbConnection.java
===================================================================
--- src/cbit/vcell/transaction/JtaDbConnection.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/JtaDbConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/31/2003 8:35:21 AM)
+ * @author: Fei Gao
+ */
+public interface JtaDbConnection {
+	public void close() throws java.sql.SQLException;
+	public void closeOnFailure() throws java.sql.SQLException;
+	public java.sql.Connection getConnection() throws java.sql.SQLException;
+	public boolean joinTransaction(javax.transaction.TransactionManager tm) throws java.sql.SQLException;
+}
Index: src/cbit/vcell/transaction/JtaOracleConnection.java
===================================================================
--- src/cbit/vcell/transaction/JtaOracleConnection.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/JtaOracleConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+/**
+ * Insert the type's description here.
+ * Creation date: (7/29/2003 9:27:42 AM)
+ * @author: Fei Gao
+ */
+public class JtaOracleConnection implements NonXAResource, JtaDbConnection {
+	private Object lock = null;
+	private java.sql.Connection oracleConnection = null;
+	private cbit.sql.ConnectionFactory connFactory = null;
+
+/**
+ * JtaOracleConnectionFactory constructor comment.
+ * @param dbUrl java.lang.String
+ * @param username java.lang.String
+ * @param password java.lang.String
+ * @param ttm javax.transaction.TransactionManager
+ * @exception javax.transaction.RollbackException The exception description.
+ * @exception java.sql.SQLException The exception description.
+ * @exception javax.transaction.xa.XAException The exception description.
+ * @exception javax.transaction.SystemException The exception description.
+ */
+public JtaOracleConnection(cbit.sql.ConnectionFactory oracleFactory) throws java.sql.SQLException {
+	lock = new Object();
+	connFactory = oracleFactory;
+	oracleConnection = oracleFactory.getConnection(lock);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public void close() throws java.sql.SQLException {
+	connFactory.release(oracleConnection, lock);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public void closeOnFailure() throws java.sql.SQLException {
+	connFactory.failed(oracleConnection, lock);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public void commit() throws javax.transaction.SystemException {
+	try {
+		oracleConnection.commit();
+	} catch (java.sql.SQLException ex) {
+		throw new javax.transaction.SystemException(ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:11:30 PM)
+ * @return cbit.sql.ConnectionFactory
+ */
+public java.sql.Connection getConnection() {
+	return oracleConnection;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public boolean joinTransaction(javax.transaction.TransactionManager tm) throws java.sql.SQLException {
+	try {
+		((JtaTransactionImpl)tm.getTransaction()).enlistNonXAResource(this);
+		return true;
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+		throw new java.sql.SQLException(ex.getMessage());		
+	}
+}
+
+
+/**
+ * rollback method comment.
+ */
+public void rollback() throws javax.transaction.SystemException {
+	try {
+		oracleConnection.rollback();
+	} catch (java.sql.SQLException ex) {
+		throw new javax.transaction.SystemException(ex.getMessage());
+	}	
+}
+}
Index: src/cbit/vcell/transaction/JtaXidImpl.java
===================================================================
--- src/cbit/vcell/transaction/JtaXidImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/JtaXidImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+import java.io.Serializable;
+import javax.transaction.xa.Xid;
+
+/**
+ * Xid implementation for JTA
+ */
+public class JtaXidImpl implements Xid, Serializable {
+
+    private static final int FORMAT_ID = 0;    
+    
+    /**
+     * Branch qualifier.
+     */
+    private byte[] branchQualifier; 
+
+    
+    
+    /**
+     * Global transaction id.
+     */
+    private byte[] globalTransactionId;
+    
+    
+/**
+ * Constructor.
+ */
+public JtaXidImpl(byte[] globalTransactionId0, byte[] branchQualifier0) {
+	setGlobalTransactionId(globalTransactionId0);
+	setBranchQualifier(branchQualifier0);
+}
+/**
+ * Obtain the transaction branch identifier part of XID as an array of 
+ * bytes.
+ * 
+ * @return Global transaction identifier.
+ */
+public byte[] getBranchQualifier() {
+	return branchQualifier;
+}
+/**
+ * The formatID is usually zero, meaning that you are using the 
+ * OSI CCR (Open Systems Interconnection Commitment, Concurrency, and Recovery standard) 
+ * for naming. If you are using another format, the formatID should be greater than zero. 
+ * A value of -1 means that the Xid is null.
+ * 
+ * Obtain the format identifier part of the XID.
+ * 
+ * @return Format identifier. O means the OSI CCR format.
+ */
+public int getFormatId() {
+	return FORMAT_ID;
+}
+/**
+ * Obtain the global transaction identifier part of XID as an array of 
+ * bytes.
+ * 
+ * @return Global transaction identifier.
+ */
+public byte[] getGlobalTransactionId() {
+	return globalTransactionId;
+}
+/**
+ * Create a new branch based on this Xid.
+ */
+public Xid newBranch(int branchNumber) {
+	return new JtaXidImpl(getGlobalTransactionId(), Integer.toString(branchNumber).getBytes());
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (1/27/2004 1:26:39 PM)
+ * @param newBranchQualifier byte[]
+ */
+private void setBranchQualifier(byte[] aBranchQualifier) {
+	int length = 0;
+	if (aBranchQualifier == null) {
+		length = 0;
+		branchQualifier = new byte[length];
+	} else {
+		length = aBranchQualifier.length <= 64 ? aBranchQualifier.length : 64;
+		branchQualifier = new byte[length];
+		System.arraycopy(aBranchQualifier, 0, branchQualifier, 0, length);
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (1/27/2004 1:26:39 PM)
+ * @param newGlobalTransactionId byte[]
+ */
+private void setGlobalTransactionId(byte[] aGlobalTransactionId) {
+	int length = 0;
+	if (aGlobalTransactionId == null) {
+		length = 0;
+		globalTransactionId = new byte[length];
+	} else {
+		length = aGlobalTransactionId.length <= 64 ? aGlobalTransactionId.length : 64;
+		globalTransactionId = new byte[length];
+		System.arraycopy(aGlobalTransactionId, 0, globalTransactionId, 0, length);
+	}
+}
+/**
+ * Obtain a String representation of this xid.
+ */
+public String toString() {
+	return "[" + new String(getGlobalTransactionId()) + "," + new String(getBranchQualifier()) + "]";
+}
+}
Index: src/cbit/vcell/transaction/JtaTransactionImpl.java
===================================================================
--- src/cbit/vcell/transaction/JtaTransactionImpl.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/JtaTransactionImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,817 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import javax.transaction.*;
+import javax.transaction.xa.*;
+
+import oracle.jdbc.xa.OracleXAException;
+
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/23/2003 4:12:01 PM)
+ * @author: Fei Gao
+ */
+public class JtaTransactionImpl implements Transaction {
+
+	private JtaXidImpl xid = null;
+
+	private Map<Xid, XAResource> branches = Collections.synchronizedMap(new HashMap<Xid, XAResource>());
+	private Map<Xid, Integer> prepareResults = Collections.synchronizedMap(new HashMap<Xid, Integer>());
+	
+	private Map<XAResource, Xid> activeBranches = Collections.synchronizedMap(new HashMap<XAResource, Xid>());
+	private List<XAResource> enlistedResources = Collections.synchronizedList(new ArrayList<XAResource>());
+	private List<NonXAResource> nonXAResources = Collections.synchronizedList(new ArrayList<NonXAResource>());
+	private Map<XAResource, Xid> suspendedResources = Collections.synchronizedMap(new HashMap<XAResource, Xid>());
+
+	private int status = Status.STATUS_ACTIVE;
+
+	private List<Synchronization> synchronizationObjects = Collections.synchronizedList(new ArrayList<Synchronization>());
+	private int branchCounter = 1;
+	private static int globalCreatedTransactions = 0;
+	private int currentTransactionNumber = 0;
+	private String currentThreadName = null;
+	private javax.transaction.TransactionManager transactionManager = null;
+
+/**
+ * Constructor.
+ */
+public JtaTransactionImpl(TransactionManager tm) {
+	// Generate the transaction id
+	globalCreatedTransactions ++;
+	currentTransactionNumber = globalCreatedTransactions;
+	currentThreadName = Thread.currentThread().getName();
+	xid = new JtaXidImpl((currentThreadName + "-" + System.currentTimeMillis() + "-" + currentTransactionNumber).getBytes(), new byte[0]);
+	this.transactionManager = tm;
+}
+
+/**
+ * Complete the transaction represented by this Transaction object.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void commit() throws	RollbackException, HeuristicMixedException, HeuristicRollbackException,	SecurityException, IllegalStateException, SystemException {	
+
+	if (status == Status.STATUS_MARKED_ROLLBACK) {
+		rollback();
+		return;
+	}
+
+	// Check status ACTIVE
+	if (status != Status.STATUS_ACTIVE)
+		throw new IllegalStateException();
+
+	// Call synchronized objects beforeCompletion
+	for (Synchronization sync : synchronizationObjects) {
+		sync.beforeCompletion();
+	}
+
+	List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<Throwable>());
+	boolean fail = false;
+
+	switch (enlistedResources.size()) {
+		case 0: {
+			// only commit nonXA
+			if (nonXAResources.size() > 0) {
+				try {
+					do_commitNonXA();
+					status = Status.STATUS_COMMITTED;
+				} catch (Throwable e) {				
+					fail = false;
+					try {
+						do_rollbackNonXA();
+					} catch (Throwable ex) {
+						exceptions.add(ex);
+						fail = true;
+					}
+					status = Status.STATUS_ROLLEDBACK;
+				}
+
+			}
+			break;
+		} // case 0
+
+		case 1:	{
+			//System.out.print("1-Phase commit started....");
+
+			// One phase commit		
+			try {
+				do_delist();
+			} catch (SystemException e) {
+				exceptions.add(e);
+				fail = true;
+				status = Status.STATUS_MARKED_ROLLBACK;
+			}
+				
+			if (!fail) {
+				try {
+					do_commitNonXA();
+					do_commit(true);
+				} catch (Throwable e) {					
+					if (e instanceof XAException) {
+						System.out.println("1-Phase commit XAException: " + getXAErrorCode((XAException)e));
+					}					
+					exceptions.add(e);
+					fail = true;				
+				}
+
+				status = Status.STATUS_COMMITTED;
+			} else {
+				try {
+					fail = false;
+					do_rollbackNonXA();
+					do_rollback();
+				} catch (Throwable e) {					
+					if (e instanceof XAException) {
+						System.out.println("1-Phase rollback XAException: " + getXAErrorCode((XAException)e));
+					}
+					exceptions.add(e);
+					fail = true;				
+				}
+				status = Status.STATUS_ROLLEDBACK;
+			}
+
+			//System.out.println("1-phase commit ended");
+			break;
+		} // case 1
+
+		default: {
+			// two phase commit						
+			// end each enlisted resource	
+			try {
+				// Preparing the resource manager using its branch xid
+				do_delist();
+			} catch (SystemException e) {
+				exceptions.add(e);
+				fail = true;
+				status = Status.STATUS_MARKED_ROLLBACK;
+			}
+
+			// Prepare each enlisted resource
+			if (!fail) {
+				try {
+					do_prepare();
+				} catch (XAException ex) {
+					ex.printStackTrace(System.out);
+					if (ex instanceof OracleXAException) {						
+						int oraerr = ((OracleXAException)ex).getOracleError();
+						System.out.println("2-Phase commit do_prepare Oracle error " + oraerr); 
+					} else {
+						System.out.println("2-Phase commit XAException: " + getXAErrorCode((XAException)ex));
+					}
+					fail = true;
+					exceptions.add(ex);
+					status = Status.STATUS_MARKED_ROLLBACK;
+				}
+			}		
+		
+			if (!fail) {
+				try {
+					do_commitNonXA();
+				} catch (Throwable e) {
+					exceptions.add(e);
+					fail = true;				
+				}
+				status = Status.STATUS_COMMITTED;
+			}
+
+			if (!fail) {
+				// Commit each enlisted resource
+				status = Status.STATUS_PREPARED;
+				status = Status.STATUS_COMMITTING;
+				
+				//System.out.print("2-Phase commit started....");
+				
+				try {
+					do_commit(false);	
+				} catch (XAException e) {
+					e.printStackTrace(System.out);
+					if (e instanceof OracleXAException) {						
+						int oraerr = ((OracleXAException)e).getOracleError();
+						System.out.println("2-Phase commit do_commit Oracle error " + oraerr); 
+					} else {
+						System.out.println("2-Phase commit XAException: " + getXAErrorCode((XAException)e));
+					}
+					exceptions.add(e);
+					fail = true;
+				}
+				status = Status.STATUS_COMMITTED;
+				//System.out.println("2-Phase commit ended");
+
+			} else {
+				System.out.println("2-Phase commit fail, rollback started....");
+				//If fail, rollback
+				status = Status.STATUS_ROLLING_BACK;
+				fail = false;
+				// Rolling back all the prepared (and unprepared) branches
+				try {
+					do_rollbackNonXA();
+					do_rollback();
+				} catch (Throwable e) {
+					if (e instanceof XAException) {
+						System.out.println("2-Phase rollback XAException: " + getXAErrorCode((XAException)e));
+					}
+					exceptions.add(e);
+					fail = true;
+				}
+				status = Status.STATUS_ROLLEDBACK;
+				//System.out.println("2-Phase rollback ended");
+			}
+
+			break;
+		} //default
+
+	}
+
+	// Call synchronized objects afterCompletion
+	for (Synchronization sync : synchronizationObjects) {
+		sync.afterCompletion(status);
+	}
+
+	// Parsing exception and throwing an appropriate exception
+	if (exceptions.size() > 0) {
+		System.out.println(this + "  COMMIT... \t\t[ FAILED ]");
+		if (status == Status.STATUS_ROLLEDBACK) {
+			if (!fail) {
+				throw new RollbackException();
+			} else {
+				throw new HeuristicRollbackException();
+			}
+		}
+		if (status == Status.STATUS_COMMITTED && fail) {
+			throw new HeuristicMixedException();
+		}
+	}
+	System.out.println(this + "  COMMIT... \t\t[ OK ]");
+}
+/**
+ * Delist the resource specified from the current transaction associated
+ * with the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @param flag One of the values of TMSUCCESS, TMSUSPEND, or TMFAIL
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is inactive.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public boolean delistResource(XAResource xaRes, int flag) throws IllegalStateException, SystemException { 
+
+	//System.out.println(this + "  DELIST " + xaRes);
+
+	// Check status ACTIVE
+	if (status != Status.STATUS_ACTIVE)
+		throw new IllegalStateException();
+
+	Xid xid = (Xid) activeBranches.get(xaRes);
+	if (xid == null) {
+		throw new IllegalStateException();
+	}
+	activeBranches.remove(xaRes);
+
+	try {
+		xaRes.end(xid, flag);
+	} catch (XAException e) {
+		e.printStackTrace(System.out);
+		return false;
+	}
+
+	if (flag == XAResource.TMSUSPEND) {
+		suspendedResources.put(xaRes, xid);
+	}
+
+	//System.out.println("Delisted ok(" + this + ") = " + xaRes + " xid: " + xid);
+
+	return true;
+
+}
+
+/**
+ * Complete the transaction represented by this Transaction object.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_commit(boolean onePhase) throws	XAException {
+
+	for (Xid key : branches.keySet()) {
+		XAResource resourceManager = branches.get(key);
+		if (onePhase) {
+			resourceManager.commit(key, true);
+		} else {
+			Integer prepareResult = prepareResults.get(key);
+			if (prepareResult != null && prepareResult == XAResource.XA_OK) {
+				resourceManager.commit(key, false);
+			}
+		}
+			
+	}	
+}
+
+/**
+ * Complete the transaction represented by this Transaction object.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_commitNonXA() throws SystemException {
+	for (int i = 0; i < nonXAResources.size(); i++){
+		NonXAResource res = (NonXAResource)nonXAResources.get(i);	
+		res.commit();	
+	}
+}
+/**
+ * Delist the resource specified from the current transaction associated
+ * with the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @param flag One of the values of TMSUCCESS, TMSUSPEND, or TMFAIL
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is inactive.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_delist() throws SystemException {
+	// end each enlisted resource	
+	for (Xid key : branches.keySet()) {
+		XAResource resourceManager = branches.get(key);
+		// Preparing the resource manager using its branch xid
+		delistResource(resourceManager, XAResource.TMSUCCESS);
+	}
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_prepare() throws XAException { 	
+	for (Xid key : branches.keySet()) {
+		XAResource resourceManager = (XAResource) branches.get(key);
+		// Preparing the resource manager using its branch xid
+		int retval = resourceManager.prepare(key);
+		prepareResults.put(key, new Integer(retval));
+	}
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_rollback() throws XAException {
+	status = Status.STATUS_ROLLING_BACK;
+	for (Xid xid : branches.keySet()) {
+		XAResource resourceManager = branches.get(xid);
+		resourceManager.rollback(xid);
+	}
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_rollbackNonXA() throws SystemException {
+	for (int i = 0; i < nonXAResources.size(); i++){
+		NonXAResource res = (NonXAResource)nonXAResources.get(i);	
+		res.rollback();	
+	}
+}
+/**
+ * Enlist the resource specified with the current transaction context of
+ * the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @return true if the resource was enlisted successfully; otherwise false.
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been marked for rollback only.
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is in prepared state or the transaction is inactive.
+ * @exception SystemException Thrown if the transaction manager
+ * encounters an unexpected error condition.
+ */
+public boolean enlistNonXAResource(NonXAResource res) {
+	//System.out.println("Enlist a non XA Resource");
+	nonXAResources.add(res);		
+	return true;
+}
+/**
+ * Enlist the resource specified with the current transaction context of
+ * the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @return true if the resource was enlisted successfully; otherwise false.
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been marked for rollback only.
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is in prepared state or the transaction is inactive.
+ * @exception SystemException Thrown if the transaction manager
+ * encounters an unexpected error condition.
+ */
+public boolean enlistResource(XAResource xaRes)	throws RollbackException, IllegalStateException, SystemException {
+
+	//System.out.println(this + "  ENLIST " + xaRes);
+	if (status == Status.STATUS_MARKED_ROLLBACK) {
+		throw new RollbackException();
+	}
+
+	// Check status ACTIVE
+	if (status != Status.STATUS_ACTIVE) {
+		throw new IllegalStateException();
+	}
+
+	// Preventing two branches from being active at the same time on the
+	// same resource manager
+	Xid activeXid = (Xid) activeBranches.get(xaRes);
+	if (activeXid != null) {
+		return false;
+	}
+		
+	boolean alreadyEnlisted = false;
+	int flag = XAResource.TMNOFLAGS;
+
+	Xid branchXid = (Xid) suspendedResources.get(xaRes);
+
+	if (branchXid == null) {
+		for (XAResource resourceManager : enlistedResources) { 
+			if (alreadyEnlisted) {
+				break;
+			}
+			try {
+				if (resourceManager.isSameRM(xaRes)) {
+					System.out.println("Same Resource: " + xaRes + "," + resourceManager);
+
+					// TMJOIN is not support , because TMJOIN is allowed only after XAResource.end is invoked
+
+					//flag = XAResource.TMJOIN;
+					// use the same branch Xid to join the existing branch
+					//branchXid = (Xid)activeBranches.get(resourceManager);
+
+					alreadyEnlisted = true;
+				}
+			} catch (XAException e) {				
+				throw new SystemException(JtaTransactionImpl.getXAErrorCode(e));
+			}
+		}
+		
+		// use different branch Xid
+		branchXid = this.xid.newBranch(branchCounter ++);
+			
+		//System.out.println("Creating new branch for " + xaRes + "with Xid " + branchXid);
+
+	} else {
+		alreadyEnlisted = true;
+		flag = XAResource.TMRESUME;
+		suspendedResources.remove(xaRes);
+	}
+
+	try {
+		//System.out.println("Starting" + xaRes + " Branch: " + branchXid + ", Flag: " + getXAFlag(flag));
+		xaRes.start(branchXid, flag);
+		//System.out.println("End Starting" + xaRes + " Branch: " + branchXid + ", Flag: " + getXAFlag(flag));
+	} catch (XAException e) {
+		System.out.println("XAResource start Error code = " + getXAErrorCode(e));
+		return false;
+	}
+
+	if (!alreadyEnlisted) {
+		enlistedResources.add(xaRes);			
+	}
+		
+	branches.put(branchXid, xaRes);		
+	activeBranches.put(xaRes, branchXid);
+		
+	return true;
+}
+/**
+ * Obtain the status of the transaction associated with the current thread.
+ *
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ * @return The transaction status. If no transaction is associated with
+ * the current thread, this method returns the Status.NoTransaction value.
+ */
+public int getStatus() throws SystemException {
+	return status;
+}
+/**
+ * Return a String representation of the error code contained in a
+ * XAException.
+ */
+public static String getXAErrorCode(Throwable throww) {
+	String result = null;
+	if (throww instanceof XAException) {
+		result = getXAErrorCode((XAException) throww);
+	} else {
+		StringWriter sw = new StringWriter();
+		throww.printStackTrace(new PrintWriter(sw, true)); //autoFlush=true
+		result = sw.toString();
+	}
+	return result;
+}
+/**
+ * Return a String representation of the error code contained in a
+ * XAException.
+ */
+public static String getXAErrorCode(XAException xae) {
+	switch (xae.errorCode) {
+		case XAException.XA_HEURCOM :
+			{
+				return "XA_HEURCOM";
+			}
+		case XAException.XA_HEURHAZ :
+			{
+				return "XA_HEURHAZ";
+			}
+		case XAException.XA_HEURMIX :
+			{
+				return "XA_HEURMIX";
+			}
+		case XAException.XA_HEURRB :
+			{
+				return "XA_HEURRB";
+			}
+		case XAException.XA_NOMIGRATE :
+			{
+				return "XA_NOMIGRATE";
+			}
+		case XAException.XA_RBBASE :
+			{
+				return "XA_RBBASE";
+			}
+		case XAException.XA_RBCOMMFAIL :
+			{
+				return "XA_RBCOMMFAIL";
+			}
+		case XAException.XA_RBDEADLOCK :
+			{
+				return "XA_RBBEADLOCK";
+			}
+		case XAException.XA_RBEND :
+			{
+				return "XA_RBEND";
+			}
+		case XAException.XA_RBINTEGRITY :
+			{
+				return "XA_RBINTEGRITY";
+			}
+		case XAException.XA_RBOTHER :
+			{
+				return "XA_RBOTHER";
+			}
+		case XAException.XA_RBPROTO :
+			{
+				return "XA_RBPROTO";
+			}
+		case XAException.XA_RBTIMEOUT :
+			{
+				return "XA_RBTIMEOUT";
+			}
+		case XAException.XA_RDONLY :
+			{
+				return "XA_RDONLY";
+			}
+		case XAException.XA_RETRY :
+			{
+				return "XA_RETRY";
+			}
+		case XAException.XAER_ASYNC :
+			{
+				return "XAER_ASYNC";
+			}
+		case XAException.XAER_DUPID :
+			{
+				return "XAER_DUPID";
+			}
+		case XAException.XAER_INVAL :
+			{
+				return "XAER_INVAL";
+			}
+		case XAException.XAER_NOTA :
+			{
+				return "XAER_NOTA";
+			}
+		case XAException.XAER_OUTSIDE :
+			{
+				return "XAER_OUTSIDE";
+			}
+		case XAException.XAER_PROTO :
+			{
+				return "XAER_PROTO";
+			}
+		case XAException.XAER_RMERR :
+			{
+				return "XAER_RMERR";
+			}
+		case XAException.XAER_RMFAIL :
+			{
+				return "XAER_RMFAIL";
+			}
+		default :
+			{
+				return "UNKNOWN";
+			}
+	}
+}
+/**
+ * Return a String representation of a flag.
+ */
+public static String getXAFlag(int flag) {
+	switch (flag) {
+		case XAResource.TMENDRSCAN :
+			{
+				return "TMENDRSCAN";
+			}
+		case XAResource.TMFAIL :
+			{
+				return "TMFAIL";
+			}
+		case XAResource.TMJOIN :
+			{
+				return "TMJOIN";
+			}
+		case XAResource.TMNOFLAGS :
+			{
+				return "TMNOFLAGS";
+			}
+		case XAResource.TMONEPHASE :
+			{
+				return "TMONEPHASE";
+			}
+		case XAResource.TMRESUME :
+			{
+				return "TMRESUME";
+			}
+		case XAResource.TMSTARTRSCAN :
+			{
+				return "TMSTARTRSCAN";
+			}
+		case XAResource.TMSUCCESS :
+			{
+				return "TMSUCCESS";
+			}
+		case XAResource.TMSUSPEND :
+			{
+				return "TMSUSPEND";
+			}
+		default :
+			{
+				return "UNKNOWN";
+			}
+	}
+}
+/**
+ * Register a synchronization object for the transaction currently
+ * associated with the calling thread. The transction manager invokes the
+ * beforeCompletion method prior to starting the transaction commit
+ * process. After the transaction is completed, the transaction manager
+ * invokes the afterCompletion method.
+ *
+ * @param sync The Synchronization object for the transaction associated
+ * with the target object.
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been marked for rollback only.
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is in prepared state or the transaction is inactive.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void registerSynchronization(Synchronization sync) throws RollbackException, IllegalStateException, SystemException {
+
+	if (status == Status.STATUS_MARKED_ROLLBACK) {
+		throw new RollbackException();
+	}
+
+	if (status != Status.STATUS_ACTIVE) {
+		throw new IllegalStateException();
+	}
+
+	synchronizationObjects.add(sync);
+
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void rollback() throws IllegalStateException, SystemException {
+
+	//System.out.println(this + "  ROLLBACK ");
+
+	// Check status ACTIVE	
+	if (status != Status.STATUS_ACTIVE && status != Status.STATUS_MARKED_ROLLBACK) {
+		throw new IllegalStateException();
+	}
+
+	status = Status.STATUS_ROLLING_BACK;
+
+	try {
+		do_rollbackNonXA();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+	}
+
+	try {
+		do_rollback();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+	}
+	
+	status = Status.STATUS_ROLLEDBACK;
+}
+/**
+ * Modify the transaction associated with the current thread such that
+ * the only possible outcome of the transaction is to roll back the
+ * transaction.
+ *
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void setRollbackOnly() throws IllegalStateException, SystemException {
+	status = Status.STATUS_MARKED_ROLLBACK;
+}
+/**
+ * Print the Transaction object in a debugger friendly manner
+ */
+public String toString() {
+	return "Transaction " + currentTransactionNumber + " xid " + xid + " in thread " + currentThreadName
+		+ ((currentThreadName.equals(Thread.currentThread().getName())) ? "" : (" current= " + Thread.currentThread().getName()));
+}
+}
Index: src/cbit/vcell/transaction/NonXAResource.java
===================================================================
--- src/cbit/vcell/transaction/NonXAResource.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/NonXAResource.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/29/2003 1:06:24 PM)
+ * @author: Fei Gao
+ */
+public interface NonXAResource {
+	public void commit() throws javax.transaction.SystemException;
+	public void rollback() throws javax.transaction.SystemException;
+}
Index: src/cbit/vcell/transaction/JtaXAOracleConnection.java
===================================================================
--- src/cbit/vcell/transaction/JtaXAOracleConnection.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/transaction/JtaXAOracleConnection.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+import javax.transaction.*;
+import java.sql.SQLException;
+import oracle.jdbc.xa.client.OracleXADataSource;
+import javax.sql.XAConnection;
+import javax.transaction.xa.XAResource;
+
+import org.vcell.util.PropertyLoader;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/21/2003 1:54:33 PM)
+ * @author: Fei Gao
+ */
+public class JtaXAOracleConnection implements JtaDbConnection {
+	private OracleXADataSource oraXADataSource = null;
+	private XAConnection  xaConnection = null;
+	private java.sql.Connection connection = null;
+
+/**
+ * OracleJtaDataSource constructor comment.
+ * @param ur java.lang.String
+ * @param uname java.lang.String
+ * @param pw java.lang.String
+ */
+public JtaXAOracleConnection() throws SQLException {
+	oraXADataSource = new OracleXADataSource();
+	oraXADataSource.setURL(PropertyLoader.getRequiredProperty(PropertyLoader.dbConnectURL));
+	oraXADataSource.setUser(PropertyLoader.getRequiredProperty(PropertyLoader.dbUserid));
+	oraXADataSource.setPassword(PropertyLoader.getRequiredProperty(PropertyLoader.dbPassword));
+	xaConnection = oraXADataSource.getXAConnection();
+}
+
+
+/**
+ * close method comment.
+ */
+public void close() throws SQLException {
+	if (connection != null) {
+		connection.close();
+		connection = null;
+	}
+}
+
+
+/**
+ * closeOnFailure method comment.
+ */
+public void closeOnFailure() throws java.sql.SQLException {
+	close(); // close the connection handle
+	if (xaConnection != null) {
+		xaConnection.close(); // close the physical connection
+		xaConnection = null;
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return java.sql.Connection
+ * @exception java.sql.SQLException The exception description.
+ * @exception java.lang.ClassNotFoundException The exception description.
+ */
+public java.sql.Connection getConnection() throws SQLException {
+	if (xaConnection == null) {
+		xaConnection = oraXADataSource.getXAConnection(); // get another physical connection
+	}
+	// From http://download-west.oracle.com/docs/cd/B14117_01/java.101/b10979/xadistra.htm#sthref552
+	// Each time an XA connection instance getConnection() method is called, it returns a new connection instance that 
+	// exhibits the default behavior, and closes any previous connection instance that still exists and had been returned 
+	// by the same XA connection instance. It is advisable to explicitly close any previous connection 
+	// instance before opening a new one, however.
+	
+	close();
+	connection = xaConnection.getConnection();	
+ 	return connection;
+}
+
+
+/**
+ * joinTransaction method comment.
+ */
+public boolean joinTransaction(TransactionManager tm) throws java.sql.SQLException {
+	try {
+		XAResource xaRes = xaConnection.getXAResource();
+		if (xaRes == null || !tm.getTransaction().enlistResource(xaRes)) {
+			return false;
+		}
+
+		return true;
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+		throw new SQLException(ex.getMessage());
+	}
+
+}
+}
Index: src/cbit/vcell/solvers/SolverControllerImpl.java
===================================================================
--- src/cbit/vcell/solvers/SolverControllerImpl.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/SolverControllerImpl.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,11 +9,11 @@
  */
 
 package cbit.vcell.solvers;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.server.LocalVCellConnection;
 import cbit.vcell.solver.SolverListener;
 import java.io.*;
 import java.util.*;
+import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.Solver;
 /**
  * This interface was generated by a SmartGuide.
@@ -26,7 +26,7 @@
 	private LocalVCellConnection vcConn = null;
 	private SolverListener solverListener = null;
 	
-	private SimulationTask simulationTask = null;
+	private SimulationJob simulationJob = null;
 	private org.vcell.util.SessionLog sessionLog = null;
 	private Solver solver = null;
 	private File directory = null;
@@ -40,15 +40,15 @@
  * @param directory java.lang.String
  * @param simIdentifier java.lang.String
  */
-public SolverControllerImpl (LocalVCellConnection argVCellConnection, org.vcell.util.SessionLog sessionLog, SimulationTask simulationTask, java.io.File directory) throws cbit.vcell.solver.SolverException {
-	this.simulationTask = simulationTask;
+public SolverControllerImpl (LocalVCellConnection argVCellConnection, org.vcell.util.SessionLog sessionLog, SimulationJob argSimulationJob, java.io.File directory) throws cbit.vcell.solver.SolverException {
+	this.simulationJob = argSimulationJob;
 	this.directory = directory;
 	this.sessionLog = sessionLog;
 	this.vcConn = argVCellConnection;
 	//
 	// instantiate an appropriate solver
 	//
-	this.solver = cbit.vcell.solver.SolverFactory.createSolver(sessionLog,directory,simulationTask, false);
+	this.solver = cbit.vcell.solver.SolverFactory.createSolver(sessionLog,directory,argSimulationJob, false);
 }
 
 
@@ -65,8 +65,8 @@
  * This method was created by a SmartGuide.
  * @return cbit.vcell.math.MathDescription
  */
-public SimulationTask getSimulationTask() {
-	return simulationTask;
+public SimulationJob getSimulationJob() {
+	return simulationJob;
 }
 
 
Index: src/cbit/vcell/solvers/FVSolver.java
===================================================================
--- src/cbit/vcell/solvers/FVSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/FVSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -32,11 +32,11 @@
 import cbit.vcell.geometry.surface.GeometrySurfaceDescription;
 import cbit.vcell.math.AnnotatedFunction;
 import cbit.vcell.math.Variable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.simdata.DataSetControllerImpl;
 import cbit.vcell.simdata.SimDataConstants;
+import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
 import cbit.vcell.solver.SolverException;
 import cbit.vcell.solver.SolverStatus;
@@ -64,13 +64,13 @@
  * @param simID java.lang.String
  * @param clientProxy cbit.vcell.solvers.ClientProxy
  */
-public FVSolver (SimulationTask simTask, File dir, SessionLog sessionLog, boolean bMsging) throws SolverException {
-	super(simTask, dir, sessionLog, bMsging);
-	if (! simTask.getSimulation().isSpatial()) {
+public FVSolver (SimulationJob argSimulationJob, File dir, SessionLog sessionLog, boolean bMsging) throws SolverException {
+	super(argSimulationJob, dir, sessionLog, bMsging);
+	if (! simulationJob.getSimulation().isSpatial()) {
 		throw new SolverException("Cannot use FVSolver on non-spatial simulation");
 	}
-	this.simResampleInfoProvider = (VCSimulationDataIdentifier)simTask.getSimulationJob().getVCDataIdentifier();
-	this.cppCoderVCell = new CppCoderVCell((new File(getBaseName())).getName(), getSaveDirectory(), simTask);
+	this.simResampleInfoProvider = (VCSimulationDataIdentifier)argSimulationJob.getVCDataIdentifier();
+	this.cppCoderVCell = new CppCoderVCell((new File(getBaseName())).getName(), getSaveDirectory(), argSimulationJob);
 }
 
 
@@ -287,14 +287,14 @@
 	//Try to save existing user defined functions
 	Vector<AnnotatedFunction> annotatedFunctionVector = new Vector<AnnotatedFunction>();
 	try{
-		annotatedFunctionVector = simTask.getSimulationJob().getSimulationSymbolTable().createAnnotatedFunctionsList(simTask.getSimulation().getMathDescription());
+		annotatedFunctionVector = simulationJob.getSimulationSymbolTable().createAnnotatedFunctionsList(simulationJob.getSimulation().getMathDescription());
 		String functionFileName = getBaseName() + FUNCTIONFILE_EXTENSION;
 		File existingFunctionFile = new File(functionFileName);
 		if(existingFunctionFile.exists()){
 			Vector<AnnotatedFunction> oldUserDefinedFunctions =
 				new Vector<AnnotatedFunction>();
 			Vector<AnnotatedFunction> allOldFunctionV =
-				FunctionFileGenerator.readFunctionsFile(existingFunctionFile, simTask.getSimulationJobID());
+				FunctionFileGenerator.readFunctionsFile(existingFunctionFile, simulationJob.getSimulationJobID());
 			for(int i = 0; i < allOldFunctionV.size(); i += 1){
 				if(allOldFunctionV.elementAt(i).isOldUserDefined()){
 					oldUserDefinedFunctions.add(allOldFunctionV.elementAt(i));
@@ -328,8 +328,8 @@
 	}else if (message.startsWith(PROGRESS_PREFIX)){
 		String progressString = message.substring(message.lastIndexOf(SEPARATOR)+1,message.indexOf("%"));
 		double progress = Double.parseDouble(progressString)/100.0;
-		double startTime = simTask.getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime();
-		double endTime = simTask.getSimulation().getSolverTaskDescription().getTimeBounds().getEndingTime();
+		double startTime = simulationJob.getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime();
+		double endTime = simulationJob.getSimulation().getSolverTaskDescription().getTimeBounds().getEndingTime();
 		setCurrentTime(startTime + (endTime-startTime)*progress);
 		return new ApplicationMessage(ApplicationMessage.PROGRESS_MESSAGE,progress,-1,null,message);
 	}else{
@@ -360,9 +360,9 @@
 	
 	autoCode(false);
 	
-//	String baseName = cppCoderVCell.getBaseFilename();
-//	String exeSuffix = System.getProperty(PropertyLoader.exesuffixProperty); // ".exe";
-//	File exeFile = new File(getSaveDirectory(), baseName + exeSuffix);
+	String baseName = cppCoderVCell.getBaseFilename();
+	String exeSuffix = System.getProperty(PropertyLoader.exesuffixProperty); // ".exe";
+	File exeFile = new File(getSaveDirectory(), baseName + exeSuffix);
 	boolean bCORBA = false;
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,SimulationMessage.MESSAGE_SOLVER_RUNNING_START));
@@ -375,28 +375,18 @@
 		throw new RuntimeException("MathExecutableCORBA not supported");
 		//executable = new MathExecutableCORBA(exeFile,mathDesc.getSimulationID(),getSessionLog());
 	}else{
-		setMathExecutable(new MathExecutable(getMathExecutableCommand()));
+		setMathExecutable(new MathExecutable(new String[] {exeFile.getAbsolutePath()}));
 	}
 
 }
 
-@Override
-public String[] getMathExecutableCommand() {
-	String exeSuffix = System.getProperty(PropertyLoader.exesuffixProperty); // ".exe";
-	String baseName = cppCoderVCell.getBaseFilename();
-	File exeFile = new File(getSaveDirectory(), baseName + exeSuffix);
-	return new String[] { exeFile.getAbsolutePath() };
-}
-
-
-
 public Geometry getResampledGeometry() throws SolverException {
 	if (resampledGeometry == null) {
 		// clone and resample geometry
 		try {
-			resampledGeometry = (Geometry) BeanUtils.cloneSerializable(simTask.getSimulation().getMathDescription().getGeometry());
+			resampledGeometry = (Geometry) BeanUtils.cloneSerializable(simulationJob.getSimulation().getMathDescription().getGeometry());
 			GeometrySurfaceDescription geoSurfaceDesc = resampledGeometry.getGeometrySurfaceDescription();
-			ISize newSize = simTask.getSimulation().getMeshSpecification().getSamplingSize();
+			ISize newSize = simulationJob.getSimulation().getMeshSpecification().getSamplingSize();
 			geoSurfaceDesc.setVolumeSampleSize(newSize);
 			geoSurfaceDesc.updateAll();		
 		} catch (Exception e) {
@@ -412,18 +402,18 @@
 	
 	try {
 		// write subdomains file
-		SubdomainInfo.write(new File(getSaveDirectory(), cppCoderVCell.getBaseFilename() + SimDataConstants.SUBDOMAINS_FILE_SUFFIX), simTask.getSimulation().getMathDescription());
+		SubdomainInfo.write(new File(getSaveDirectory(), cppCoderVCell.getBaseFilename() + SimDataConstants.SUBDOMAINS_FILE_SUFFIX), simulationJob.getSimulation().getMathDescription());
 		
 		PrintWriter pw = new PrintWriter(new FileWriter(new File(getSaveDirectory(), cppCoderVCell.getBaseFilename()+SimDataConstants.VCG_FILE_EXTENSION)));
 		GeometryFileWriter.write(pw, getResampledGeometry());
 		pw.close();
 				
-		FieldDataIdentifierSpec[] argFieldDataIDSpecs = simTask.getSimulationJob().getFieldDataIdentifierSpecs();
+		FieldDataIdentifierSpec[] argFieldDataIDSpecs = simulationJob.getFieldDataIdentifierSpecs();
 		if(argFieldDataIDSpecs != null && argFieldDataIDSpecs.length > 0){
 			fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_RESAMPLE_FD);
 			
 			FieldFunctionArguments psfFieldFunc = null;
-			Variable var = simTask.getSimulationJob().getSimulationSymbolTable().getVariable(SimDataConstants.PSF_FUNCTION_NAME);
+			Variable var = simulationJob.getSimulationSymbolTable().getVariable(SimDataConstants.PSF_FUNCTION_NAME);
 			if (var != null) {
 				FieldFunctionArguments[] ffas = FieldUtilities.getFieldFunctionArguments(var.getExpression());
 				if (ffas == null || ffas.length == 0) {
@@ -446,7 +436,7 @@
 			boolean bResample[] = new boolean[argFieldDataIDSpecs.length];
 			Arrays.fill(bResample, true);
 			for (int i = 0; i < argFieldDataIDSpecs.length; i++) {
-				argFieldDataIDSpecs[i].getFieldFuncArgs().getTime().bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+				argFieldDataIDSpecs[i].getFieldFuncArgs().getTime().bindExpression(simulationJob.getSimulationSymbolTable());
 				if (argFieldDataIDSpecs[i].getFieldFuncArgs().equals(psfFieldFunc)) {
 					bResample[i] = false;
 				}
@@ -455,7 +445,7 @@
 			int numMembraneElements = getResampledGeometry().getGeometrySurfaceDescription().getSurfaceCollection().getTotalPolygonCount();
 			CartesianMesh simpleMesh = CartesianMesh.createSimpleCartesianMesh(getResampledGeometry().getOrigin(), 
 					getResampledGeometry().getExtent(),
-					simTask.getSimulation().getMeshSpecification().getSamplingSize(),
+					simulationJob.getSimulation().getMeshSpecification().getSamplingSize(),
 					getResampledGeometry().getGeometrySurfaceDescription().getRegionImage());
 			String secondarySimDataDir = PropertyLoader.getProperty(PropertyLoader.secondarySimDataDirProperty, null);			
 			DataSetControllerImpl dsci = new DataSetControllerImpl(new NullSessionLog(), null, getSaveDirectory().getParentFile(),
Index: src/cbit/vcell/solvers/AbstractCompiledSolver.java
===================================================================
--- src/cbit/vcell/solvers/AbstractCompiledSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/AbstractCompiledSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -16,7 +16,6 @@
 import org.vcell.util.SessionLog;
 
 import cbit.vcell.math.AnnotatedFunction;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.Simulation;
 import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
@@ -40,10 +39,10 @@
 /**
  * AbstractPDESolver constructor comment.
  */
-public AbstractCompiledSolver(SimulationTask simTask, File directory, SessionLog sessionLog, boolean bMsging) throws SolverException {
-	super(simTask, directory, sessionLog);
+public AbstractCompiledSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog, boolean bMsging) throws SolverException {
+	super(simulationJob, directory, sessionLog);
 	bMessaging = bMsging;
-	setCurrentTime(simTask.getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime());
+	setCurrentTime(simulationJob.getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime());
 }
 /**
  * Insert the method's description here.
@@ -70,7 +69,7 @@
  * Creation date: (6/26/2001 5:03:04 PM)
  * @return cbit.vcell.solvers.MathExecutable
  */
-public MathExecutable getMathExecutable() {
+protected MathExecutable getMathExecutable() {
 	return mathExecutable;
 }
 /**
@@ -79,7 +78,7 @@
  * @return double
  */
 public double getProgress() {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	TimeBounds timeBounds = simulation.getSolverTaskDescription().getTimeBounds();
 	double startTime = timeBounds.getStartingTime();
 	double endTime = timeBounds.getEndingTime();
@@ -126,7 +125,7 @@
 private void runSolver() {
 	try {
 		fieldRunning = true;
-		setCurrentTime(simTask.getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime());
+		setCurrentTime(simulationJob.getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime());
 		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_STARTING, SimulationMessage.MESSAGE_SOLVER_STARTING_INIT));
 		// fireSolverStarting("initializing");
 		// depends on solver; the initialize() method in actual solver will fire detailed messages
@@ -224,7 +223,4 @@
 		throw new RuntimeException("Error creating .function file for "+functionFileGenerator.getBasefileName()+e.getMessage());
 	}		
 }
-
-public abstract String[] getMathExecutableCommand();
-
 }
Index: src/cbit/vcell/solvers/CppClassCoderContourVarContext.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderContourVarContext.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderContourVarContext.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -19,8 +19,8 @@
 import cbit.vcell.math.ReservedVariable;
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
+import cbit.vcell.solver.SimulationJob;
 /**
  * This class was generated by a SmartGuide.
  * 
@@ -35,10 +35,10 @@
 protected CppClassCoderContourVarContext(CppCoderVCell argCppCoderVCell,
 												Equation argEquation,
 												FilamentSubDomain argFilamentSubDomain,
-												SimulationTask simTask, 
+												SimulationJob argSimulationJob, 
 												String argParentClass) throws Exception
 {
-	super(argCppCoderVCell,argEquation,argFilamentSubDomain,simTask,argParentClass);
+	super(argCppCoderVCell,argEquation,argFilamentSubDomain,argSimulationJob,argParentClass);
 	this.compartmentSubDomain = argFilamentSubDomain.getOutsideCompartment();
 }
 
Index: src/cbit/vcell/solvers/CombinedSundialsSolver.java
===================================================================
--- src/cbit/vcell/solvers/CombinedSundialsSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CombinedSundialsSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -10,7 +10,6 @@
 
 package cbit.vcell.solvers;
 
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.math.AnnotatedFunction;
 import cbit.vcell.solver.*;
 import cbit.vcell.solver.ode.CVodeSolverStandalone;
@@ -35,12 +34,12 @@
  * @param sessionLog cbit.vcell.server.SessionLog
  * @exception cbit.vcell.solver.SolverException The exception description.
  */
-public CombinedSundialsSolver(SimulationTask simTask, File directory, SessionLog sessionLog, boolean bMessaging) throws cbit.vcell.solver.SolverException {
-	super(simTask, directory, sessionLog, bMessaging);
-	if (simTask.getSimulation().getMathDescription().hasFastSystems()) {
-		realSolver = new IDASolverStandalone(simTask, directory, sessionLog, bMessaging);
+public CombinedSundialsSolver(SimulationJob simJob, File directory, SessionLog sessionLog, boolean bMessaging) throws cbit.vcell.solver.SolverException {
+	super(simJob, directory, sessionLog, bMessaging);
+	if (simulationJob.getSimulation().getMathDescription().hasFastSystems()) {
+		realSolver = new IDASolverStandalone(simJob, directory, sessionLog, bMessaging);
 	} else {
-		realSolver = new CVodeSolverStandalone(simTask, directory, sessionLog, bMessaging);
+		realSolver = new CVodeSolverStandalone(simJob, directory, sessionLog, bMessaging);
 	}
 	realSolver.addSolverListener(new SolverListener() {
 		public final void solverAborted(SolverEvent event) {		
@@ -92,7 +91,7 @@
 }
 
 @Override
-public MathExecutable getMathExecutable() {	
+protected MathExecutable getMathExecutable() {	
 	return realSolver.getMathExecutable();
 }
 
@@ -100,9 +99,4 @@
 public Vector<AnnotatedFunction> createFunctionList() {
 	return realSolver.createFunctionList();
 }
-
-@Override
-public String[] getMathExecutableCommand() {
-	return realSolver.getMathExecutableCommand();
 }
-}
Index: src/cbit/vcell/solvers/CppClassCoderMembraneRegionVarContext.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderMembraneRegionVarContext.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderMembraneRegionVarContext.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -23,7 +23,6 @@
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolVariable;
 import cbit.vcell.math.VolumeRegionVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.SimulationJob;
@@ -39,10 +38,10 @@
 protected CppClassCoderMembraneRegionVarContext(CppCoderVCell argCppCoderVCell,
 												Equation argEquation,
 												MembraneSubDomain argMembraneSubDomain,
-												SimulationTask simTask, 
+												SimulationJob argSimulationJob, 
 												String argParentClass) throws Exception
 {
-	super(argCppCoderVCell,argEquation,argMembraneSubDomain,simTask,argParentClass);
+	super(argCppCoderVCell,argEquation,argMembraneSubDomain,argSimulationJob,argParentClass);
 }
 
 
@@ -92,7 +91,7 @@
 	out.println("{");
 	try {
 		Expression ic = getEquation().getInitialExpression();
-		ic.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+		ic.bindExpression(simulationJob.getSimulationSymbolTable());
 		double value = ic.evaluateConstant();
 		out.println("\tinitialValue = new double;");
 		out.println("\t*initialValue = " + value + ";");
@@ -131,7 +130,7 @@
 
 	try {
 		Expression ic = getEquation().getInitialExpression();
-		ic.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+		ic.bindExpression(simulationJob.getSimulationSymbolTable());
 		double value = ic.evaluateConstant();
 	}catch (Exception e){
 		out.println("\tvirtual double getInitialValue(MembraneElement *memElement);");
Index: src/cbit/vcell/solvers/SolverController.java
===================================================================
--- src/cbit/vcell/solvers/SolverController.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/solvers/SolverController.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.solvers;
+import cbit.vcell.solver.*;
+import java.rmi.*;
+/**
+ * This interface was generated by a SmartGuide.
+ * 
+ */
+public interface SolverController extends java.rmi.Remote {
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+String getHost() throws RemoteException, org.vcell.util.DataAccessException;
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public double getProgress() throws RemoteException, SolverNotRunningException, org.vcell.util.DataAccessException;	
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.solver.Simulation
+ */
+public cbit.vcell.solver.SimulationJob getSimulationJob() throws RemoteException, org.vcell.util.DataAccessException;
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SolverStatus getSolverStatus() throws RemoteException, org.vcell.util.DataAccessException;	
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void startSimulationJob() throws RemoteException, SimExecutionException, org.vcell.util.DataAccessException;
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void stopSimulationJob() throws RemoteException, org.vcell.util.DataAccessException;
+}
Index: src/cbit/vcell/solvers/LocalSolverController.java
===================================================================
--- src/cbit/vcell/solvers/LocalSolverController.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/LocalSolverController.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,11 +15,11 @@
 import javax.swing.event.EventListenerList;
 
 import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
 import org.vcell.util.SessionLog;
 
 import cbit.rmi.event.WorkerEvent;
 import cbit.rmi.event.WorkerEventListener;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.server.LocalVCellConnection;
 import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
@@ -32,7 +32,7 @@
  * This type was created in VisualAge.
  */
 @SuppressWarnings("serial")
-public class LocalSolverController implements SolverListener {
+public class LocalSolverController extends java.rmi.server.UnicastRemoteObject implements SolverController, SolverListener {
 	private SolverControllerImpl solverControllerImpl = null;
 	private EventListenerList listenerList = new EventListenerList();
 	private SessionLog log = null;
@@ -48,12 +48,12 @@
 /**
  * LocalMathController constructor comment.
  * @exception java.rmi.RemoteException The exception description.
- * @throws SolverException 
  */
-public LocalSolverController(LocalVCellConnection vcellConnection, SessionLog sessionLog, SimulationTask simTask, File dataDirectory) throws SolverException {
+public LocalSolverController(LocalVCellConnection vcellConnection, SessionLog sessionLog, SimulationJob simJob, File dataDirectory) throws java.rmi.RemoteException, SolverException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortSolverController,0));
 	this.log = sessionLog;
 	this.vcConn = vcellConnection;
-	solverControllerImpl = new SolverControllerImpl(vcellConnection, sessionLog, simTask, dataDirectory);
+	solverControllerImpl = new SolverControllerImpl(vcellConnection, sessionLog, simJob, dataDirectory);
 	solverControllerImpl.getSolver().addSolverListener(this);
 }
 
@@ -131,9 +131,9 @@
 /**
  * getMathDescriptionVCML method comment.
  */
-public SimulationTask getSimulationTask() throws DataAccessException {
+public SimulationJob getSimulationJob() throws DataAccessException {
 	try {
-		return solverControllerImpl.getSimulationTask();
+		return solverControllerImpl.getSimulationJob();
 	}catch (Throwable e){
 		log.exception(e);
 		throw new DataAccessException(e.getMessage());
@@ -179,12 +179,12 @@
 public void solverAborted(SolverEvent event) {
 	try {
 		log.print("LocalSolverController Caught solverAborted("+event.getSource().toString()+",error='"+event.getSimulationMessage()+"')");
-		SimulationJob simJob = getSimulationTask().getSimulationJob();
+		SimulationJob simJob = getSimulationJob();
 		if (serialParameterScanJobIndex >= 0) {
-			SimulationTask newSimTask = new SimulationTask(new SimulationJob(simJob.getSimulation(), serialParameterScanJobIndex, simJob.getFieldDataIdentifierSpecs()),getSimulationTask().getTaskID());
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_FAILURE, this, newSimTask, vcConn.getHost(), event.getSimulationMessage()));
+			SimulationJob newSimJob = new SimulationJob(simJob.getSimulation(), serialParameterScanJobIndex, simJob.getFieldDataIdentifierSpecs());
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_FAILURE, this, newSimJob, vcConn.getHost(), event.getSimulationMessage()));
 		} else {
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_FAILURE, this, getSimulationTask(), vcConn.getHost(), event.getSimulationMessage()));
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_FAILURE, this, getSimulationJob(), vcConn.getHost(), event.getSimulationMessage()));
 		}
 	}catch (Throwable e){
 		log.exception(e);
@@ -199,12 +199,12 @@
 public void solverFinished(SolverEvent event) {
 	try {
 		log.print("LocalSolverController Caught solverFinished("+event.getSource().toString()+")");
-		SimulationJob simJob = getSimulationTask().getSimulationJob();
+		SimulationJob simJob = getSimulationJob();
 		if (serialParameterScanJobIndex >= 0) {
-			SimulationTask newSimTask = new SimulationTask(new SimulationJob(simJob.getSimulation(), serialParameterScanJobIndex, simJob.getFieldDataIdentifierSpecs()),getSimulationTask().getTaskID());
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_COMPLETED, this, newSimTask, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));
+			SimulationJob newSimJob = new SimulationJob(simJob.getSimulation(), serialParameterScanJobIndex, simJob.getFieldDataIdentifierSpecs());
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_COMPLETED, this, newSimJob, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));
 		} else {
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_COMPLETED, this, getSimulationTask(), vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));	
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_COMPLETED, this, simJob, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));	
 		}		
 	}catch (Throwable e){
 		log.exception(e);
@@ -220,7 +220,7 @@
 	try {
 		// don't log progress and data events; data events at larger interval, since more expensive on client side
 		if (System.currentTimeMillis() - timeOfLastDataMessage > 4000 * getMessagingInterval()) {
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_DATA, this, getSimulationTask(), vcConn.getHost(), event.getProgress(), new Double(event.getTimePoint()), event.getSimulationMessage()));
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_DATA, this, getSimulationJob(), vcConn.getHost(), event.getProgress(), new Double(event.getTimePoint()), event.getSimulationMessage()));
 		}
 	}catch (Throwable e){
 		log.exception(e);
@@ -236,15 +236,16 @@
 	try {
 		// don't log progress and data events
 		if (System.currentTimeMillis() - timeOfLastProgressMessage > 1000 * getMessagingInterval()) {
+			SimulationJob simJob = getSimulationJob();
 			if (serialParameterScanJobIndex >= 0) {
-				SimulationTask newSimTask = new SimulationTask(new SimulationJob(getSimulationTask().getSimulation(), serialParameterScanJobIndex, getSimulationTask().getSimulationJob().getFieldDataIdentifierSpecs()),getSimulationTask().getTaskID());
-				fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_PROGRESS, this, newSimTask, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));
+				SimulationJob newSimJob = new SimulationJob(simJob.getSimulation(), serialParameterScanJobIndex, simJob.getFieldDataIdentifierSpecs());
+				fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_PROGRESS, this, newSimJob, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));
 				if (event.getProgress() >= 1) {
-					fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_COMPLETED, this, newSimTask, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), SimulationMessage.MESSAGE_JOB_COMPLETED));
+					fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_COMPLETED, this, newSimJob, vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), SimulationMessage.MESSAGE_JOB_COMPLETED));
 					serialParameterScanJobIndex ++;
 				}
 			} else {
-				fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_PROGRESS, this, getSimulationTask(), vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));
+				fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_PROGRESS, this, getSimulationJob(), vcConn.getHost(), new Double(event.getProgress()), new Double(event.getTimePoint()), event.getSimulationMessage()));
 			}
 		}
 	}catch (Throwable e){
@@ -260,11 +261,12 @@
 public void solverStarting(SolverEvent event) {
 	try {
 		log.print("LocalSolverController Caught solverStarting("+event.getSource().toString()+")");
+		SimulationJob simJob = getSimulationJob();
 		if (serialParameterScanJobIndex >= 0) {
-			SimulationTask newSimTask = new SimulationTask(new SimulationJob(getSimulationTask().getSimulation(), serialParameterScanJobIndex, getSimulationTask().getSimulationJob().getFieldDataIdentifierSpecs()),getSimulationTask().getTaskID());
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_STARTING, this, newSimTask, vcConn.getHost(), event.getSimulationMessage()));
+			SimulationJob newSimJob = new SimulationJob(simJob.getSimulation(), serialParameterScanJobIndex, simJob.getFieldDataIdentifierSpecs());
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_STARTING, this, newSimJob, vcConn.getHost(), event.getSimulationMessage()));
 		} else {
-			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_STARTING, this, getSimulationTask(), vcConn.getHost(), event.getSimulationMessage()));
+			fireWorkerEvent(new WorkerEvent(WorkerEvent.JOB_STARTING, this, simJob, vcConn.getHost(), event.getSimulationMessage()));
 		}
 	}catch (Throwable e){
 		log.exception(e);
@@ -291,8 +293,8 @@
  */
 public void startSimulationJob() throws SimExecutionException, DataAccessException {
 	try {
-		resultSetSavedSet.remove(getSimulationTask().getSimulationJob().getVCDataIdentifier());
-		if (getSimulationTask().getSimulation().isSerialParameterScan()) {
+		resultSetSavedSet.remove(getSimulationJob().getVCDataIdentifier());
+		if (getSimulationJob().getSimulation().isSerialParameterScan()) {
 			serialParameterScanJobIndex = 0;
 		}
 		solverControllerImpl.startSimulationJob();
Index: src/cbit/vcell/solvers/CppClassCoderSimulation.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderSimulation.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderSimulation.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,42 +9,18 @@
  */
 
 package cbit.vcell.solvers;
-import java.io.File;
-import java.io.PrintWriter;
-import java.util.Enumeration;
-import java.util.Vector;
+import java.util.*;
+import java.io.*;
 
-import org.vcell.util.PropertyLoader;
-
-import cbit.vcell.field.FieldDataIdentifierSpec;
-import cbit.vcell.field.FieldFunctionArguments;
-import cbit.vcell.field.FieldUtilities;
-import cbit.vcell.math.CompartmentSubDomain;
-import cbit.vcell.math.Equation;
-import cbit.vcell.math.FilamentVariable;
-import cbit.vcell.math.MathDescription;
-import cbit.vcell.math.MemVariable;
-import cbit.vcell.math.MembraneRegionVariable;
-import cbit.vcell.math.PdeEquation;
-import cbit.vcell.math.RandomVariable;
-import cbit.vcell.math.SubDomain;
-import cbit.vcell.math.Variable;
-import cbit.vcell.math.VolVariable;
-import cbit.vcell.math.VolumeRegionVariable;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.simdata.SimDataConstants;
 import cbit.vcell.simdata.VariableType;
-import cbit.vcell.solver.DefaultOutputTimeSpec;
-import cbit.vcell.solver.ErrorTolerance;
-import cbit.vcell.solver.OutputTimeSpec;
-import cbit.vcell.solver.Simulation;
-import cbit.vcell.solver.SimulationSymbolTable;
-import cbit.vcell.solver.SolverDescription;
-import cbit.vcell.solver.SolverTaskDescription;
-import cbit.vcell.solver.UniformOutputTimeSpec;
+import cbit.vcell.solver.*;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.field.FieldFunctionArguments;
+import cbit.vcell.field.FieldUtilities;
+import cbit.vcell.math.*;
+import cbit.vcell.messaging.JmsUtils;
 
 /**
  * This class was generated by a SmartGuide.
@@ -58,9 +34,9 @@
  * VarContextCppCoder constructor comment.
  * @param name java.lang.String
  */
-protected CppClassCoderSimulation(CppCoderVCell cppCoderVCell, SimulationTask simTask, String baseDataName) 
+protected CppClassCoderSimulation(CppCoderVCell cppCoderVCell, SimulationJob argSimulationJob, String baseDataName) 
 {
-	super(simTask, cppCoderVCell,"UserSimulation", "Simulation");
+	super(argSimulationJob, cppCoderVCell,"UserSimulation", "Simulation");
 	this.baseDataName = baseDataName;
 }
 
@@ -92,7 +68,7 @@
 	out.println("\tdouble pcgRelTol = SimTool::getInstance()->getPCGRelativeErrorTolerance();");
 	out.println();
 
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	MathDescription mathDescription = simSymbolTable.getSimulation().getMathDescription();
 	
 	Variable variables[] = simSymbolTable.getVariables();
@@ -273,7 +249,7 @@
  */
 protected void writeGetSimTool(java.io.PrintWriter out) throws Exception {
 
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	SolverTaskDescription taskDesc = simulation.getSolverTaskDescription();
 	if (taskDesc==null){
 		throw new Exception("task description not defined");
@@ -298,7 +274,7 @@
 	out.println();
 	
 	out.println("\tSimTool::create();");	
-	out.println("\tsprintf(tempString, \"%s%c" + simTask.getSimulationJobID() + "\\0\", outputPath, DIRECTORY_SEPARATOR);");
+	out.println("\tsprintf(tempString, \"%s%c" + simulationJob.getSimulationJobID() + "\\0\", outputPath, DIRECTORY_SEPARATOR);");
 	out.println("\tSimTool::getInstance()->setBaseFilename(tempString);");
 	
 	double defaultTimeStep = taskDesc.getTimeStep().getDefaultTimeStep();
@@ -334,7 +310,7 @@
 	out.println();
 	
 	out.println("\tSimulationMessaging::getInstVar()->setWorkerEvent(new WorkerEvent(JOB_STARTING, \"initializing mesh...\"));");
-	out.println("\tsprintf(tempString, \"%s%c" + simTask.getSimulationJobID() + ".vcg\\0\", outputPath, DIRECTORY_SEPARATOR);");
+	out.println("\tsprintf(tempString, \"%s%c" + simulationJob.getSimulationJobID() + ".vcg\\0\", outputPath, DIRECTORY_SEPARATOR);");
 	out.println("\tCartesianMesh* mesh = new CartesianMesh();");
 	out.println("\tifstream ifs(tempString);");
 	out.println("\tif (!ifs.is_open()){");
@@ -390,7 +366,7 @@
  */
 protected void writeMain(java.io.PrintWriter out) throws Exception {
 
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	FieldFunctionArguments[] fieldFuncArgs = simulation.getMathDescription().getFieldFunctionArguments();
 	//FieldDataIdentifierSpec[] fieldDataIDSs = simulationJob.getFieldDataIdentifierSpecs();
 	SolverTaskDescription taskDesc = simulation.getSolverTaskDescription();
@@ -505,14 +481,14 @@
 	out.println("\t\t\tSimulationMessaging::create();");
 	out.println("\t\t} else {");
 	out.println("#ifdef USE_MESSAGING");
-	out.println("\t\t\tchar* broker = \"" + PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL) + "\";");
-    out.println("\t\t\tchar *smqusername = \"" + PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser) + "\";");
-    out.println("\t\t\tchar *password = \"" + PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword) + "\";");
-    out.println("\t\t\tchar *qname = \"" + VCellQueue.WorkerEventQueue.getName() + "\";");  
-	out.println("\t\t\tchar* tname = \"" + VCellTopic.ServiceControlTopic.getName() + "\";");
+	out.println("\t\t\tchar* broker = \"" + JmsUtils.getJmsUrl() + "\";");
+    out.println("\t\t\tchar *smqusername = \"" + JmsUtils.getJmsUserID() + "\";");
+    out.println("\t\t\tchar *password = \"" + JmsUtils.getJmsPassword() + "\";");
+    out.println("\t\t\tchar *qname = \"" + JmsUtils.getQueueWorkerEvent() + "\";");  
+	out.println("\t\t\tchar* tname = \"" + JmsUtils.getTopicServiceControl() + "\";");
 	out.println("\t\t\tchar* vcusername = \"" + simulation.getVersion().getOwner().getName() + "\";");
 	out.println("\t\t\tjint simKey = " + simulation.getVersion().getVersionKey() + ";");
-	out.println("\t\t\tjint jobIndex = " + simTask.getSimulationJob().getJobIndex() + ";");
+	out.println("\t\t\tjint jobIndex = " + simulationJob.getJobIndex() + ";");
 	out.println("\t\t\tSimulationMessaging::create(broker, smqusername, password, qname, tname, vcusername, simKey, jobIndex, taskID);");
 	out.println("#endif");
 	out.println("\t\t}");
@@ -520,7 +496,7 @@
 	out.println("\t\tSimulationMessaging::getInstVar()->start(); // start the thread");
 	out.println("#endif");
 
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	if (fieldFuncArgs != null && fieldFuncArgs.length > 0) {
 		FieldFunctionArguments psfFieldFunc = null;
Index: src/cbit/vcell/solvers/CppClassCoderFeature.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderFeature.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderFeature.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -15,7 +15,6 @@
 import cbit.vcell.math.BoundaryConditionType;
 import cbit.vcell.math.CompartmentSubDomain;
 import cbit.vcell.math.MembraneSubDomain;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.SimulationJob;
 /**
  * This class was generated by a SmartGuide.
@@ -28,10 +27,10 @@
  * VarContextCppCoder constructor comment.
  * @param name java.lang.String
  */
-protected CppClassCoderFeature(CppCoderVCell cppCoderVCell, SimulationTask simTask, 
+protected CppClassCoderFeature(CppCoderVCell cppCoderVCell, SimulationJob argSimulationJob, 
 										CompartmentSubDomain volSubDomain, MembraneSubDomain memSubDomain) 
 {
-	super(simTask, cppCoderVCell,"Feature"+volSubDomain.getName(), "Feature");
+	super(argSimulationJob, cppCoderVCell,"Feature"+volSubDomain.getName(), "Feature");
 	this.volumeSubDomain = volSubDomain;
 	this.membraneSubDomain = memSubDomain;
 }
@@ -47,7 +46,7 @@
  * @param out java.io.PrintWriter
  */
 protected void writeConstructor(java.io.PrintWriter out) throws Exception {
-	int handle = simTask.getSimulation().getMathDescription().getHandle(volumeSubDomain);	
+	int handle = simulationJob.getSimulation().getMathDescription().getHandle(volumeSubDomain);	
 	out.println(getClassName()+"::"+getClassName()+"(string& Aname, int priority)");
 	out.println(": Feature(Aname, "+handle+", priority)");
  	out.println("{");
Index: src/cbit/vcell/solvers/FiniteVolumeFileWriter.java
===================================================================
--- src/cbit/vcell/solvers/FiniteVolumeFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/FiniteVolumeFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -65,7 +65,6 @@
 import cbit.vcell.math.VolumeRandomVariable;
 import cbit.vcell.math.VolumeRegionEquation;
 import cbit.vcell.math.VolumeRegionVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Discontinuity;
 import cbit.vcell.parser.DivideByZeroException;
 import cbit.vcell.parser.Expression;
@@ -178,19 +177,19 @@
 		VARIABLE_END,
 	}
 
-public FiniteVolumeFileWriter(PrintWriter pw, SimulationTask simTask, Geometry geo, File dir) {	// for optimization only, no messaging
-	this (pw, simTask, geo, dir, false);
+public FiniteVolumeFileWriter(PrintWriter pw, SimulationJob simJob, Geometry geo, File dir) {	// for optimization only, no messaging
+	this (pw, simJob, geo, dir, false);
 	bInlineVCG = true; 
 }
 
-public FiniteVolumeFileWriter(PrintWriter pw, SimulationTask simTask, Geometry geo, File dir, boolean arg_bMessaging) {
-	super(pw, simTask, arg_bMessaging);
+public FiniteVolumeFileWriter(PrintWriter pw, SimulationJob simJob, Geometry geo, File dir, boolean arg_bMessaging) {
+	super(pw, simJob, arg_bMessaging);
 	resampledGeometry = geo;
 	userDirectory = dir;
 }
 
 private Expression subsituteExpression(Expression exp, VariableDomain variableDomain) throws ExpressionException  {
-	return subsituteExpression(exp, simTask.getSimulationJob().getSimulationSymbolTable(), variableDomain);
+	return subsituteExpression(exp, simulationJob.getSimulationSymbolTable(), variableDomain);
 }
 /**
  * Insert the method's description here.
@@ -224,9 +223,9 @@
  */
 public void write(String[] parameterNames) throws Exception {
 	Variable originalVars[] = null;
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	MathDescription mathDesc = simulation.getMathDescription();
-	if (simTask.getSimulation().isSerialParameterScan()) {
+	if (simulationJob.getSimulation().isSerialParameterScan()) {
 		originalVars = (Variable[])BeanUtils.getArray(mathDesc.getVariables(),Variable.class);
 		Variable allVars[] = (Variable[])BeanUtils.getArray(mathDesc.getVariables(),Variable.class);
 		MathOverrides mathOverrides = simulation.getMathOverrides();	
@@ -272,12 +271,12 @@
 }
 
 private void writeSmoldyn() throws Exception {
-	String baseName =  new File(userDirectory, simTask.getSimulationJobID()).getPath();
+	String baseName =  new File(userDirectory, simulationJob.getSimulationJobID()).getPath();
 	String inputFilename = baseName + SimDataConstants.SMOLDYN_INPUT_FILE_EXTENSION;
 	PrintWriter pw = null;
 	try {
 		pw = new PrintWriter(inputFilename);
-		SmoldynFileWriter stFileWriter = new SmoldynFileWriter(pw, false, baseName, simTask, bUseMessaging);
+		SmoldynFileWriter stFileWriter = new SmoldynFileWriter(pw, false, baseName, simulationJob, bUseMessaging);
 		stFileWriter.write();
 	} finally {
 		if (pw != null) {
@@ -310,7 +309,7 @@
  * @throws DivideByZeroException 
 */
 private void writeDataProcessor() throws DataAccessException, IOException, MathException, DivideByZeroException, ExpressionException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	DataProcessingInstructions dpi = simulation.getDataProcessingInstructions();
 	if (dpi == null) {
 		printWriter.println("DATA_PROCESSOR_BEGIN " + DataProcessingInstructions.ROI_TIME_SERIES);
@@ -334,7 +333,7 @@
 	}
 	double[] origData = simDataBlock.getData();	
 
-	String filename = SimulationJob.createSimulationJobID(Simulation.createSimulationID(simulation.getKey()), simTask.getSimulationJob().getJobIndex()) + FieldDataIdentifierSpec.getDefaultFieldDataFileNameForSimulation(fdis.getFieldFuncArgs());
+	String filename = SimulationJob.createSimulationJobID(Simulation.createSimulationID(simulation.getKey()), simulationJob.getJobIndex()) + FieldDataIdentifierSpec.getDefaultFieldDataFileNameForSimulation(fdis.getFieldFuncArgs());
 	
 	File fdatFile = new File(userDirectory, filename);
 	
@@ -391,7 +390,7 @@
 	if (fastSystem == null) {
 		return;
 	}
-	FastSystemAnalyzer fs_analyzer = new FastSystemAnalyzer(fastSystem, simTask.getSimulationJob().getSimulationSymbolTable());
+	FastSystemAnalyzer fs_analyzer = new FastSystemAnalyzer(fastSystem, simulationJob.getSimulationSymbolTable());
 	int numIndep = fs_analyzer.getNumIndependentVariables();
 	int numDep = fs_analyzer.getNumDependentVariables();
 	int numPseudo = fs_analyzer.getNumPseudoConstants();	
@@ -480,12 +479,12 @@
  * @throws ExpressionException 
  */
 private void writeCompartment_VarContext(CompartmentSubDomain volSubDomain) throws ExpressionException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	//
 	// get list of volVariables participating in PDEs (anywhere).
 	//
 	Vector<VolVariable> pdeVolVariableList = new Vector<VolVariable>();
-	Variable[] variables = simTask.getSimulationJob().getSimulationSymbolTable().getVariables();
+	Variable[] variables = simulationJob.getSimulationSymbolTable().getVariables();
 	for (int i = 0; i < variables.length; i++){
 		if (variables[i] instanceof VolVariable && simulation.getMathDescription().isPDE((VolVariable)variables[i])){
 			pdeVolVariableList.add((VolVariable)variables[i]);
@@ -621,7 +620,7 @@
  * @throws MathException 
 */
 private void writeCompartments() throws ExpressionException, MathException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	MathDescription mathDesc = simulation.getMathDescription();
 	Enumeration<SubDomain> enum1 = mathDesc.getSubDomains();
 	while (enum1.hasMoreElements()) {		
@@ -699,7 +698,7 @@
 		flux = exp.infix();
 	} else {
 		for (String symbol : symbols) {
-			Variable var = simTask.getSimulationJob().getSimulationSymbolTable().getVariable(symbol);
+			Variable var = simulationJob.getSimulationSymbolTable().getVariable(symbol);
 			if (var instanceof VolVariable || var instanceof VolumeRegionVariable) {
 				fluxExpr.substituteInPlace(new Expression(var.getName()), new Expression(var.getName() + "_" + var.getDomain().getName() + "_membrane"));
 			}
@@ -853,7 +852,7 @@
  * @throws MathException 
  */
 private void writeMembranes() throws ExpressionException, MathException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	MathDescription mathDesc = simulation.getMathDescription();
 	Enumeration<SubDomain> enum1 = mathDesc.getSubDomains();
 	while (enum1.hasMoreElements()) {		
@@ -887,7 +886,7 @@
  * @throws MathException 
 */
 private void writeModelDescription() throws MathException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	
 	printWriter.println("# Model description: FEATURE name handle boundary_conditions");
 	printWriter.println(FVInputFileKeyword.MODEL_BEGIN);
@@ -911,8 +910,8 @@
 
 
 private void getDiscontinuityTimes(Vector<Discontinuity> discontinuities, TreeSet<Double> discontinuityTimes) throws ExpressionException, MathException {
-	Simulation simulation = simTask.getSimulation();
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	Simulation simulation = simulationJob.getSimulation();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	for (Discontinuity discontinuity : discontinuities) {
 		Expression rfexp = discontinuity.getRootFindingExp();
@@ -984,7 +983,7 @@
  * @throws ExpressionException 
 */
 private void writeSimulationParamters() throws ExpressionException, MathException {	
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	SolverTaskDescription solverTaskDesc = simulation.getSolverTaskDescription();
 	
 	printWriter.println("# Simulation Parameters");
@@ -1006,7 +1005,7 @@
 			Enumeration<Equation> enum_equ = sd.getEquations();
 			while (enum_equ.hasMoreElements()){
 				Equation equation = enum_equ.nextElement();
-				equation.getDiscontinuities(simTask.getSimulationJob().getSimulationSymbolTable(), discontinuities);
+				equation.getDiscontinuities(simulationJob.getSimulationSymbolTable(), discontinuities);
 			}
 		}
 		getDiscontinuityTimes(discontinuities, discontinuityTimes);
@@ -1020,7 +1019,7 @@
 	} else { 
 		printWriter.println(FVInputFileKeyword.SOLVER + " " + FVInputFileKeyword.FV_SOLVER + " " + solverTaskDesc.getErrorTolerance().getRelativeErrorTolerance());
 	}
-	printWriter.println(FVInputFileKeyword.BASE_FILE_NAME + " " + new File(userDirectory, simTask.getSimulationJobID()).getAbsolutePath());
+	printWriter.println(FVInputFileKeyword.BASE_FILE_NAME + " " + new File(userDirectory, simulationJob.getSimulationJobID()).getAbsolutePath());
     printWriter.println(FVInputFileKeyword.ENDING_TIME + " " + solverTaskDesc.getTimeBounds().getEndingTime());    
     OutputTimeSpec outputTimeSpec = solverTaskDesc.getOutputTimeSpec();	
 	if (solverTaskDesc.getSolverDescription().equals(SolverDescription.SundialsPDE)) {
@@ -1070,7 +1069,7 @@
 	if (bInlineVCG) {
 		GeometryFileWriter.write(printWriter, resampledGeometry);
 	} else {
-		printWriter.println(FVInputFileKeyword.VCG_FILE + " " + new File(userDirectory, simTask.getSimulationJobID() + SimDataConstants.VCG_FILE_EXTENSION).getAbsolutePath());
+		printWriter.println(FVInputFileKeyword.VCG_FILE + " " + new File(userDirectory, simulationJob.getSimulationJobID() + SimDataConstants.VCG_FILE_EXTENSION).getAbsolutePath());
 	}	
 	printWriter.println(FVInputFileKeyword.MESH_END);
 	printWriter.println();
@@ -1141,7 +1140,7 @@
  * @throws IOException 
  */
 private void writeVariables() throws MathException, ExpressionException, IOException {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	printWriter.println("# Variables : type name domain time_dependent_flag advection_flag grad_flag solve_whole_mesh_flag solve_regions");
 	printWriter.println(FVInputFileKeyword.VARIABLE_BEGIN);
@@ -1187,7 +1186,7 @@
 			 		}
 			  	}
 				if (totalNumCompartments == listOfSubDomains.size()
-						|| listOfSubDomains.size() == 0 && simTask.getSimulation().getSolverTaskDescription().getSolverDescription().equals(SolverDescription.SundialsPDE)) {
+						|| listOfSubDomains.size() == 0 && simulationJob.getSimulation().getSolverTaskDescription().getSolverDescription().equals(SolverDescription.SundialsPDE)) {
 					printWriter.print(" true");
 				} else {
 					printWriter.print(" false");
@@ -1223,7 +1222,7 @@
 	
 	int numRandomVariables = rvList.size();
 	if (numRandomVariables > 0) {
-		ISize samplingSize = simTask.getSimulation().getMeshSpecification().getSamplingSize();
+		ISize samplingSize = simulationJob.getSimulation().getMeshSpecification().getSamplingSize();
 		String[] varNameArr = new String[numRandomVariables];
 		VariableType[] varTypeArr = new VariableType[numRandomVariables];
 		double[][] dataArr = new double[numRandomVariables][];
@@ -1245,7 +1244,7 @@
 			printWriter.println(" " + varNameArr[i]);
 			dataArr[i] = generateRandomNumbers(rv, numRandomNumbers);
 		}
-		File rvFile = new File(userDirectory, simTask.getSimulationJobID() + RANDOM_VARIABLE_FILE_EXTENSION);
+		File rvFile = new File(userDirectory, simulationJob.getSimulationJobID() + RANDOM_VARIABLE_FILE_EXTENSION);
 		DataSet.writeNew(rvFile, varNameArr, varTypeArr, samplingSize, dataArr);
 	}
 	printWriter.println(FVInputFileKeyword.VARIABLE_END);
@@ -1272,7 +1271,7 @@
 }
 
 private void writeSerialParameterScans() throws ExpressionException,  DivideByZeroException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	if (!simulation.isSerialParameterScan()) {
 		return;
 	}
@@ -1314,7 +1313,7 @@
 */
 
 private void writeFieldData() throws FileNotFoundException, ExpressionException, DataAccessException {
-	FieldDataIdentifierSpec[] fieldDataIDSpecs = simTask.getSimulationJob().getFieldDataIdentifierSpecs();
+	FieldDataIdentifierSpec[] fieldDataIDSpecs = simulationJob.getFieldDataIdentifierSpecs();
 	if (fieldDataIDSpecs == null || fieldDataIDSpecs.length == 0) {
 		return;
 	}
@@ -1329,7 +1328,7 @@
 	
 	FieldFunctionArguments psfFieldFunc = null;
 	
-	Variable var = simTask.getSimulationJob().getSimulationSymbolTable().getVariable(SimDataConstants.PSF_FUNCTION_NAME);
+	Variable var = simulationJob.getSimulationSymbolTable().getVariable(SimDataConstants.PSF_FUNCTION_NAME);
 	if (var != null) {
 		FieldFunctionArguments[] ffas = FieldUtilities.getFieldFunctionArguments(var.getExpression());
 		if (ffas == null || ffas.length == 0) {
@@ -1350,7 +1349,7 @@
 		if(!uniqueFieldDataIDSpecs.contains(fieldDataIDSpecs[i])){
 			FieldFunctionArguments ffa = fieldDataIDSpecs[i].getFieldFuncArgs();
 			File newResampledFieldDataFile = new File(userDirectory,
-					SimulationData.createCanonicalResampleFileName((VCSimulationDataIdentifier)simTask.getSimulationJob().getVCDataIdentifier(),
+					SimulationData.createCanonicalResampleFileName((VCSimulationDataIdentifier)simulationJob.getVCDataIdentifier(),
 							fieldDataIDSpecs[i].getFieldFuncArgs())
 				);
 			uniqueFieldDataIDSpecs.add(fieldDataIDSpecs[i]);
Index: src/cbit/vcell/solvers/CppClassCoderFastSystem.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderFastSystem.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderFastSystem.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -20,7 +20,6 @@
 import cbit.vcell.math.ReservedVariable;
 import cbit.vcell.math.SubDomain;
 import cbit.vcell.math.Variable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.solver.SimulationJob;
 /**
@@ -35,11 +34,11 @@
  * @param name java.lang.String
  */
 protected CppClassCoderFastSystem(CppCoderVCell cppCoderVCell, FastSystem fastSystem,
-								SubDomain subDomain,SimulationTask simTask,String parentClass) throws Exception
+								SubDomain subDomain,SimulationJob arg_simJob,String parentClass) throws Exception
 {
-	super(simTask, cppCoderVCell,parentClass+subDomain.getName(), parentClass);
+	super(arg_simJob, cppCoderVCell,parentClass+subDomain.getName(), parentClass);
 	this.subDomain = subDomain;
-	this.fs_analyzer = new FastSystemAnalyzer(fastSystem, simTask.getSimulationJob().getSimulationSymbolTable());
+	this.fs_analyzer = new FastSystemAnalyzer(fastSystem, simulationJob.getSimulationSymbolTable());
 }
 /**
  * This method was created by a SmartGuide.
@@ -230,7 +229,7 @@
 	Enumeration<PseudoConstant> enum2 = fs_analyzer.getPseudoConstants();
 	while (enum2.hasMoreElements()){
 		PseudoConstant pc = (PseudoConstant)enum2.nextElement();
-		out.println("\t" + CppClassCoder.getEscapedFieldVariableName_C(pc.getName()) + " = " + infix_C(simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(pc.getPseudoExpression()).flatten())+";");
+		out.println("\t" + CppClassCoder.getEscapedFieldVariableName_C(pc.getName()) + " = " + infix_C(simulationJob.getSimulationSymbolTable().substituteFunctions(pc.getPseudoExpression()).flatten())+";");
 		invariantCount++;
 	}
 		
@@ -357,7 +356,7 @@
 		out.println("\tdouble " + CppClassCoder.getEscapedLocalVariableName_C(pc.getName()) + " = " + CppClassCoder.getEscapedFieldVariableName_C(pc.getName()) + ";");
 	}
 	
-	FieldFunctionArguments[] fieldFuncArgs = simTask.getSimulationJob().getSimulationSymbolTable().getSimulation().getMathDescription().getFieldFunctionArguments();
+	FieldFunctionArguments[] fieldFuncArgs = simulationJob.getSimulationSymbolTable().getSimulation().getMathDescription().getFieldFunctionArguments();
 
 	for (int i = 0; fieldFuncArgs != null && i < fieldFuncArgs.length; i ++) {
 		String localvarname = CppClassCoder.getEscapedLocalFieldVariableName_C(fieldFuncArgs[i]);
Index: src/cbit/vcell/solvers/HTCSolver.java
===================================================================
--- src/cbit/vcell/solvers/HTCSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/HTCSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -13,7 +13,6 @@
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.PrintWriter;
-import java.util.ArrayList;
 
 import org.vcell.util.Executable;
 import org.vcell.util.PropertyLoader;
@@ -35,7 +34,7 @@
  */
 public abstract class HTCSolver extends AbstractSolver {
 	protected AbstractSolver realSolver = null;
-	protected ArrayList<String> cmdArguments = new ArrayList<String>();
+	protected java.lang.String cmdArguments = "";
 	protected SimulationTask simulationTask = null;
 
 /**
@@ -46,10 +45,10 @@
  * @exception cbit.vcell.solver.SolverException The exception description.
  */
 public HTCSolver(SimulationTask simTask, File directory, SessionLog sessionLog) throws SolverException {
-	super(simTask, directory, sessionLog);
+	super(simTask.getSimulationJob(), directory, sessionLog);
 	simulationTask = simTask;
-	if (!simTask.getSimulation().getSolverTaskDescription().getSolverDescription().isJavaSolver()) {
-		realSolver = (AbstractSolver)SolverFactory.createSolver(sessionLog, directory, simTask, true);
+	if (!simulationJob.getSimulation().getSolverTaskDescription().getSolverDescription().isJavaSolver()) {
+		realSolver = (AbstractSolver)SolverFactory.createSolver(sessionLog, directory, simTask.getSimulationJob(), true);
 		realSolver.addSolverListener(new SolverListener() {
 			public final void solverAborted(SolverEvent event) {		
 				fireSolverAborted(event.getSimulationMessage());
@@ -82,15 +81,14 @@
 			
 		});	
 	}
-	cmdArguments.add("-tid");
-	cmdArguments.add(String.valueOf(simTask.getTaskID()));
+	cmdArguments = "-tid " + String.valueOf(simTask.getTaskID());
 }
 
 /**
  *  This method takes the place of the old runUnsteady()...
  */
 protected void initialize() throws SolverException {
-	if (simTask.getSimulation().getSolverTaskDescription().getSolverDescription().isJavaSolver()) {
+	if (simulationJob.getSimulation().getSolverTaskDescription().getSolverDescription().isJavaSolver()) {
 		writeJavaInputFile();
 	} else {
 		realSolver.initialize(); 
@@ -102,7 +100,7 @@
 	try {
 		File inputFile = new File(getBaseName() + JAVA_INPUT_EXTENSION);
 		if (!inputFile.exists()) {	// write input file which is just xml				
-			String xmlString = XmlHelper.simToXML(simTask.getSimulation());
+			String xmlString = XmlHelper.simToXML(simulationJob.getSimulation());
 			pw = new PrintWriter(inputFile);
 			pw.println(xmlString);
 			pw.close();
@@ -127,7 +125,7 @@
 	} else {
 		File inputFile = new File(getBaseName() + JAVA_INPUT_EXTENSION);
 		Executable exe = new Executable(new String[]{PropertyLoader.getRequiredProperty(PropertyLoader.javaSimulationExecutable), 
-				/*VCellServerID.getSystemServerID().toString(),*/ inputFile.getParent(), inputFile.getName(), getJobIndex()+""});
+				VCellServerID.getSystemServerID().toString(), inputFile.getParent(), inputFile.getName(), getJobIndex()+""});
 		return exe.getCommand();
 	}
 }
Index: src/cbit/vcell/solvers/CppClassCoderMembraneVarContext.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderMembraneVarContext.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderMembraneVarContext.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -12,7 +12,6 @@
 
 
 import cbit.vcell.math.*;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.*;
 import cbit.vcell.solver.*;
 /**
@@ -27,10 +26,10 @@
 protected CppClassCoderMembraneVarContext(CppCoderVCell argCppCoderVCell,
 												Equation argEquation,
 												MembraneSubDomain argMembraneSubDomain,
-												SimulationTask simTask, 
+												SimulationJob argSimulationJob, 
 												String argParentClass) throws Exception
 {
-	super(argCppCoderVCell,argEquation,argMembraneSubDomain,simTask,argParentClass);
+	super(argCppCoderVCell,argEquation,argMembraneSubDomain,argSimulationJob,argParentClass);
 }
 
 
@@ -79,7 +78,7 @@
 	out.println("{");
 	try {
 		Expression ic = getEquation().getInitialExpression();
-		ic.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+		ic.bindExpression(simulationJob.getSimulationSymbolTable());
 		double value = ic.evaluateConstant();
 		out.println("\tinitialValue = new double;");
 		out.println("\t*initialValue = "+value+";");
@@ -117,7 +116,7 @@
 	out.println("\tvirtual void resolveReferences(Simulation *sim);");
 
 	BoundaryConditionType bc = null;
-	int dimension = simTask.getSimulation().getMathDescription().getGeometry().getDimension();
+	int dimension = simulationJob.getSimulation().getMathDescription().getGeometry().getDimension();
 	if (getEquation() instanceof PdeEquation){
 		PdeEquation pdeEqu = (PdeEquation)getEquation();
 		if (pdeEqu.getBoundaryXm()!=null){
@@ -184,7 +183,7 @@
 	}		
 	try {
 		Expression ic = getEquation().getInitialExpression();
-		ic.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+		ic.bindExpression(simulationJob.getSimulationSymbolTable());
 		double value = ic.evaluateConstant();
 	}catch (Exception e){
 		out.println("\tvirtual double getInitialValue(MembraneElement *memElement);");
@@ -243,7 +242,7 @@
 		writeMembraneFunction(out,"getMembraneDiffusionRate", new Expression(0.0), bFlippedInsideOutside);
 	}
 	out.println("");
-	MathDescription mathDesc = simTask.getSimulation().getMathDescription();
+	MathDescription mathDesc = simulationJob.getSimulation().getMathDescription();
 	int dimension = mathDesc.getGeometry().getDimension();
 	if (getEquation() instanceof PdeEquation){
 		PdeEquation pde = (PdeEquation)getEquation();
Index: src/cbit/vcell/solvers/FVSolverStandalone.java
===================================================================
--- src/cbit/vcell/solvers/FVSolverStandalone.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/FVSolverStandalone.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -18,7 +18,6 @@
 import org.vcell.util.SessionLog;
 
 import cbit.vcell.math.AnnotatedFunction;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.Simulation;
 import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
@@ -41,12 +40,12 @@
  * @param simID java.lang.String
  * @param clientProxy cbit.vcell.solvers.ClientProxy
  */
-public FVSolverStandalone (SimulationTask simTask, File dir, SessionLog sessionLog) throws SolverException {
-	this(simTask, dir, sessionLog, true);
+public FVSolverStandalone (SimulationJob argSimulationJob, File dir, SessionLog sessionLog) throws SolverException {
+	this(argSimulationJob, dir, sessionLog, true);
 }
 	
-public FVSolverStandalone (SimulationTask simTask, File dir, SessionLog sessionLog, boolean arg_bMessaging) throws SolverException {
-	super(simTask, dir, sessionLog, arg_bMessaging);
+public FVSolverStandalone (SimulationJob argSimulationJob, File dir, SessionLog sessionLog, boolean arg_bMessaging) throws SolverException {
+	super(argSimulationJob, dir, sessionLog, arg_bMessaging);
 }
 
 /**
@@ -54,21 +53,21 @@
  */
 protected void initialize() throws SolverException {
 	try {
-		Simulation sim = simTask.getSimulation();
+		Simulation sim = simulationJob.getSimulation();
 		if (sim.isSerialParameterScan()) {
 			//write functions file for all the simulations in the scan
 			for (int scan = 0; scan < sim.getScanCount(); scan ++) {
-				SimulationJob simJob = new SimulationJob(sim, scan, simTask.getSimulationJob().getFieldDataIdentifierSpecs());
+				SimulationJob simJob = new SimulationJob(sim, scan, simulationJob.getFieldDataIdentifierSpecs());
 				// ** Dumping the functions of a simulation into a '.functions' file.
 				String basename = new File(getSaveDirectory(), simJob.getSimulationJobID()).getPath();
 				String functionFileName = basename + FUNCTIONFILE_EXTENSION;
 				
-				Vector<AnnotatedFunction> funcList = simJob.getSimulationSymbolTable().createAnnotatedFunctionsList(simTask.getSimulation().getMathDescription());				
+				Vector<AnnotatedFunction> funcList = simJob.getSimulationSymbolTable().createAnnotatedFunctionsList(simulationJob.getSimulation().getMathDescription());				
 				//Try to save existing user defined functions	
 				try{
 					File existingFunctionFile = new File(functionFileName);
 					if (existingFunctionFile.exists()){
-						Vector<AnnotatedFunction> oldFuncList = FunctionFileGenerator.readFunctionsFile(existingFunctionFile, simTask.getSimulationJobID());
+						Vector<AnnotatedFunction> oldFuncList = FunctionFileGenerator.readFunctionsFile(existingFunctionFile, simulationJob.getSimulationJobID());
 						for(AnnotatedFunction func : oldFuncList){
 							if(func.isOldUserDefined()){
 								funcList.add(func);
@@ -101,34 +100,22 @@
 	
 		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INPUT_FILE));
 			
-		File fvinputFile = new File(getInputFilename());
+		File fvinputFile = new File(getSaveDirectory(), cppCoderVCell.getBaseFilename()+".fvinput");
 		PrintWriter pw = null;
 		try {
 			pw = new PrintWriter(new FileWriter(fvinputFile));
-			new FiniteVolumeFileWriter(pw, simTask, getResampledGeometry(), getSaveDirectory(), bMessaging).write();
+			new FiniteVolumeFileWriter(pw, simulationJob, getResampledGeometry(), getSaveDirectory(), bMessaging).write();
 		} finally {
 			if (pw != null) {
 				pw.close();
 			}
 		}
 	
-		setMathExecutable(new MathExecutable(getMathExecutableCommand()));
+		String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.finiteVolumeExecutableProperty);
+		setMathExecutable(new MathExecutable(new String[] {executableName, fvinputFile.getAbsolutePath()}));
 	} catch (Exception ex) {
 		ex.printStackTrace(System.out);
 		throw new SolverException(ex.getMessage());
 	}
 }
-
-private String getInputFilename(){
-	return new File(getSaveDirectory(),cppCoderVCell.getBaseFilename()+".fvinput").getAbsolutePath();
 }
-
-@Override
-public String[] getMathExecutableCommand() {
-	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.finiteVolumeExecutableProperty);
-	String inputFilename = getInputFilename();
-	return new String[] { executableName, inputFilename };
-}
-
-
-}
Index: src/cbit/vcell/solvers/PBSSolver.java
===================================================================
--- src/cbit/vcell/solvers/PBSSolver.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/vcell/solvers/PBSSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.solvers;
+import java.io.File;
+
+import org.vcell.util.ExecutableException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.SessionLog;
+
+import cbit.htc.PBSUtils;
+import cbit.htc.PbsJobID;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.solver.SolverStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (4/14/2005 10:47:25 AM)
+ * @author: Fei Gao
+ */
+public class PBSSolver extends HTCSolver {
+	private static String PBS_SUBMIT_FILE_EXT = ".pbs.sub";
+/**
+ * CondorSolver constructor comment.
+ * @param simTask cbit.vcell.messaging.server.SimulationTask
+ * @param directory java.io.File
+ * @param sessionLog cbit.vcell.server.SessionLog
+ * @exception cbit.vcell.solver.SolverException The exception description.
+ */
+public PBSSolver(SimulationTask simTask, java.io.File directory, SessionLog sessionLog) throws cbit.vcell.solver.SolverException {
+	super(simTask, directory, sessionLog);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/26/2003 2:23:53 PM)
+ * @throws SolverException 
+ * @throws ExecutableException 
+ */
+private PbsJobID submit2PBS() throws SolverException, ExecutableException {
+	fireSolverStarting(SimulationMessage.MESSAGE_SOLVEREVENT_STARTING_SUBMITTING);
+	String cmd = getExecutableCommand();
+	String subFile = new File(getBaseName()).getPath() + PBS_SUBMIT_FILE_EXT;
+	String jobname = "S_" + simulationTask.getSimKey() + "_" + simulationTask.getSimulationJob().getJobIndex();
+	
+	PbsJobID jobid = PBSUtils.submitJob(simulationTask.getComputeResource(), jobname, subFile, cmd, cmdArguments, 1, simulationTask.getEstimatedMemorySizeMB());
+	if (jobid == null) {
+		fireSolverAborted(SimulationMessage.jobFailed("Failed. (error message: submitting to job scheduler failed)."));
+		return null;
+	}
+	fireSolverStarting(SimulationMessage.solverEvent_Starting_Submit("submitted to job scheduler, job id is " + jobid, jobid));
+	
+	// babysitPBSSubmission(jobid);
+	
+	return jobid;
+}
+
+/**
+ * the code below was called synchronously within submit2PBS();
+ * 
+ */
+@Deprecated
+private void babysitPBSSubmission(PbsJobID jobid) throws SolverException{
+
+	// if PBS has problem with dispatching jobs, jobs that have been submitted
+	// but are not running, will be redispatched after 5 minutes. Then we have duplicate
+	// jobs or "failed" jobs actually running in PBS.
+	// to avoid this, kill the job, ask the user to try again later if the jobs
+	// are not in running status 2 minutes after submission.
+	long t = System.currentTimeMillis();
+	int status;
+	while (true) {
+		try {
+			Thread.sleep(1000);
+		} catch (InterruptedException ex) {
+		}
+		
+		VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"done waiting 1 second, getting pbs status");
+		status = PBSUtils.getJobStatus(jobid);
+		VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"pbsStatus = "+PBSUtils.getJobStatusDescription(status));
+		if (PBSUtils.isJobExiting(status)){
+			// pbs command tracejob takes more than 1 minute to get exit status after the job exists. 
+			// we don't want to spend so much time on a job, especially when the job is very short. 
+			// However, if dispatcher restarted the simulation, which means the first run failed, 
+			// we have to find out why.
+			if ((simulationTask.getTaskID() & MessageConstants.TASKID_RETRYCOUNTER_MASK) != 0) {
+				VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"status indicates exiting and retry>0, waiting 1 minute");
+				try {
+					Thread.sleep(MessageConstants.MINUTE_IN_MS); // have to sleep at least one minute to get tracejob exist status;
+				} catch (InterruptedException ex) {
+				}
+				VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"getting pbs status");
+				if (!PBSUtils.isJobExecOK(jobid)) {
+					VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"pbs status indicates exit status");
+					throw new SolverException("Job [" + jobid + "] exited unexpectedly: [" + PBSUtils.getJobExecStatus(jobid));			
+				}
+			}
+			VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"pbs status Okay");
+			break;
+		} else if (PBSUtils.isJobRunning(status)) {
+			//check to see if it exits soon after it runs
+			VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"Job is running, waiting 1 second before getting pbs status");
+			try {
+				Thread.sleep(1000);
+			} catch (InterruptedException ex) {
+			}
+			status = PBSUtils.getJobStatus(jobid);
+			VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"pbs status = "+PBSUtils.getJobStatusDescription(status));
+			if (PBSUtils.isJobExiting(status)) {
+				if ((simulationTask.getTaskID() & MessageConstants.TASKID_RETRYCOUNTER_MASK) != 0) {
+					VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"status indicates exiting and retry>0, waiting 1 minute");
+					try {
+						Thread.sleep(MessageConstants.MINUTE_IN_MS); // have to sleep at least one minute to get tracejob exist status;
+					} catch (InterruptedException ex) {
+					}
+					if (!PBSUtils.isJobExecOK(jobid)) {
+						VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"pbs status indicates exit status");
+						throw new SolverException("Job [" + jobid + "] exited unexpectedly: " + PBSUtils.getJobExecStatus(jobid));			
+					}
+				}
+			}
+			VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"pbs status Okay");
+			break;
+		} else if (System.currentTimeMillis() - t > 4 * MessageConstants.MINUTE_IN_MS) {
+			String pendingReason = PBSUtils.getPendingReason(jobid);
+			PBSUtils.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+			throw new SolverException("PBS Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")");
+		}
+	}
+	System.out.println("It took " + (System.currentTimeMillis() - t) + " ms to verify pbs job status " + PBSUtils.getJobStatusDescription(status));
+	VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobid,"It took " + (System.currentTimeMillis() - t) + " ms to verify pbs job status " + PBSUtils.getJobStatusDescription(status));
+}
+
+@Override
+public double getCurrentTime() {
+	return 0;
+}
+
+@Override
+public double getProgress() {
+	return 0;
+}
+
+public void startSolver() {
+	try {
+		VCMongoMessage.sendPBSWorkerMessage(simulationTask,null, "calling PBSSolver.initialize()");
+		initialize();
+		VCMongoMessage.sendPBSWorkerMessage(simulationTask,null, "calling PBSSolver.submit2PBS()");
+		PbsJobID jobID = submit2PBS();
+		VCMongoMessage.sendPBSWorkerMessage(simulationTask,jobID, "PBSSolver.submit2PBS() returned");
+	} catch (Throwable throwable) {
+		VCMongoMessage.sendPBSWorkerMessage(simulationTask,null, "PBSSolver.startSolver() exception: "+throwable.getClass().getName()+" "+throwable.getMessage());
+		getSessionLog().exception(throwable);
+		setSolverStatus(new SolverStatus (SolverStatus.SOLVER_ABORTED, SimulationMessage.solverAborted(throwable.getMessage())));
+		fireSolverAborted(SimulationMessage.solverAborted(throwable.getMessage()));		
+	}
+}
+
+public void stopSolver() {
+}
+}
Index: src/cbit/vcell/solvers/CppCoderVCell.java
===================================================================
--- src/cbit/vcell/solvers/CppCoderVCell.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppCoderVCell.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -23,18 +23,17 @@
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolVariable;
 import cbit.vcell.math.VolumeRegionEquation;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.solver.Simulation;
 import cbit.vcell.solver.SimulationJob;
 
 public class CppCoderVCell extends CppCoder
 {
-	private SimulationTask simTask = null;
+	private SimulationJob simulationJob = null;
 
-public CppCoderVCell(String baseFilename, java.io.File directory, SimulationTask simTask){
+public CppCoderVCell(String baseFilename, java.io.File directory, SimulationJob argSimulationJob){
 	super(baseFilename,directory);
-	this.simTask = simTask;
+	this.simulationJob = argSimulationJob;
 }                              
 
 
@@ -155,13 +154,13 @@
 	//
 	// add Simulation coder
 	//
-	Simulation simulation = simTask.getSimulation();
-	addCppClassCoder(new CppClassCoderSimulation(this,simTask,new java.io.File(dir,baseFilename).getPath()));
+	Simulation simulation = simulationJob.getSimulation();
+	addCppClassCoder(new CppClassCoderSimulation(this,simulationJob,new java.io.File(dir,baseFilename).getPath()));
 	
 	//
 	// add Model coder
 	//
-	addCppClassCoder(new CppClassCoderVCellModel(this,simTask));
+	addCppClassCoder(new CppClassCoderVCellModel(this,simulationJob));
 	
 	//
 	// add Feature coders
@@ -171,12 +170,12 @@
 		SubDomain subDomain = enum1.nextElement();
 		if (subDomain instanceof CompartmentSubDomain){
 			CompartmentSubDomain volSubDomain = (CompartmentSubDomain)subDomain;
-			addCppClassCoder(new CppClassCoderFeature(this,simTask,volSubDomain,null));
+			addCppClassCoder(new CppClassCoderFeature(this,simulationJob,volSubDomain,null));
 			
 			//
 			// add VolumeVarContext coders
 			//
-			Variable[] vars = simTask.getSimulationJob().getSimulationSymbolTable().getVariables();
+			Variable[] vars = simulationJob.getSimulationSymbolTable().getVariables();
 			for (int i = 0; i < vars.length; i ++) {
 				Equation equation = volSubDomain.getEquation(vars[i]);
 				if (equation != null && equation instanceof VolumeRegionEquation) {
@@ -188,7 +187,7 @@
 						equation = new PdeEquation(vars[i], bSteady, new Expression(0.0), new Expression(0.0), new Expression(0.0));
 					} 
 					if (equation != null) {
-						addCppClassCoder(new CppClassCoderVolumeVarContext(this,equation,volSubDomain,simTask,"VolumeVarContext"));
+						addCppClassCoder(new CppClassCoderVolumeVarContext(this,equation,volSubDomain,simulationJob,"VolumeVarContext"));
 					}
 				}
 			}
@@ -202,9 +201,9 @@
 			while (enum_equ.hasMoreElements()){
 				Equation equation = enum_equ.nextElement();
 				if (equation instanceof MembraneRegionEquation){
-					addCppClassCoder(new CppClassCoderMembraneRegionVarContext(this,equation,memSubDomain,simTask,"MembraneRegionVarContext"));
+					addCppClassCoder(new CppClassCoderMembraneRegionVarContext(this,equation,memSubDomain,simulationJob,"MembraneRegionVarContext"));
 				}else{
-					addCppClassCoder(new CppClassCoderMembraneVarContext(this,equation,memSubDomain,simTask,"MembraneVarContext"));
+					addCppClassCoder(new CppClassCoderMembraneVarContext(this,equation,memSubDomain,simulationJob,"MembraneVarContext"));
 				}
 			}	
 		}else if (subDomain instanceof FilamentSubDomain){
@@ -219,7 +218,7 @@
 				if (equation instanceof FilamentRegionEquation){
 //					addCppClassCoder(new CppClassCoderFilamentRegionVarContext(this,equation,filamentSubDomain,simulation,"ContourRegionVarContext"));
 				}else if (equation.getSolutionType() == Equation.UNKNOWN_SOLUTION){
-					addCppClassCoder(new CppClassCoderContourVarContext(this,equation,filamentSubDomain,simTask,"ContourVarContext"));
+					addCppClassCoder(new CppClassCoderContourVarContext(this,equation,filamentSubDomain,simulationJob,"ContourVarContext"));
 				}else if (equation.getSolutionType() == Equation.EXACT_SOLUTION){
 //					addCppClassCoder(new CppClassCoderExactContourVarContext(this,equation,filamentSubDomain,mathDesc,"ExactContourVarContext"));	
 					throw new Exception("membrane equation has unsupported solution type <EXACT SOLUTION>");
@@ -233,7 +232,7 @@
 		//
 		FastSystem fastSystem = subDomain.getFastSystem();
 		if (fastSystem!=null){
-			addCppClassCoder(new CppClassCoderFastSystem(this,fastSystem,subDomain,simTask,"FastSystem"));
+			addCppClassCoder(new CppClassCoderFastSystem(this,fastSystem,subDomain,simulationJob,"FastSystem"));
 		}	
 	}	
 
Index: src/cbit/vcell/solvers/CppClassCoder.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoder.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoder.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -13,7 +13,6 @@
 import java.io.*;
 import cbit.vcell.field.FieldFunctionArguments;
 import cbit.vcell.field.FieldUtilities;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.parser.FunctionInvocation;
@@ -28,7 +27,7 @@
 	private String className = null;
 	private String parentClassName = null;
 	protected CppCoder cppCoder = null;
-	protected final SimulationTask simTask;
+	protected final SimulationJob simulationJob;
 
 	private static final String C_FIELDVAR_PREFIX = "vcell_fieldvar_";
 	private static final String C_LOCALVAR_PREFIX = "vcell_localvar_";
@@ -38,8 +37,8 @@
  * This method was created by a SmartGuide.
  * @param className java.lang.String
  */
-public CppClassCoder (SimulationTask simTask, CppCoder cppCoder, String className, String parentClassName) {
-	this.simTask = simTask;
+public CppClassCoder (SimulationJob simJob, CppCoder cppCoder, String className, String parentClassName) {
+	simulationJob = simJob;
 	this.cppCoder = cppCoder;
 	this.className = className;
 	this.parentClassName = parentClassName;
Index: src/cbit/vcell/solvers/CppClassCoderAbstractVarContext.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderAbstractVarContext.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderAbstractVarContext.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -30,7 +30,6 @@
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolVariable;
 import cbit.vcell.math.VolumeRegionVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.SimulationJob;
@@ -51,10 +50,10 @@
 protected CppClassCoderAbstractVarContext(CppCoderVCell cppCoderVCell, 
 											Equation argEquation, 
 											SubDomain argSubDomain, 
-											SimulationTask simTask, 
+											SimulationJob argSimulationJob, 
 											String argParentClass) throws Exception
 {
-	super(simTask, cppCoderVCell,argParentClass+argSubDomain.getName()+argEquation.getVariable().getName(), argParentClass);
+	super(argSimulationJob, cppCoderVCell,argParentClass+argSubDomain.getName()+argEquation.getVariable().getName(), argParentClass);
 	this.equation = argEquation;
 	this.variable = argEquation.getVariable();
 	this.subDomain = argSubDomain;
@@ -78,7 +77,7 @@
  */
 protected Variable[] getRequiredVariables() throws Exception {
 
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	//
 	// default implementation (need to override in VolumeVarContext)
 	//
@@ -159,7 +158,7 @@
 	out.println("double "+getClassName()+"::"+functionName+"(ContourElement *contourElement)");
 	out.println("{");
 
-	Expression exp2 = simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(exp).flatten();
+	Expression exp2 = simulationJob.getSimulationSymbolTable().substituteFunctions(exp).flatten();
 	writeContourFunctionDeclarations(out,"contourElement",exp2);
 
 	out.println("\treturn "+infix_C(exp2)+";");
@@ -176,7 +175,7 @@
 protected void writeContourFunctionDeclarations(java.io.PrintWriter out, String contourElementString, Expression exp) throws Exception {
 
 	boolean wc_defined = false;
-	Enumeration<Variable> enum1 = simTask.getSimulationJob().getSimulationSymbolTable().getRequiredVariables(exp);
+	Enumeration<Variable> enum1 = simulationJob.getSimulationSymbolTable().getRequiredVariables(exp);
 	
 	String compute_wc =	
 		  "\tWorldCoord wc_begin = " + contourElementString + "->wc_begin;\n"	
@@ -259,7 +258,7 @@
 	out.println("double "+getClassName()+"::"+functionName+"(MembraneElement *memElement)");
 	out.println("{");
 
-	Expression exp2 = simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(exp).flatten();
+	Expression exp2 = simulationJob.getSimulationSymbolTable().substituteFunctions(exp).flatten();
 	writeMembraneFunctionDeclarations(out,"memElement",exp2,bFlipInsideOutside,"   ");
 
 	out.println("\treturn "+infix_C(exp2)+";");
@@ -276,7 +275,7 @@
 protected final void writeMembraneFunctionDeclarations(java.io.PrintWriter out, String membraneElementString, Expression exp, boolean bFlipInsideOutside, String pad) throws Exception {
 
 	boolean wc_defined = false;
-	Enumeration<Variable> enum1 = simTask.getSimulationJob().getSimulationSymbolTable().getRequiredVariables(exp);
+	Enumeration<Variable> enum1 = simulationJob.getSimulationSymbolTable().getRequiredVariables(exp);
 
 	while (enum1.hasMoreElements()){
 		Variable var = enum1.nextElement();
@@ -353,7 +352,7 @@
 	out.println("double "+getClassName()+"::"+functionName+"(MembraneRegion *memRegion)");
 	out.println("{");
 
-	Expression exp2 = simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(exp).flatten();
+	Expression exp2 = simulationJob.getSimulationSymbolTable().substituteFunctions(exp).flatten();
 	writeMembraneRegionFunctionDeclarations(out,"memRegion",exp2);
 
 	out.println("\treturn "+infix_C(exp2)+";");
@@ -369,7 +368,7 @@
  */
 protected final void writeMembraneRegionFunctionDeclarations(java.io.PrintWriter out, String membraneRegionString, Expression exp) throws Exception {
 
-	Enumeration<Variable> enum1 = simTask.getSimulationJob().getSimulationSymbolTable().getRequiredVariables(exp);
+	Enumeration<Variable> enum1 = simulationJob.getSimulationSymbolTable().getRequiredVariables(exp);
 	
 	while (enum1.hasMoreElements()){
 		Variable var = enum1.nextElement();
@@ -451,8 +450,8 @@
 	out.println("double "+getClassName()+"::"+functionName+"()");
 	out.println("{");
 
-	exp.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
-	Expression exp2 = simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(exp).flatten();
+	exp.bindExpression(simulationJob.getSimulationSymbolTable());
+	Expression exp2 = simulationJob.getSimulationSymbolTable().substituteFunctions(exp).flatten();
 	try {
 		exp2.evaluateConstant();
 	} catch (Exception ex) {
@@ -478,7 +477,7 @@
 	out.println("double "+getClassName()+"::"+functionName+"(long volumeIndex)");
 	out.println("{");
 
-	exp.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+	exp.bindExpression(simulationJob.getSimulationSymbolTable());
 	Expression exp2 = substituteFunctions(exp).flatten();
 	writeVolumeFunctionDeclarations(out,exp2,"volumeIndex");
 
@@ -500,7 +499,7 @@
 	}	
 
 	boolean wc_defined = false;
-	Enumeration<Variable> enum1 = simTask.getSimulationJob().getSimulationSymbolTable().getRequiredVariables(exp);
+	Enumeration<Variable> enum1 = simulationJob.getSimulationSymbolTable().getRequiredVariables(exp);
 
 	while (enum1.hasMoreElements()){
 		Variable var = enum1.nextElement();
@@ -558,7 +557,7 @@
 	out.println("double "+getClassName()+"::"+functionName+"(VolumeRegion *volumeRegion)");
 	out.println("{");
 
-	exp.bindExpression(simTask.getSimulationJob().getSimulationSymbolTable());
+	exp.bindExpression(simulationJob.getSimulationSymbolTable());
 	Expression exp2 = substituteFunctions(exp).flatten();
 	writeVolumeRegionFunctionDeclarations(out,exp2,"volumeRegion");
 
@@ -581,7 +580,7 @@
 
 	String regionIndexString = "regionIndex";
 	out.println("\tlong "+regionIndexString+" = "+volumeRegionString+"->getId();");
-	Enumeration<Variable> enum1 = simTask.getSimulationJob().getSimulationSymbolTable().getRequiredVariables(exp);
+	Enumeration<Variable> enum1 = simulationJob.getSimulationSymbolTable().getRequiredVariables(exp);
 
 	while (enum1.hasMoreElements()){
 		Variable var = enum1.nextElement();
@@ -607,6 +606,6 @@
 }
 
 Expression substituteFunctions(Expression exp) throws MathException, ExpressionException {
-	return simTask.getSimulationJob().getSimulationSymbolTable().substituteFunctions(exp);
+	return simulationJob.getSimulationSymbolTable().substituteFunctions(exp);
 }
 }
Index: src/cbit/vcell/solvers/CppClassCoderVolumeVarContext.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderVolumeVarContext.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderVolumeVarContext.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -13,7 +13,6 @@
 
 
 import cbit.vcell.math.*;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.*;
 import cbit.vcell.solver.*;
 /**
@@ -30,12 +29,12 @@
 protected CppClassCoderVolumeVarContext(CppCoderVCell argCppCoderVCell,
 												Equation argEquation,
 												CompartmentSubDomain argVolumeSubDomain,
-												SimulationTask simTask, 
+												SimulationJob argSimulationJob, 
 												String argParentClass) throws Exception
 {
-	super(argCppCoderVCell, argEquation, argVolumeSubDomain, simTask, argParentClass);
+	super(argCppCoderVCell, argEquation, argVolumeSubDomain, argSimulationJob, argParentClass);
 	Vector<MembraneSubDomain> membraneSubDomainOwnedList = new Vector<MembraneSubDomain>();
-	MembraneSubDomain membranes[] = simTask.getSimulation().getMathDescription().getMembraneSubDomains(argVolumeSubDomain);
+	MembraneSubDomain membranes[] = simulationJob.getSimulation().getMathDescription().getMembraneSubDomains(argVolumeSubDomain);
 	for (int i = 0; i < membranes.length; i++){
 		//
 		// determine membrane "owner" for reasons of code generation (owner compartment is that which has a greater priority ... now this is arbitrary)
@@ -78,7 +77,7 @@
 	//
 	// 
 	//
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	Variable requiredVariables[] = super.getRequiredVariables();
 	if (getEquation() instanceof PdeEquation){
 		for (int i = 0;membraneSubDomainsOwned!=null && i < membraneSubDomainsOwned.length; i++){
@@ -118,7 +117,7 @@
  * @param out java.io.PrintWriter
  */
 protected void writeConstructor(java.io.PrintWriter out) throws Exception {
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	out.println(getClassName()+"::"+getClassName()+"(Feature *Afeature, string& AspeciesName)");
 	out.println(": "+getParentClassName()+"(Afeature,AspeciesName)");
@@ -184,7 +183,7 @@
 	out.println("\tvoid resolveReferences(Simulation *sim);");
 
 	BoundaryConditionType bc = null;
-	int dimension = simTask.getSimulation().getMathDescription().getGeometry().getDimension();
+	int dimension = simulationJob.getSimulation().getMathDescription().getGeometry().getDimension();
 	if (getEquation() instanceof PdeEquation){
 		PdeEquation pdeEqu = (PdeEquation)getEquation();
 		if (pdeEqu.getBoundaryXm()!=null){
@@ -256,7 +255,7 @@
 		}	
 	}		
 	
-	SymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	try {
 		Expression ic = getEquation().getInitialExpression();
 		ic.bindExpression(simSymbolTable );
@@ -383,7 +382,7 @@
 			//out.println("   printf(\"getFlux(index=%ld, insideHandle=%d, outsideHandle=%ld), MembraneElement outside feature = '%s'\\n\",element->index,insideHandle,outsideHandle,outsideFeature->getName());");
 			out.println("\tswitch(outsideHandle){");
 			for (int i = 0; i < membraneSubDomainsOwned.length; i++){
-				cbit.vcell.geometry.GeometrySpec geoSpec = simTask.getSimulation().getMathDescription().getGeometry().getGeometrySpec();
+				cbit.vcell.geometry.GeometrySpec geoSpec = simulationJob.getSimulation().getMathDescription().getGeometry().getGeometrySpec();
 				boolean bFlipInsideOutside = (membraneSubDomainsOwned[i].getOutsideCompartment() == getCompartmentSubDomain());
 				cbit.vcell.geometry.SubVolume outsideSubVolume = null;
 				if (bFlipInsideOutside){
@@ -454,7 +453,7 @@
 	out.println("");
 	writeGetFlux(out,"getFlux");
 	out.println("");
-	int dimension = simTask.getSimulation().getMathDescription().getGeometry().getDimension();
+	int dimension = simulationJob.getSimulation().getMathDescription().getGeometry().getDimension();
 	if (getEquation() instanceof PdeEquation){
 		PdeEquation pde = (PdeEquation)getEquation();
 		BoundaryConditionType bc = getCompartmentSubDomain().getBoundaryConditionXm();
Index: src/cbit/vcell/solvers/CppClassCoderVCellModel.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderVCellModel.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/CppClassCoderVCellModel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -12,7 +12,6 @@
 
 import java.util.*;
 import cbit.vcell.math.*;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.*;
 /**
  * This class was generated by a SmartGuide.
@@ -23,9 +22,9 @@
  * VarContextCppCoder constructor comment.
  * @param name java.lang.String
  */
-protected CppClassCoderVCellModel(CppCoderVCell cppCoderVCell, SimulationTask simTask) 
+protected CppClassCoderVCellModel(CppCoderVCell cppCoderVCell, SimulationJob argSimulationJob) 
 {
-	super(simTask, cppCoderVCell,"UserVCellModel", "VCellModel");
+	super(argSimulationJob, cppCoderVCell,"UserVCellModel", "VCellModel");
 }
 /**
  * This method was created by a SmartGuide.
@@ -56,7 +55,7 @@
  	//
  	// add 'Contours' to VCellModel (if any)
  	//
- 	cbit.vcell.geometry.FilamentGroup fg = simTask.getSimulation().getMathDescription().getGeometry().getGeometrySpec().getFilamentGroup();
+ 	cbit.vcell.geometry.FilamentGroup fg = simulationJob.getSimulation().getMathDescription().getGeometry().getGeometrySpec().getFilamentGroup();
   	for (int i=0;i<fg.getFilamentCount();i++){
 	  	out.println("\taddContour(new Contour("+i+"));  // for Filament "+fg.getFilamentNames()[i]);
   	}	 	
Index: src/cbit/vcell/solvers/AbstractSolver.java
===================================================================
--- src/cbit/vcell/solvers/AbstractSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/solvers/AbstractSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -19,7 +19,6 @@
 import cbit.vcell.math.Constant;
 import cbit.vcell.math.MathUtilities;
 import cbit.vcell.math.VolVariable;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.mongodb.VCMongoMessage;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
@@ -47,26 +46,25 @@
 	private SolverStatus fieldSolverStatus = new SolverStatus(SolverStatus.SOLVER_READY, SimulationMessage.MESSAGE_SOLVER_READY);
 	private File saveDirectory = null;
 	private boolean saveEnabled = true;
-	protected final SimulationTask simTask;
-	public static boolean bMakeUserDirs = true;
+	protected final SimulationJob simulationJob;
 
 /**
  * AbstractSolver constructor comment.
  */
-public AbstractSolver(SimulationTask simTask, File directory, SessionLog sessionLog) throws SolverException {
+public AbstractSolver(SimulationJob simulationJob, File directory, SessionLog sessionLog) throws SolverException {
 
-	this.simTask = simTask;
+	this.simulationJob = simulationJob;
 	this.fieldSessionLog = sessionLog;
 	if (!directory.exists()){
-		if (bMakeUserDirs && !directory.mkdirs()){
+		if (!directory.mkdirs()){
 			String msg = "could not create directory "+directory;
 			sessionLog.alert(msg);
 			throw new ConfigurationException(msg);
 		}
 	}		 
 		this.saveDirectory = directory;
-	if (!simTask.getSimulationJob().getSimulation().checkValid()) {
-		throw new SolverException(simTask.getSimulationJob().getSimulation().getWarning());
+	if (!simulationJob.getSimulation().checkValid()) {
+		throw new SolverException(simulationJob.getSimulation().getWarning());
 	}
 }
 
@@ -86,7 +84,7 @@
  */
 protected void fireSolverAborted(SimulationMessage message) {
 	// Create event
-	SolverEvent event = new SolverEvent(this, SolverEvent.SOLVER_ABORTED, message, getProgress(), getCurrentTime(), message.getHtcJobId());
+	SolverEvent event = new SolverEvent(this, SolverEvent.SOLVER_ABORTED, message, getProgress(), getCurrentTime(), message.getPbsJobId());
 	VCMongoMessage.sendSolverEvent(event);
 	// Guaranteed to return a non-null array
 	Object[] listeners = listenerList.getListenerList();
@@ -162,7 +160,7 @@
  */
 protected void fireSolverStarting(SimulationMessage message) {
 	// Create event
-	SolverEvent event = new SolverEvent(this, SolverEvent.SOLVER_STARTING, message, 0, 0, message.getHtcJobId());
+	SolverEvent event = new SolverEvent(this, SolverEvent.SOLVER_STARTING, message, 0, 0, message.getPbsJobId());
 	VCMongoMessage.sendSolverEvent(event);
 	// Guaranteed to return a non-null array
 	Object[] listeners = listenerList.getListenerList();
@@ -199,7 +197,7 @@
  * getCurrentTime method comment.
  */
 protected final String getBaseName() {
-	return (new File(getSaveDirectory(), simTask.getSimulationJob().getSimulationJobID()).getPath());
+	return (new File(getSaveDirectory(), simulationJob.getSimulationJobID()).getPath());
 }
 
 
@@ -230,7 +228,7 @@
 	//
 	// collect the explicit term
 	//
-	SimulationSymbolTable simSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	SimulationSymbolTable simSymbolTable = simulationJob.getSimulationSymbolTable();
 	
 	Expression sensFuncExp = funcExpr.differentiate(constant.getName());
 	sensFuncExp.bindExpression(simSymbolTable);
@@ -278,19 +276,10 @@
  * @return int
  */
 public int getJobIndex() {
-	return getSimulationJob().getJobIndex();
+	return simulationJob.getJobIndex();
 }
 
-/**
- * Insert the method's description here.
- * Creation date: (6/26/2001 3:42:59 PM)
- * @return int
- */
-public int getTaskID() {
-	return simTask.getTaskID();
-}
 
-
 /**
  * Insert the method's description here.
  * Creation date: (6/28/01 2:36:57 PM)
@@ -356,7 +345,7 @@
 
 
 public SimulationJob getSimulationJob() {
-	return simTask.getSimulationJob();
+	return simulationJob;
 }
 
 }
Index: src/cbit/vcell/xml/XmlHelper.java
===================================================================
--- src/cbit/vcell/xml/XmlHelper.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/xml/XmlHelper.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -10,26 +10,17 @@
 
 package cbit.vcell.xml;
 
-import static cbit.vcell.xml.VFrapXmlHelper.CreateSaveVFrapDataSymbols;
-import static cbit.vcell.xml.VFrapXmlHelper.LoadVFrapSpecialImages;
-import static cbit.vcell.xml.VFrapXmlHelper.ReplaceVFrapNamesWithSymbolNames;
-import static cbit.vcell.xml.VFrapXmlHelper.SaveVFrapSpecialImagesAsFieldData;
-import static cbit.vcell.xml.VFrapXmlHelper.checkNameAvailability;
-
 import java.awt.Component;
 import java.beans.PropertyVetoException;
 import java.io.File;
 import java.io.IOException;
 import java.io.StringReader;
-import java.util.ArrayList;
 import java.util.Hashtable;
-import java.util.List;
 
 import org.jdom.Comment;
 import org.jdom.Document;
 import org.jdom.Element;
 import org.jdom.Namespace;
-import org.jdom.Text;
 import org.vcell.cellml.CellQuanVCTranslator;
 import org.vcell.sbml.vcell.MathModel_SBMLExporter;
 import org.vcell.sbml.vcell.SBMLExporter;
@@ -42,6 +33,7 @@
 import org.vcell.util.document.VCDocument;
 import org.vcell.util.gui.UtilCancelException;
 
+import static cbit.vcell.xml.VFrapXmlHelper.*;
 import cbit.image.ImageException;
 import cbit.image.VCImage;
 import cbit.util.xml.VCLogger;
@@ -54,7 +46,6 @@
 import cbit.vcell.biomodel.meta.xml.XMLMetaDataWriter;
 import cbit.vcell.client.TopLevelWindowManager;
 import cbit.vcell.clientdb.DocumentManager;
-import cbit.vcell.field.FieldDataIdentifierSpec;
 import cbit.vcell.geometry.Geometry;
 import cbit.vcell.mapping.MathMapping;
 import cbit.vcell.mapping.MathSymbolMapping;
@@ -62,7 +53,6 @@
 import cbit.vcell.math.MathDescription;
 import cbit.vcell.math.MathException;
 import cbit.vcell.mathmodel.MathModel;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.model.Kinetics;
 import cbit.vcell.model.Parameter;
 import cbit.vcell.model.ReactionStep;
@@ -830,120 +820,6 @@
 	ReplaceVFrapNamesWithSymbolNames(bioModel);
 	return bioModel;
 }
-private static final String SimulationTask_tag = "SimulationTask";
-private static final String FieldFunctionIdentifierSpec_tag = "FieldFunctionIdentifierSpec"; 
-private static final String ComputeResource_tag = "ComputeResource";
-private static final String TaskId_attr = "TaskId";
-private static final String JobIndex_attr = "JobIndex";
 
-public static String simTaskToXML(SimulationTask simTask) throws XmlParseException {
-
-	String simTaskString = null;
-	
-	if (simTask == null) {
-		throw new XmlParseException("Invalid input for SimulationTask: " + simTask);
-	}
-	Xmlproducer xmlProducer = new Xmlproducer(true);
-	
-	SimulationJob simJob = simTask.getSimulationJob();
-	Simulation sim = simJob.getSimulation();
-	
-	Element container = new Element(SimulationTask_tag); 
-	int taskId = simTask.getTaskID();
-	container.setAttribute(TaskId_attr, ""+taskId);
-	int jobIndex = simJob.getJobIndex();
-	container.setAttribute(JobIndex_attr, ""+jobIndex);
-
-	String computeResource = simTask.getComputeResource();
-	if (computeResource!=null){
-		Element computeResourceElement = new Element(ComputeResource_tag);
-		Text text = new Text(computeResource);
-		computeResourceElement.addContent(text);
-		container.addContent(computeResourceElement);
-	}
-
-	FieldDataIdentifierSpec[] fdisSpecs = simJob.getFieldDataIdentifierSpecs();
-	if (fdisSpecs!=null){
-		for (FieldDataIdentifierSpec fdisSpec : fdisSpecs){
-			Element fdisElement = new Element(FieldFunctionIdentifierSpec_tag);
-			fdisElement.setText(fdisSpec.toCSVString());
-			container.addContent(fdisElement);
-		}
-	}
-	
-	MathDescription md = sim.getMathDescription();
-	Element mathElement = xmlProducer.getXML(md);
-	container.addContent(mathElement);
-
-	Element simElement = xmlProducer.getXML(sim);
-	container.addContent(simElement);
-
-	Geometry geom = md.getGeometry();    
-	if (geom != null) {
-		Element geomElement = xmlProducer.getXML(geom);
-		container.addContent(geomElement);
-	} else {
-		System.err.println("No corresponding geometry for the simulation: " + sim.getName());
-	}
-	
-	container = XmlUtil.setDefaultNamespace(container, Namespace.getNamespace(XMLTags.VCML_NS));		
-	simTaskString = XmlUtil.xmlToString(container);
-	
-	return simTaskString;
 }
 
-public static SimulationTask XMLToSimTask(String xmlString) throws XmlParseException, ExpressionException {
-
-	Namespace ns = Namespace.getNamespace(XMLTags.VCML_NS);
-	
-	try {
-		if (xmlString == null || xmlString.length() == 0) {
-			throw new XmlParseException("Invalid xml for Simulation: " + xmlString);
-		}
-		Element root =  (XmlUtil.stringToXML(xmlString, null)).getRootElement();     //default parser and no validation
-		if (!root.getName().equals(SimulationTask_tag)){
-			throw new RuntimeException("expecting top level element to be "+SimulationTask_tag);
-		}
-		int taskId = Integer.parseInt(root.getAttributeValue(TaskId_attr));
-		int jobIndex = Integer.parseInt(root.getAttributeValue(JobIndex_attr));
-		String computeResource = root.getChildTextTrim(ComputeResource_tag, ns);
-		
-		List children = root.getChildren(FieldFunctionIdentifierSpec_tag, ns);
-		ArrayList<FieldDataIdentifierSpec> fdisArrayList = new ArrayList<FieldDataIdentifierSpec>();
-		for (Object child : children){
-			if (child instanceof Element){
-				String fdisText = ((Element)child).getTextTrim();
-				FieldDataIdentifierSpec fdis = FieldDataIdentifierSpec.fromCSVString(fdisText);
-				fdisArrayList.add(fdis);
-			}
-		}
-		FieldDataIdentifierSpec[] fdisArray = fdisArrayList.toArray(new FieldDataIdentifierSpec[0]);
-		
-		Element simElement = root.getChild(XMLTags.SimulationTag, ns);
-		Element mdElement = root.getChild(XMLTags.MathDescriptionTag, ns);
-		Element geomElement = root.getChild(XMLTags.GeometryTag, ns);
-		XmlReader reader = new XmlReader(true, ns);
-		MathDescription md = reader.getMathDescription(mdElement);
-		if (geomElement != null) {
-			Geometry geom = reader.getGeometry(geomElement);
-			md.setGeometry(geom);
-		}
-		Simulation sim = reader.getSimulation(simElement, md);
-		sim.refreshDependencies();
-		
-		SimulationJob simJob = new SimulationJob(sim,jobIndex,fdisArray);
-		SimulationTask simTask = new SimulationTask(simJob,taskId,computeResource);
-		return simTask;
-		
-	} catch (PropertyVetoException pve) {
-		pve.printStackTrace();
-		throw new XmlParseException("Unable to parse simulation string: "+pve.getMessage());
-	}
-}
-
-
-
-
-
-}
-
Index: src/cbit/vcell/client/ClientRequestManager.java
===================================================================
--- src/cbit/vcell/client/ClientRequestManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/ClientRequestManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -2677,11 +2677,11 @@
  * @param documentWindowManager cbit.vcell.client.DocumentWindowManager
  * @param simulations cbit.vcell.solver.Simulation[]
  */
-public void runSimulation(final SimulationInfo simInfo, int numSimulationScanJobs) throws DataAccessException{
+public void runSimulation(final SimulationInfo simInfo) throws DataAccessException{
 
 	getClientServerManager().
 		getJobManager().
-			startSimulation(simInfo.getAuthoritativeVCSimulationIdentifier(), numSimulationScanJobs);
+			startSimulation(simInfo.getAuthoritativeVCSimulationIdentifier());
 }		
 
 
Index: src/cbit/vcell/client/ClientSimManager.java
===================================================================
--- src/cbit/vcell/client/ClientSimManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/ClientSimManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -57,7 +57,6 @@
 import cbit.vcell.export.server.ExportServiceImpl;
 import cbit.vcell.field.FieldDataIdentifierSpec;
 import cbit.vcell.mapping.SimulationContext;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.math.AnnotatedFunction;
 import cbit.vcell.resource.ResourceUtil;
 import cbit.vcell.simdata.DataSetControllerImpl;
@@ -465,11 +464,11 @@
 			File smoldynExe = ResourceUtil.SolverExecutable.Smoldyn.getExecutable();
 	
 			Simulation simulation = new TempSimulation(originalSimulation, false);
-			SimulationTask simTask = new SimulationTask(new SimulationJob(simulation, 0, null),0);
-			File inputFile = new File(ResourceUtil.getLocalSimDir(), simTask.getSimulationJobID() + SimDataConstants.SMOLDYN_INPUT_FILE_EXTENSION);
+			SimulationJob simJob = new SimulationJob(simulation, 0, null);
+			File inputFile = new File(ResourceUtil.getLocalSimDir(), simJob.getSimulationJobID() + SimDataConstants.SMOLDYN_INPUT_FILE_EXTENSION);
 			inputFile.deleteOnExit();
 			PrintWriter pw = new PrintWriter(inputFile);
-			SmoldynFileWriter smf = new SmoldynFileWriter(pw, true, new File(ResourceUtil.getLocalSimDir(), simTask.getSimulationJobID()).getAbsolutePath(), simTask, false);
+			SmoldynFileWriter smf = new SmoldynFileWriter(pw, true, new File(ResourceUtil.getLocalSimDir(), simJob.getSimulationJobID()).getAbsolutePath(), simJob, false);
 			smf.write();
 			pw.close();	
 			String[] cmd = new String[] {smoldynExe.getAbsolutePath(), inputFile.getAbsolutePath()};
@@ -569,8 +568,8 @@
 						
 			Simulation simulation = new TempSimulation(originalSimulation, false);
 			StdoutSessionLog log = new StdoutSessionLog("Quick run");
-			SimulationTask simTask = new SimulationTask(new SimulationJob(simulation, 0, null),0);
-			Solver solver = createQuickRunSolver(log, localSimDataDir, simTask);
+			SimulationJob simJob = new SimulationJob(simulation, 0, null);
+			Solver solver = createQuickRunSolver(log, localSimDataDir, simJob);
 			if (solver == null) {
 				throw new RuntimeException("null solver");
 			}
@@ -652,8 +651,8 @@
 }
 
 
-private Solver createQuickRunSolver(StdoutSessionLog sessionLog, File directory, SimulationTask simTask) throws SolverException, IOException {
-	SolverDescription solverDescription = simTask.getSimulation().getSolverTaskDescription().getSolverDescription();
+private Solver createQuickRunSolver(StdoutSessionLog sessionLog, File directory, SimulationJob simJob) throws SolverException, IOException {
+	SolverDescription solverDescription = simJob.getSimulation().getSolverTaskDescription().getSolverDescription();
 	if (solverDescription == null) {
 		throw new IllegalArgumentException("SolverDescription cannot be null");
 	}
@@ -665,7 +664,7 @@
 	
 	ResourceUtil.prepareSolverExecutable(solverDescription);	
 	// create solver from SolverFactory
-	Solver solver = SolverFactory.createSolver(sessionLog, directory, simTask, false);
+	Solver solver = SolverFactory.createSolver(sessionLog, directory, simJob, false);
 
 	return solver;
 }
Index: src/cbit/vcell/client/task/RunSims.java
===================================================================
--- src/cbit/vcell/client/task/RunSims.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/task/RunSims.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -258,7 +258,7 @@
 					//
 					// translate to common ancestral simulation (oldest mathematically equivalent simulation)
 					//
-					jobManager.startSimulation(simInfo.getAuthoritativeVCSimulationIdentifier(),sim.getScanCount());
+					jobManager.startSimulation(simInfo.getAuthoritativeVCSimulationIdentifier());
 					// updateStatus
 					clientSimManager.updateStatusFromStartRequest(sim, false, null);
 				} else {
Index: src/cbit/vcell/client/RequestManager.java
===================================================================
--- src/cbit/vcell/client/RequestManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/RequestManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -253,7 +253,7 @@
  * @param documentWindowManager cbit.vcell.client.DocumentWindowManager
  * @param simulation cbit.vcell.solver.Simulation
  */
-void runSimulation(SimulationInfo simInfo, int numSimulationScanJobs) throws DataAccessException;
+void runSimulation(SimulationInfo simInfo) throws DataAccessException;
 
 
 /**
Index: src/cbit/vcell/client/server/ClientJobManager.java
===================================================================
--- src/cbit/vcell/client/server/ClientJobManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/server/ClientJobManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -143,7 +143,7 @@
 public void simulationJobStatusChanged(cbit.rmi.event.SimulationJobStatusEvent simJobStatusEvent) {
 	try {
 		getClientServerManager().getDocumentManager().updateServerSimulationStatusFromJobEvent(simJobStatusEvent);
-		fireSimStatusEvent(new SimStatusEvent(this, simJobStatusEvent.getVCSimulationIdentifier(), simJobStatusEvent.getTimepoint() != null, simJobStatusEvent.getJobStatus().getSchedulerStatus().isFailed(), simJobStatusEvent.getJobStatus().getJobIndex()));
+		fireSimStatusEvent(new SimStatusEvent(this, simJobStatusEvent.getVCSimulationIdentifier(), simJobStatusEvent.getTimepoint() != null, simJobStatusEvent.getJobStatus().isFailed(), simJobStatusEvent.getJobStatus().getJobIndex()));
 	} catch (Exception e) {
 		e.printStackTrace();
 	}
@@ -174,14 +174,14 @@
  * Insert the method's description here.
  * Creation date: (6/4/2004 3:22:42 PM)
  */
-public void startSimulation(VCSimulationIdentifier vcSimulationIdentifier, int numSimulationScanJobs) throws DataAccessException {
+public void startSimulation(VCSimulationIdentifier vcSimulationIdentifier) throws DataAccessException {
 	try {
-		getClientServerManager().getSimulationController().startSimulation(vcSimulationIdentifier, numSimulationScanJobs);
+		getClientServerManager().getSimulationController().startSimulation(vcSimulationIdentifier);
 	} catch (RemoteException rexc) {
 		handleRemoteException(rexc);
 		// once more before we fail
 		try {
-			getClientServerManager().getSimulationController().startSimulation(vcSimulationIdentifier, numSimulationScanJobs);
+			getClientServerManager().getSimulationController().startSimulation(vcSimulationIdentifier);
 		} catch (RemoteException rexc2) {
 			handleRemoteException(rexc2);
 			throw new DataAccessException("Start simulation '"+vcSimulationIdentifier+"' failed\n"+rexc2.getMessage());
Index: src/cbit/vcell/client/server/JobManager.java
===================================================================
--- src/cbit/vcell/client/server/JobManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/server/JobManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -48,7 +48,7 @@
  * This method was created by a SmartGuide.
  * @exception java.rmi.RemoteException The exception description.
  */
-void startSimulation(VCSimulationIdentifier vcSimulationIdentifier, int numSimulationScanJobs) throws DataAccessException;
+void startSimulation(VCSimulationIdentifier vcSimulationIdentifier) throws DataAccessException;
 
 
 /**
Index: src/cbit/vcell/client/server/AsynchMessageManager.java
===================================================================
--- src/cbit/vcell/client/server/AsynchMessageManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/server/AsynchMessageManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -14,6 +14,7 @@
 import javax.swing.SwingUtilities;
 import javax.swing.event.EventListenerList;
 
+import org.vcell.util.MessageConstants;
 
 import cbit.rmi.event.DataJobEvent;
 import cbit.rmi.event.DataJobListener;
@@ -30,7 +31,6 @@
 import cbit.vcell.client.SimStatusEvent;
 import cbit.vcell.client.SimStatusListener;
 import cbit.vcell.client.TopLevelWindowManager;
-import cbit.vcell.message.messages.MessageConstants;
 import cbit.vcell.server.VCellConnection;
 
 /**
Index: src/cbit/vcell/client/desktop/simulation/SimulationStatusDetailsTableModel.java
===================================================================
--- src/cbit/vcell/client/desktop/simulation/SimulationStatusDetailsTableModel.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/desktop/simulation/SimulationStatusDetailsTableModel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -25,10 +25,8 @@
 	private final static int COLUMN_SUBMITDATE = 4;
 	private final static int COLUMN_STARTDATE = 5;
 	private final static int COLUMN_ENDDATE = 6;
-	private final static int COLUMN_HTCID = 7;
-	private final static int COLUMN_TASKID = 8;
 	
-	private String[] columnNames = new String[] {"Scan Index", "Status", "Compute Host", "Software Version", "Submit Date", "Start Date", "End Date", "HTC ID", "Task ID"};
+	private String[] columnNames = new String[] {"Scan Index", "Status", "Compute Host", "Software Version", "Submit Date", "Start Date", "End Date"};
 	protected transient java.beans.PropertyChangeSupport propertyChange;
 	private SimulationStatusDetails fieldSimulationStatusDetails = null;
 
@@ -172,18 +170,6 @@
 				}
 				return jobStatus.getEndDate();
 			}
-			case COLUMN_HTCID : {
-				if (jobStatus == null || jobStatus.getSimulationExecutionStatus()==null || jobStatus.getSimulationExecutionStatus().getHtcJobID()==null) {
-					return null;
-				}
-				return jobStatus.getSimulationExecutionStatus().getHtcJobID().toDatabase();
-			}
-			case COLUMN_TASKID : {
-				if (jobStatus == null) {
-					return null;
-				}
-				return jobStatus.getTaskID();
-			}
 			default: {
 				if (jobStatus == null) {
 					return null;
Index: src/cbit/vcell/client/desktop/simulation/SimulationStatusDetails.java
===================================================================
--- src/cbit/vcell/client/desktop/simulation/SimulationStatusDetails.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/desktop/simulation/SimulationStatusDetails.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -70,7 +70,7 @@
 		SimulationJobStatus jobStatus = simStatus.getJobStatus(index);
 		Double progress = simStatus.getProgressAt(index);
 		if (jobStatus != null) {
-			if (progress != null && jobStatus.getSchedulerStatus().isRunning() && progress.doubleValue() > 0 ) {
+			if (progress != null && jobStatus.isRunning() && progress.doubleValue() > 0 ) {
 				statusBars[index].setValue((int)(progress.doubleValue() * 100));
 				return statusBars[index];
 			} else {
Index: src/cbit/vcell/client/desktop/DatabaseSearchPanel.java
===================================================================
--- src/cbit/vcell/client/desktop/DatabaseSearchPanel.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/desktop/DatabaseSearchPanel.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -37,7 +37,7 @@
 import com.ibm.icu.util.StringTokenizer;
 
 import cbit.gui.TextFieldAutoCompletion;
-import cbit.vcell.message.server.console.DatePanel;
+import cbit.vcell.messaging.admin.DatePanel;
 
 @SuppressWarnings("serial")
 public class DatabaseSearchPanel extends CollapsiblePanel {
Index: src/cbit/vcell/client/test/VCellClientTest.java
===================================================================
--- src/cbit/vcell/client/test/VCellClientTest.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/test/VCellClientTest.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -100,18 +100,8 @@
 		csInfo = ClientServerInfo.createRemoteServerInfo(hosts, user,(password==null || password.length()==0?null:new UserLoginInfo.DigestedPassword(password)));
 	}
 	try {
-		String propertyFile = PropertyLoader.getProperty(PropertyLoader.propertyFileProperty, "");
-		if (propertyFile.length()>0){
-			try {
-				PropertyLoader.loadProperties();
-				VCMongoMessage.enabled = true;
-				VCMongoMessage.serviceStartup(ServiceName.client,null,null);
-			}catch (Exception e){
-				System.out.println("failed to start Mongo logging");
-			}
-		}else{
-			VCMongoMessage.enabled = false;
-		}
+		VCMongoMessage.enabled = false; // comment out to enable logging to MongoDB.
+		VCMongoMessage.serviceStartup(ServiceName.client,null,null);
 		vcellClient = VCellClient.startClient(initialDocument, csInfo);
 	} catch (Throwable exception) {
 		System.err.println("Exception occurred in main() of VCellApplication");
Index: src/cbit/vcell/client/TestingFrameworkWindowManager.java
===================================================================
--- src/cbit/vcell/client/TestingFrameworkWindowManager.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/TestingFrameworkWindowManager.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -2842,7 +2842,7 @@
 			pp.setProgress((int)(1+(((double)i/(double)tcrits.length)*100)));
 			pp.setMessage("Trying to run sim "+tcrits[i].getSimInfo().getName());
 			updateTCritStatus(tcrits[i],TestCriteriaNew.TCRIT_STATUS_SIMRUNNING,null);
-			getRequestManager().runSimulation(tcrits[i].getSimInfo(),tcrits[i].getScanCount());
+			getRequestManager().runSimulation(tcrits[i].getSimInfo());
 		}catch(Throwable e){
 			e.printStackTrace();
 			errors.append("Failed to start sim "+tcrits[i].getSimInfo().getVersion().getName()+" "+e.getClass().getName()+" mesg="+e.getMessage()+"\n");
Index: src/cbit/vcell/client/LocalDataSetControllerProvider.java
===================================================================
--- src/cbit/vcell/client/LocalDataSetControllerProvider.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/vcell/client/LocalDataSetControllerProvider.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -10,6 +10,8 @@
 
 package cbit.vcell.client;
 
+import java.rmi.RemoteException;
+
 import org.vcell.util.DataAccessException;
 import org.vcell.util.SessionLog;
 import org.vcell.util.document.TimeSeriesJobResults;
@@ -51,54 +53,54 @@
 			this.dataServerImpl = new DataServerImpl(log, dsci, esi);
 		}
 
-		public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws DataAccessException {
+		public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws RemoteException, DataAccessException {
 			return dataServerImpl.fieldDataFileOperation(user,fieldDataFileOperationSpec);
 		}
 
-		public DataIdentifier[] getDataIdentifiers(OutputContext outputContext,	VCDataIdentifier vcdataID) throws DataAccessException {
+		public DataIdentifier[] getDataIdentifiers(OutputContext outputContext,	VCDataIdentifier vcdataID) throws RemoteException, DataAccessException {
 			return dataServerImpl.getDataIdentifiers(outputContext, user, vcdataID);
 		}
 
-		public double[] getDataSetTimes(VCDataIdentifier vcdataID) throws DataAccessException {
+		public double[] getDataSetTimes(VCDataIdentifier vcdataID) throws RemoteException, DataAccessException {
 			return dataServerImpl.getDataSetTimes(user, vcdataID);
 		}
 
-		public AnnotatedFunction[] getFunctions(OutputContext outputContext, VCDataIdentifier vcdataID) throws DataAccessException {
+		public AnnotatedFunction[] getFunctions(OutputContext outputContext, VCDataIdentifier vcdataID) throws DataAccessException,	RemoteException {
 			return dataServerImpl.getFunctions(outputContext,user, vcdataID);
 		}
 
-		public PlotData getLineScan(OutputContext outputContext, VCDataIdentifier vcdataID, String varName, double time, SpatialSelection spatialSelection) throws DataAccessException {
+		public PlotData getLineScan(OutputContext outputContext, VCDataIdentifier vcdataID, String varName, double time, SpatialSelection spatialSelection) throws RemoteException, DataAccessException {
 			return dataServerImpl.getLineScan(outputContext, user, vcdataID, varName, time, spatialSelection);
 		}
 
-		public CartesianMesh getMesh(VCDataIdentifier vcdataID) throws DataAccessException {
+		public CartesianMesh getMesh(VCDataIdentifier vcdataID) throws RemoteException, DataAccessException {
 			return dataServerImpl.getMesh(user, vcdataID);
 		}
 
-		public ODESimData getODEData(VCDataIdentifier vcdataID)	throws DataAccessException {
+		public ODESimData getODEData(VCDataIdentifier vcdataID)	throws DataAccessException, RemoteException {
 			return dataServerImpl.getODEData(user, vcdataID);
 		}
 
-		public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdataID, double time) throws DataAccessException {
+		public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdataID, double time) throws DataAccessException, RemoteException {
 			return dataServerImpl.getParticleDataBlock(user, vcdataID, time);
 		}
 
-		public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdataID) throws DataAccessException {
+		public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdataID) throws DataAccessException, RemoteException {
 			return dataServerImpl.getDataProcessingOutput(user, vcdataID);		}
 
-		public boolean getParticleDataExists(VCDataIdentifier vcdataID) throws DataAccessException {
+		public boolean getParticleDataExists(VCDataIdentifier vcdataID) throws DataAccessException, RemoteException {
 			return dataServerImpl.getParticleDataExists(user, vcdataID);
 		}
 
-		public SimDataBlock getSimDataBlock(OutputContext outputContext, VCDataIdentifier vcdataID, String varName, double time) throws DataAccessException { 		
+		public SimDataBlock getSimDataBlock(OutputContext outputContext, VCDataIdentifier vcdataID, String varName, double time) throws RemoteException, DataAccessException { 		
 			return dataServerImpl.getSimDataBlock(outputContext, user, vcdataID, varName, time);		
 		}
 
-		public TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext, VCDataIdentifier vcdataID, TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {
+		public TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext, VCDataIdentifier vcdataID, TimeSeriesJobSpec timeSeriesJobSpec) throws RemoteException, DataAccessException {
 			return dataServerImpl.getTimeSeriesValues(outputContext, user, vcdataID, timeSeriesJobSpec);
 		}
 
-		public ExportEvent makeRemoteFile(OutputContext outputContext, ExportSpecs exportSpecs) throws DataAccessException {
+		public ExportEvent makeRemoteFile(OutputContext outputContext, ExportSpecs exportSpecs) throws DataAccessException, RemoteException {
 			return dataServerImpl.makeRemoteFile(outputContext,user, exportSpecs);
 		}
 	}
Index: src/cbit/rmi/event/DataJobEvent.java
===================================================================
--- src/cbit/rmi/event/DataJobEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/rmi/event/DataJobEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -76,7 +76,6 @@
 	return timeSeriesJobResults;
 }
 
-@Override
 public boolean isSupercededBy(MessageEvent messageEvent) {
 	if (messageEvent instanceof DataJobEvent){
 		DataJobEvent dataJobEvent = (DataJobEvent)messageEvent;
Index: src/cbit/rmi/event/PerformanceMonitorEvent.java
===================================================================
--- src/cbit/rmi/event/PerformanceMonitorEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/rmi/event/PerformanceMonitorEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -82,7 +82,7 @@
 	return user;
 }
 
-@Override
+
 public boolean isSupercededBy(MessageEvent messageEvent) {
 	return false;
 }
Index: src/cbit/rmi/event/WorkerEvent.java
===================================================================
--- src/cbit/rmi/event/WorkerEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/rmi/event/WorkerEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -9,10 +9,8 @@
  */
 
 package cbit.rmi.event;
-
 import org.vcell.util.document.User;
 
-import cbit.vcell.message.server.htc.HtcJobID;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.Simulation;
 import cbit.vcell.solver.SimulationJob;
@@ -27,14 +25,6 @@
  */
 public class WorkerEvent extends MessageEvent {
 	
-	public static final int JOB_ACCEPTED = 998;
-	public static final int JOB_STARTING = 999;
-	public static final int JOB_DATA = 1000;
-	public static final int JOB_PROGRESS = 1001;
-	public static final int JOB_FAILURE = 1002;
-	public static final int JOB_COMPLETED = 1003;
-	public static final int JOB_WORKER_ALIVE = 1004;
-	public static final int JOB_WORKER_EXIT = 1015;
 
 	private VCSimulationIdentifier vcSimulationIdentifier = null;
 	private int jobIndex = -1;
@@ -44,7 +34,6 @@
 	private Double progress = null;
 	private Double timePoint = null;
 	private SimulationMessage eventMessage = null;
-	private HtcJobID htcJobID = null;
 
 public WorkerEvent(int eventType0, Object source, VCSimulationIdentifier simId0, int jobIndex0, String hostName0, int taskID0, Double progress0, Double timePoint0, SimulationMessage arg_eventMessage) {
 	super(source, new MessageSource(source, Simulation.createSimulationID(simId0.getSimulationKey())), new MessageData(new Double[] {progress0, timePoint0}));
@@ -61,14 +50,14 @@
 	eventMessage = arg_eventMessage;
 }
 
-//public WorkerEvent(int eventType0, Object source, SimulationJob simJob, String hostName0, SimulationMessage message) {
-//	this(eventType0, source, simJob.getVCDataIdentifier().getVcSimID(), simJob.getJobIndex(), hostName0, 0, null, null, message);
-//}
-//
-//public WorkerEvent(int eventType0, Object source, SimulationJob simJob, String hostName0, Double progress0, Double timePoint0, SimulationMessage message) {
-//	this(eventType0, source, simJob.getVCDataIdentifier().getVcSimID(), simJob.getJobIndex(), hostName0, 0, progress0, timePoint0, message);
-//}
-//
+public WorkerEvent(int eventType0, Object source, SimulationJob simJob, String hostName0, SimulationMessage message) {
+	this(eventType0, source, simJob.getVCDataIdentifier().getVcSimID(), simJob.getJobIndex(), hostName0, 0, null, null, message);
+}
+
+public WorkerEvent(int eventType0, Object source, SimulationJob simJob, String hostName0, Double progress0, Double timePoint0, SimulationMessage message) {
+	this(eventType0, source, simJob.getVCDataIdentifier().getVcSimID(), simJob.getJobIndex(), hostName0, 0, progress0, timePoint0, message);
+}
+
 public WorkerEvent(int eventType0, Object source, SimulationTask simTask, String hostName0, Double progress0, Double timePoint0, SimulationMessage message) {
 	this(eventType0, source, simTask.getSimulationInfo().getAuthoritativeVCSimulationIdentifier(), simTask.getSimulationJob().getJobIndex(), hostName0, simTask.getTaskID(), progress0, timePoint0, message);
 }
@@ -147,9 +136,7 @@
 	return timePoint;
 }
 
-public HtcJobID getHtcJobID(){
-	return htcJobID;
-}
+
 /**
  * Insert the method's description here.
  * Creation date: (3/11/2004 9:33:30 AM)
@@ -205,7 +192,6 @@
  * Creation date: (3/11/2004 9:33:30 AM)
  * @return boolean
  */
-@Override
 public boolean isSupercededBy(MessageEvent messageEvent) {
 	if (messageEvent instanceof WorkerEvent){
 		WorkerEvent workerEvent = (WorkerEvent)messageEvent;
@@ -275,17 +261,4 @@
 public boolean isWorkerAliveEvent() {
 	return eventType == JOB_WORKER_ALIVE;
 }
-
-public boolean isWorkerExitEvent() {
-	return eventType == JOB_WORKER_EXIT;
 }
-
-public void setHtcJobID(HtcJobID htcJobID) {
-	this.htcJobID = htcJobID;
-}
-
-public String show(){
-	return "WorkerEvent(type="+eventType+",simID="+this.vcSimulationIdentifier+",job="+jobIndex+",task="+taskID+",progress="+progress+",timepoint="+timePoint+",msg="+eventMessage.toSerialization();
-}
-
-}
Index: src/cbit/rmi/event/ExportEvent.java
===================================================================
--- src/cbit/rmi/event/ExportEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/rmi/event/ExportEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -109,7 +109,7 @@
 }
 
 
-@Override
+
 public boolean isSupercededBy(MessageEvent messageEvent) {
 	if (messageEvent instanceof ExportEvent){
 		ExportEvent exportEvent = (ExportEvent)messageEvent;
Index: src/cbit/rmi/event/SimulationJobStatusEvent.java
===================================================================
--- src/cbit/rmi/event/SimulationJobStatusEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/rmi/event/SimulationJobStatusEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -99,8 +99,6 @@
 
 	return jobStatus.getVCSimulationIdentifier();
 }
-
-@Override
 public boolean isSupercededBy(MessageEvent messageEvent) {
 	if (messageEvent instanceof SimulationJobStatusEvent){
 		SimulationJobStatusEvent simulationJobStatusEvent = (SimulationJobStatusEvent)messageEvent;
@@ -109,7 +107,7 @@
 		if (jobStatus != null && jobStatus2 != null 
 				&& jobStatus.getVCSimulationIdentifier().equals(jobStatus2.getVCSimulationIdentifier()) 
 				&& jobStatus.getJobIndex() == jobStatus2.getJobIndex()) {
-			if (jobStatus.getSchedulerStatus().isRunning() && getProgress() != null && jobStatus2.getSchedulerStatus().isRunning() && simulationJobStatusEvent.getProgress() !=null){
+			if (jobStatus.isRunning() && getProgress() != null && jobStatus2.isRunning() && simulationJobStatusEvent.getProgress() !=null){
 				if (getProgress()<simulationJobStatusEvent.getProgress()){
 					return true;
 				}
Index: src/cbit/rmi/event/MessageEvent.java
===================================================================
--- src/cbit/rmi/event/MessageEvent.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/cbit/rmi/event/MessageEvent.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -19,7 +19,15 @@
 public abstract class MessageEvent extends java.util.EventObject {
 	private MessageSource messageSource = null;
 	private MessageData messageData = null;
-		
+	
+	public static final int JOB_ACCEPTED = 998;
+	public static final int JOB_STARTING = 999;
+	public static final int JOB_DATA = 1000;
+	public static final int JOB_PROGRESS = 1001;
+	public static final int JOB_FAILURE = 1002;
+	public static final int JOB_COMPLETED = 1003;
+	public static final int JOB_WORKER_ALIVE = 1004;
+	
 	public final static int EXPORT_PROGRESS = 1004;
 	public final static int EXPORT_FAILURE = 1005;
 	public final static int EXPORT_COMPLETE = 1006;
Index: src/cbit/htc/HTCUtils.java
===================================================================
--- src/cbit/htc/HTCUtils.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/htc/HTCUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.htc;
+
+import java.io.File;
+import java.util.StringTokenizer;
+
+import org.vcell.util.PropertyLoader;
+
+
+public class HTCUtils {
+
+	/**
+	 * Insert the method's description here.
+	 * Creation date: (2/8/2007 8:40:06 AM)
+	 * @return java.io.File
+	 */
+	public static java.io.File getJobSubmitTemplate(String computeResource) {
+		File submitTemplate = null;
+		String templates = PropertyLoader.getRequiredProperty(PropertyLoader.htcSubmitTemplates);
+		StringTokenizer st = new StringTokenizer(templates, " ,");
+		while (st.hasMoreTokens()) {
+			String token = st.nextToken();
+			if (computeResource == null || token.startsWith(computeResource)) {
+				StringTokenizer st1 = new StringTokenizer(token, "@");
+				token = st1.nextToken();
+				token = st1.nextToken();
+				submitTemplate = new java.io.File(token);
+				break;
+			}
+		}
+		if (submitTemplate == null || !submitTemplate.exists()) {
+			throw new RuntimeException("HTC submit template file doesn't exist");
+		}
+		return submitTemplate;
+	}
+
+}
Index: src/cbit/htc/CondorConstants.java
===================================================================
--- src/cbit/htc/CondorConstants.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/htc/CondorConstants.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.htc;
+/**
+ * Insert the type's description here.
+ * Creation date: (9/29/2003 10:21:51 AM)
+ * @author: Fei Gao
+ */
+public interface CondorConstants {
+	public static final int CONDOR_STATUS_UNEXPANDED = 0; //Never been run
+	public static final int CONDOR_STATUS_IDLE = 1;
+	public static final int CONDOR_STATUS_RUNNING = 2;
+	public static final int CONDOR_STATUS_REMOVED = 3;
+	public static final int CONDOR_STATUS_COMPLETED = 4;  	
+	public static final int CONDOR_STATUS_ONHOLD = 5;  
+	public static final int CONDOR_STATUS_EXITED = 6;  
+	public static final int CONDOR_STATUS_UNKNOWN = -1;  
+
+	public static final String[] CONDOR_JOB_STATUS = {"U", "I", "R", "X", "C", "H", "EXITED"};
+	
+	public final static String JOB_CMD_SUBMIT = "condor_submit";
+	public final static String JOB_CMD_DELETE = "condor_rm";
+	public final static String JOB_CMD_STATUSDETAILS = "condor_q";
+	public final static String JOB_CMD_STATUS = "condor_q";
+	//public final static String JOB_CMD_RUNNINGDETAILS = "condor_status -run";
+	public final static String JOB_CMD_HISTORY = "condor_history";	
+}
Index: src/cbit/htc/PBSConstants.java
===================================================================
--- src/cbit/htc/PBSConstants.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/htc/PBSConstants.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.htc;
+
+
+public class PBSConstants {
+	static final int PBS_STATUS_UNKNOWN = -1; 			//Not a status in PBS. 
+	static final int PBS_STATUS_JOBARRAYSTARTED = 0; 	//Job arrays only: job array has started
+	static final int PBS_STATUS_EXITING = 1; 			// Job is exiting after having run
+	static final int PBS_STATUS_HELD = 2; 				// Job is held. A job is put into a held state by the server or by a user or
+																// administrator. A job stays in a held state until it is released by a user or
+																// administrator.
+	static final int PBS_STATUS_QUEUED = 3; 				//Job is queued, eligible to run or be routed
+	static final int PBS_STATUS_RUNNING = 4; 			//Job is running
+	static final int PBS_STATUS_SUSPENDEDBYSERVER = 5; 	//Job is suspended by server. A job is put into the suspended state when a
+																//higher priority job needs the resources.
+	static final int PBS_STATUS_TRANSITING = 6; 			//Job is in transition (being moved to a new location)
+	static final int PBS_STATUS_SUSPENDEDBYUSER = 7; 	//Job is suspended due to workstation becoming busy
+	static final int PBS_STATUS_WAITING = 8; 			//Job is waiting for its requested execution time to be reached or job specified
+																//a stage-in request which failed for some reason.
+	static final int PBS_STATUS_SUBJOBFINISHED = 9;		//Subjobs only; subjob is finished (expired.)
+	
+	static final String[] PBS_JOB_STATUS = {"B", "E", "H", "Q", "R", "S", "T", "U", "W", "X"};
+
+	/*
+	The exit value of a job may fall in one of three ranges: X < 0, 0 <=X < 128, X >=128.
+	
+	X < 0:
+	This is a PBS special return value indicating that the job could not be executed. These
+	negative values are listed in the table below.
+	
+	0 <= X < 128 (or 256):
+	This is the exit value of the top process in the job, typically the shell. This may be the exit
+	value of the last command executed in the shell or the .logout script if the user has such a
+	script (csh).
+	
+	X >= 128 (or 256 depending on the system)
+	This means the job was killed with a signal. The signal is given by X modulo 128 (or
+	256). For example an exit value of 137 means the job's top process was killed with signal
+	9 (137 % 128 = 9).
+	 */
+	static final int JOB_EXEC_OK = 0; 					//	job exec successful
+	static final int JOB_EXEC_FAIL1 =  -1; 				//	"Job exec failed, before files, no retry"
+	static final int JOB_EXEC_FAIL2 =  -2; 				//	"Job exec failed, after files, no retry"
+	static final int JOB_EXEC_RETRY =  -3; 				//	"Job execution failed, do retry"
+	static final int JOB_EXEC_INITABT =  -4; 			//	Job aborted on MOM initialization
+	static final int JOB_EXEC_INITRST =  -5; 			//	"Job aborted on MOM init, chkpt, no migrate"
+	static final int JOB_EXEC_INITRMG =  -6; 			//	"Job aborted on MOM init, chkpt, ok migrate"
+	static final int JOB_EXEC_BADRESRT =  -7; 			//	Job restart failed
+	static final int JOB_EXEC_GLOBUS_INIT_RETRY  =  -8; 	//	Init. globus job failed. do retry
+	static final int JOB_EXEC_GLOBUS_INIT_FAIL =  -9; 	//	Init. globus job failed. no retry
+	static final int JOB_EXEC_FAILUID =  -10; 			//	invalid uid/gid for job
+	static final int JOB_EXEC_RERUN =  -11; 				//	Job rerun
+	static final int JOB_EXEC_CHKP  =  -12; 				//	Job was checkpointed and killed
+	static final int JOB_EXEC_FAIL_PASSWORD = -13;		// Job failed due to a bad password
+	
+	static final String[] PBS_JOB_EXEC_STATUS = {
+		"job exec successful",
+		"Job exec failed, before files, no retry",
+		"Job exec failed, after files, no retry",
+		"Job execution failed, do retry",
+		"Job aborted on MOM initialization",
+		"Job aborted on MOM init, chkpt, no migrate",
+		"Job aborted on MOM init, chkpt, ok migrate",
+		"Job restart failed",
+		"Init. globus job failed. do retry",
+		"Init. globus job failed. no retry",
+		"invalid uid/gid for job",
+		"Job rerun",
+		"Job was checkpointed and killed",
+		"Job failed due to a bad password"
+	};
+	
+
+	static final int PBS_SIMULATION_JOB = 1;
+	static final int PBS_SERVICE_JOB = 2;
+	
+	static final String PBS_JOB_TEMPLATE = 
+		    "#PBS -m a\r\n"
+			+"#PBS -M schaff@neuron.uchc.edu\r\n"
+			+"#PBS -j oe\r\n"
+			+"#PBS -k oe\r\n"
+			+"#PBS -r n\r\n"
+			+"#PBS -l nice=10\r\n"
+			+"\r\n"
+			+"export PATH=/cm/shared/apps/torque/2.5.5/bin/:$PATH\r\n"
+			+"export LD_LIBRARY_PATH=/share/apps/sonic/mq8.5.1:$LD_LIBRARY_PATH\r\n";
+	
+	final static String JOB_CMD_SUBMIT = "qsub";
+	final static String JOB_CMD_DELETE = "qdel";
+	final static String JOB_CMD_STATUS = "qstat";	
+	final static String JOB_CMD_HISTORY = "tracejob";
+	final static String SERVER_CMD_STATUS = "qstat";
+	final static int PBS_MEM_OVERHEAD_MB = 70;	
+}
Index: src/cbit/htc/CondorUtils.java
===================================================================
--- src/cbit/htc/CondorUtils.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/htc/CondorUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.htc;
+import static cbit.htc.CondorConstants.*;
+
+import org.vcell.util.Executable;
+/**
+ * Insert the type's description here.
+ * Creation date: (9/25/2003 9:59:32 AM)
+ * @author: Fei Gao
+ */
+public class CondorUtils {
+	private static org.vcell.util.SessionLog condorLog = new org.vcell.util.StdoutSessionLog("Condor-Command");
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:34:36 AM)
+ * @return int
+ * @param jobid java.lang.String
+ */
+public static int getJobStatus(String jobid) {		
+	int iStatus = CONDOR_STATUS_UNKNOWN;
+	org.vcell.util.Executable exe = null;
+	String line = null;
+	
+	try {
+		String[] cmd = new String[]{JOB_CMD_STATUS, jobid};
+		exe = new org.vcell.util.Executable(cmd);
+		exe.start();
+		
+		String output = exe.getStdoutString();
+		java.util.StringTokenizer st = new java.util.StringTokenizer(output, "\n");
+		while (st.hasMoreTokens()) {
+			line = st.nextToken().trim();		
+			if (line.startsWith(jobid)) {	
+				java.util.StringTokenizer st1 = new java.util.StringTokenizer(line, " ");
+				String status = st1.nextToken();
+				status = st1.nextToken();
+				status = st1.nextToken();
+				status = st1.nextToken();
+				status = st1.nextToken();
+				status = st1.nextToken();
+				
+				for (iStatus = 0; iStatus < CONDOR_JOB_STATUS.length; iStatus ++) {
+					if (status.equals(CONDOR_JOB_STATUS[iStatus])) {
+						return iStatus;
+					}
+				}
+				break;
+			}	
+		}		
+		
+	} catch (org.vcell.util.ExecutableException ex) {
+	}
+
+	int exitCode = 0;
+	
+	if (iStatus == CONDOR_STATUS_UNKNOWN) {
+		String[] cmd = new String[]{JOB_CMD_HISTORY, "-l", jobid};
+		try {		
+			exe = new org.vcell.util.Executable(cmd);
+			exe.start();
+
+			String output = exe.getStdoutString();
+			java.util.StringTokenizer st = new java.util.StringTokenizer(output, "\n");
+			while (st.hasMoreTokens()) {
+				line = st.nextToken().trim();
+				if (line.startsWith("ExitCode")) {
+					java.util.StringTokenizer st1 = new java.util.StringTokenizer(line, " ");
+					String status = st1.nextToken();
+					status = st1.nextToken();
+					status = st1.nextToken();
+					exitCode = Integer.parseInt(status);					
+				} else 	if (line.startsWith("JobStatus")) {	
+					java.util.StringTokenizer  st2 = new java.util.StringTokenizer(line, " ");
+					String status = st2.nextToken();
+					status = st2.nextToken();
+					status = st2.nextToken();
+					iStatus = Integer.parseInt(status);
+				} 
+			}		
+		} catch (org.vcell.util.ExecutableException ex0) {
+			condorLog.exception(ex0);
+			return CONDOR_STATUS_UNKNOWN;
+		}
+	}
+
+	if (iStatus == CONDOR_STATUS_COMPLETED && exitCode != 0) {
+		return CONDOR_STATUS_EXITED;
+	}					
+
+	return iStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:34:36 AM)
+ * @return int
+ * @param jobid java.lang.String
+ */
+public static String getPendingReason(String jobid) {
+	org.vcell.util.Executable exe = null;
+	String reason = "";
+	
+	try {
+		String[] cmd = new String[]{JOB_CMD_STATUSDETAILS, "-analyze", jobid};
+		exe = new Executable(cmd);
+		exe.start();
+		
+		String output = exe.getStdoutString();
+		int index = output.indexOf(jobid);
+		if (index >= 0) {
+			reason = output.substring(index);
+			return reason;
+		}		
+		
+	} catch (org.vcell.util.ExecutableException ex) {
+		condorLog.exception(ex);
+	}
+
+	return reason;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:35:12 AM)
+ * @param jobid java.lang.String
+ */
+public static void killJob(String jobid) {
+	if (jobid == null) {
+		return;
+	}
+		
+	try {
+		String[] cmd = new String[]{JOB_CMD_DELETE, jobid};
+		Executable exe = new Executable(cmd);
+		exe.start();
+	} catch (org.vcell.util.ExecutableException ex) {
+		condorLog.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/26/2003 3:06:31 PM)
+ * @param args java.lang.String[]
+ */
+public static void main(String[] args) {		
+	
+	try {
+		int status = CondorUtils.getJobStatus("15");
+		System.out.println("status=" + CONDOR_JOB_STATUS[status]);
+		status = CondorUtils.getJobStatus("89");
+		System.out.println("status=" + CONDOR_JOB_STATUS[status]);
+		status = CondorUtils.getJobStatus("91");
+		System.out.println("status=" + CONDOR_JOB_STATUS[status]);
+
+		//CondorUtils.killJob(jobid);		
+	} catch (Exception ex) {
+		ex.printStackTrace();
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/25/2003 8:04:51 AM)
+ * @param command java.lang.String
+ */
+public static String submitJob(String computeResource, String sub_file, String executable, String cmdArguments) throws org.vcell.util.ExecutableException {		
+
+	try {	
+		java.io.BufferedReader br = new java.io.BufferedReader(new java.io.FileReader(HTCUtils.getJobSubmitTemplate(computeResource)));
+		java.io.PrintWriter pw = new java.io.PrintWriter(new java.io.FileOutputStream(sub_file));
+		pw.println();
+		pw.println("executable = " + executable);
+		pw.println("arguments = " + cmdArguments);
+		pw.println();
+		pw.println("#log = " + executable + ".condor.log");
+		pw.println("#input = " + executable + ".in");
+		pw.println("#output = " + executable + ".out");
+		pw.println("#error = " + executable + ".err");
+		while (true) {
+			String line = br.readLine();
+			if (line == null) {
+				break;
+			}
+			pw.println(line);
+		}
+		pw.close();
+		br.close();
+	} catch (java.io.IOException ex) {
+		ex.printStackTrace(System.out);
+		return null;
+	}
+	
+	String[] completeCommand =  new String[] {JOB_CMD_SUBMIT, sub_file};
+	String jobid = null;
+	org.vcell.util.Executable exe = new Executable(completeCommand);
+	exe.start();
+	String output = exe.getStdoutString();
+	String typicalWords = "submitted to cluster";
+	int index1  = output.indexOf (typicalWords);
+	if (index1 > 0) { // success submission
+		jobid = output.substring(index1 + typicalWords.length()).trim();
+		int index2 = jobid.lastIndexOf('.');
+		jobid = jobid.substring(0, index2) ;
+	}
+	return jobid;
+}
+}
Index: src/cbit/htc/PBSUtils.java
===================================================================
--- src/cbit/htc/PBSUtils.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/htc/PBSUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.htc;
+
+import static cbit.htc.PBSConstants.JOB_CMD_DELETE;
+import static cbit.htc.PBSConstants.JOB_CMD_HISTORY;
+import static cbit.htc.PBSConstants.JOB_CMD_STATUS;
+import static cbit.htc.PBSConstants.JOB_CMD_SUBMIT;
+import static cbit.htc.PBSConstants.JOB_EXEC_OK;
+import static cbit.htc.PBSConstants.PBS_JOB_EXEC_STATUS;
+import static cbit.htc.PBSConstants.PBS_JOB_STATUS;
+import static cbit.htc.PBSConstants.PBS_MEM_OVERHEAD_MB;
+import static cbit.htc.PBSConstants.PBS_STATUS_EXITING;
+import static cbit.htc.PBSConstants.PBS_STATUS_RUNNING;
+import static cbit.htc.PBSConstants.PBS_STATUS_UNKNOWN;
+import static cbit.htc.PBSConstants.SERVER_CMD_STATUS;
+
+import java.io.BufferedReader;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.StringTokenizer;
+
+import org.vcell.util.Executable;
+import org.vcell.util.ExecutableException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.StdoutSessionLog;
+
+public class PBSUtils {
+	private static SessionLog pbsLog = new StdoutSessionLog("PBS-Command");
+	private static String pbsServer = null;	 
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:34:36 AM)
+ * @return int
+ * @param jobid java.lang.String
+ */
+public static String checkServerStatus() throws ExecutableException {
+	org.vcell.util.Executable exe = new Executable(new String[] {SERVER_CMD_STATUS, "-B"});
+	exe.start();
+	
+	String output = exe.getStdoutString();
+	/*
+	Server             Max   Tot   Que   Run   Hld   Wat   Trn   Ext Status
+	---------------- ----- ----- ----- ----- ----- ----- ----- ----- -----------
+	dll-2-1-1            0     0     0     0     0     0     0     0 Active
+	*/	
+	StringTokenizer st = new StringTokenizer(output, "\n");	
+	st.nextToken();
+	st.nextToken();
+	String line = st.nextToken();
+	st = new StringTokenizer(line, " ");
+	pbsServer = st.nextToken();			
+	
+	return pbsServer;
+}
+
+static int getJobExitCode(PbsJobID jobid) {
+	/*
+	Job: 67.dll-2-1-1
+
+	06/04/2007 10:04:37  S    Job Queued at request of fgao@bigfish.vcell.uchc.edu, owner =
+	                          fgao@bigfish.vcell.uchc.edu, job name = test3.sub, queue = workq
+	06/04/2007 10:04:37  S    Job Run at request of Scheduler@dll-2-1-1.vcell.uchc.edu on hosts
+	                          (dll-2-1-2:ncpus=1)
+	06/04/2007 10:04:37  L    Considering job to run
+	06/04/2007 10:04:37  A    queue=workq
+	06/04/2007 10:04:42  L    Job run
+	06/04/2007 10:04:42  A    user=fgao group="RConsole Users" jobname=test3.sub queue=workq ctime=1180965876
+	                          qtime=1180965877 etime=1180965877 start=1180965882 exec_host=dll-2-1-2/0
+	                          exec_vnode=(dll-2-1-2:ncpus=1) Resource_List.ncpus=1 Resource_List.nodect=1
+	                          Resource_List.place=pack Resource_List.select=1:ncpus=1 resource_assigned.ncpus=1
+	06/04/2007 10:04:42  S    Job Modified at request of Scheduler@dll-2-1-1.vcell.uchc.edu
+	06/04/2007 10:04:42  S    Obit received
+	06/04/2007 10:04:42  S    Exit_status=0 resources_used.cput=00:00:00 resources_used.walltime=00:00:00
+	06/04/2007 10:04:42  A    user=fgao group="RConsole Users" jobname=test3.sub queue=workq ctime=1180965876
+	                          qtime=1180965877 etime=1180965877 start=1180965882 exec_host=dll-2-1-2/0
+	                          exec_vnode=(dll-2-1-2:ncpus=1) Resource_List.ncpus=1 Resource_List.nodect=1
+	                          Resource_List.place=pack Resource_List.select=1:ncpus=1 session=6872
+	                          alt_id=HomeDirectory=Z: end=1180965882 Exit_status=0 resources_used.cput=00:00:00
+	                          resources_used.walltime=00:00:00
+	06/04/2007 10:04:44  S    Post job file processing error
+	 */
+	int iExitCode = JOB_EXEC_OK;
+	Executable exe = null;
+	
+	try {
+		String[] cmd = new String[] {JOB_CMD_HISTORY, "-p", PropertyLoader.getRequiredProperty(PropertyLoader.pbsHomeDir), jobid.getID()};
+		exe = new Executable(cmd);
+		exe.start();
+		
+		String output = exe.getStdoutString();
+		final String exitStatus = "Exit_status=";
+		int idx = output.indexOf(exitStatus);
+		if (idx < 0) {
+			throw new RuntimeException("Job [" + jobid + "] : unknown status"); 
+		}
+		output = output.substring(idx);
+		StringTokenizer st = new StringTokenizer(output, " =");
+		st.nextToken();
+		iExitCode = Integer.parseInt(st.nextToken()); 
+		return iExitCode;
+		
+	} catch (ExecutableException ex) {
+		throw new RuntimeException("No job history for job [" + jobid + "]");
+	}	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:34:36 AM)
+ * @return int
+ * @param jobid java.lang.String
+ */
+public static int getJobStatus(PbsJobID jobid) {		
+	int iStatus = PBS_STATUS_UNKNOWN;
+	Executable exe = null;
+	
+	try {
+		String[] cmd = new String[]{JOB_CMD_STATUS, "-s", jobid.getID()};
+		exe = new Executable(cmd);
+		exe.start();
+		
+		String output = exe.getStdoutString();
+		StringTokenizer st = new StringTokenizer(output, "\r\n"); 
+		String strStatus = "";
+		while (st.hasMoreTokens()) {
+			if (st.nextToken().toLowerCase().trim().startsWith("job id")) {
+				if (st.hasMoreTokens()) {
+					st.nextToken();
+				}
+				if (st.hasMoreTokens()) {
+					strStatus = st.nextToken();
+				}
+				break;
+			}			
+		}
+		if (strStatus.length() == 0) {
+			return iStatus;
+		}
+		/*
+		
+		pbssrv: 
+		                                                            Req'd  Req'd   Elap
+		Job ID          Username Queue    Jobname    SessID NDS TSK Memory Time  S Time
+		--------------- -------- -------- ---------- ------ --- --- ------ ----- - -----
+		29908.pbssrv    vcell    workqAlp S_32925452  30022   1   1  100mb   --  R 00:29
+		   Job run at Mon Apr 27 at 08:28 on (dll-2-6-6:ncpus=1:mem=102400kb)
+
+		*/		
+		st = new StringTokenizer(strStatus, " ");
+		String token = "";
+		for (int i = 0; i < 10 && st.hasMoreTokens(); i ++) {
+			token = st.nextToken();
+		}
+		for (iStatus = 0; iStatus < PBS_JOB_STATUS.length; iStatus ++) {
+			if (token.equals(PBS_JOB_STATUS[iStatus])) {
+				return iStatus;
+			}
+		}		
+	} catch (ExecutableException ex) {
+		return PBS_STATUS_EXITING;
+	}
+	return iStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:34:36 AM)
+ * @return int
+ * @param jobid java.lang.String
+ */
+public static String getPendingReason(PbsJobID jobid) {
+	String pendingReason = "unknown pending reason";
+	Executable exe = null;
+	
+	try {
+		String[] cmd = new String[]{JOB_CMD_STATUS, "-s", jobid.getID()};
+		exe = new Executable(cmd);
+		exe.start();
+		
+		/*
+		
+		pbssrv: 
+		                                                            Req'd  Req'd   Elap
+		Job ID          Username Queue    Jobname    SessID NDS TSK Memory Time  S Time
+		--------------- -------- -------- ---------- ------ --- --- ------ ----- - -----
+		29908.pbssrv    vcell    workqAlp S_32925452  30022   1   1  100mb   --  R 00:29
+		   Job run at Mon Apr 27 at 08:28 on (dll-2-6-6:ncpus=1:mem=102400kb)
+
+		*/		
+		String output = exe.getStdoutString();
+		StringTokenizer st = new StringTokenizer(output, "\r\n"); 
+		while (st.hasMoreTokens()) {
+			if (st.nextToken().toLowerCase().trim().startsWith("job id")) {
+				if (st.hasMoreTokens()) {
+					st.nextToken();
+				}
+				if (st.hasMoreTokens()) {
+					st.nextToken();
+				}
+				pendingReason = "";
+				while (st.hasMoreTokens()) {
+					pendingReason += st.nextToken();
+				}
+				break;
+			}			
+		}
+	} catch (ExecutableException ex) {
+		ex.printStackTrace(System.out);
+	}
+	return pendingReason;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/29/2003 10:35:12 AM)
+ * @param jobid java.lang.String
+ */
+public static void killJob(PbsJobID jobid) {
+	if (jobid == null) {
+		return;
+	}
+		
+	try {
+		String[] cmd = new String[]{JOB_CMD_DELETE, jobid.getID()};
+		Executable exe = new Executable(cmd);
+		exe.start();
+	} catch (ExecutableException ex) {
+		pbsLog.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/26/2003 3:06:31 PM)
+ * @param args java.lang.String[]
+ */
+public static void main(String[] args) {		
+	
+//	try {		
+//		PropertyLoader.loadProperties();
+//		
+//		PbsJobID jobid = new PbsJobID("29908"); //PBSUtils.submitJob(null, "D:\\PBSPro_Jobs\\test3.sub", "dir", "");
+//		int status = PBSUtils.getJobStatus(jobid);
+//		System.out.println("jobid=" + jobid);
+//		System.out.println("status=" + PBS_JOB_STATUS[status]);
+//		System.out.println("pendingreason=" + getPendingReason(jobid));
+//		int code = PBSUtils.getJobExitCode(jobid);
+//		System.out.println("exitcode=" + code + ":" + PBS_JOB_EXEC_STATUS[-code] + "]");
+//	} catch (Exception ex) {
+//		ex.printStackTrace();
+//	}
+	
+	
+//	try {
+//		PropertyLoader.loadProperties();
+//		submitServiceJob ("Resource", "T_Db1", "C:\\Users\\eboyce\\Desktop\\testTemplate.sub", "dir", "*.*", 5, 128);
+//	} catch (ExecutableException e) {
+//		// TODO Auto-generated catch block
+//		e.printStackTrace();
+//	} catch (IOException e) {
+//		// TODO Auto-generated catch block
+//		e.printStackTrace();
+//	}
+	
+	
+}
+
+
+
+
+
+public static PbsJobID submitJob(String computeResource, String jobName, String sub_file, String executable, String cmdArguments, int ncpus, double memSize) throws ExecutableException {
+	return submitJob(computeResource, jobName, sub_file, executable, cmdArguments, ncpus, memSize, PBSConstants.PBS_SIMULATION_JOB);
+}
+
+public static PbsJobID submitServiceJob(String computeResource, String jobName, String sub_file, String executable, String cmdArguments, int ncpus, double memSize) throws ExecutableException {
+	return submitJob(computeResource, jobName, sub_file, executable, cmdArguments, ncpus, memSize, PBSConstants.PBS_SERVICE_JOB);
+}
+
+private static PbsJobID submitJob(String computeResource, String jobName, String sub_file, String executable, String cmdArguments, int ncpus, double memSize, int jobCategory) throws ExecutableException {	
+	try {	
+		PrintWriter pw = new PrintWriter(new FileOutputStream(sub_file));
+		pw.println("# Generated without file template.");
+		pw.println("#PBS -N " + jobName);
+		pw.println("#PBS -l mem=" + (int)(memSize + PBS_MEM_OVERHEAD_MB) + "mb");
+		String pbsQueueNameString = "#PBS -q ";
+		String siteNameString = null;
+		String siteNAMEString = PropertyLoader.getRequiredProperty(PropertyLoader.vcellServerIDProperty).trim();
+		if (siteNAMEString.toUpperCase().equals("ALPHA")) {siteNameString = "Alpha";} 
+		else if  (siteNAMEString.toUpperCase().equals("BETA")) {siteNameString = "Beta";} 
+		else if  (siteNAMEString.toUpperCase().equals("REL")) {siteNameString = "Rel";} 
+		else if  (siteNAMEString.toUpperCase().equals("TEST")) {siteNameString = "Test";} 
+		else {
+			pw.close();
+			throw new ExecutableException("Invalid Server Site ID String: \""+siteNAMEString+"\"");
+		}
+		
+		if (jobCategory==PBSConstants.PBS_SIMULATION_JOB) {
+			pbsQueueNameString = pbsQueueNameString+"workq"+siteNameString;
+		}
+		else if (jobCategory==PBSConstants.PBS_SERVICE_JOB) {
+			pbsQueueNameString = pbsQueueNameString+"serviceq"+siteNameString;
+		} else {
+			pw.close();
+			throw new ExecutableException("Invalid jobCategory: "+Integer.toString(jobCategory));
+		}
+		
+		pw.println(pbsQueueNameString);
+		pw.print(PBSConstants.PBS_JOB_TEMPLATE);
+		pw.println();
+		pw.println(executable + " " + cmdArguments);
+		pw.close();
+	} catch (IOException ex) {
+		ex.printStackTrace(System.out);
+		return null;
+	}
+	
+	String[] completeCommand = new String[] {JOB_CMD_SUBMIT, sub_file};
+	Executable exe = new Executable(completeCommand);
+	exe.start();
+	String jobid = exe.getStdoutString().trim();
+	return new PbsJobID(jobid);
+}
+
+public static boolean isJobExiting(int status) {
+	return status == PBS_STATUS_EXITING;
+}
+
+public static boolean isJobRunning(int status) {
+	return status == PBS_STATUS_RUNNING;
+}
+
+public static boolean isJobRunning(PbsJobID jobid) {
+	return isJobRunning(getJobStatus(jobid));
+}
+
+public static boolean isJobExecOK(PbsJobID jobid) {
+	return getJobExitCode(jobid) == JOB_EXEC_OK;
+}
+
+public static String getJobStatusDescription(int status) {
+	return PBSConstants.PBS_JOB_STATUS[status];
+}
+
+public static String getJobExecStatus(PbsJobID jobid) {
+	int exitCode = getJobExitCode(jobid);
+	if (exitCode <= 0) {
+		return PBS_JOB_EXEC_STATUS[-exitCode];
+	} else {
+		return "job was killed with system signal " + exitCode;
+	}	
+}
+}
Index: src/cbit/htc/PbsJobID.java
===================================================================
--- src/cbit/htc/PbsJobID.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/cbit/htc/PbsJobID.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,33 @@
+package cbit.htc;
+
+import java.io.Serializable;
+
+import org.vcell.util.Compare;
+import org.vcell.util.Matchable;
+
+public class PbsJobID implements Serializable, Matchable {
+	private String jobID;
+	
+	public PbsJobID(String jobID){
+		this.jobID = jobID;
+	}
+	
+	public String toString(){
+		return getID();
+	}
+	
+	public String getID(){
+		return this.jobID;
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof PbsJobID){
+			PbsJobID other = (PbsJobID)obj;
+			if (!Compare.isEqual(jobID,other.jobID)){
+				return false;
+			}
+			return true;
+		}
+		return false;
+	}
+}
Index: src/org/vcell/optimization/OptXmlWriter.java
===================================================================
--- src/org/vcell/optimization/OptXmlWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/optimization/OptXmlWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -33,7 +33,6 @@
 import cbit.vcell.math.MathUtilities;
 import cbit.vcell.math.Variable;
 import cbit.vcell.mathmodel.MathModel;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.model.ReservedSymbol;
 import cbit.vcell.modelopt.ParameterEstimationTask;
 import cbit.vcell.modelopt.ReferenceDataMappingSpec;
@@ -441,7 +440,7 @@
 				simulation.getSolverTaskDescription().setTimeBounds(new TimeBounds(0.0, refDataEndTime));
 				simulation.getSolverTaskDescription().setSolverDescription(SolverDescription.IDA);
 				StringWriter simulationInputStringWriter = new StringWriter();
-				IDAFileWriter idaFileWriter = new IDAFileWriter(new PrintWriter(simulationInputStringWriter,true), new SimulationTask(new SimulationJob(simulation, 0, null),0));
+				IDAFileWriter idaFileWriter = new IDAFileWriter(new PrintWriter(simulationInputStringWriter,true), new SimulationJob(simulation, 0, null));
 				idaFileWriter.write(parameterNames);
 				simulationInputStringWriter.close();
 				modelElement.setAttribute(OptXmlTags.ModelType_Attr,OptXmlTags.ModelType_Attr_IDA);
@@ -459,7 +458,7 @@
 				simulation.getSolverTaskDescription().setTimeBounds(new TimeBounds(0.0, refDataEndTime));
 				simulation.getSolverTaskDescription().setSolverDescription(SolverDescription.CVODE);
 				StringWriter simulationInputStringWriter = new StringWriter();
-				CVodeFileWriter cvodeFileWriter = new CVodeFileWriter(new PrintWriter(simulationInputStringWriter,true), new SimulationTask(new SimulationJob(simulation, 0, null),0));
+				CVodeFileWriter cvodeFileWriter = new CVodeFileWriter(new PrintWriter(simulationInputStringWriter,true), new SimulationJob(simulation, 0, null));
 				cvodeFileWriter.write(parameterNames);
 				simulationInputStringWriter.close();
 				modelElement.setAttribute(OptXmlTags.ModelType_Attr,OptXmlTags.ModelType_Attr_CVODE);
@@ -517,10 +516,10 @@
 				e.printStackTrace();
 				throw new SolverException(e.getMessage());
 			}	
-			SimulationTask simTask = new SimulationTask(new SimulationJob(simulation, 0, pdeObjectiveFunction.getFieldDataIDSs()),0);
+			SimulationJob simJob = new SimulationJob(simulation, 0, pdeObjectiveFunction.getFieldDataIDSs());
 			
 			StringWriter simulationInputStringWriter = new StringWriter();
-			FiniteVolumeFileWriter fvFileWriter = new FiniteVolumeFileWriter(new PrintWriter(simulationInputStringWriter,true), simTask, resampledGeometry, pdeObjectiveFunction.getWorkingDirectory());		
+			FiniteVolumeFileWriter fvFileWriter = new FiniteVolumeFileWriter(new PrintWriter(simulationInputStringWriter,true), simJob, resampledGeometry, pdeObjectiveFunction.getWorkingDirectory());		
 			fvFileWriter.write(parameterNames);
 			simulationInputStringWriter.close();
 			modelElement.setAttribute(OptXmlTags.ModelType_Attr,OptXmlTags.ModelType_Attr_FVSOLVER);
Index: src/org/vcell/solver/smoldyn/SmoldynSolver.java
===================================================================
--- src/org/vcell/solver/smoldyn/SmoldynSolver.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/solver/smoldyn/SmoldynSolver.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -19,8 +19,8 @@
 
 import cbit.vcell.math.AnnotatedFunction;
 import cbit.vcell.math.MathException;
-import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.simdata.SimDataConstants;
+import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
 import cbit.vcell.solver.SolverException;
 import cbit.vcell.solver.SolverStatus;
@@ -36,8 +36,8 @@
  */
 public class SmoldynSolver extends AbstractCompiledSolver {
 
-public SmoldynSolver(SimulationTask simTask, java.io.File directory, SessionLog sessionLog, boolean bMsging) throws SolverException {
-	super(simTask, directory, sessionLog, bMsging);
+public SmoldynSolver(SimulationJob simulationJob, java.io.File directory, SessionLog sessionLog, boolean bMsging) throws SolverException {
+	super(simulationJob, directory, sessionLog, bMsging);
 }
 
 
@@ -88,7 +88,7 @@
 	
 	// write subdomains file
 	try {
-		SubdomainInfo.write(new File(getBaseName() + SimDataConstants.SUBDOMAINS_FILE_SUFFIX), simTask.getSimulation().getMathDescription());
+		SubdomainInfo.write(new File(getBaseName() + SimDataConstants.SUBDOMAINS_FILE_SUFFIX), simulationJob.getSimulation().getMathDescription());
 	} catch (IOException e1) {
 		e1.printStackTrace();
 		throw new SolverException(e1.getMessage());
@@ -97,7 +97,7 @@
 		throw new SolverException(e1.getMessage());
 	}
 
-	String inputFilename = getInputFilename();
+	String inputFilename = getBaseName() + SMOLDYN_INPUT_FILE_EXTENSION;	
 	sessionLog.print("SmoldynSolver.initialize() baseName = " + getBaseName());
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, SimulationMessage.MESSAGE_SOLVER_RUNNING_INPUT_FILE));
@@ -106,7 +106,7 @@
 	PrintWriter pw = null;
 	try {
 		pw = new PrintWriter(inputFilename);
-		SmoldynFileWriter stFileWriter = new SmoldynFileWriter(pw, false, getBaseName(), simTask, bMessaging);
+		SmoldynFileWriter stFileWriter = new SmoldynFileWriter(pw, false, getBaseName(), simulationJob, bMessaging);
 		stFileWriter.write();
 	} catch (Exception e) {
 		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, SimulationMessage.solverAborted("Could not generate input file: " + e.getMessage())));
@@ -120,21 +120,11 @@
 
 	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,SimulationMessage.MESSAGE_SOLVER_RUNNING_START));	
 	//get executable path+name.
-	setMathExecutable(new MathExecutable(getMathExecutableCommand()));	
+	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.smoldynExecutableProperty);
+	setMathExecutable(new MathExecutable(new String[] {executableName, inputFilename}));	
 	//setMathExecutable(new cbit.vcell.solvers.MathExecutable(executableName + " gibson " + getBaseName() + ".stochInput" + " " + getBaseName() + ".stoch"));
 }
 
-private String getInputFilename(){
-	return getBaseName() + SMOLDYN_INPUT_FILE_EXTENSION;
-}
-
-@Override
-public String[] getMathExecutableCommand() {
-	String executableName = PropertyLoader.getRequiredProperty(PropertyLoader.smoldynExecutableProperty);
-	String inputFilename = getInputFilename();
-	return new String[] { executableName, inputFilename };
-}
-
 /**
  * Insert the method's description here.
  * Creation date: (10/11/2006 11:16:02 AM)
Index: src/org/vcell/solver/smoldyn/SmoldynFileWriter.java
===================================================================
--- src/org/vcell/solver/smoldyn/SmoldynFileWriter.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/solver/smoldyn/SmoldynFileWriter.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -12,9 +12,11 @@
 
 
 import java.awt.Color;
+import java.awt.Graphics2D;
 import java.beans.PropertyVetoException;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintStream;
@@ -29,6 +31,8 @@
 import java.util.StringTokenizer;
 import java.util.zip.DeflaterOutputStream;
 
+import javax.imageio.ImageIO;
+
 import org.apache.commons.math.random.RandomDataImpl;
 import org.vcell.util.BeanUtils;
 import org.vcell.util.Coordinate;
@@ -82,9 +86,7 @@
 import cbit.vcell.math.SubDomain;
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VolumeParticleVariable;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
-import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.messaging.JmsUtils;
 import cbit.vcell.parser.DivideByZeroException;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionBindingException;
@@ -300,22 +302,22 @@
 	private CartesianMesh cartesianMesh = null;
 	private String baseFileName = null;
 
-public SmoldynFileWriter(PrintWriter pw, boolean bGraphic, String baseName, SimulationTask simTask, boolean bMessaging) 
+public SmoldynFileWriter(PrintWriter pw, boolean bGraphic, String baseName, SimulationJob arg_simulationJob, boolean bMessaging) 
 {
-	super(pw, simTask, bMessaging);
+	super(pw, arg_simulationJob, bMessaging);
 	this.bGraphicOpenGL = bGraphic;
 	baseFileName = baseName;
 	this.outputFile = new File(baseFileName + SimDataConstants.SMOLDYN_OUTPUT_FILE_EXTENSION); 
 	
 	//get user defined random seed. If it doesn't exist, we assign system time (in millisecond) to it.
-	SmoldynSimulationOptions smoldynSimulationOptions = simTask.getSimulation().getSolverTaskDescription().getSmoldynSimulationOptions();
+	SmoldynSimulationOptions smoldynSimulationOptions = arg_simulationJob.getSimulation().getSolverTaskDescription().getSmoldynSimulationOptions();
 	if (smoldynSimulationOptions.getRandomSeed() != null) {
 		this.randomSeed = smoldynSimulationOptions.getRandomSeed();
 	} else {
 		this.randomSeed = System.currentTimeMillis();
 	}
 	//We add jobindex to the random seed in case there is a parameter scan.
-	randomSeed = randomSeed + simTask.getSimulationJob().getJobIndex();
+	randomSeed = randomSeed + simulationJob.getJobIndex();
 	dist.reSeed(randomSeed);
 }
 
@@ -344,9 +346,9 @@
 }
 
 private void init() throws SolverException {
-	simulation = simTask.getSimulation();
+	simulation = simulationJob.getSimulation();
 	mathDesc = simulation.getMathDescription();
-	simulationSymbolTable = simTask.getSimulationJob().getSimulationSymbolTable();
+	simulationSymbolTable = simulationJob.getSimulationSymbolTable();
 
 	particleVariableList = new ArrayList<ParticleVariable>();
 	Variable[] variables = simulationSymbolTable.getVariables();
@@ -623,7 +625,7 @@
 }
 
 private void writeDataProcessor() throws DataAccessException, IOException, MathException, DivideByZeroException, ExpressionException {
-	Simulation simulation = simTask.getSimulation();
+	Simulation simulation = simulationJob.getSimulation();
 	DataProcessingInstructions dpi = simulation.getDataProcessingInstructions();
 	if (dpi == null) {
 		printWriter.println(SmoldynKeyword.cmd + " " + SmoldynKeyword.B + " " + VCellSmoldynKeyword.vcellDataProcess + " begin " + DataProcessingInstructions.ROI_TIME_SERIES);
@@ -645,7 +647,7 @@
 			throw new IllegalArgumentException("field function variable type (" + varType.getTypeName() + ") doesn't match real variable type (" + dataVarType.getTypeName() + ")");
 		}
 		double[] origData = simDataBlock.getData();	
-		String filename = SimulationJob.createSimulationJobID(Simulation.createSimulationID(simulation.getKey()), simTask.getSimulationJob().getJobIndex()) + FieldDataIdentifierSpec.getDefaultFieldDataFileNameForSimulation(fdis.getFieldFuncArgs());
+		String filename = SimulationJob.createSimulationJobID(Simulation.createSimulationID(simulation.getKey()), simulationJob.getJobIndex()) + FieldDataIdentifierSpec.getDefaultFieldDataFileNameForSimulation(fdis.getFieldFuncArgs());
 		
 		File fdatFile = new File(userDirectory, filename);
 		
@@ -1934,16 +1936,16 @@
 }
 
 private void writeJms(Simulation simulation) {
-	if (simTask  != null) {
+	if (simulationJob  != null) {
 		printWriter.println("# JMS_Paramters");
 		printWriter.println("start_jms"); 
-		printWriter.println(PropertyLoader.getRequiredProperty(PropertyLoader.jmsProvider) + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL)
-				+ " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser) + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword)
-				+ " " + VCellQueue.WorkerEventQueue.getName()  
-				+ " " + VCellTopic.ServiceControlTopic.getName()
+		printWriter.println(JmsUtils.getJmsProvider() + " " + JmsUtils.getJmsUrl()
+			+ " " + JmsUtils.getJmsUserID() + " " + JmsUtils.getJmsPassword()
+			+ " " + JmsUtils.getQueueWorkerEvent()  
+			+ " " + JmsUtils.getTopicServiceControl()
 			+ " " + simulation.getVersion().getOwner().getName()
 			+ " " + simulation.getVersion().getVersionKey()
-			+ " " + simTask.getSimulationJob().getJobIndex());
+			+ " " + simulationJob.getJobIndex());
 		printWriter.println("end_jms");
 		printWriter.println();
 	}
Index: src/org/vcell/util/FileUtils.java
===================================================================
--- src/org/vcell/util/FileUtils.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/util/FileUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -53,8 +53,9 @@
         }
 
         // ensure that parent dir of dest file exists!
-        File parent = destFile.getParentFile();
-        if (parent!=null && !parent.exists()) {
+        // not using getParentFile method to stay 1.1 compat
+        File parent = new File(destFile.getParent());
+        if (!parent.exists()) {
             parent.mkdirs();
         }
 
@@ -212,21 +213,4 @@
   }
 }
 
-public static void deleteFile(String filePath) throws IOException {
-	File f = new File(filePath);
-	if (!f.exists()) {
-		throw new IOException("File \""+filePath+"\" does not exist.");
-	}
-	if (!f.canWrite()) {
-		throw new IOException("File \""+filePath+"\" is write protected.");
-	}	
-	if (f.isDirectory()) {
-		throw new IOException("File \""+filePath+"\" is a directory, and I'm currently programmed to balk at deleting whole directories.");
-	}
-	boolean bSuccess = f.delete();
-	if (!bSuccess) {
-		throw new IOException("File \""+filePath+"\" deletion attempt failed.");
-	}
 }
-
-}
Index: src/org/vcell/util/PropertyLoader.java
===================================================================
--- src/org/vcell/util/PropertyLoader.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/util/PropertyLoader.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -13,12 +13,10 @@
 import java.util.Arrays;
 import java.util.Vector;
 
-import cbit.vcell.message.server.htc.HtcJobID.BatchSystemType;
 
 
 
 
-
 public class PropertyLoader {
 	public static final String ADMINISTRATOR_ACCOUNT = "Administrator";
 	public static final String ADMINISTRATOR_ID = "2";
@@ -44,6 +42,8 @@
 	public static final String libsProperty					= "vcell.c++.libs";
 	public static final String finiteVolumeExecutableProperty = "vcell.finitevolume.executable";
 	
+	public static final String optLibsProperty				= "vcell.opt.libs";
+	public static final String optIncludeProperty			= "vcell.opt.include";
 	//
 	public static final String sundialsSolverExecutableProperty		= "vcell.sundialsSolver.executable";
 	
@@ -63,7 +63,6 @@
 	public static final String bioformatsJarFileName		= "vcell.bioformatsJarFileName";
 	public static final String bioformatsClasspath			= "vcell.bioformatsClasspath";
 	public static final String bioformatsJarDownloadURL		= "vcell.bioformatsJarDownloadURL";
-	
 	// Smoldyn
 	public static final String smoldynExecutableProperty		= "vcell.smoldyn.executable";
 	
@@ -90,6 +89,7 @@
 	public static final String sbml1SchemaUrlProperty		= "vcell.xml.sbml1SchemaUrl";
 	public static final String sbml2SchemaUrlProperty		= "vcell.xml.sbml2SchemaUrl";
 	public static final String cellmlSchemaUrlProperty      = "vcell.xml.cellmlSchemaUrl"; 
+	public static final String triangleCmdProperty			= "vcell.mesh.trianglecmd";
 	
 	public static final String dataSetCrawlerEnabled		= "vcell.dataSetCrawlerEnabled";
 	public static final String dataSetCrawlerIntervalMinutes= "vcell.dataSetCrawlerIntervalMinutes";
@@ -97,16 +97,19 @@
 	public static final String odeComputeServerHosts		= "vcell.odeComputeServerHosts";   // comma-separated list of hosts
 	public static final String pdeComputeServerHosts		= "vcell.pdeComputeServerHosts";   // comma-separated list of hosts
 	public static final String hostSeparator	= ",";
+	//added by RB, to accomodate some experiment-related stuff
+	public static final String expSchemaUrlProperty = "vcell.experiment.expSchemaUrl";
+	public static final String expXMLRep = "vcell.experiment.expXMLRep";
+	public static final String expLoadDump = "vcell.experiment.expLoadDump";
 
 	public static final String jmsProvider				= "vcell.jms.provider";
-	public static final String jmsProviderValueActiveMQ		= "ActiveMQ";
-	public static final String jmsProviderValueSonicMQ		= "SonicMQ";
 	public static final String jmsURL					= "vcell.jms.url";
 	public static final String jmsUser					= "vcell.jms.user";
 	public static final String jmsPassword				= "vcell.jms.password";
 	public static final String jmsSimReqQueue			= "vcell.jms.queue.simReq";
 	public static final String jmsDataRequestQueue		= "vcell.jms.queue.dataReq";
 	public static final String jmsDbRequestQueue		= "vcell.jms.queue.dbReq";
+	public static final String jmsBNGRequestQueue		= "vcell.jms.queue.bngReq";
 	public static final String jmsSimJobQueue			= "vcell.jms.queue.simJob";
 	public static final String jmsWorkerEventQueue		= "vcell.jms.queue.workerEvent";
 	public static final String jmsWorkerPrefetchCount	= "vcell.jms.workerPrefetchCount";
@@ -130,7 +133,7 @@
 	public static final String rmiPortVCellServer			= "vcell.rmi.port.vcellServer";
 	public static final String rmiPortMessageHandler		= "vcell.rmi.port.messageHandler";
 	public static final String rmiPortRegistry				= "vcell.rmi.port.registry";
-	public static final String rmiBootstrapHost				= "vcell.rmi.host";
+	public static final String rmiPortBNGService			= "vcell.rmi.port.bngService";
 
 	public static final String serverManageConfig = "vcell.messaging.serverManagerConfig";
 	public static final String bootstrapConfig = "vcell.messaging.bootstrapConfig";
@@ -139,18 +142,26 @@
 
 	public static final String vcellServerHost = "vcell.serverHost";
 
+	public static final String vcellAnonymizerBootstrapPropertyFile = "vcell.anonymizer.bootstrap.propertyFile";
+	public static final String vcellAnonymizerBootstrapLogfile = "vcell.anonymizer.bootstrap.logfile";
+	public static final String vcellAnonymizerBootstrapLocalHost = "vcell.anonymizer.bootstrap.localHost";
+	public static final String vcellAnonymizerBootstrapLocalPort = "vcell.anonymizer.bootstrap.localPort";	
+	public static final String vcellAnonymizerBootstrapRemoteHost = "vcell.anonymizer.bootstrap.remoteHost";
+	public static final String vcellAnonymizerBootstrapRemotePort = "vcell.anonymizer.bootstrap.remotePort";
+	
+	public static final String vcellBNGPerl = "vcell.bng.perl.executable";
+	public static final String vcellBNGScript = "vcell.bng.script";
+
 	public static final String vcellClientTimeoutMS = "vcell.client.timeoutMS";
 	
-	public static final String htcBatchSystemType = "vcell.htc.batchSystemType";
-	public static final String    htcBatchSystemTypeValue_PBS = BatchSystemType.PBS.name();
-	public static final String    htcBatchSystemTypeValue_SGE = BatchSystemType.SGE.name();
+	public static final String lsfJobQueue = "vcell.lsf.jobQueue";
+	
+	public static final String htcSubmitTemplates = "vcell.htc.submittemplates";		
 	public static final String htcPartitionMaximumJobs = "vcell.htc.partition.maximumJobs";
 	public static final String htcPartitionShareServerIDs = "vcell.htc.partition.shareServerIDs";
 	public static final String htcComputeResources = "vcell.htc.computeresources";
 	
 	public static final String pbsHomeDir = "vcell.pbs.homeDir";
-	public static final String pbsServiceQueuePrefix = "vcell.pbs.pbsServiceQueuePrefix";
-	public static final String pbsWorkQueuePrefix = "vcell.pbs.pbsWorkQueuePrefix";
 	
 	public static final String limitJobMemoryMB="vcell.limit.jobMemoryMB";
 	
@@ -159,8 +170,7 @@
 	public static final String vcellSMTPEmailAddress = "vcell.smtp.emailAddress";
 	
 	public static final String javaSimulationExecutable = "vcell.javaSimulation.executable";
-	public static final String simulationPreprocessor = "vcell.simulation.preprocessor";
-	public static final String simulationPostprocessor = "vcell.simulation.postprocessor";
+	
 	public final static String mathSBMLDirectory = "vcell.mathSBML.directory";
 	public final static String COPASIExecutable = "vcell.COPASI.executable";
 	public final static String mathematicaKernelExecutable = "vcell.mathematica.kernel.executable";
@@ -192,6 +202,9 @@
 		libsProperty,
 		finiteVolumeExecutableProperty,
 		
+		optLibsProperty,
+		optIncludeProperty,
+		
 		sundialsSolverExecutableProperty,
 		
 		stochExecutableProperty,
@@ -221,11 +234,15 @@
 		sbml1SchemaUrlProperty,
 		sbml2SchemaUrlProperty,
 		cellmlSchemaUrlProperty,
+		triangleCmdProperty,
 		dataSetCrawlerEnabled,
 		dataSetCrawlerIntervalMinutes,
 		simDataServerHost,
 		odeComputeServerHosts,
 		pdeComputeServerHosts,
+		expSchemaUrlProperty,
+		expXMLRep,
+		expLoadDump,
 		
 		jmsProvider,
 		jmsURL,
@@ -234,6 +251,7 @@
 		jmsSimReqQueue,
 		jmsDataRequestQueue,
 		jmsDbRequestQueue,
+		jmsBNGRequestQueue,
 		jmsSimJobQueue,
 		jmsWorkerEventQueue,
 		jmsWorkerPrefetchCount,
@@ -263,14 +281,26 @@
 		rmiPortVCellServer,
 		rmiPortMessageHandler,
 		rmiPortRegistry,
+		rmiPortBNGService,
 
+		vcellAnonymizerBootstrapLogfile,
+		vcellAnonymizerBootstrapLocalHost,
+		vcellAnonymizerBootstrapLocalPort,
+		vcellAnonymizerBootstrapRemoteHost,
+		vcellAnonymizerBootstrapRemotePort,
+
+		vcellBNGPerl,
+		vcellBNGScript,
+
 		vcellClientTimeoutMS,
 		
+		lsfJobQueue,
+		
+		htcSubmitTemplates,		
 		htcComputeResources,
 		htcPartitionMaximumJobs,
 		htcPartitionShareServerIDs,		
 		pbsHomeDir,
-
 		
 		limitJobMemoryMB,
 		
@@ -279,7 +309,6 @@
 		vcellSMTPEmailAddress,
 		
 		javaSimulationExecutable,
-		simulationPreprocessor,
 		
 		mathSBMLDirectory,
 		COPASIExecutable,
@@ -360,6 +389,40 @@
 
 
 /**
+ * Insert the method's description here.
+ * Creation date: (6/8/2006 12:29:59 PM)
+ */
+public static void loadAnonymizerProperties() {
+	try {
+		java.util.Properties sysProperties = new java.util.Properties(System.getProperties());
+		
+		String customPropertyFileName = sysProperties.getProperty(PropertyLoader.vcellAnonymizerBootstrapPropertyFile);		
+
+		java.io.InputStream propInput = null;		
+		if (customPropertyFileName != null && new java.io.File(customPropertyFileName).exists()){
+			System.out.println("property file [" + customPropertyFileName + "] is specified on the command line");
+			propInput = new java.io.FileInputStream(customPropertyFileName);
+		} else {
+			System.out.println("property file is not specified on the command line, or it doesn't exist.");
+			customPropertyFileName = "Resource[/cbit/vcell/anonymizer/anonymizer.properties.txt]";
+			java.net.URL propURL = PropertyLoader.class.getResource("/cbit/vcell/anonymizer/anonymizer.properties.txt");
+			propInput = propURL.openConnection().getInputStream();
+			System.out.println("trying to use the property file in the jar file [/cbit/vcell/anonymizer/anonymizer.properties.txt]");		
+		}
+		
+		sysProperties.load(propInput);
+		propInput.close();
+		System.out.println("loaded properties from " + customPropertyFileName);
+
+		System.setProperties(sysProperties);
+		
+	} catch (Exception ex) {
+		ex.printStackTrace();
+	}	
+}
+
+
+/**
  * This method was created in VisualAge.
  */
 public final static void loadProperties() throws java.io.IOException {
Index: src/org/vcell/util/Executable.java
===================================================================
--- src/org/vcell/util/Executable.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/util/Executable.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -287,10 +287,16 @@
 		if (numReadOut > 0) {
 			String newInput = new String(charArrayOut, 0, numReadOut);
 			outString += newInput;
+			if (numReadOut == charArrayOut.length) {
+				outString += "\n(standard output truncated...)";
+			}
 		}
 		if (numReadErr > 0) {
 			String newInput = new String(charArrayErr, 0, numReadErr);
 			errString += newInput;
+			if (numReadErr == charArrayErr.length) {
+				errString += "\n(standard output truncated...)";
+			}
 		}
 		setOutputString(outString);
 		setErrorString(errString);
Index: src/org/vcell/util/BeanUtils.java
===================================================================
--- src/org/vcell/util/BeanUtils.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/util/BeanUtils.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -830,9 +830,9 @@
 		Transport.send(msg);
 	}
 
-	public static void sendErrorReport(Throwable exception) throws RuntimeException {
+	public static void sendErrorReport(Throwable exception) throws RemoteException {
 		if (exception == null) {
-			throw new RuntimeException("Send Error Report, exception is null");
+			throw new RemoteException("Send Error Report, exception is null");
 		}
 		String smtpHost = PropertyLoader.getProperty(PropertyLoader.vcellSMTPHostName, null);
 		if (smtpHost == null) {
@@ -854,10 +854,10 @@
 			BeanUtils.sendSMTP(smtpHost, Integer.parseInt(smtpPort), from, to, subject, content);
 		} catch (AddressException e) {
 			e.printStackTrace();
-			throw new RuntimeException(e.getMessage());
+			throw new RemoteException(e.getMessage());
 		} catch (MessagingException e) {
 			e.printStackTrace();
-			throw new RuntimeException(e.getMessage());
+			throw new RemoteException(e.getMessage());
 		}
 	}
 
Index: src/org/vcell/util/document/VCellServerID.java
===================================================================
--- src/org/vcell/util/document/VCellServerID.java	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ src/org/vcell/util/document/VCellServerID.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -87,7 +87,4 @@
 public String toString() {
 	return serverID;
 }
-public String toCamelCase() {
-    return serverID.toUpperCase().charAt(0)+serverID.substring(1).toLowerCase();
 }
-}
Index: src/org/vcell/util/MessageConstants.java
===================================================================
--- src/org/vcell/util/MessageConstants.java	(.../VCell_5.1_message/VCell)	(revision 0)
+++ src/org/vcell/util/MessageConstants.java	(.../VCell_5.1_messaging)	(revision 12065)
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package org.vcell.util;
+/**
+ * Insert the type's description here.
+ * Creation date: (10/23/2001 12:16:47 PM)
+ * @author: Jim Schaff
+ */
+public interface MessageConstants {
+	public static final int MAX_SERVICE_LISTENERS = 5;	
+	
+	public static final String METHOD_NAME_PROPERTY	= "MethodName";	
+	public static final String USERNAME_PROPERTY	= "UserName";
+	public static final String SIZE_MB_PROPERTY		= "SizeMB";
+	public static final String SIMKEY_PROPERTY		= "SimKey";
+	public static final String JOBINDEX_PROPERTY		= "JobIndex";
+	public static final String TASKID_PROPERTY		= "TaskID";
+	public static final String FIELDDATAID_PROPERTY		= "FieldDataID";
+
+	// bitmapped counter so that allows 3 retries for each request (but preserves ordinal nature)
+	// bits 0-3: retry count
+	// bits 4-31: submit
+	// max retries must be less than 15.
+	public static final int TASKID_USERCOUNTER_MASK		= 0xFFFFFFF0;
+	public static final int TASKID_RETRYCOUNTER_MASK	= 0x0000000F;
+	public static final int TASKID_USERINCREMENT	    = 0x00000010;
+	public static final int TASKID_MAX_RETRIES = 0;
+
+	public static final String JMSCORRELATIONID_PROPERTY	= "JMSCorrelationID";
+	
+	public static final String MESSAGE_TYPE_SIMULATION_JOB_VALUE = "SimulationJob";
+	public static final String MESSAGE_TYPE_SIMSTATUS_VALUE	= "SimStatus";
+	public static final String MESSAGE_TYPE_RPC_SERVICE_VALUE = "RPCService";
+	public static final String MESSAGE_TYPE_EXPORT_EVENT_VALUE = "ExportEvent";
+	public static final String MESSAGE_TYPE_DATA_EVENT_VALUE = "DataEvent";
+	
+	public static final String MESSAGE_TYPE_PROPERTY	= "MessageType";
+	public static final String MESSAGE_TYPE_STOPSIMULATION_VALUE	= "StopSimulation";	
+
+	public static final String COMPUTE_RESOURCE_PROPERTY	= "ComputeResource";	
+	
+	public static final String HOSTNAME_PROPERTY		= "HostName";
+	public static final String SERVICE_TYPE_PROPERTY	= "ServiceType";
+	
+	public enum ServiceType { 
+		DB ("Db"),	
+		DATA ("Data"),
+		DATAEXPORT ("Exprt"),
+		DISPATCH ("Dsptch"),
+		PBSCOMPUTE ("PbsC"),	// submit everything to PBS
+		LOCALCOMPUTE ("LclC"),   // local pde and ode
+		SERVERMANAGER ("ServerManager");
+		
+		private final String typeName;
+		ServiceType(String tn) {
+			typeName = tn;
+		}
+		
+		public String getName() {
+			return typeName;
+		}
+
+		@Override
+		public String toString() {
+			return typeName;
+		}
+		
+		public static ServiceType fromName(String name) {
+			for (ServiceType st : ServiceType.values()) {
+				if (st.getName().equals(name)) {
+					return st;
+				}
+			}			
+			throw new RuntimeException(name + " is not a legitiamte service type");
+		}
+	}
+
+	public static final int PRIORITY_LOW = 0;
+	public static final int PRIORITY_DEFAULT = 5;
+	public static final int PRIORITY_HIGH = 9;
+
+	public static final int QUEUE_ID_WAITING = 0;
+	public static final int QUEUE_ID_SIMULATIONJOB = 1;
+	public static final int QUEUE_ID_NULL = 2;
+
+	public static final int SECOND_IN_MS = 1000; // in milliseconds
+	public static final int MINUTE_IN_S = 60;
+	public static final int MINUTE_IN_MS = MINUTE_IN_S * SECOND_IN_MS; // in milliseconds
+
+	public static final long INTERVAL_PING_SERVER = 5 * MINUTE_IN_MS; // in milliseconds
+	public static final long INTERVAL_SERVER_FAIL = 10 * MINUTE_IN_MS; // in milliseconds
+	public static final long INTERVAL_DATABASE_SERVER_FAIL = 10 * 60; // in seconds
+	public static final long INTERVAL_PROGRESS_MESSAGE = 5 * SECOND_IN_MS;	
+}
Index: .classpath
===================================================================
--- .classpath	(.../VCell_5.1_message/VCell)	(revision 12250)
+++ .classpath	(.../VCell_5.1_messaging)	(revision 12065)
@@ -3,7 +3,7 @@
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
 	<classpathentry kind="src" path="src">
 		<attributes>
-			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="VCell_5.1/nativelibs/win64"/>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="VCell_5.1/nativelibs/win"/>
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="src" path="src_jvisit"/>
@@ -11,24 +11,17 @@
 	<classpathentry kind="src" path="resources_vfrap"/>
 	<classpathentry kind="src" path="src_vfrap">
 		<attributes>
-			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="VCell_5.1/nativelibs/win64"/>
+			<attribute name="org.eclipse.jdt.launching.CLASSPATH_ATTR_LIBRARY_PATH_ENTRY" value="VCell/nativelibs/Win32"/>
 		</attributes>
 	</classpathentry>
-	<classpathentry kind="src" path="sshj"/>
 	<classpathentry kind="src" path="resources"/>
-	<classpathentry kind="lib" path="lib/activemq-core-5.6.0.jar"/>
-	<classpathentry kind="lib" path="lib/camel-jms-2.9.2.jar"/>
-	<classpathentry kind="lib" path="lib/geronimo-j2ee-management_1.1_spec-1.0.1.jar"/>
-	<classpathentry kind="lib" path="lib/geronimo-jms_1.1_spec-1.1.1.jar"/>
-	<classpathentry kind="lib" path="lib/geronimo-jta_1.0.1B_spec-1.0.1.jar"/>
-	<classpathentry exported="true" kind="lib" path="lib/slf4j-api-1.6.4.jar"/>
-	<classpathentry exported="true" kind="lib" path="lib/slf4j-log4j12-1.6.4.jar"/>
-	<classpathentry exported="true" kind="lib" path="lib/log4j-1.2.16.jar"/>
-	<classpathentry kind="lib" path="lib/kahadb-5.6.0.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/xercesImpl-2.7.1.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/icu4j-3.4.4.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/iri-0.7.jar"/>
+	<classpathentry exported="true" kind="lib" path="lib/log4j-1.2.13.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/lucene-core-2.3.1.jar"/>
+	<classpathentry exported="true" kind="lib" path="lib/slf4j-api-1.5.6.jar"/>
+	<classpathentry exported="true" kind="lib" path="lib/slf4j-log4j12-1.5.6.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/stax-api-1.0.1.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/wstx-asl-3.2.9.jar"/>
 	<classpathentry exported="true" kind="lib" path="lib/xml-apis.jar"/>
@@ -74,8 +67,5 @@
 	<classpathentry kind="lib" path="lib/jhall.jar"/>
 	<classpathentry kind="lib" path="lib/netty-3.2.5.Final.jar"/>
 	<classpathentry kind="lib" path="lib/mongo-2.8.0.jar"/>
-	<classpathentry kind="lib" path="lib/ucp.jar"/>
-	<classpathentry kind="lib" path="lib/ucpdemos.jar"/>
-	<classpathentry kind="lib" path="lib/bcprov-jdk15on-147.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
Index: lib/slf4j-log4j12-1.6.4.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/kahadb-5.6.0.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/camel-jms-2.9.2.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/ucpdemos.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/log4j-1.2.16.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/activemq-core-5.6.0.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/bcprov-jdk15on-147.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/geronimo-jta_1.0.1B_spec-1.0.1.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/ucp.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/geronimo-jms_1.1_spec-1.1.1.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/slf4j-api-1.6.4.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: lib/geronimo-j2ee-management_1.1_spec-1.0.1.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
