package cbit.vcell.solvers;
import java.io.File;
import java.io.FileWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;

import org.vcell.util.PropertyLoader;
import org.vcell.util.SessionLog;

import cbit.vcell.math.AnnotatedFunction;
import cbit.vcell.math.VariableType;
import cbit.vcell.mesh.CartesianMesh;
import cbit.vcell.simdata.FunctionFileGenerator;
import cbit.vcell.simulation.Simulation;
/**
 * This interface was generated by a SmartGuide.
 * 
 */
public class FVSolver extends AbstractCompiledSolver implements Solver {
	private CppCoderVCell cppCoderVCell = null;

/**
 * This method was created by a SmartGuide.
 * @param mathDesc cbit.vcell.math.MathDescription
 * @param platform cbit.vcell.solvers.Platform
 * @param directory java.lang.String
 * @param simID java.lang.String
 * @param clientProxy cbit.vcell.solvers.ClientProxy
 */
public FVSolver (SimulationJob argSimulationJob, File dir, SessionLog sessionLog) throws SolverException {
	super(argSimulationJob, dir, sessionLog);
	if (! getSimulation().getIsSpatial()) {
		throw new SolverException("Cannot use FVSolver on non-spatial simulation");
	}
	this.cppCoderVCell = new CppCoderVCell((new File(getBaseName())).getName(), getSaveDirectory(), argSimulationJob);
}


/**
 * This method was created by a SmartGuide.
 */
private void autoCode(boolean bNoCompile) throws SolverException {
	getSessionLog().print("LocalMathController.autoCode()");
	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "initializing coder"));
	fireSolverStarting("generating code...");
	
	String baseName = new File(getSaveDirectory(), cppCoderVCell.getBaseFilename()).getPath();

	String Compile = System.getProperty(PropertyLoader.compilerProperty);                 // "cl /c";
	String Link = System.getProperty(PropertyLoader.linkerProperty);                      // "cl";
	String exeOutputSpecifier = System.getProperty(PropertyLoader.exeOutputProperty);     // "/Fe";
	String objOutputSpecifier = System.getProperty(PropertyLoader.objOutputProperty);     // "/Fo";
	String compileFlags = System.getProperty(PropertyLoader.includeProperty)+" "+
							System.getProperty(PropertyLoader.definesProperty);           // "/I"+includeDir+" /DWIN32 /DDEBUG";
	String CodeFilename = baseName+System.getProperty(PropertyLoader.srcsuffixProperty);  // ".cpp";
	String libs = System.getProperty(PropertyLoader.libsProperty);                        // libraryDir+"VCLIB.lib";
	String exeSuffix = System.getProperty(PropertyLoader.exesuffixProperty);              // ".exe";
	String HeaderFilename = baseName+".h";
	String ExeFilename = baseName+exeSuffix;
	String ObjFilename = baseName+System.getProperty(PropertyLoader.objsuffixProperty);

	// ** Dumping the functions of a simulation into a '.functions' file.
	String functionFileName = baseName+".functions";
	AnnotatedFunction[] annotatedFunctionList = Simulation.createAnnotatedFunctionsList(getSimulation());
	FunctionFileGenerator functionFileGenerator = new FunctionFileGenerator(functionFileName, annotatedFunctionList);

	try {
		functionFileGenerator.generateFunctionFile();		
	}catch (Exception e){
		e.printStackTrace(System.out);
		throw new RuntimeException("autocode exception: Error creating .function file for "+functionFileGenerator.getBasefileName()+e.getMessage());
	}		
	
	try {
		cppCoderVCell.initialize();
	}catch (Exception e){
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, "autocode init exception: "+e.getMessage()));
		e.printStackTrace(System.out);
		throw new SolverException("autocode init exception: "+e.getMessage());
	}		
	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "generating code"));
	
	java.io.FileOutputStream osCode = null;
	java.io.FileOutputStream osHeader = null;
	try {
		osCode = new java.io.FileOutputStream(CodeFilename);
	}catch (java.io.IOException e){
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, "error opening code file '"+CodeFilename+": "+e.getMessage()));
		e.printStackTrace(System.out);
		throw new SolverException("error opening code file '"+CodeFilename+": "+e.getMessage());
	}		
	
	try {
		osHeader = new java.io.FileOutputStream(HeaderFilename);
	}catch (java.io.IOException e){
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, "error opening header file '"+HeaderFilename+": "+e.getMessage()));
		e.printStackTrace(System.out);
		throw new SolverException("error opening header file '"+HeaderFilename+": "+e.getMessage());
	}		
	
	try {
		cppCoderVCell.code(osHeader,osCode);
		osCode.close();
		osHeader.close();
	}catch (Exception e){
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, "autocode coding exception: "+e.getMessage()));
		e.printStackTrace(System.out);
		throw new SolverException("autocode coding exception: "+e.getMessage());
	}	
	
	if (bNoCompile){
		return;
	}	
	
	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "compiling and linking code"));
	fireSolverStarting("compiling code...");
	try {		
		String compileCommand = Compile+" "+CodeFilename+" "+compileFlags+" "+objOutputSpecifier+ObjFilename;
System.out.println(compileCommand);
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "% "+compileCommand));
		
		Runtime runtime = Runtime.getRuntime();
		Process process = runtime.exec(compileCommand);

		String stdoutString = "";
		String stderrString = "";

		InputStream inputStream = process.getInputStream();
		if (inputStream!=null){
			char charArray[] = new char[1000];
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			int numRead = inputStreamReader.read(charArray,0,charArray.length);
			if (numRead>0){
				stdoutString += new String(charArray,0,numRead);
				if (numRead == charArray.length){
					stdoutString += "\n(standard output truncated...)";
				}	
			}
			inputStreamReader.close();
		}	
		
		inputStream = process.getErrorStream();
		if (inputStream!=null){
			char charArray[] = new char[1000];
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			int numRead = inputStreamReader.read(charArray,0,charArray.length);
			if (numRead>0){
				stderrString += new String(charArray,0,numRead);
				if (numRead == charArray.length){
					stderrString += "\n(standard output truncated...)";
				}	
			}
			inputStreamReader.close();	
		}	
		
		try {
			process.waitFor();
//			throw new RemoteException("didn't wait for process");
		}catch (InterruptedException e){
		}	
		int retcode = 0;
		retcode = process.exitValue();
		if (retcode == 0){
			setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "compilation successful, return code = "+retcode));	
		}else{
			getSessionLog().print("stderr:\n"+stderrString);
			getSessionLog().print("stdout:\n"+stdoutString);
			throw new SolverException("compilation failed, return code = "+retcode+"\n"+stderrString);
		}		
		process = null;
		
	}catch (Exception e){
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, "error compiling: "+e.getMessage()));
		e.printStackTrace(System.out);
		throw new SolverException("error compiling: "+e.getMessage());		
	}

	
	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "linking code"));
	try {		
		String linkCommand = Link+" "+exeOutputSpecifier+ExeFilename+" "+ObjFilename+" "+libs;
System.out.println(linkCommand);
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "% "+linkCommand));
		
		Runtime runtime = Runtime.getRuntime();
		Process process = runtime.exec(linkCommand);

		String stdoutString = "";
		String stderrString = "";

		InputStream inputStream = process.getInputStream();
		if (inputStream!=null){
			char charArray[] = new char[1000];
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			int numRead = inputStreamReader.read(charArray,0,charArray.length);
			if (numRead>0){
				stdoutString += new String(charArray,0,numRead);
				if (numRead == charArray.length){
					stdoutString += "\n(standard output truncated...)";
				}	
			}
			inputStreamReader.close();
		}	
		
		inputStream = process.getErrorStream();
		if (inputStream!=null){
			char charArray[] = new char[1000];
			InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
			int numRead = inputStreamReader.read(charArray,0,charArray.length);
			if (numRead>0){
				stderrString += new String(charArray,0,numRead);
				if (numRead == charArray.length){
					stderrString += "\n(standard output truncated...)";
				}	
			}
			inputStreamReader.close();	
		}	
		
		try {
			process.waitFor();
//			throw new RemoteException("didn't wait for process");
		}catch (InterruptedException e){
		}	
		int retcode = 0;
		retcode = process.exitValue();
		if (retcode == 0){
			setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "link successful, return code = "+retcode));	
		}else{
			getSessionLog().print("stderr:\n"+stderrString);
			getSessionLog().print("stdout:\n"+stdoutString);
			throw new SolverException("link failed, return code = "+retcode);
		}		
		process = null;
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "compile/link complete"));
		
	}catch (Exception e){
		setSolverStatus(new SolverStatus(SolverStatus.SOLVER_ABORTED, "error linking: "+e.getMessage()));
		e.printStackTrace(System.out);
		throw new SolverException("error linking: "+e.getMessage());		
	}	
}


/**
 * Insert the method's description here.
 * Creation date: (12/9/2002 4:53:30 PM)
 */
public void cleanup() {
	// nothing special needed
}


/**
 * Insert the method's description here.
 * Creation date: (6/27/01 3:25:11 PM)
 * @return cbit.vcell.solvers.ApplicationMessage
 * @param message java.lang.String
 */
public ApplicationMessage getApplicationMessage(String message) {
	//
	// "data:iteration:time"  .... sent every time data written for FVSolver
	// "progress:xx.x%"        .... sent every 1% for FVSolver
	//
	//
	String SEPARATOR = ":";
	String DATA_PREFIX = "data:";
	String PROGRESS_PREFIX = "progress:";
	if (message.startsWith(DATA_PREFIX)){
		double timepoint = Double.parseDouble(message.substring(message.lastIndexOf(SEPARATOR)+1));
		setCurrentTime(timepoint);
		return new ApplicationMessage(ApplicationMessage.DATA_MESSAGE,getProgress(),timepoint,null,message);
	}else if (message.startsWith(PROGRESS_PREFIX)){
		String progressString = message.substring(message.lastIndexOf(SEPARATOR)+1,message.indexOf("%"));
		double progress = Double.parseDouble(progressString)/100.0;
		double startTime = getSimulation().getSolverTaskDescription().getTimeBounds().getStartingTime();
		double endTime = getSimulation().getSolverTaskDescription().getTimeBounds().getEndingTime();
		setCurrentTime(startTime + (endTime-startTime)*progress);
		return new ApplicationMessage(ApplicationMessage.PROGRESS_MESSAGE,progress,-1,null,message);
	}else{
		throw new RuntimeException("unrecognized message");
	}
}


/**
 * Insert the method's description here.
 * Creation date: (4/17/2001 8:47:08 AM)
 * @return java.lang.String
 */
public static String getDescription() {
	return "Finite Volume, Structured Grid";
}


/**
 * This method was created by a SmartGuide.
 */
public void initialize() throws SolverException {
	fireSolverStarting("processing geometry...");
	try {	
		cbit.vcell.geometry.Geometry geo = getSimulation().getMathDescription().getGeometry();
		PrintWriter pw = new PrintWriter(new FileWriter(new File(getSaveDirectory(), cppCoderVCell.getBaseFilename()+".vcg")));
		cbit.vcell.geometry.surface.GeometryFileWriter.write(geo, getSimulation().getMeshSpecification().getSamplingSize(),pw);
		pw.close();
	} catch (Exception ex) {
		throw new SolverException(ex.getMessage());
	}
	
	resampleFieldData();

	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING, "PDESolver initializing"));
	fireSolverStarting("PDESolver initializing...");
	
	autoCode(false);
	
	String baseName = cppCoderVCell.getBaseFilename();
	String exeSuffix = System.getProperty(PropertyLoader.exesuffixProperty); // ".exe";
	File exeFile = new File(getSaveDirectory(), baseName + exeSuffix);
	boolean bCORBA = false;

	setSolverStatus(new SolverStatus(SolverStatus.SOLVER_RUNNING,"PDESolver starting"));
	
	try{
		bCORBA = Boolean.getBoolean(PropertyLoader.corbaEnabled);
	}catch (Throwable t){}

	if (bCORBA) {
		throw new RuntimeException("MathExecutableCORBA not supported");
		//executable = new MathExecutableCORBA(exeFile,mathDesc.getSimulationID(),getSessionLog());
	}else{
		setMathExecutable(new MathExecutable(exeFile));
	}

}

/**
 * Insert the method's description here.
 * Creation date: (9/21/2006 1:28:12 PM)
 */
private void resampleFieldData() throws SolverException {
	fireSolverStarting("resampling field data...");
	try {	
		cbit.vcell.simdata.FieldDataIdentifier[] fieldDataIDs = getFieldDataIdentifiers();
		if (fieldDataIDs != null) {
			for (int i = 0; i < fieldDataIDs.length; i ++) {
				File fieldFile = new File(getSaveDirectory(), cppCoderVCell.getBaseFilename() + fieldDataIDs[i].getDefaultFieldDataFileNameForSimulation());
				
				//PrintWriter pw = new PrintWriter(new FileWriter(new File(getSaveDirectory(), cppCoderVCell.getBaseFilename()+".fdat")));
				File origDataFile = new File(getSaveDirectory(), fieldDataIDs[i].getDataFilePath());
				if (fieldFile.exists() && origDataFile.lastModified() < fieldFile.lastModified()) {
					continue;
				}
				if (!origDataFile.exists()) {
					throw new RuntimeException("Field Data for " + fieldDataIDs[i].getFieldName() + " doesn't exist!");
				}

				if (fieldDataIDs[i].getOrigin().compareEqual(getSimulation().getMathDescription().getGeometry().getOrigin())
					&& fieldDataIDs[i].getExtent().compareEqual(getSimulation().getMathDescription().getGeometry().getExtent()) 
					&& fieldDataIDs[i].getSize().compareEqual(getSimulation().getMeshSpecification().getSamplingSize())) {
					org.vcell.util.FileUtils.copyFile(origDataFile, fieldFile);
				} else {
					CartesianMesh origMesh = CartesianMesh.createSimpleCartesianMesh(fieldDataIDs[i].getOrigin(), fieldDataIDs[i].getExtent(), fieldDataIDs[i].getSize());
					CartesianMesh newMesh = CartesianMesh.createSimpleCartesianMesh(getSimulation().getMathDescription().getGeometry().getOrigin(), getSimulation().getMathDescription().getGeometry().getExtent(),
						getSimulation().getMeshSpecification().getSamplingSize());

					double[] origData = cbit.vcell.simdata.DataSet.fetchSimData(fieldDataIDs[i].getVariableName(), origDataFile);
					double[] newData = null;
					
					switch (getSimulation().getMathDescription().getGeometry().getDimension()) {
						case 1:
							newData = cbit.vcell.solver.test.MathTestingUtilities.resample1DSpatialSimple(origData, origMesh, newMesh);
							break;
						case 2:
							newData = cbit.vcell.solver.test.MathTestingUtilities.resample2DSpatialSimple(origData, origMesh, newMesh);
							break;
						case 3:
							newData = cbit.vcell.solver.test.MathTestingUtilities.resample3DSpatialSimple(origData, origMesh, newMesh);
							break;					
					}				
					cbit.vcell.simdata.DataSet.write(fieldFile, fieldDataIDs[i].getVariableName(), VariableType.VOLUME.getType(), getSimulation().getMeshSpecification().getSamplingSize(), newData);
				}
			}
		}
	} catch (Exception ex) {
		throw new SolverException(ex.getMessage());
	}
}

/**
 * Insert the method's description here.
 * Creation date: (6/27/2001 2:33:03 PM)
 */
public void propertyChange(java.beans.PropertyChangeEvent event) {
	super.propertyChange(event);
	
	if (event.getSource() == getMathExecutable() && event.getPropertyName().equals("applicationMessage")) {
		String messageString = (String)event.getNewValue();
		if (messageString==null || messageString.length()==0){
			return;
		}
		ApplicationMessage appMessage = getApplicationMessage(messageString);
		if (appMessage!=null && appMessage.getMessageType() == ApplicationMessage.DATA_MESSAGE) {
			fireSolverPrinted(appMessage.getTimepoint());
		}
	}
}
}