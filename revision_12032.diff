Index: src/cbit/vcell/message/jms/ConsumerContextJms.java
===================================================================
--- src/cbit/vcell/message/jms/ConsumerContextJms.java	(revision 12032)
+++ src/cbit/vcell/message/jms/ConsumerContextJms.java	(revision 12031)
@@ -27,6 +27,7 @@
 import cbit.vcell.message.VCRpcRequest;
 import cbit.vcell.message.VCTopicConsumer;
 import cbit.vcell.message.VCellQueue;
+import cbit.vcell.messaging.server.RpcRequest;
 import cbit.vcell.mongodb.VCMongoMessage;
 
 public class ConsumerContextJms implements Runnable {
@@ -76,12 +77,14 @@
 						}
 						ObjectMessage objectMessage = (ObjectMessage)jmsMessage;
 						Serializable object = objectMessage.getObject();
-						if (!(object instanceof VCRpcRequest)){
+						if (!(object instanceof VCRpcRequest) && !(object instanceof RpcRequest)){
 							jmsSession.commit();
 							throw new VCMessagingException("expecting RpcRequest in message");
 						}
 						VCRpcRequest vcRpcRequest = null;
-						if (object instanceof VCRpcRequest){
+						if (object instanceof RpcRequest){
+							vcRpcRequest = VCRpcRequest.fromRpcRequest(((RpcRequest)object));
+						} else if (object instanceof VCRpcRequest){
 							vcRpcRequest = (VCRpcRequest)object;
 						}
 						
Index: src/cbit/vcell/message/VCRpcRequest.java
===================================================================
--- src/cbit/vcell/message/VCRpcRequest.java	(revision 12032)
+++ src/cbit/vcell/message/VCRpcRequest.java	(revision 12031)
@@ -20,7 +20,9 @@
 import org.vcell.util.SessionLog;
 import org.vcell.util.document.User;
 
+import cbit.vcell.messaging.server.RpcRequest;
 
+
 /**
  * Insert the type's description here.
  * Creation date: (5/13/2003 1:41:34 PM)
@@ -194,4 +196,9 @@
 	}
 }
 
+public static VCRpcRequest fromRpcRequest(RpcRequest rpcRequest) {
+	VCRpcRequest vcRpcRequest = new VCRpcRequest(rpcRequest.getUser(), rpcRequest.getRequestedServiceType(), rpcRequest.getMethodName(), rpcRequest.getArguments());
+	return vcRpcRequest;
 }
+
+}
Index: src/cbit/vcell/message/server/ServiceStatus.java
===================================================================
--- src/cbit/vcell/message/server/ServiceStatus.java	(revision 12032)
+++ src/cbit/vcell/message/server/ServiceStatus.java	(revision 12031)
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server;
-
-import java.io.Serializable;
-import java.util.Date;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.Compare;
-import org.vcell.util.Matchable;
-
-import cbit.htc.PbsJobID;
-
-import static cbit.vcell.message.server.ManageConstants.*;
-
-public class ServiceStatus implements ComparableObject, Matchable, Serializable {
-	private ServiceSpec serviceSpec = null;
-	private Date date = null;
-	private int status;
-	private String statusMsg;
-	private PbsJobID pbsJobId;
-	
-	public ServiceStatus(ServiceSpec ss, Date d, int s, String sm, PbsJobID pbsJobID) {
-		super();
-		this.serviceSpec = ss;
-		this.date = d;
-		this.status = s;
-		this.statusMsg = sm;
-		this.pbsJobId = pbsJobID;
-	}
-
-	public Date getDate() {
-		return date;
-	}
-
-	public ServiceSpec getServiceSpec() {
-		return serviceSpec;
-	}
-
-	public int getStatus() {
-		return status;
-	}
-
-	public String getStatusMsg() {
-		return statusMsg;
-	}
-	
-	public boolean isRunning() {
-		return status == ManageConstants.SERVICE_STATUS_RUNNING;
-	}
-	public Object[] toObjects(){
-		return new Object[]{serviceSpec.getServerID(), serviceSpec.getType(), serviceSpec.getOrdinal(), 
-				SERVICE_STARTUP_TYPES[serviceSpec.getStartupType()], serviceSpec.getMemoryMB(), date, SERVICE_STATUSES[status], statusMsg, pbsJobId};		
-	}
-
-	public boolean equals(Object obj) {
-		if (obj instanceof Matchable) {
-			return compareEqual((Matchable)obj);
-		}
-		return false;
-	}
-	
-	public boolean compareEqual(Matchable obj) {
-		if (obj instanceof ServiceStatus) {
-			ServiceStatus ss = (ServiceStatus)obj;
-		
-			if (!serviceSpec.compareEqual(ss.serviceSpec)) {
-				return false;
-			}
-			if (!date.equals(ss.date)) {
-				return false;
-			}
-			if (status != ss.status) {
-				return false;
-			}
-			if (!statusMsg.equals(ss.statusMsg)) {
-				return false;
-			}
-			if (!Compare.isEqualOrNull(pbsJobId, ss.pbsJobId)) {
-				return false;
-			}
-			return true;
-		}
-		return false;
-	}
-
-	public PbsJobID getPbsJobId() {
-		return pbsJobId;
-	}
-	
-	public String toString() {
-		return serviceSpec.toString();
-	}
-}
Index: src/cbit/vcell/message/server/ManageConstants.java
===================================================================
--- src/cbit/vcell/message/server/ManageConstants.java	(revision 12032)
+++ src/cbit/vcell/message/server/ManageConstants.java	(revision 12031)
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server;
-import org.vcell.util.MessageConstants;
-
-/**
- * Insert the type's description here.
- * Creation date: (8/8/2003 10:23:15 AM)
- * @author: Fei Gao
- */
-public interface ManageConstants {
-	public static final long INTERVAL_PING_SERVICE = 10 * MessageConstants.MINUTE_IN_MS; // in minutes
-	public static final long INTERVAL_PING_RESPONSE = 10 * MessageConstants.SECOND_IN_MS; // in milliseconds
-
-	public static final String MESSAGE_TYPE_PROPERTY = MessageConstants.MESSAGE_TYPE_PROPERTY;
-	public static final String MESSAGE_TYPE_ISSERVICEALIVE_VALUE	= "IsServiceAlive";
-	public static final String MESSAGE_TYPE_IAMALIVE_VALUE	= "IAmAlive";		
-	public static final String MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE	= "AskPerformance";
-	public static final String MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE	= "RefreshServerManager";
-	public static final String MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE	= "ReplyPerformance";
-//	public static final String MESSAGE_TYPE_STARTSERVICE_VALUE	= "StartService";
-	public static final String MESSAGE_TYPE_STOPSERVICE_VALUE	= "StopService";
-
-	public static final String MESSAGE_TYPE_BROADCASTMESSAGE_VALUE	= "BroadcastMessage";
-	public static final String BROADCASTMESSAGE_CONTENT_PROPERTY = "BroadcastMessageContent";
-
-	public static final String FILE_NAME_PROPERTY = "FileName";
-	public static final String FILE_LENGTH_PROPERTY = "FileLength";
-	
-	public static final int SERVICE_STARTUPTYPE_AUTOMATIC = 0;	// restart it if the service is dead 
-	public static final int SERVICE_STARTUPTYPE_MANUAL = 1;
-	
-	public static final String[] SERVICE_STARTUP_TYPES = {"automatic", "manual"};
-
-	public static final int SERVICE_STATUS_RUNNING = 0;	// restart it if the service is dead 
-	public static final int SERVICE_STATUS_NOTRUNNING = 1;	// restart it if the service is dead
-	public static final int SERVICE_STATUS_FAILED = 2; 	
-
-	public static final String[] SERVICE_STATUSES = {"running", "not running", "failed"};
-	
-	public static final String SERVICE_ID_PROPERTY	= "ServiceID";
-	
-	public static final String SERVERID_RELEASE = "REL";
-	public static final String SERVERID_ALPHA = "ALPHA";
-	public static final String SERVERID_BETA = "BETA";
-	
-	public static final String AllSites[] = {SERVERID_ALPHA, SERVERID_BETA, SERVERID_RELEASE};	
-}
Index: src/cbit/vcell/message/server/ManageUtils.java
===================================================================
--- src/cbit/vcell/message/server/ManageUtils.java	(revision 12032)
+++ src/cbit/vcell/message/server/ManageUtils.java	(revision 12031)
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server;
-import java.net.UnknownHostException;
-import java.util.StringTokenizer;
-
-import org.vcell.util.Executable;
-
-import cbit.vcell.resource.ResourceUtil;
-
-/**
- * Insert the type's description here.
- * Creation date: (8/11/2003 11:41:43 AM)
- * @author: Fei Gao
- */
-public class ManageUtils {
-	private static java.text.SimpleDateFormat dateTimeFormatter = new java.text.SimpleDateFormat(" yyyy_MM_dd 'at' HH-mm-ss", java.util.Locale.US);
-
-/**
- * ManageUtils constructor comment.
- */
-public ManageUtils() {
-	super();
-}
-
-public static String getHostName() {
-	try {
-		String hostname = cbit.vcell.message.server.ManageUtils.getLocalHostName();
-		StringTokenizer st = new StringTokenizer(hostname, ".");
-		hostname = st.nextToken(); // abbr hostname
-		return hostname;
-	} catch (UnknownHostException ex) {
-		ex.printStackTrace();
-		return "UnknownHost";
-	}	 
-}
-
-/**
- * Insert the method's description here.
- * Creation date: (10/26/2001 5:49:02 PM)
- * @return boolean
- * @param file java.io.File
- * @param archiveDirectory java.io.File
- */
-public static void archiveByDateAndTime(String fileName, String arcDir) {
-	try {
-		if (fileName == null) {
-			return;
-		}
-		
-		java.io.File archiveDirectory = null;
-		java.io.File file = new java.io.File(fileName);
-			
-		if (arcDir == null) {
-			archiveDirectory = new java.io.File("." + java.io.File.separator);
-		} else {
-			archiveDirectory = new java.io.File(arcDir);
-		}
-		
-		archiveDirectory.mkdir(); // in case it isn't there...
-		if (file.exists()) {
-			String archivedName = file.getName() + dateTimeFormatter.format(new java.util.Date());
-			file.renameTo(new java.io.File(archiveDirectory, archivedName));
-		}
-	} catch (Throwable exc) {
-		exc.printStackTrace(System.out);
-	}
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (9/25/2003 8:43:41 AM)
- * @return java.lang.String
- * @param keyword java.lang.String
- */
-public static String getEnvVariable(String keyword, org.vcell.util.SessionLog log) {
-	String value = null;
-	String[] command = null;
-	
-	if (ResourceUtil.bWindows) {
-		command = new String[]{"cmd.exe", "/c" , "echo %" + keyword + "%"};
-	} else {
-		command = new String[]{"echo", "$" + keyword};
-	}
-	
-	try {
-		Executable exe = new Executable(command);
-		exe.start();
-		value = exe.getStdoutString().trim();
-	} catch (Exception e) {
-		log.exception(e);
-	}
-	
-	return value;
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (12/3/2003 9:32:25 AM)
- * @return java.lang.String
- */
-public static String getFullLocalHostName() throws java.net.UnknownHostException {
-	java.net.InetAddress inet = java.net.InetAddress.getLocalHost();	
-	String hostName = java.net.InetAddress.getByName(inet.getHostAddress()).getHostName();
-	return hostName;
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (12/3/2003 9:32:25 AM)
- * @return java.lang.String
- */
-public static String getLocalHostName() throws java.net.UnknownHostException {
-	String hostName = java.net.InetAddress.getLocalHost().getHostName();
-	if (hostName != null) {
-		hostName = hostName.toLowerCase();
-	}
-	return hostName;
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (12/4/2003 7:38:11 AM)
- * @return java.lang.String
- */
-public static String readLog(java.io.File file) throws java.io.IOException {
-	java.io.FileReader reader = new java.io.FileReader(file);
-	char[] content = new char[10000];
-	String out = "";
-	while (true) {
-		int n = reader.read(content, 0, 10000);
-		if (n == -1) {
-			break;
-		} else
-			if (n > 0) {
-				out += new String(content, 0, n);
-			}
-	}
-	reader.close();
-	return out;
-}
-}
Index: src/cbit/vcell/message/server/ServiceInstanceStatus.java
===================================================================
--- src/cbit/vcell/message/server/ServiceInstanceStatus.java	(revision 12032)
+++ src/cbit/vcell/message/server/ServiceInstanceStatus.java	(revision 12031)
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server;
-
-import java.io.Serializable;
-import java.util.Date;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.Matchable;
-import org.vcell.util.MessageConstants.ServiceType;
-import org.vcell.util.document.VCellServerID;
-
-
-
-public class ServiceInstanceStatus implements Matchable, Serializable, ComparableObject {
-	private VCellServerID serverID;
-	private ServiceType type;
-	private int ordinal;
-	private Date startDate;
-	private String hostname;	
-	private boolean bRunning = false;
-		
-	public ServiceInstanceStatus(VCellServerID sID, ServiceType t, int o, String h, Date d, boolean br) {
-		super();
-		this.serverID = sID;
-		this.type = t;
-		this.ordinal = o;
-		hostname = h;
-		startDate = d;
-		this.bRunning = br;
-	}
-	
-	public int getOrdinal() {
-		return ordinal;
-	}
-
-	public VCellServerID getServerID() {
-		return serverID;
-	}
-
-	public ServiceType getType() {
-		return type;
-	}
-	
-	public String toString() {
-		return "[" + serverID + "," + type + "," + ordinal + "," + "," + hostname + "," + startDate + "," + bRunning + "]";
-	}
-
-	public String getID() {
-		return getSpecID() + "_" + hostname + "_" + startDate.getTime();
-	}
-	
-	public String getSpecID() {
-		return ServiceSpec.getServiceID(serverID, type, ordinal);
-	}
-	
-	public Object[] toObjects() {
-		return new Object[] {serverID, type, ordinal, hostname, startDate, bRunning};
-	}
-		
-	public boolean equals(Object obj) {
-		if (obj instanceof Matchable) {
-			return compareEqual((Matchable)obj);
-		}
-		return false;
-	}
-	
-	public int hashCode() {
-		return getID().hashCode();
-	}
-	
-	public boolean compareEqual(Matchable obj) {
-		if (obj instanceof ServiceInstanceStatus) {
-			ServiceInstanceStatus ss = (ServiceInstanceStatus)obj;
-		
-			if (!serverID.equals(ss.serverID)) {
-				return false;
-			}
-			if (!type.equals(ss.type)) {
-				return false;
-			}
-			if (ordinal != ss.ordinal) {
-				return false;
-			}		
-			if (!hostname.equals(ss.hostname)) {
-				return false;
-			}
-			if (!startDate.equals(ss.startDate)) {
-				return false;
-			}
-			return true;
-		}		
-		return false;
-	}
-
-	public boolean isRunning() {
-		return bRunning;
-	}
-
-	public void setRunning(boolean running) {
-		bRunning = running;
-	}
-
-	public Date getStartDate() {
-		return startDate;
-	}
-}
Index: src/cbit/vcell/message/server/ServiceSpec.java
===================================================================
--- src/cbit/vcell/message/server/ServiceSpec.java	(revision 12032)
+++ src/cbit/vcell/message/server/ServiceSpec.java	(revision 12031)
@@ -1,99 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server;
-
-import static cbit.vcell.message.server.ManageConstants.SERVICE_STARTUP_TYPES;
-
-import java.io.Serializable;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.Matchable;
-import org.vcell.util.MessageConstants.ServiceType;
-import org.vcell.util.document.VCellServerID;
-
-
-
-public class ServiceSpec implements Matchable, Serializable, ComparableObject {
-	private VCellServerID serverID;
-	private ServiceType type;
-	private int ordinal;
-	private int startupType;
-	private int memoryMB;	
-	
-	public ServiceSpec(VCellServerID sID, ServiceType t, int o, int st, int mm) {
-		super();
-		this.serverID = sID;
-		this.type = t;
-		this.ordinal = o;
-		this.startupType = st;
-		this.memoryMB = mm;
-	}
-	
-	public int getMemoryMB() {
-		return memoryMB;
-	}
-
-	public int getOrdinal() {
-		return ordinal;
-	}
-
-	public VCellServerID getServerID() {
-		return serverID;
-	}
-
-	public ServiceType getType() {
-		return type;
-	}
-	
-	public String toString() {
-		return "[" + serverID + "," + type + "," + ordinal + "," + ManageConstants.SERVICE_STARTUP_TYPES[startupType] + "," + memoryMB + "M]";
-	}
-
-	public int getStartupType() {
-		return startupType;
-	}
-
-	public String getID() {
-		return getServiceID(serverID, type, ordinal);
-	}
-	public static String getServiceID(VCellServerID serverID, ServiceType type, int ordinal) {
-		return serverID + "_" + type.getName() + "_" + ordinal;
-	}
-	
-	public Object[] toObjects() {
-		return new Object[] {serverID, type, ordinal, SERVICE_STARTUP_TYPES[startupType], memoryMB};
-	}
-		
-	public boolean equals(Object obj) {
-		if (obj instanceof Matchable) {
-			return compareEqual((Matchable)obj);
-		}
-		return false;
-	}
-	
-	public boolean compareEqual(Matchable obj) {
-		if (obj instanceof ServiceSpec) {
-			ServiceSpec ss = (ServiceSpec)obj;
-		
-			if (!serverID.equals(ss.serverID)) {
-				return false;
-			}
-			if (!type.equals(ss.type)) {
-				return false;
-			}
-			if (ordinal != ss.ordinal) {
-				return false;
-			}			
-			return true;
-		}		
-		return false;
-	}
-}
Index: src/cbit/vcell/message/server/console/ServiceInstanceStatusTableModel.java
===================================================================
--- src/cbit/vcell/message/server/console/ServiceInstanceStatusTableModel.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/ServiceInstanceStatusTableModel.java	(revision 12031)
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-
-import java.util.Comparator;
-import java.util.Date;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.MessageConstants.ServiceType;
-import org.vcell.util.gui.sorttable.ColumnComparator;
-
-import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
-
-
-/**
- * Insert the type's description here.
- * Creation date: (8/19/2003 10:46:32 AM)
- * @author: Fei Gao
- */
-@SuppressWarnings("serial")
-public class ServiceInstanceStatusTableModel extends VCellSortTableModel<ComparableObject> {
-
-public ServiceInstanceStatusTableModel() {
-	super(new String[]{"Site", "Type", "Ordinal", "Host", "Start Date", "Running"});
-}
-
-public Class<?> getColumnClass(int columnIndex) {
-	if (columnIndex == 0 || columnIndex == 3) {
-		return String.class;
-	}		
-	if (columnIndex == 1) {
-		return ServiceType.class;
-	}
-	if (columnIndex == 5) {
-		return Boolean.class;
-	}
-	if (columnIndex == 2) {
-		return Number.class;
-	}
-	if (columnIndex == 4) {
-		return Date.class;
-	}
-	return Object.class;
-}
-
-public Object getValueAt(int row, int col) {
-	ComparableObject status = getValueAt(row);
-	Object[] values = status.toObjects();
-	return values[col];
-}
-
-public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
-	return new ColumnComparator(col, ascending);
-}
-}
Index: src/cbit/vcell/message/server/console/AddNewServiceDialog.java
===================================================================
--- src/cbit/vcell/message/server/console/AddNewServiceDialog.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/AddNewServiceDialog.java	(revision 12031)
@@ -1,504 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-
-import java.awt.Color;
-
-import javax.swing.*;
-
-import org.vcell.util.MessageConstants.ServiceType;
-import org.vcell.util.document.VCellServerID;
-
-import cbit.vcell.message.server.ManageConstants;
-import cbit.vcell.message.server.ServiceSpec;
-
-
-/**
- * Insert the type's description here.
- * Creation date: (8/22/2003 3:43:58 PM)
- * @author: Fei Gao
- */
-public class AddNewServiceDialog extends javax.swing.JDialog {
-	private javax.swing.JButton ivjNewButton = null;
-	private javax.swing.JButton ivjCancelButton = null;
-	private javax.swing.JComboBox ivjOrdinalCombo = null;
-	private javax.swing.JTextField ivjSiteField = null;
-	private javax.swing.JComboBox ivjTypeCombo = null;	
-	private javax.swing.JComboBox ivjStartupCombo = null;
-	private javax.swing.JTextField ivjMemoryMBField = null;
-	private javax.swing.JPanel ivjJDialogContentPane = null;
-	private JPanel ivjMainPanel = null;
-	public boolean action = false;
-	IvjEventHandler ivjEventHandler = new IvjEventHandler();
-
-class IvjEventHandler implements java.awt.event.ActionListener {
-		public void actionPerformed(java.awt.event.ActionEvent e) {
-			if (e.getSource() == AddNewServiceDialog.this.getNewButton()) 
-				connEtoC1(e);
-			if (e.getSource() == AddNewServiceDialog.this.getCancelButton()) 
-				connEtoC2(e);
-		}
-	};
-/**
- * AddNewServiceDialog constructor comment.
- */
-public AddNewServiceDialog() {
-	super();
-	initialize();
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Dialog
- */
-public AddNewServiceDialog(java.awt.Dialog owner) {
-	super(owner);
-	initialize();
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Dialog
- * @param title java.lang.String
- */
-public AddNewServiceDialog(java.awt.Dialog owner, String title) {
-	super(owner, title);
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Dialog
- * @param title java.lang.String
- * @param modal boolean
- */
-public AddNewServiceDialog(java.awt.Dialog owner, String title, boolean modal) {
-	super(owner, title, modal);
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Dialog
- * @param modal boolean
- */
-public AddNewServiceDialog(java.awt.Dialog owner, boolean modal) {
-	super(owner, modal);
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Frame
- */
-public AddNewServiceDialog(java.awt.Frame owner) {
-	super(owner);
-	initialize();
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Frame
- * @param title java.lang.String
- */
-public AddNewServiceDialog(java.awt.Frame owner, String title) {
-	super(owner, title);
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Frame
- * @param title java.lang.String
- * @param modal boolean
- */
-public AddNewServiceDialog(java.awt.Frame owner, String title, boolean modal) {
-	super(owner, title, modal);
-}
-/**
- * AddNewServiceDialog constructor comment.
- * @param owner java.awt.Frame
- * @param modal boolean
- */
-public AddNewServiceDialog(java.awt.Frame owner, boolean modal) {
-	super(owner, modal);
-}
-/**
- * Comment
- */
-public void newButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {	
-	if (getTypeCombo().getSelectedIndex() < 0 
-			|| getOrdinalCombo().getSelectedItem() == null || getStartupCombo().getSelectedIndex() < 0
-			|| getMemoryMBField().getText().length() == 0) {
-		javax.swing.JOptionPane.showMessageDialog(this, "Some fields are missing!", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
-		return;
-	}
-	
-	try {
-		int ordinal = Integer.parseInt("" + getOrdinalCombo().getSelectedItem());
-	} catch (NumberFormatException ex) {
-		javax.swing.JOptionPane.showMessageDialog(this, "Ordinal must be a number!", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
-		return;
-	}
-	
-	action = true;
-	dispose();
-	return;
-}
-/**
- * Comment
- */
-public void cancelButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
-	action = false;
-	dispose();
-	return;
-}
-
-/**
- * connEtoC1:  (AddNewAddButton.action.actionPerformed(java.awt.event.ActionEvent) --> AddNewServiceDialog.addNewAddButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
- * @param arg1 java.awt.event.ActionEvent
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private void connEtoC1(java.awt.event.ActionEvent arg1) {
-	try {
-		// user code begin {1}
-		// user code end
-		this.newButton_ActionPerformed(arg1);
-		// user code begin {2}
-		// user code end
-	} catch (java.lang.Throwable ivjExc) {
-		// user code begin {3}
-		// user code end
-		handleException(ivjExc);
-	}
-}
-/**
- * connEtoC2:  (AddNewCancelButton.action.actionPerformed(java.awt.event.ActionEvent) --> AddNewServiceDialog.addNewCancelButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
- * @param arg1 java.awt.event.ActionEvent
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private void connEtoC2(java.awt.event.ActionEvent arg1) {
-	try {
-		// user code begin {1}
-		// user code end
-		this.cancelButton_ActionPerformed(arg1);
-		// user code begin {2}
-		// user code end
-	} catch (java.lang.Throwable ivjExc) {
-		// user code begin {3}
-		// user code end
-		handleException(ivjExc);
-	}
-}
-/**
- * Return the AddNewAddButton property value.
- * @return javax.swing.JButton
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private javax.swing.JButton getNewButton() {
-	if (ivjNewButton == null) {
-		try {
-			ivjNewButton = new javax.swing.JButton();
-			ivjNewButton.setText("New");
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjNewButton;
-}
-
-/**
- * Return the AddNewCancelButton property value.
- * @return javax.swing.JButton
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private javax.swing.JButton getCancelButton() {
-	if (ivjCancelButton == null) {
-		try {
-			ivjCancelButton = new javax.swing.JButton();
-			ivjCancelButton.setText("Cancel");
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjCancelButton;
-}
-
-/**
- * Return the AddNewLogFileField property value.
- * @return javax.swing.JTextField
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private javax.swing.JTextField getMemoryMBField() {
-	if (ivjMemoryMBField == null) {
-		try {
-			ivjMemoryMBField = new javax.swing.JTextField();
-			ivjMemoryMBField.setText("100");
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjMemoryMBField;
-}
-
-/**
- * Return the AddNewServiceNameField property value.
- * @return javax.swing.JTextField
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private javax.swing.JComboBox getOrdinalCombo() {
-	if (ivjOrdinalCombo == null) {
-		try {
-			ivjOrdinalCombo = new javax.swing.JComboBox();
-			for (int i = 0; i < 20; i ++) {
-				ivjOrdinalCombo.addItem(i);
-			}
-			ivjOrdinalCombo.setSelectedIndex(-1);
-			ivjOrdinalCombo.setEditable(true);
-			
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjOrdinalCombo;
-}
-
-private javax.swing.JTextField getSiteField() {
-	if (ivjSiteField == null) {
-		try {
-			ivjSiteField = new javax.swing.JTextField();
-			ivjSiteField.setText(VCellServerID.getSystemServerID().toString());
-			ivjSiteField.setEditable(false);
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjSiteField;
-}
-
-private javax.swing.JComboBox getStartupCombo() {
-	if (ivjStartupCombo == null) {
-		try {
-			ivjStartupCombo = new javax.swing.JComboBox();
-			for (int i = 0; i < ManageConstants.SERVICE_STARTUP_TYPES.length; i ++) {
-				ivjStartupCombo.addItem(ManageConstants.SERVICE_STARTUP_TYPES[i]);
-			}			
-			ivjStartupCombo.setSelectedIndex(0);
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjStartupCombo;
-}
-
-private javax.swing.JComboBox getTypeCombo() {
-	if (ivjTypeCombo == null) {
-		try {
-			ivjTypeCombo = new javax.swing.JComboBox();
-			for (ServiceType st : ServiceType.values()) {
-				if (!st.equals(ServiceType.SERVERMANAGER)) {
-					ivjTypeCombo.addItem(st);
-				}
-			}			
-			ivjTypeCombo.setSelectedIndex(-1);
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjTypeCombo;
-}
-
-/**
- * Return the JDialogContentPane property value.
- * @return javax.swing.JPanel
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private javax.swing.JPanel getJDialogContentPane() {
-	if (ivjJDialogContentPane == null) {
-		try {
-			ivjJDialogContentPane = new javax.swing.JPanel();
-			ivjJDialogContentPane.setName("JDialogContentPane");
-			ivjJDialogContentPane.setLayout(new java.awt.BorderLayout());
-			
-			JPanel panel3 = new JPanel(new java.awt.FlowLayout());
-			panel3.add(getNewButton());
-			panel3.add(getCancelButton());
-			
-			getJDialogContentPane().add(panel3, "South");
-			getJDialogContentPane().add(getMainPanel(), "Center");
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjJDialogContentPane;
-}
-
-/**
- * Return the JPanel4 property value.
- * @return javax.swing.JPanel
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private javax.swing.JPanel getMainPanel() {
-	if (ivjMainPanel == null) {
-		try {
-			ivjMainPanel = new javax.swing.JPanel();
-			ivjMainPanel.setLayout(new java.awt.GridLayout(5, 2));
-			ivjMainPanel.add(new JLabel("Site"));
-			ivjMainPanel.add(getSiteField());
-			ivjMainPanel.add(new JLabel("Type"));
-			ivjMainPanel.add(getTypeCombo());
-			ivjMainPanel.add(new JLabel("Ordinal"));
-			ivjMainPanel.add(getOrdinalCombo());
-			ivjMainPanel.add(new JLabel("Startup Type"));
-			ivjMainPanel.add(getStartupCombo());
-			ivjMainPanel.add(new JLabel("Memory MB"));
-			ivjMainPanel.add(getMemoryMBField());
-			// user code begin {1}
-			// user code end
-		} catch (java.lang.Throwable ivjExc) {
-			// user code begin {2}
-			// user code end
-			handleException(ivjExc);
-		}
-	}
-	return ivjMainPanel;
-}
-
-/**
- * Insert the method's description here.
- * Creation date: (8/22/2003 4:07:31 PM)
- * @return cbit.vcell.messaging.admin.VCellServiceConfig
- */
-public ServiceSpec getServiceSpec() {
-	VCellServerID site = VCellServerID.getServerID(getSiteField().getText());
-	ServiceType stype = (ServiceType)getTypeCombo().getSelectedItem();
-	int ordinal = 0;
-	try {
-		ordinal = Integer.parseInt("" + getOrdinalCombo().getSelectedItem());
-	} catch (NumberFormatException ex) {
-		throw new RuntimeException("Ordinal must be a number!");		
-	}
-	int startup = getStartupCombo().getSelectedIndex();
-	int memoryMB = Integer.parseInt(getMemoryMBField().getText());
-
-	return new ServiceSpec(site, stype, ordinal, startup, memoryMB);
-}
-/**
- * Called whenever the part throws an exception.
- * @param exception java.lang.Throwable
- */
-private void handleException(java.lang.Throwable exception) {
-
-	/* Uncomment the following lines to print uncaught exceptions to stdout */
-	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
-	// exception.printStackTrace(System.out);
-}
-/**
- * Initializes connections
- * @exception java.lang.Exception The exception description.
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private void initConnections() throws java.lang.Exception {
-	// user code begin {1}
-	// user code end
-	getNewButton().addActionListener(ivjEventHandler);
-	getCancelButton().addActionListener(ivjEventHandler);
-}
-/**
- * Initialize the class.
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private void initialize() {
-	try {
-		// user code begin {1}
-		// user code end
-		setTitle("Add new service");
-		setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
-		setSize(471, 225);
-		setModal(true);
-		setResizable(false);
-		setContentPane(getJDialogContentPane());
-		initConnections();
-	} catch (java.lang.Throwable ivjExc) {
-		handleException(ivjExc);
-	}
-	// user code begin {2}
-	// user code end
-}
-
-public void modifyService(ServiceSpec ss) {
-	this.setTitle("Modify Service");
-	getNewButton().setText("Modify");	 
-	getSiteField().setText(ss.getServerID().toString());
-	getSiteField().setEditable(false);
-	getSiteField().setBackground(Color.white);
-	getTypeCombo().setSelectedItem(ss.getType());
-	getTypeCombo().setEnabled(false);
-	getTypeCombo().setBackground(Color.white);
-	getOrdinalCombo().setSelectedItem(ss.getOrdinal());
-	getOrdinalCombo().setEnabled(false);
-	getOrdinalCombo().setBackground(Color.white);
-	getStartupCombo().setSelectedIndex(ss.getStartupType());
-	getMemoryMBField().setText(ss.getMemoryMB() + "");
-}
-/**
- * Insert the method's description here.
- * Creation date: (8/22/2003 5:10:29 PM)
- * @return boolean
- */
-public boolean isAction() {
-	return action;
-}
-/**
- * main entrypoint - starts the part when it is run as an application
- * @param args java.lang.String[]
- */
-public static void main(java.lang.String[] args) {
-	try {
-		AddNewServiceDialog aAddNewServiceDialog;
-		aAddNewServiceDialog = new AddNewServiceDialog();
-		aAddNewServiceDialog.setModal(true);
-		aAddNewServiceDialog.addWindowListener(new java.awt.event.WindowAdapter() {
-			public void windowClosing(java.awt.event.WindowEvent e) {
-				System.exit(0);
-			};
-		});
-		aAddNewServiceDialog.setVisible(true);
-		java.awt.Insets insets = aAddNewServiceDialog.getInsets();
-		aAddNewServiceDialog.setSize(aAddNewServiceDialog.getWidth() + insets.left + insets.right, aAddNewServiceDialog.getHeight() + insets.top + insets.bottom);
-		aAddNewServiceDialog.setVisible(true);
-	} catch (Throwable exception) {
-		System.err.println("Exception occurred in main() of javax.swing.JDialog");
-		exception.printStackTrace(System.out);
-	}
-}
-}
Index: src/cbit/vcell/message/server/console/JobTableModel.java
===================================================================
--- src/cbit/vcell/message/server/console/JobTableModel.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/JobTableModel.java	(revision 12031)
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-import java.util.Comparator;
-import java.util.Date;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.gui.sorttable.ColumnComparator;
-
-import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
-
-/**
- * Insert the type's description here.
- * Creation date: (8/28/2003 1:38:32 PM)
- * @author: Fei Gao
- */
-public class JobTableModel extends VCellSortTableModel<ComparableObject> {
-	public final static int columnIndex_UserID = 0;
-	public final static int columnIndex_SimID = 1;
-	private final static int columnIndex_JobIndex = 2;
-	private final static int columnIndex_SolverType = 3;
-	private final static int columnIndex_Status = 4;
-	private final static int columnIndex_ComputeHost = 5;
-	private final static int columnIndex_ServerID = 6;
-	private final static int columnIndex_TaskID = 7;
-	private final static int columnIndex_SubmitDate = 8;
-	private final static int columnIndex_StartDate = 9;
-	private final static int columnIndex_EndDate = 10;
-	private final static int columnIndex_ElapsedTime = 11;
-
-/**
- * JobTableModel constructor comment.
- */
-public JobTableModel() {
-	super(new String[]{"User ID", "Sim ID", "Job Index", "Solver Type", "Status", "Compute Host", "Server ID", "Task ID", "Submit Date", "Start Date", "End Date", "Elapsed (h:m:s)"});
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (8/19/2003 2:14:05 PM)
- * @return java.lang.Class
- * @param columnIndex int
- */
-public Class getColumnClass(int columnIndex) {
-	if (columnIndex == columnIndex_SimID || columnIndex == columnIndex_TaskID || columnIndex == columnIndex_JobIndex) {
-		return Number.class;
-	} else if (columnIndex == columnIndex_SubmitDate || columnIndex == columnIndex_StartDate || columnIndex == columnIndex_EndDate) {
-		return Date.class;
-	} else if (columnIndex == columnIndex_ElapsedTime){
-		return Long.class;
-	} else {		
-		return String.class;
-	}
-}
-
-/**
- * getValueAt method comment.
- */
-public Object getValueAt(int row, int col) {
-	ComparableObject jobStatus = getValueAt(row);
-	Object[] values = jobStatus.toObjects();
-	return values[col];
-}
-
-public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
-	return new ColumnComparator(col, ascending);
-}
-
-}
Index: src/cbit/vcell/message/server/console/UserConnectionTableModel.java
===================================================================
--- src/cbit/vcell/message/server/console/UserConnectionTableModel.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/UserConnectionTableModel.java	(revision 12031)
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-import java.util.Comparator;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.gui.sorttable.ColumnComparator;
-
-import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
-/**
- * Insert the type's description here.
- * Creation date: (2/27/2006 10:21:21 AM)
- * @author: Fei Gao
- */
-@SuppressWarnings("serial")
-public class UserConnectionTableModel extends VCellSortTableModel<ComparableObject> {
-	private final static int columnIndex_UserID = 0;
-	//private final static int columnIndex_ElapsedTime = 2;
-	//private final static int columnIndex_ConnectedTime = 1;
-
-/**
- * UserConnectionTableModel constructor comment.
- */
-public UserConnectionTableModel() {
-	super(new String[]{"User ID"});
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (8/19/2003 2:14:05 PM)
- * @return java.lang.Class
- * @param columnIndex int
- */
-public Class<?> getColumnClass(int columnIndex) {
-	if (columnIndex == columnIndex_UserID) {
-		return String.class;
-	}
-
-	return null;
-}
-
-
-	/**
-	 * Returns an attribute value for the cell at <I>columnIndex</I>
-	 * and <I>rowIndex</I>.
-	 *
-	 * @param	rowIndex	the row whose value is to be looked up
-	 * @param	columnIndex 	the column whose value is to be looked up
-	 * @return	the value Object at the specified cell
-	 */
-public Object getValueAt(int row, int col) {
-	ComparableObject userconn = getValueAt(row);
-	Object[] values = userconn.toObjects();
-	return values[col];
-}
-
-public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
-	return new ColumnComparator(col, ascending);
-}
-}
Index: src/cbit/vcell/message/server/console/SimpleUserConnection.java
===================================================================
--- src/cbit/vcell/message/server/console/SimpleUserConnection.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/SimpleUserConnection.java	(revision 12031)
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-import java.util.Date;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.document.User;
-/**
- * Insert the type's description here.
- * Creation date: (4/5/2006 9:39:11 AM)
- * @author: Fei Gao
- */
-public class SimpleUserConnection implements ComparableObject {
-	private User user = null;
-	private Date connectedTime = null;
-	private int elapsedTime = 0;
-
-/**
- * SimpleUserConnection constructor comment.
- */
-public SimpleUserConnection(User arg_user, Date arg_connectedTime) {
-	super();
-	user = arg_user;
-	connectedTime = arg_connectedTime;
-	elapsedTime = (int)(System.currentTimeMillis() - connectedTime.getTime());
-}
-
-
-/**
- * toObjects method comment.
- */
-public java.lang.Object[] toObjects() {
-	return new Object[] {user.getName(), connectedTime, new Integer(elapsedTime)};
-}
-}
Index: src/cbit/vcell/message/server/console/DatePanel.java
===================================================================
--- src/cbit/vcell/message/server/console/DatePanel.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/DatePanel.java	(revision 12031)
@@ -1,246 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-
-import java.awt.GridBagConstraints;
-import java.awt.GridBagLayout;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-
-import javax.swing.JLabel;
-import javax.swing.JTextField;
-
-/**
- * Insert the type's description here.
- * Creation date: (8/29/2003 2:51:26 PM)
- * @author: Fei Gao
- */
-@SuppressWarnings("serial")
-public class DatePanel extends javax.swing.JPanel {
-	private javax.swing.JComboBox ivjDayCombo = null;
-	private javax.swing.JComboBox ivjMonthCombo = null;
-	private javax.swing.JComboBox ivjYearCombo = null;
-	private IvjEventHandler ivjEventHandler = new IvjEventHandler();
-
-	private class IvjEventHandler implements java.awt.event.ItemListener {
-		public void itemStateChanged(java.awt.event.ItemEvent e) {
-			if (e.getSource() == DatePanel.this.getMonthCombo()) 
-				monthCombo_ItemEvent();
-			if (e.getSource() == DatePanel.this.getYearCombo()) 
-				yearCombo_ItemEvent();
-		}
-	};
-/**
- * DatePanel constructor comment.
- */
-public DatePanel() {
-	super();
-	initialize();
-}
-
-/**
- * Insert the method's description here.
- * Creation date: (8/29/2003 3:04:18 PM)
- */
-private void changeMonth() {
-	int month = Integer.parseInt((String)getMonthCombo().getSelectedItem());
-	int year = Integer.parseInt((String)getYearCombo().getSelectedItem());
-	java.util.GregorianCalendar cal = new java.util.GregorianCalendar(year, month - 1, 1);
-	getDayCombo().removeAllItems();
-
-	int maxday = cal.getActualMaximum(java.util.Calendar.DAY_OF_MONTH);
-	for (int i = 1; i <= maxday; i++){
-		getDayCombo().addItem(i + "");	
-	}
-}
-/**
- * Comment
- */
-public void reset() {
-	updateInterface(new GregorianCalendar());
-}
-/**
- * Insert the method's description here.
- * Creation date: (8/29/2003 3:17:06 PM)
- * @return java.util.Date
- */
-public Date getDate() {
-	int month = Integer.parseInt((String)getMonthCombo().getSelectedItem());
-	int day  = Integer.parseInt((String)getDayCombo().getSelectedItem());
-	int year = Integer.parseInt((String)getYearCombo().getSelectedItem());
-
-	java.util.GregorianCalendar calendar = new java.util.GregorianCalendar(year, month - 1, day);
-	return calendar.getTime();
-}
-
-/**
- * Return the JComboBox2 property value.
- * @return javax.swing.JComboBox
- */
-private javax.swing.JComboBox getDayCombo() {
-	if (ivjDayCombo == null) {
-		try {
-			ivjDayCombo = new javax.swing.JComboBox();
-			ivjDayCombo.setName("DayCombo");
-			ivjDayCombo.setToolTipText("Day");
-			JTextField tf = new JTextField(4);
-			ivjDayCombo.setPreferredSize(tf.getPreferredSize());
-			ivjDayCombo.setEditable(true);
-		} catch (java.lang.Throwable ivjExc) {
-			handleException(ivjExc);
-		}
-	}
-	return ivjDayCombo;
-}
-/**
- * Return the JComboBox1 property value.
- * @return javax.swing.JComboBox
- */
-private javax.swing.JComboBox getMonthCombo() {
-	if (ivjMonthCombo == null) {
-		try {
-			ivjMonthCombo = new javax.swing.JComboBox();
-			ivjMonthCombo.setName("MonthCombo");
-			ivjMonthCombo.setToolTipText("Month");
-			ivjMonthCombo.setEditable(true);
-			JTextField tf = new JTextField(4);
-			ivjMonthCombo.setPreferredSize(tf.getPreferredSize());
-		} catch (java.lang.Throwable ivjExc) {
-			handleException(ivjExc);
-		}
-	}
-	return ivjMonthCombo;
-}
-/**
- * Return the JComboBox3 property value.
- * @return javax.swing.JComboBox
- */
-private javax.swing.JComboBox getYearCombo() {
-	if (ivjYearCombo == null) {
-		try {
-			ivjYearCombo = new javax.swing.JComboBox();
-			ivjYearCombo.setName("YearCombo");
-			ivjYearCombo.setToolTipText("Year");
-			JTextField tf = new JTextField(6);
-			ivjYearCombo.setPreferredSize(tf.getPreferredSize());
-			ivjYearCombo.setEditable(true);
-		} catch (java.lang.Throwable ivjExc) {
-			handleException(ivjExc);
-		}
-	}
-	return ivjYearCombo;
-}
-/**
- * Called whenever the part throws an exception.
- * @param exception java.lang.Throwable
- */
-private void handleException(java.lang.Throwable exception) {
-
-	/* Uncomment the following lines to print uncaught exceptions to stdout */
-	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
-	// exception.printStackTrace(System.out);
-}
-/**
- * Initialize the class.
- */
-/* WARNING: THIS METHOD WILL BE REGENERATED. */
-private void initialize() {
-	try {
-		setName("DatePanel");
-		setLayout(new GridBagLayout());
-		GridBagConstraints gbc = new GridBagConstraints();
-		gbc.gridx = 0;
-		gbc.gridy = 0;
-		gbc.weightx = 1.0;
-		gbc.anchor = GridBagConstraints.LINE_START;
-		gbc.fill = GridBagConstraints.HORIZONTAL;
-		add(getMonthCombo(), gbc);
-		
-		gbc = new GridBagConstraints();
-		gbc.gridx = 1;
-		gbc.gridy = 0;
-		add(new JLabel("/"), gbc);
-		
-		gbc = new GridBagConstraints();
-		gbc.gridx = 2;
-		gbc.gridy = 0;
-		gbc.weightx = 1.0;
-		gbc.anchor = GridBagConstraints.LINE_START;
-		gbc.fill = GridBagConstraints.HORIZONTAL;
-		add(getDayCombo(), gbc);
-		
-		gbc = new GridBagConstraints();
-		gbc.gridx = 3;
-		gbc.gridy = 0;
-		add(new JLabel("/"), gbc);
-		
-		gbc = new GridBagConstraints();
-		gbc.gridx = 4;
-		gbc.gridy = 0;
-		gbc.weightx = 1;
-		gbc.anchor = GridBagConstraints.LINE_START;
-		gbc.fill = GridBagConstraints.HORIZONTAL;
-		add(getYearCombo(), gbc);
-		
-		Calendar cal = new GregorianCalendar();
-		int currYear = cal.get(java.util.Calendar.YEAR);
-		for (int i = -20; i <= 0; i ++) {
-			getYearCombo().addItem((i + currYear) + "");
-		}
-		for (int i = 1; i <= 12; i ++) {
-			getMonthCombo().addItem(i + "");
-		}
-		updateInterface(cal);
-		getMonthCombo().addItemListener(ivjEventHandler);
-		getYearCombo().addItemListener(ivjEventHandler);
-	} catch (java.lang.Throwable ivjExc) {
-		handleException(ivjExc);
-	}
-}
-/**
- * Comment
- */
-private void monthCombo_ItemEvent() {
-	changeMonth();
-}
-/**
- * Insert the method's description here.
- * Creation date: (9/3/2003 8:02:44 AM)
- */
-private void updateInterface(Calendar calendar) {
-	for (int i = 1; i <= calendar.getActualMaximum(java.util.Calendar.DAY_OF_MONTH); i ++) {
-		getDayCombo().addItem(i + "");
-	}
-	getYearCombo().setSelectedItem(calendar.get(java.util.Calendar.YEAR) + "");
-	getMonthCombo().setSelectedItem((calendar.get(java.util.Calendar.MONTH) + 1) + "");
-	getDayCombo().setSelectedItem(calendar.get(java.util.Calendar.DATE) + "");	
-}
-
-@Override
-public void setEnabled(boolean enabled) {
-	getYearCombo().setEnabled(enabled);
-	getMonthCombo().setEnabled(enabled);
-	getDayCombo().setEnabled(enabled);
-	super.setEnabled(enabled);
-}
-/**
- * Comment
- */
-private void yearCombo_ItemEvent() {
-	changeMonth();
-	return;
-}
-
-public void setCalendar(Calendar cal) {
-	updateInterface(cal);
-}
-}
Index: src/cbit/vcell/message/server/console/ServiceStatusTableModel.java
===================================================================
--- src/cbit/vcell/message/server/console/ServiceStatusTableModel.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/ServiceStatusTableModel.java	(revision 12031)
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.message.server.console;
-
-import java.util.Comparator;
-import java.util.Date;
-
-import org.vcell.util.ComparableObject;
-import org.vcell.util.MessageConstants.ServiceType;
-import org.vcell.util.gui.sorttable.ColumnComparator;
-
-import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
-
-
-/**
- * Insert the type's description here.
- * Creation date: (8/19/2003 2:24:48 PM)
- * @author: Fei Gao
- */
-@SuppressWarnings("serial")
-public class ServiceStatusTableModel extends VCellSortTableModel<ComparableObject> {
-/**
- * ServiceStatusTableModel constructor comment.
- */
-public ServiceStatusTableModel() {
-	super(new String[] {"Site", "Type", "Ordinal", "Startup Type", "MemoryMB", "Date", "Status", "Status Message", "PBS Job ID"});
-}
-
-/**
- * Insert the method's description here.
- * Creation date: (8/19/2003 2:14:05 PM)
- * @return java.lang.Class
- * @param columnIndex int
- */
-public Class<?> getColumnClass(int columnIndex) {
-	if (columnIndex == 5) {
-		return Date.class;
-	} else if (columnIndex == 2 || columnIndex == 4) {
-		return Number.class;
-	} else if (columnIndex == 1) {
-		return ServiceType.class;
-	} else {
-		return String.class;
-	}
-}
-/**
- * getValueAt method comment.
- */
-public Object getValueAt(int row, int col) {	
-	ComparableObject serviceStatus = getValueAt(row);
-	Object[] values = serviceStatus.toObjects();
-	return values[col];
-}
-
-public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
-	return new ColumnComparator(col, ascending);
-}
-}
Index: src/cbit/vcell/message/server/console/ServerManageConsole.java
===================================================================
--- src/cbit/vcell/message/server/console/ServerManageConsole.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/ServerManageConsole.java	(revision 12031)
@@ -9,11 +9,11 @@
  */
 
 package cbit.vcell.message.server.console;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_PROPERTY;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
 
 import java.awt.BorderLayout;
 import java.awt.Color;
@@ -83,13 +83,20 @@
 import cbit.vcell.message.VCTopicConsumer;
 import cbit.vcell.message.VCTopicConsumer.TopicListener;
 import cbit.vcell.message.VCellTopic;
-import cbit.vcell.message.server.ManageConstants;
-import cbit.vcell.message.server.ServiceInstanceStatus;
-import cbit.vcell.message.server.ServiceSpec;
-import cbit.vcell.message.server.ServiceStatus;
 import cbit.vcell.message.server.bootstrap.RpcDbServerProxy;
 import cbit.vcell.message.server.bootstrap.RpcSimServerProxy;
-import cbit.vcell.messaging.db.SimpleJobStatus;
+import cbit.vcell.messaging.admin.AddNewServiceDialog;
+import cbit.vcell.messaging.admin.DatePanel;
+import cbit.vcell.messaging.admin.JobTableModel;
+import cbit.vcell.messaging.admin.ManageConstants;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.admin.ServiceInstanceStatusTableModel;
+import cbit.vcell.messaging.admin.ServiceSpec;
+import cbit.vcell.messaging.admin.ServiceStatus;
+import cbit.vcell.messaging.admin.ServiceStatusTableModel;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
+import cbit.vcell.messaging.admin.SimpleUserConnection;
+import cbit.vcell.messaging.admin.UserConnectionTableModel;
 import cbit.vcell.messaging.db.SimulationJobTable;
 import cbit.vcell.modeldb.AdminDBTopLevel;
 import cbit.vcell.modeldb.DbDriver;
Index: src/cbit/vcell/message/server/console/ZombieSlayer.java
===================================================================
--- src/cbit/vcell/message/server/console/ZombieSlayer.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/ZombieSlayer.java	(revision 12031)
@@ -8,6 +8,7 @@
 import org.vcell.util.SessionLog;
 import org.vcell.util.StdoutSessionLog;
 import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.VCellServerID;
 
 import cbit.sql.ConnectionFactory;
 import cbit.sql.KeyFactory;
@@ -19,6 +20,7 @@
 import cbit.vcell.message.server.pbs.PbsProxyLocal;
 import cbit.vcell.message.server.pbs.PbsProxySsh;
 import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatusInfo;
 import cbit.vcell.modeldb.AdminDBTopLevel;
 import cbit.vcell.modeldb.DatabaseServerImpl;
 import cbit.vcell.modeldb.DbDriver;
Index: src/cbit/vcell/message/server/console/SimulationJobStatusDetailDialog.java
===================================================================
--- src/cbit/vcell/message/server/console/SimulationJobStatusDetailDialog.java	(revision 12032)
+++ src/cbit/vcell/message/server/console/SimulationJobStatusDetailDialog.java	(revision 12031)
@@ -11,7 +11,7 @@
 package cbit.vcell.message.server.console;
 import javax.swing.BorderFactory;
 
-import cbit.vcell.messaging.db.SimpleJobStatus;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 
 /**
  * Insert the type's description here.
Index: src/cbit/vcell/message/server/db/DatabaseServer.java
===================================================================
--- src/cbit/vcell/message/server/db/DatabaseServer.java	(revision 12032)
+++ src/cbit/vcell/message/server/db/DatabaseServer.java	(revision 12031)
@@ -25,9 +25,9 @@
 import cbit.vcell.message.VCMessagingService.VCMessagingDelegate;
 import cbit.vcell.message.VCRpcConsumer;
 import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.server.ManageUtils;
-import cbit.vcell.message.server.ServiceInstanceStatus;
 import cbit.vcell.message.server.ServiceProvider;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
 import cbit.vcell.modeldb.DatabasePolicySQL;
 import cbit.vcell.modeldb.DatabaseServerImpl;
 import cbit.vcell.mongodb.VCMongoMessage;
Index: src/cbit/vcell/message/server/dispatcher/SimulationStateMachine.java
===================================================================
--- src/cbit/vcell/message/server/dispatcher/SimulationStateMachine.java	(revision 12032)
+++ src/cbit/vcell/message/server/dispatcher/SimulationStateMachine.java	(revision 12031)
@@ -22,7 +22,7 @@
 import cbit.vcell.message.VCellTopic;
 import cbit.vcell.message.messages.SimulationTaskMessage;
 import cbit.vcell.message.messages.StatusMessage;
-import cbit.vcell.message.messages.WorkerEventMessage;
+import cbit.vcell.messaging.WorkerEventMessage;
 import cbit.vcell.messaging.db.SimulationExecutionStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
Index: src/cbit/vcell/message/server/dispatcher/SimulationDispatcher.java
===================================================================
--- src/cbit/vcell/message/server/dispatcher/SimulationDispatcher.java	(revision 12032)
+++ src/cbit/vcell/message/server/dispatcher/SimulationDispatcher.java	(revision 12031)
@@ -37,9 +37,9 @@
 import cbit.vcell.message.VCRpcRequest;
 import cbit.vcell.message.VCellQueue;
 import cbit.vcell.message.messages.WorkerEventMessage;
-import cbit.vcell.message.server.ManageUtils;
-import cbit.vcell.message.server.ServiceInstanceStatus;
 import cbit.vcell.message.server.ServiceProvider;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatusInfo;
 import cbit.vcell.modeldb.AdminDBTopLevel;
Index: src/cbit/vcell/message/server/sim/PbsSimulationWorker.java
===================================================================
--- src/cbit/vcell/message/server/sim/PbsSimulationWorker.java	(revision 12032)
+++ src/cbit/vcell/message/server/sim/PbsSimulationWorker.java	(revision 12031)
@@ -40,12 +40,12 @@
 import cbit.vcell.message.VCellQueue;
 import cbit.vcell.message.messages.SimulationTaskMessage;
 import cbit.vcell.message.messages.WorkerEventMessage;
-import cbit.vcell.message.server.ManageUtils;
-import cbit.vcell.message.server.ServiceInstanceStatus;
 import cbit.vcell.message.server.ServiceProvider;
 import cbit.vcell.message.server.pbs.PbsProxy;
 import cbit.vcell.message.server.pbs.PbsProxyLocal;
 import cbit.vcell.message.server.pbs.PbsProxySsh;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.mongodb.VCMongoMessage;
 import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
Index: src/cbit/vcell/message/server/sim/JavaSimulationExecutable.java
===================================================================
--- src/cbit/vcell/message/server/sim/JavaSimulationExecutable.java	(revision 12032)
+++ src/cbit/vcell/message/server/sim/JavaSimulationExecutable.java	(revision 12031)
@@ -32,7 +32,7 @@
 import cbit.vcell.message.VCTopicConsumer.TopicListener;
 import cbit.vcell.message.VCellTopic;
 import cbit.vcell.message.messages.WorkerEventMessage;
-import cbit.vcell.message.server.ManageUtils;
+import cbit.vcell.messaging.admin.ManageUtils;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.mongodb.VCMongoMessage;
 import cbit.vcell.solver.Simulation;
Index: src/cbit/vcell/message/server/sim/LocalSimulationWorker.java
===================================================================
--- src/cbit/vcell/message/server/sim/LocalSimulationWorker.java	(revision 12032)
+++ src/cbit/vcell/message/server/sim/LocalSimulationWorker.java	(revision 12031)
@@ -34,9 +34,9 @@
 import cbit.vcell.message.VCellQueue;
 import cbit.vcell.message.messages.SimulationTaskMessage;
 import cbit.vcell.message.messages.WorkerEventMessage;
-import cbit.vcell.message.server.ManageUtils;
-import cbit.vcell.message.server.ServiceInstanceStatus;
 import cbit.vcell.message.server.ServiceProvider;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.mongodb.VCMongoMessage;
 import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
Index: src/cbit/vcell/message/server/data/SimDataServer.java
===================================================================
--- src/cbit/vcell/message/server/data/SimDataServer.java	(revision 12032)
+++ src/cbit/vcell/message/server/data/SimDataServer.java	(revision 12031)
@@ -35,9 +35,9 @@
 import cbit.vcell.message.VCRpcConsumer;
 import cbit.vcell.message.VCellQueue;
 import cbit.vcell.message.VCellTopic;
-import cbit.vcell.message.server.ManageUtils;
-import cbit.vcell.message.server.ServiceInstanceStatus;
 import cbit.vcell.message.server.ServiceProvider;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
 import cbit.vcell.mongodb.VCMongoMessage;
 import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
 import cbit.vcell.simdata.Cachetable;
Index: src/cbit/vcell/message/server/manager/ServerManagerDaemon.java
===================================================================
--- src/cbit/vcell/message/server/manager/ServerManagerDaemon.java	(revision 12032)
+++ src/cbit/vcell/message/server/manager/ServerManagerDaemon.java	(revision 12031)
@@ -9,19 +9,19 @@
  */
 
 package cbit.vcell.message.server.manager;
-import static cbit.vcell.message.server.ManageConstants.INTERVAL_PING_RESPONSE;
-import static cbit.vcell.message.server.ManageConstants.INTERVAL_PING_SERVICE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_PROPERTY;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.SERVICE_ID_PROPERTY;
-import static cbit.vcell.message.server.ManageConstants.SERVICE_STARTUPTYPE_AUTOMATIC;
-import static cbit.vcell.message.server.ManageConstants.SERVICE_STATUS_FAILED;
-import static cbit.vcell.message.server.ManageConstants.SERVICE_STATUS_RUNNING;
+import static cbit.vcell.messaging.admin.ManageConstants.INTERVAL_PING_RESPONSE;
+import static cbit.vcell.messaging.admin.ManageConstants.INTERVAL_PING_SERVICE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_ID_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_STARTUPTYPE_AUTOMATIC;
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_STATUS_FAILED;
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_STATUS_RUNNING;
 
 import java.io.File;
 import java.io.FileOutputStream;
@@ -55,13 +55,13 @@
 import cbit.vcell.message.VCTopicConsumer;
 import cbit.vcell.message.VCTopicConsumer.TopicListener;
 import cbit.vcell.message.VCellTopic;
-import cbit.vcell.message.server.ManageUtils;
-import cbit.vcell.message.server.ServiceInstanceStatus;
-import cbit.vcell.message.server.ServiceStatus;
 import cbit.vcell.message.server.pbs.PbsProxy;
 import cbit.vcell.message.server.pbs.PbsProxy.PbsJobNotFoundException;
 import cbit.vcell.message.server.pbs.PbsProxyLocal;
 import cbit.vcell.message.server.pbs.PbsProxySsh;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.admin.ServiceStatus;
 import cbit.vcell.messaging.db.UpdateSynchronizationException;
 import cbit.vcell.modeldb.AdminDBTopLevel;
 import cbit.vcell.modeldb.DbDriver;
Index: src/cbit/vcell/message/server/ServiceProvider.java
===================================================================
--- src/cbit/vcell/message/server/ServiceProvider.java	(revision 12032)
+++ src/cbit/vcell/message/server/ServiceProvider.java	(revision 12031)
@@ -9,14 +9,14 @@
  */
 
 package cbit.vcell.message.server;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_PROPERTY;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE;
-import static cbit.vcell.message.server.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
-import static cbit.vcell.message.server.ManageConstants.SERVICE_ID_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_ID_PROPERTY;
 
 import java.io.File;
 import java.io.FileNotFoundException;
@@ -35,6 +35,7 @@
 import cbit.vcell.message.VCTopicConsumer;
 import cbit.vcell.message.VCTopicConsumer.TopicListener;
 import cbit.vcell.message.VCellTopic;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
 
 /**
  * Insert the type's description here.
Index: src/cbit/vcell/message/server/bootstrap/ClientTopicMessageCollector.java
===================================================================
--- src/cbit/vcell/message/server/bootstrap/ClientTopicMessageCollector.java	(revision 12032)
+++ src/cbit/vcell/message/server/bootstrap/ClientTopicMessageCollector.java	(revision 12031)
@@ -34,7 +34,7 @@
 import cbit.vcell.message.VCTopicConsumer.TopicListener;
 import cbit.vcell.message.VCellTopic;
 import cbit.vcell.message.messages.StatusMessage;
-import cbit.vcell.message.server.ManageConstants;
+import cbit.vcell.messaging.admin.ManageConstants;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.solver.VCSimulationIdentifier;
 
Index: src/cbit/vcell/modeldb/LocalAdminDbServer.java
===================================================================
--- src/cbit/vcell/modeldb/LocalAdminDbServer.java	(revision 12032)
+++ src/cbit/vcell/modeldb/LocalAdminDbServer.java	(revision 12031)
@@ -23,7 +23,7 @@
 import org.vcell.util.document.VCellServerID;
 
 import cbit.sql.*;
-import cbit.vcell.messaging.db.SimpleJobStatus;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatusInfo;
 import cbit.vcell.messaging.db.UpdateSynchronizationException;
Index: src/cbit/vcell/modeldb/AdminDBTopLevel.java
===================================================================
--- src/cbit/vcell/modeldb/AdminDBTopLevel.java	(revision 12032)
+++ src/cbit/vcell/modeldb/AdminDBTopLevel.java	(revision 12031)
@@ -9,7 +9,8 @@
  */
 
 package cbit.vcell.modeldb;
-import cbit.vcell.message.server.ServiceStatus;
+import cbit.vcell.messaging.admin.ServiceStatus;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.solver.ode.gui.SimulationStatus;
 import java.sql.Connection;
 import java.sql.SQLException;
@@ -29,7 +30,6 @@
 import org.vcell.util.document.VCellServerID;
 
 import cbit.vcell.messaging.db.ServiceStatusDbDriver;
-import cbit.vcell.messaging.db.SimpleJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatusInfo;
 import cbit.vcell.messaging.db.UpdateSynchronizationException;
Index: src/cbit/vcell/modeldb/AdminDatabaseServerXAImpl.java
===================================================================
--- src/cbit/vcell/modeldb/AdminDatabaseServerXAImpl.java	(revision 0)
+++ src/cbit/vcell/modeldb/AdminDatabaseServerXAImpl.java	(revision 12031)
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.modeldb;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.sql.*;
+import cbit.vcell.server.*;
+import cbit.vcell.messaging.db.*;
+/**
+ * Insert the type's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @author: Ion Moraru
+ */
+public class AdminDatabaseServerXAImpl implements AdminDatabaseServerXA {
+	private SessionLog log = null;
+	private AdminDBTopLevel adminDbTop = null;
+
+public AdminDatabaseServerXAImpl(KeyFactory keyFactory, SessionLog sessionLog) throws DataAccessException {
+
+	this.log = sessionLog;
+	DbDriver.setKeyFactory(keyFactory);
+	try {
+		adminDbTop = new AdminDBTopLevel(null,log);
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException("Error creating AdminDbTop " + e.getMessage());
+	}		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus[]
+ * @param con java.sql.Connection
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public cbit.vcell.messaging.db.SimulationJobStatusInfo[] getActiveJobs(java.sql.Connection con, VCellServerID[] serverIDs) throws DataAccessException {
+	try {
+		SimulationJobStatusInfo[] jobStatuses = adminDbTop.getActiveJobs(con, serverIDs);
+		return jobStatuses;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting active jobs");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param intervalSeconds long
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus getNextObsoleteSimulation(java.sql.Connection con, long intervalSeconds) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.getNextObsoleteSimulation(con, intervalSeconds);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting NextObsoleteSimulation");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simKey cbit.sql.KeyValue
+ * @param jobIndex int
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus[] getSimulationJobStatusArray(java.sql.Connection con, org.vcell.util.document.KeyValue simKey, int jobIndex) throws DataAccessException {
+	try {
+		SimulationJobStatus[] jobStatus = adminDbTop.getSimulationJobStatusArray(con, simKey, jobIndex);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting SimulationJobStatus for ["+simKey+"]["+jobIndex+"]");
+	}
+}
+
+public SimulationJobStatus getSimulationJobStatus(java.sql.Connection con, org.vcell.util.document.KeyValue simKey, int jobIndex, int taskID) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.getSimulationJobStatus(con, simKey, jobIndex, taskID);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting SimulationJobStatus for ["+simKey+"]["+jobIndex+"]");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/31/2003 2:34:12 PM)
+ * @return cbit.vcell.solvers.SimulationJobStatus[]
+ * @param bActiveOnly boolean
+ * @param userOnly cbit.vcell.server.User
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationJobStatus[] getSimulationJobStatus(java.sql.Connection con, boolean bActiveOnly, org.vcell.util.document.User userOnly) throws DataAccessException {
+	try {
+		return adminDbTop.getSimulationJobStatus(con, bActiveOnly,userOnly);
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure getting SimulationJobStatus");
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus insertSimulationJobStatus(java.sql.Connection con, SimulationJobStatus simulationJobStatus) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.insertSimulationJobStatus(con, simulationJobStatus);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure inserting SimulationJobStatus: "+simulationJobStatus);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 5:20:07 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param oldSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @param newSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public SimulationJobStatus updateSimulationJobStatus(java.sql.Connection con, SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws DataAccessException {
+	try {
+		SimulationJobStatus jobStatus = adminDbTop.updateSimulationJobStatus(con, oldSimulationJobStatus, newSimulationJobStatus);
+		return jobStatus;
+	}catch (Throwable e){
+		log.exception(e);
+		throw new DataAccessException("failure updating SimulationJobStatus: "+oldSimulationJobStatus);
+	}
+}
+}
Index: src/cbit/vcell/server/SimulationControllerImpl.java
===================================================================
--- src/cbit/vcell/server/SimulationControllerImpl.java	(revision 12032)
+++ src/cbit/vcell/server/SimulationControllerImpl.java	(revision 12031)
@@ -43,6 +43,7 @@
 import cbit.vcell.message.server.dispatcher.SimulationDispatcherEngine;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.vcell.messaging.server.LocalDispatcherDbManager;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.solver.Simulation;
 import cbit.vcell.solver.SimulationInfo;
@@ -106,6 +107,8 @@
 	private SimulationDatabase simulationDatabase = null;
 	private EventListenerList listenerList = new javax.swing.event.EventListenerList();
 	
+	LocalDispatcherDbManager dispatcherDbManager;
+	
 	private SimulationDispatcherEngine simulationDispatcherEngine = new SimulationDispatcherEngine();
 	
 
Index: src/cbit/vcell/server/AdminDatabaseServerXA.java
===================================================================
--- src/cbit/vcell/server/AdminDatabaseServerXA.java	(revision 0)
+++ src/cbit/vcell/server/AdminDatabaseServerXA.java	(revision 12031)
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.server;
+import cbit.vcell.messaging.db.*;
+import java.sql.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+public interface AdminDatabaseServerXA {
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:06:44 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus[]
+ * @param con java.sql.Connection
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatusInfo[] getActiveJobs(java.sql.Connection con, VCellServerID[] serverIDs) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:01:00 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param intervalSeconds long
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus getNextObsoleteSimulation(Connection con, long intervalSeconds) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/5/2005 1:06:45 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simKey cbit.sql.KeyValue
+ * @param jobIndex int
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus getSimulationJobStatus(Connection con, KeyValue simKey, int jobIndex, int taskID) throws DataAccessException;
+
+
+SimulationJobStatus[] getSimulationJobStatusArray(Connection con, KeyValue simKey, int jobIndex) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/14/2006 4:08:59 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus[]
+ * @param con java.sql.Connection
+ * @param bActiveOnly boolean
+ * @param userOnly cbit.vcell.server.User
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus[] getSimulationJobStatus(Connection con, boolean bActiveOnly, User userOnly) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:43:20 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param simulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus insertSimulationJobStatus(Connection con, SimulationJobStatus simulationJobStatus) throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/4/2005 1:03:06 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ * @param con java.sql.Connection
+ * @param oldSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @param newSimulationJobStatus cbit.vcell.messaging.db.SimulationJobStatus
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+SimulationJobStatus updateSimulationJobStatus(Connection con, SimulationJobStatus oldSimulationJobStatus, SimulationJobStatus newSimulationJobStatus) throws DataAccessException;
+}
Index: src/cbit/vcell/server/AdminDatabaseServer.java
===================================================================
--- src/cbit/vcell/server/AdminDatabaseServer.java	(revision 12032)
+++ src/cbit/vcell/server/AdminDatabaseServer.java	(revision 12031)
@@ -18,7 +18,7 @@
 import org.vcell.util.document.User;
 import org.vcell.util.document.UserInfo;
 
-import cbit.vcell.messaging.db.SimpleJobStatus;
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.UpdateSynchronizationException;
 
Index: src/cbit/vcell/solver/stoch/NetCDFWriter.java
===================================================================
--- src/cbit/vcell/solver/stoch/NetCDFWriter.java	(revision 12032)
+++ src/cbit/vcell/solver/stoch/NetCDFWriter.java	(revision 12031)
@@ -16,9 +16,7 @@
 import java.util.Hashtable;
 import java.util.Vector;
 
-import org.apache.commons.math.random.RandomDataImpl;
 import org.vcell.util.Compare;
-import org.vcell.util.PropertyLoader;
 
 import ucar.ma2.ArrayChar;
 import ucar.ma2.ArrayDouble;
@@ -37,17 +35,19 @@
 import cbit.vcell.math.VarIniCondition;
 import cbit.vcell.math.VarIniCount;
 import cbit.vcell.math.Variable;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
+import cbit.vcell.messaging.JmsUtils;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.Expression;
 import cbit.vcell.parser.ExpressionException;
 import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationSymbolTable;
 import cbit.vcell.solver.SolverTaskDescription;
 import cbit.vcell.solver.TimeBounds;
 import cbit.vcell.solver.UniformOutputTimeSpec;
 
+import org.apache.commons.math.random.RandomDataImpl;
+
 /**
  * This class is used to write input file for stochastic hybrid solvers.
  * The input file will be in NetCDF format containing all the requred model information
@@ -254,15 +254,15 @@
 				// write jms info
 				if (bMessaging) {
 					ArrayChar.D1 jmsString = new ArrayChar.D1(stringLen.getLength());
-					jmsString.setString(PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL));
+					jmsString.setString(JmsUtils.getJmsUrl());
 					ncfile.write("JMS_BROKER", jmsString);
-					jmsString.setString(PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser));
+					jmsString.setString(JmsUtils.getJmsUserID());
 					ncfile.write("JMS_USER", jmsString);
-					jmsString.setString(PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword));
+					jmsString.setString(JmsUtils.getJmsPassword());
 					ncfile.write("JMS_PASSWORD", jmsString);
-					jmsString.setString(VCellQueue.WorkerEventQueue.getName());
+					jmsString.setString(JmsUtils.getQueueWorkerEvent());
 					ncfile.write("JMS_QUEUE", jmsString);
-					jmsString.setString(VCellTopic.ServiceControlTopic.getName());
+					jmsString.setString(JmsUtils.getTopicServiceControl());
 					ncfile.write("JMS_TOPIC", jmsString);
 					jmsString.setString(simulation.getVersion().getOwner().getName());
 					ncfile.write("VCELL_USER", jmsString);
Index: src/cbit/vcell/solver/SolverFileWriter.java
===================================================================
--- src/cbit/vcell/solver/SolverFileWriter.java	(revision 12032)
+++ src/cbit/vcell/solver/SolverFileWriter.java	(revision 12031)
@@ -9,12 +9,9 @@
  */
 
 package cbit.vcell.solver;
-import java.io.PrintWriter;
+import java.io.*;
 
-import org.vcell.util.PropertyLoader;
-
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
+import cbit.vcell.messaging.JmsUtils;
 import cbit.vcell.messaging.server.SimulationTask;
 /**
  * Insert the type's description here.
@@ -69,10 +66,10 @@
 	if (bUseMessaging) {
 		printWriter.println("# JMS_Paramters");
 		printWriter.println(SolverInputFileKeyword.JMS_PARAM_BEGIN);
-		printWriter.println(SolverInputFileKeyword.JMS_BROKER + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL));
-	    printWriter.println(SolverInputFileKeyword.JMS_USER + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser) + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword));
-	    printWriter.println(SolverInputFileKeyword.JMS_QUEUE + " " + VCellQueue.WorkerEventQueue.getName());  
-		printWriter.println(SolverInputFileKeyword.JMS_TOPIC + " " + VCellTopic.ServiceControlTopic.getName());
+		printWriter.println(SolverInputFileKeyword.JMS_BROKER + " " + JmsUtils.getJmsUrl());
+	    printWriter.println(SolverInputFileKeyword.JMS_USER + " " + JmsUtils.getJmsUserID() + " " + JmsUtils.getJmsPassword());
+	    printWriter.println(SolverInputFileKeyword.JMS_QUEUE + " " + JmsUtils.getQueueWorkerEvent());  
+		printWriter.println(SolverInputFileKeyword.JMS_TOPIC + " " + JmsUtils.getTopicServiceControl());
 		printWriter.println(SolverInputFileKeyword.VCELL_USER + " " + simTask.getSimulation().getVersion().getOwner().getName());
 		printWriter.println(SolverInputFileKeyword.SIMULATION_KEY + " " + simTask.getSimulation().getVersion().getVersionKey());
 		printWriter.println(SolverInputFileKeyword.JOB_INDEX + " " + simTask.getSimulationJob().getJobIndex());
Index: src/cbit/vcell/messaging/QueueMessageCollector.java
===================================================================
--- src/cbit/vcell/messaging/QueueMessageCollector.java	(revision 0)
+++ src/cbit/vcell/messaging/QueueMessageCollector.java	(revision 12031)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/26/2003 10:54:16 AM)
+ * @author: Fei Gao
+ */
+public class QueueMessageCollector extends QueueListenerImpl {
+	private QueueListener queueListener;
+/**
+ * QueueMessageCollector constructor comment.
+ */
+public QueueMessageCollector(QueueListener queueListener0) {
+	super();
+	queueListener = queueListener0;
+}
+/**
+ * onQueueMessage method comment.
+ */
+public void onQueueMessage(Message message) throws JMSException {
+	if (queueListener != null) {
+		queueListener.onQueueMessage(message);
+	}
+}
+}
Index: src/cbit/vcell/messaging/JmsConnectionFactory.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnectionFactory.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnectionFactory.java	(revision 12031)
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.JMSException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/24/2004 2:24:10 PM)
+ * @author: Fei Gao
+ */
+public interface JmsConnectionFactory {
+	public JmsXAConnection createXAConnection() throws JMSException;
+	public JmsConnection createConnection() throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsXAConnection.java
===================================================================
--- src/cbit/vcell/messaging/JmsXAConnection.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsXAConnection.java	(revision 12031)
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/2/2003 8:32:58 AM)
+ * @author: Fei Gao
+ */
+public interface JmsXAConnection extends JmsConnection {
+	XAConnection getXAConnection();
+	public JmsXASession getXASession() throws JMSException;
+}
Index: src/cbit/vcell/messaging/db/SimpleJobStatus.java
===================================================================
--- src/cbit/vcell/messaging/db/SimpleJobStatus.java	(revision 12032)
+++ src/cbit/vcell/messaging/db/SimpleJobStatus.java	(revision 12031)
@@ -1,211 +0,0 @@
-/*
- * Copyright (C) 1999-2011 University of Connecticut Health Center
- *
- * Licensed under the MIT License (the "License").
- * You may not use this file except in compliance with the License.
- * You may obtain a copy of the License at:
- *
- *  http://www.opensource.org/licenses/mit-license.php
- */
-
-package cbit.vcell.messaging.db;
-import cbit.vcell.solver.VCSimulationIdentifier;
-import java.math.BigDecimal;
-
-import org.vcell.util.ComparableObject;
-
-import cbit.vcell.solver.SolverTaskDescription;
-
-/**
- * Insert the type's description here.
- * Creation date: (9/3/2003 10:39:26 AM)
- * @author: Fei Gao
- */
-public class SimpleJobStatus implements ComparableObject {
-	private String userID = null;
-	private SimulationJobStatus jobStatus = null;
-	private SolverTaskDescription solverTaskDesc = null;
-	private Long elapsedTime = null;
-
-/**
- * SimpleJobStatus constructor comment.
- */
-public SimpleJobStatus(String user, SimulationJobStatus arg_jobStatus, SolverTaskDescription arg_solverTaskDesc) {	
-	super();
-	this.userID = user;
-	this.jobStatus = arg_jobStatus;
-	this.solverTaskDesc = arg_solverTaskDesc;
-	this.elapsedTime = null;
-	if (getStartDate()!=null){
-		if (getEndDate()!=null){
-			this.elapsedTime = ((getEndDate().getTime()-getStartDate().getTime()));
-		}else if (jobStatus.getSchedulerStatus().isRunning()){
-			this.elapsedTime = ((System.currentTimeMillis()-getStartDate().getTime()));
-		}
-	}
-
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public java.lang.String getComputeHost() {
-	if (jobStatus == null) {
-		return null;
-	}	
-	return jobStatus.getComputeHost();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.util.Date
- */
-public java.util.Date getEndDate() {
-	if (jobStatus == null) {
-		return null;
-	}
-	return jobStatus.getEndDate();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public Integer getJobIndex() {
-	if (jobStatus == null || jobStatus.getServerID() == null) {
-		return null;
-	}	
-	return new Integer(jobStatus.getJobIndex());
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public java.lang.String getServerID() {
-	if (jobStatus == null || jobStatus.getServerID() == null) {
-		return null;
-	}	
-	return jobStatus.getServerID().toString();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (7/8/2004 1:29:11 PM)
- * @return java.lang.String
- */
-public String getSolverDescriptionVCML() {
-	if (solverTaskDesc == null) {
-		return "Error: Null Solver Description";
-	}
-	return solverTaskDesc.getVCML();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.util.Date
- */
-public java.util.Date getStartDate() {
-	if (jobStatus == null) {
-		return null;
-	}
-	return jobStatus.getStartDate();
-}
-
-/**
- * Insert the method's description here.
- * Creation date: (12/17/2003 2:47:11 PM)
- * @return java.lang.String
- */
-public String getStatusMessage() {
-	return jobStatus.getSimulationMessage().getDisplayMessage();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.util.Date
- */
-public java.util.Date getSubmitDate() {
-	return jobStatus.getSubmitDate();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public Integer getTaskID() {
-	if (jobStatus == null || jobStatus.getServerID() == null) {
-		return null;
-	}	
-	return new Integer(jobStatus.getTaskID());
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (3/29/2004 2:09:31 PM)
- * @return java.lang.String
- */
-public java.lang.String getUserID() {
-	return userID;
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (12/17/2003 2:54:17 PM)
- * @return cbit.sql.KeyValue
- */
-public VCSimulationIdentifier getVCSimulationIdentifier() {
-	return jobStatus.getVCSimulationIdentifier();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (7/19/2004 3:21:23 PM)
- * @return boolean
- */
-public boolean isDone() {
-	return jobStatus.getSchedulerStatus().isDone();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (5/7/2004 8:53:02 AM)
- * @return boolean
- */
-public boolean isRunning() {
-	return jobStatus.getSchedulerStatus().isRunning();
-}
-
-
-/**
- * Insert the method's description here.
- * Creation date: (9/3/2003 10:45:39 AM)
- * @return java.lang.String[]
- */
-public Object[] toObjects() {	
-	return new Object[] {userID,  new BigDecimal(getVCSimulationIdentifier().getSimulationKey().toString()), getJobIndex(), 
-		solverTaskDesc == null || solverTaskDesc.getSolverDescription() == null ? "" : solverTaskDesc.getSolverDescription().getDisplayLabel(), 		
-		getStatusMessage(), getComputeHost(), getServerID(), getTaskID(), getSubmitDate(), getStartDate(), getEndDate(),
-		elapsedTime};
-}
-}
Index: src/cbit/vcell/messaging/db/SimulationJobDbDriver.java
===================================================================
--- src/cbit/vcell/messaging/db/SimulationJobDbDriver.java	(revision 12032)
+++ src/cbit/vcell/messaging/db/SimulationJobDbDriver.java	(revision 12031)
@@ -24,6 +24,7 @@
 import org.vcell.util.document.User;
 import org.vcell.util.document.VCellServerID;
 
+import cbit.vcell.messaging.admin.SimpleJobStatus;
 import cbit.vcell.modeldb.UserTable;
 
 /**
Index: src/cbit/vcell/messaging/db/ServiceStatusDbDriver.java
===================================================================
--- src/cbit/vcell/messaging/db/ServiceStatusDbDriver.java	(revision 12032)
+++ src/cbit/vcell/messaging/db/ServiceStatusDbDriver.java	(revision 12031)
@@ -17,7 +17,7 @@
 import org.vcell.util.document.KeyValue;
 import org.vcell.util.document.VCellServerID;
 
-import cbit.vcell.message.server.ServiceStatus;
+import cbit.vcell.messaging.admin.ServiceStatus;
 
 /**
  * Insert the type's description here.
Index: src/cbit/vcell/messaging/db/ServiceTable.java
===================================================================
--- src/cbit/vcell/messaging/db/ServiceTable.java	(revision 12032)
+++ src/cbit/vcell/messaging/db/ServiceTable.java	(revision 12031)
@@ -9,8 +9,8 @@
  */
 
 package cbit.vcell.messaging.db;
-import cbit.vcell.message.server.ServiceSpec;
-import cbit.vcell.message.server.ServiceStatus;
+import cbit.vcell.messaging.admin.ServiceSpec;
+import cbit.vcell.messaging.admin.ServiceStatus;
 import cbit.htc.PbsJobID;
 import cbit.sql.*;
 import java.sql.*;
Index: src/cbit/vcell/messaging/TopicListenerImpl.java
===================================================================
--- src/cbit/vcell/messaging/TopicListenerImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/TopicListenerImpl.java	(revision 12031)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/9/2003 12:05:19 PM)
+ * @author: Fei Gao
+ */
+public abstract class TopicListenerImpl implements MessageListener {
+	
+	
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/17/2003 10:09:06 AM)
+ */
+public TopicListenerImpl() {
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public final void onMessage(Message message) {
+	try {
+		onTopicMessage(message);
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public abstract void onTopicMessage(Message message) throws JMSException ; 
+}
Index: src/cbit/vcell/messaging/WorkerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/WorkerMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/WorkerMessaging.java	(revision 12031)
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.server.Worker;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.solver.SimulationMessage;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/2/2003 3:00:59 PM)
+ * @author: Fei Gao
+ */
+public class WorkerMessaging extends JmsServiceProviderMessaging implements ControlTopicListener {
+	private JmsSession jobRetriever = null;
+	private JmsSession workerEventSession = null;
+	private String jobSelector = null;
+	private Worker myWorker = null;
+	private SimulationTask currentTask = null;	
+	private long lastMsgTimeStamp;
+	private boolean bProgress = true;
+	
+	class KeepAliveThread extends Thread {
+		public KeepAliveThread() {
+			super();
+			setName("KeepAliveThread_Worker");
+		}	
+		public void run() {
+			while (true) {
+				try {
+					sleep(MessageConstants.INTERVAL_PING_SERVER);
+				} catch (InterruptedException ex) {
+				}
+		
+				long t = System.currentTimeMillis();
+				if (myWorker.isRunning() && lastMsgTimeStamp != 0 && t - lastMsgTimeStamp > MessageConstants.INTERVAL_PING_SERVER) {
+					log.print("@@@@Worker:Sending alive message");
+					sendWorkerAlive();
+				}
+			}
+		}	
+	}	
+
+/**
+ * WorkerMessaging constructor comment.
+ */
+public WorkerMessaging(Worker worker0, SessionLog log0) throws JMSException {
+	super(worker0, log0);
+	myWorker = worker0;
+	reconnect();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public SimulationTask getNextTask() { 	
+	//
+	// create a transactional receive/send to get a "task" object (that this worker can handle) 
+	// and send an "accept" status message to the SchedulerControl queue
+	//
+	//log.print("==GNT");
+	currentTask = null;
+	
+	try {			
+		//log.print("Created receiver with filter = " + jobSelector);		
+		Message message = jobRetriever.receiveMessage(JmsUtils.getQueueSimJob(), jobSelector, 100);
+		if (message == null) { // no message
+			try {
+				jobRetriever.rollback(); 
+			} catch (Exception ex) {
+				log.exception(ex);
+			}
+			currentTask = null;
+			
+		} else { 
+			log.print("received message " + JmsUtils.toString(message));
+			SimulationTaskMessage taskMsg = new SimulationTaskMessage(message);
+			currentTask = taskMsg.getSimulationTask();
+			
+			log.print("Job accepted: " + currentTask);
+			WorkerEventMessage.sendAccepted(jobRetriever, this, currentTask, ManageUtils.getHostName());
+			jobRetriever.commit();
+			
+			lastMsgTimeStamp = System.currentTimeMillis();
+		}
+		
+	} catch (Exception ex) {
+		try {
+			jobRetriever.rollback(); 
+		} catch (Exception e) {
+			log.exception(e);
+		}
+		currentTask = null;
+	}
+	
+	return currentTask;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/2/2003 3:06:25 PM)
+ */
+protected void reconnect() throws JMSException {
+	jobSelector = myWorker.getJobSelector();	
+	
+	super.reconnect();
+	log.print("Job Selector : " + jobSelector);
+	jobRetriever = jmsConn.getTransactedSession(); // transactional
+	int workerPrefetchCount = Integer.parseInt(PropertyLoader.getProperty(PropertyLoader.jmsWorkerPrefetchCount, "-1"));
+	if (workerPrefetchCount > 0) {
+		jobRetriever.setPrefetchCount(workerPrefetchCount); // get messages one by one
+		jobRetriever.setPrefetchThreshold(0);
+	}
+	workerEventSession = jmsConn.getAutoSession();		
+	
+	JmsSession serviceListenTopicSession = jmsConn.getAutoSession();
+	serviceListenTopicSession.setupTopicListener(JmsUtils.getTopicServiceControl(), null, new ControlMessageCollector(myWorker));
+	jmsConn.startConnection();
+	
+	if (myWorker.getServiceType() == ServiceType.LOCALCOMPUTE) { // only start the keepalive thread for local worker
+		log.print("Start keep alive thread");
+		new KeepAliveThread().start();
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendCompleted(double progress, double timeSec, SimulationMessage simulationMessage) {
+	if (currentTask == null) {
+		return;
+	}
+
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendComplete(" + currentTask.getSimulationJobID() + ")");
+		WorkerEventMessage.sendCompleted(workerEventSession, this, currentTask, ManageUtils.getHostName(),  progress, timeSec, simulationMessage);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendFailed(SimulationMessage failureMessage) {
+	if (currentTask == null) {
+		return;
+	}
+		
+	try {
+		log.print("sendFailure(" + currentTask.getSimulationJobID() + "," + failureMessage +")");
+		WorkerEventMessage.sendFailed(workerEventSession, this, currentTask, ManageUtils.getHostName(), failureMessage);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException ex) {
+        log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendNewData(double progress, double timeSec, SimulationMessage simulationMessage) {
+	if (currentTask == null) {
+		return;
+	}
+	
+	try {
+		long t = System.currentTimeMillis();
+		if (bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE) { // don't send data message too frequently
+			log.print("sendNewData(" + currentTask.getSimulationJobID() + "," + (progress * 100) + "%," + timeSec + ")");		
+			WorkerEventMessage.sendNewData(workerEventSession, this, currentTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+		
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = false;
+		}
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendProgress(double progress, double timeSec, SimulationMessage simulationMessage) {
+	if (currentTask == null) {
+		return;
+	}
+
+	try {
+		long t = System.currentTimeMillis();
+	if (!bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE 
+		|| ((int)(progress * 100)) % 25 == 0) { // don't send progress message too frequently
+			log.print("sendProgress(" + currentTask.getSimulationJobID() + "," + (progress * 100) + "%," + timeSec + ")");
+			WorkerEventMessage.sendProgress(workerEventSession, this, currentTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+			
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = true;
+		}
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+public void sendStarting(SimulationMessage startingMessage) {
+	if (currentTask == null) {
+		return;
+	}
+	
+	try {
+		log.print("sendStarting(" + currentTask.getSimulationJobID() + ")");
+		WorkerEventMessage.sendStarting(workerEventSession, this, currentTask, ManageUtils.getHostName(), startingMessage);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+void sendWorkerAlive() {
+	if (currentTask == null) {
+		return;
+	}
+
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendWorkerAlive(" + currentTask.getSimulationJobID() + ")");
+		WorkerEventMessage.sendWorkerAlive(workerEventSession, this, currentTask, ManageUtils.getHostName(), SimulationMessage.MESSAGE_WORKEREVENT_WORKERALIVE);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2004 11:21:59 AM)
+ */
+public void startReceiving() throws JMSException {
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2004 11:21:59 AM)
+ */
+public void stopReceiving() throws JMSException {
+	jmsConn.stopConnection();
+}
+}
Index: src/cbit/vcell/messaging/JmsConnection.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnection.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnection.java	(revision 12031)
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/10/2003 10:21:50 AM)
+ * @author: Fei Gao
+ */
+public interface JmsConnection extends ExceptionListener {
+	public void close() throws JMSException;
+	public void closeSession(JmsSession session) throws JMSException;
+	JmsProvider getJmsProvider();
+	public boolean isBadConnection(JMSException ex);
+	public boolean isConnectionDropped();
+	public void startConnection() throws JMSException;
+	public void stopConnection() throws JMSException;
+	
+	public JmsSession getAutoSession() throws JMSException;
+	public JmsSession getClientAckSession() throws JMSException;
+	Connection getConnection();
+	public JmsSession getTransactedSession() throws JMSException;
+
+}
Index: src/cbit/vcell/messaging/JmsUtils.java
===================================================================
--- src/cbit/vcell/messaging/JmsUtils.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsUtils.java	(revision 12031)
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.PropertyLoader;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/17/2001 10:16:55 AM)
+ * @author: Jim Schaff
+ */
+public class JmsUtils {
+
+
+
+/**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.server.ProcessStatus
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public static cbit.vcell.messaging.admin.ServicePerformance getServicePerformance() {
+	try {
+		long javaFreeMemoryBytes = Runtime.getRuntime().freeMemory();
+		long javaTotalMemoryBytes = Runtime.getRuntime().totalMemory();
+		long maxJavaMemoryBytes = -1;
+		try {
+			maxJavaMemoryBytes = Long.parseLong(org.vcell.util.PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty));
+		} catch (NumberFormatException e){
+			System.out.println("error reading property '"+org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty+"', "+e.getMessage());
+		}
+		return new cbit.vcell.messaging.admin.ServicePerformance(javaFreeMemoryBytes,javaTotalMemoryBytes,maxJavaMemoryBytes);
+	} catch (Throwable e){
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/9/2004 9:17:51 AM)
+ * @return java.lang.String
+ * @param message javax.jms.Message
+ * @param propertyName java.lang.String
+ */
+public static Object parseProperty(Message message, String propertyName, Class propertyType) throws MessagePropertyNotFoundException {
+	try {
+		if (message.propertyExists(propertyName)) {
+			if (propertyType.equals(String.class)) {
+				return message.getStringProperty(propertyName);
+			} else 	if (propertyType.equals(int.class)) {
+				return new Integer(message.getIntProperty(propertyName));
+			} else 	if (propertyType.equals(long.class)) {
+				return new Long(message.getLongProperty(propertyName));
+			} else 	if (propertyType.equals(double.class)) {
+				return new Double(message.getDoubleProperty(propertyName));
+			} else {
+				throw new RuntimeException("Unexpected Property [" + propertyName + "," + propertyType + "]");
+			}
+		} else {
+			throw new MessagePropertyNotFoundException(propertyName);
+		}
+	} catch (JMSException ex) {
+		throw new MessagePropertyNotFoundException("JMSException on parsing [" + propertyName + "," + propertyType + "]:" + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:03:40 AM)
+ * @return java.lang.String
+ * @param message javax.jms.Message
+ */
+public static String toString(Message message) throws JMSException {
+	if (message == null)
+		return null;
+		
+	java.util.Enumeration enum1 = message.getPropertyNames();
+	StringBuffer buffer = new StringBuffer();
+	while (enum1.hasMoreElements()){
+		String propName = (String)enum1.nextElement();
+		try {
+			String value = (String)parseProperty(message, propName, String.class);
+			buffer.append(" " + propName + "='" + value + "'");
+		} catch (MessagePropertyNotFoundException ex) {
+			// definitely should not happen
+		}
+	}
+	return buffer.toString();
+}
+
+public final static String getJmsProvider() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsProvider);
+}
+
+public final static String getJmsUrl() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL);
+}
+
+public final static String getJmsUserID() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser);
+}
+
+public final static String getJmsPassword() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword);
+}
+
+public static final String getQueueDbReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsDbRequestQueue);
+}
+
+public static final String getQueueSimDataReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsDataRequestQueue);
+}
+
+
+public static final String getQueueSimJob() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsSimJobQueue);
+}
+
+
+public static final String getQueueSimReq() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsSimReqQueue);
+}
+
+
+public static final String getQueueWorkerEvent() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsWorkerEventQueue);
+}
+
+
+public static final String getTopicClientStatus() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsClientStatusTopic);
+}
+
+
+public static final String getTopicDaemonControl() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsDaemonControlTopic);
+}
+
+
+public static final String getTopicServiceControl() {
+	return PropertyLoader.getRequiredProperty(PropertyLoader.jmsServiceControlTopic);
+}
+
+public static final int getMaxOdeJobsPerUser() {
+	return Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.maxOdeJobsPerUser));
+}
+
+
+public static final int getMaxPdeJobsPerUser() {
+	return Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.maxPdeJobsPerUser));
+}
+
+
+}
Index: src/cbit/vcell/messaging/SimulationTaskMessage.java
===================================================================
--- src/cbit/vcell/messaging/SimulationTaskMessage.java	(revision 0)
+++ src/cbit/vcell/messaging/SimulationTaskMessage.java	(revision 12031)
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+
+import cbit.vcell.xml.XmlParseException;
+
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.xml.XmlHelper;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.parser.ExpressionException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/31/2003 11:39:39 AM)
+ * @author: Fei Gao
+ */
+public class SimulationTaskMessage {
+	private SimulationTask simTask = null;
+
+/**
+ * SimulationMessageHelper constructor comment.
+ */
+public SimulationTaskMessage(SimulationTask simTask0) {
+	super();
+	simTask = simTask0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/20/2004 11:02:09 AM)
+ * @param message javax.jms.Message
+ */
+public SimulationTaskMessage(Message message) throws XmlParseException, JMSException {
+	parse(message);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/20/2004 11:01:40 AM)
+ * @return cbit.vcell.solver.Simulation
+ */
+public SimulationTask getSimulationTask() {
+	return simTask;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/29/2003 2:51:01 PM)
+ * @return cbit.vcell.solver.Simulation
+ * @param xml java.lang.String
+ */
+private void parse(Message message) throws XmlParseException, JMSException {
+	if (message == null | !(message instanceof javax.jms.TextMessage)) {
+		return;
+	}		
+		
+	String xmlString = ((TextMessage)message).getText();
+	Simulation simulation = XmlHelper.XMLToSim(xmlString);
+	int taskID = -1;
+	int jobIndex = -1;
+	FieldDataIdentifierSpec[] fieldDataIDs = null;
+	try {
+		taskID = ((Integer)JmsUtils.parseProperty(message, MessageConstants.TASKID_PROPERTY, int.class)).intValue();
+	} catch (MessagePropertyNotFoundException ex) {
+		throw new JMSException("Required property " + MessageConstants.TASKID_PROPERTY + " is missing");
+	}	
+	try {
+		jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+	} catch (MessagePropertyNotFoundException ex) {
+		throw new JMSException("Required property " + MessageConstants.JOBINDEX_PROPERTY + " is missing");
+	}
+
+	// is ok if there is no field data
+	try {
+		String fdstrs = (String)JmsUtils.parseProperty(message, MessageConstants.FIELDDATAID_PROPERTY, String.class);
+		java.util.StringTokenizer st = new java.util.StringTokenizer(fdstrs, "\n");
+		fieldDataIDs = new FieldDataIdentifierSpec[st.countTokens()];
+		int count = 0;
+		while (st.hasMoreTokens()) {
+			try{
+				fieldDataIDs[count ++] = 
+					FieldDataIdentifierSpec.fromCSVString(st.nextToken());
+			}catch(ExpressionException e){
+				throw new XmlParseException("Error creating FieldDataIdentifierSpec", e);
+			}
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		 System.out.println("Property " + MessageConstants.FIELDDATAID_PROPERTY + " is missing");
+	}	
+
+	simTask = new SimulationTask(new SimulationJob(simulation, jobIndex, fieldDataIDs), taskID);
+}
+
+
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 11:08:17 AM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+public void sendSimulationTask(JmsSession session) throws javax.jms.JMSException, cbit.vcell.xml.XmlParseException {
+	session.sendMessage(JmsUtils.getQueueSimJob(), toMessage(session), DeliveryMode.PERSISTENT, 0);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/29/2003 2:49:00 PM)
+ * @return java.lang.String
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private String simulation2XML() throws XmlParseException {
+	return XmlHelper.simToXML(simTask.getSimulationJob().getSimulation());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 11:08:17 AM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+private javax.jms.Message toMessage(JmsSession session) throws javax.jms.JMSException, cbit.vcell.xml.XmlParseException {
+	javax.jms.Message message = session.createTextMessage(simulation2XML());		
+
+	message.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_SIMULATION_JOB_VALUE); // must have
+	message.setIntProperty(MessageConstants.JOBINDEX_PROPERTY, simTask.getSimulationJob().getJobIndex()); // must have
+	message.setIntProperty(MessageConstants.TASKID_PROPERTY, simTask.getTaskID()); // must have
+	
+	message.setStringProperty(MessageConstants.USERNAME_PROPERTY, simTask.getUserName()); // might be used to remove from the job queue when do stopSimulation
+	message.setLongProperty(MessageConstants.SIMKEY_PROPERTY, Long.parseLong(simTask.getSimKey() + "")); // might be used to remove from the job queue when do stopSimulation
+
+	message.setDoubleProperty(MessageConstants.SIZE_MB_PROPERTY, simTask.getEstimatedMemorySizeMB()); // for worker message filter
+	
+	if (simTask.getComputeResource() != null) {
+		message.setStringProperty(MessageConstants.COMPUTE_RESOURCE_PROPERTY, simTask.getComputeResource()); // for worker message filter
+	}
+
+	FieldDataIdentifierSpec[] fieldDataIDs = simTask.getSimulationJob().getFieldDataIdentifierSpecs();
+	if (fieldDataIDs != null && fieldDataIDs.length > 0) {
+		StringBuffer sb = new StringBuffer();
+		for (int i = 0; i < fieldDataIDs.length; i ++) {
+			sb.append(fieldDataIDs[i].toCSVString() + "\n");
+		}
+		message.setStringProperty(MessageConstants.FIELDDATAID_PROPERTY, sb.toString());
+	}
+	return message;
+}
+}
Index: src/cbit/vcell/messaging/QueueListenerImpl.java
===================================================================
--- src/cbit/vcell/messaging/QueueListenerImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/QueueListenerImpl.java	(revision 12031)
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/26/2003 10:48:42 AM)
+ * @author: Fei Gao
+ */
+public abstract class QueueListenerImpl implements javax.jms.MessageListener {
+/**
+ * QueueListenerImpl constructor comment.
+ */
+public QueueListenerImpl() {
+	super();
+}
+/**
+ * onMessage method comment.
+ */
+public final void onMessage(Message message) {
+	try {
+		onQueueMessage(message);
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}	
+}
+	public abstract void onQueueMessage(Message message) throws JMSException ;
+}
Index: src/cbit/vcell/messaging/AbstractJmsConnectionImpl.java
===================================================================
--- src/cbit/vcell/messaging/AbstractJmsConnectionImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/AbstractJmsConnectionImpl.java	(revision 12031)
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (6/6/2003 11:16:18 AM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractJmsConnectionImpl implements ExceptionListener, JmsConnection {
+	protected JmsProvider jmsProvider = null;
+	protected boolean connectionDropped = false;
+	protected boolean inSetup = false;
+	protected Connection connection = null;	
+
+	protected static final int JMSCONNECTION_PING_INTERVAL = 30; // second
+	protected static final long JMSCONNECTION_RETRY_INTERVAL = 10 * MessageConstants.SECOND_IN_MS; //second
+		
+	protected List<JmsSession> sessionList = Collections.synchronizedList(new ArrayList<JmsSession>());
+
+	protected AbstractJmsConnectionImpl(JmsProvider argJmsProvider) throws JMSException {
+		jmsProvider = argJmsProvider;
+	}
+
+	protected final synchronized void checkConnection() {
+		while (connectionDropped) {
+			try {
+				System.out.println("I am waiting for Queue Connection");
+				wait();
+			} catch (InterruptedException ex) {
+			}
+		}
+	}
+
+	protected final void closeAllSessions() {
+		synchronized (sessionList) {
+			for (JmsSession session : sessionList) {
+				try {
+					session.close();
+				} catch (JMSException ex) {
+					// try to close it, if can't, it's ok
+				}
+			}		
+		}
+		sessionList.clear();
+	}
+
+	public final void closeSession(JmsSession session) throws JMSException {
+		synchronized (sessionList) {
+			session.close();
+			sessionList.remove(session);	
+		}
+	}
+
+	public final JmsProvider getJmsProvider() {
+		return jmsProvider;
+	}
+	
+	public final boolean isBadConnection(JMSException ex){
+		return jmsProvider.isBadConnection(ex);
+	}
+
+	public final boolean isConnectionDropped() {
+		return connectionDropped;
+	}
+	
+	public final void onException(JMSException jmse) { 
+		// See if connection was dropped.
+	
+		// Tell the user that there is a problem.
+	
+		// See if the error is a dropped connection. If so, try to reconnect.
+		// NOTE: the test is against SonicMQ error codes.
+		if (isBadConnection(jmse)) {	
+			// Reestablish the connection
+			// If we are in connection setup, the setupConnection method itself will retry.
+			if (!inSetup) {
+				System.out.println(this + ":Please wait while the application tries to re-establish the connection...");
+				synchronized (this) {
+					connectionDropped = true;
+					inSetup = true;
+					setupConnection();			
+					setupOnException();
+					inSetup = false;
+					connectionDropped = false;					
+					notifyAll();
+				}
+			}	
+		}
+	}
+
+	protected final synchronized void setupOnException() {
+		try {
+			List<JmsSession> tempList = new ArrayList<JmsSession>();
+			tempList.addAll(sessionList);
+			sessionList.clear();
+			
+			for (JmsSession session : tempList) {
+				session.setupOnException();				
+				sessionList.add(session);
+			}
+				
+			startConnection();
+		} catch (Exception ex) {
+			ex.printStackTrace(System.out);
+		}
+		
+	}
+ 
+	protected abstract void setupConnection();
+ 
+	public final void close() throws javax.jms.JMSException {
+		closeAllSessions();	
+		connection.close();
+	}
+	
+	public final JmsSession getAutoSession() throws JMSException {
+		return getSession(false, Session.AUTO_ACKNOWLEDGE);
+	}
+	
+	
+	public final JmsSession getClientAckSession() throws JMSException {
+		return getSession(false, Session.CLIENT_ACKNOWLEDGE);
+	}
+	
+	public final JmsSession getTransactedSession() throws JMSException {
+		return getSession(true, Session.AUTO_ACKNOWLEDGE);
+	}
+	
+	public final javax.jms.Connection getConnection() {
+		return connection;
+	}
+
+	private final JmsSession getSession(boolean transactional, int ackMode) throws JMSException {
+		checkConnection();
+		
+		JmsSession session = new JmsSessionImp(this, transactional, ackMode);
+		session.setupSession();
+		synchronized (sessionList) {
+			sessionList.add(session);	
+		}
+		
+		return session;	
+	}
+	
+	public final void startConnection() throws JMSException {
+		connection.start();
+	}
+	
+	
+	public final void stopConnection() throws javax.jms.JMSException {
+		connection.stop();
+	}
+}
Index: src/cbit/vcell/messaging/WorkerEventMessage.java
===================================================================
--- src/cbit/vcell/messaging/WorkerEventMessage.java	(revision 0)
+++ src/cbit/vcell/messaging/WorkerEventMessage.java	(revision 12031)
@@ -0,0 +1,314 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import java.sql.SQLException;
+
+import cbit.vcell.messaging.server.SimulationDispatcher;
+import cbit.vcell.messaging.server.SimulationTask;
+import javax.jms.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+
+import cbit.vcell.solver.SimulationInfo;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.rmi.event.WorkerEvent;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/5/2004 12:35:20 PM)
+ * @author: Fei Gao
+ */
+public class WorkerEventMessage {
+	private WorkerEvent workerEvent = null;	
+	private static final String MESSAGE_TYPE_WORKEREVENT_VALUE	= "WorkerEvent";
+
+	private static final String WORKEREVENT_STATUS = "WorkerEvent_Status";
+	private static final String WORKEREVENT_PROGRESS = "WorkerEvent_Progress";
+	private static final String WORKEREVENT_TIMEPOINT = "WorkerEvent_TimePoint";
+	private static final String WORKEREVENT_STATUSMSG = "WorkerEvent_StatusMsg";
+	
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public WorkerEventMessage(WorkerEvent event) {
+	workerEvent = event;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public WorkerEventMessage(SimulationDispatcher dispatcher, Message message0) throws JMSException, DataAccessException {
+	parseMessage(dispatcher, message0);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/11/2004 11:32:33 AM)
+ * @return cbit.rmi.event.WorkerEvent
+ */
+public cbit.rmi.event.WorkerEvent getWorkerEvent() {
+	return workerEvent;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:19:48 PM)
+ * @param message javax.jms.Message
+ */
+private void parseMessage(SimulationDispatcher dispatcher, Message message) throws JMSException {
+	if (message == null) {
+		throw new RuntimeException("Null message");
+	}	
+
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		if (msgType != null && !msgType.equals(MESSAGE_TYPE_WORKEREVENT_VALUE)) {
+			throw new RuntimeException("Wrong message");
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		throw new RuntimeException("Wrong message");
+	}
+			
+	if (message instanceof ObjectMessage) {
+		Object obj = ((ObjectMessage)message).getObject();
+		if (!(obj instanceof WorkerEvent)) {
+			throw new IllegalArgumentException("Expecting " + SimulationInfo.class.getName() + " in message.");
+		}
+		workerEvent = (WorkerEvent)obj;
+
+		// from c++ executable
+	} else if (message instanceof TextMessage) {
+		try {
+			String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+			if (msgType != null && !msgType.equals(MESSAGE_TYPE_WORKEREVENT_VALUE)) {
+				throw new RuntimeException("Wrong message"); // wrong message
+			}
+			int status = ((Integer)JmsUtils.parseProperty(message, WORKEREVENT_STATUS, int.class)).intValue();
+			String hostname = (String)JmsUtils.parseProperty(message, MessageConstants.HOSTNAME_PROPERTY, String.class);
+			String username = (String)JmsUtils.parseProperty(message, MessageConstants.USERNAME_PROPERTY, String.class);
+			int taskID = ((Integer)JmsUtils.parseProperty(message, MessageConstants.TASKID_PROPERTY, int.class)).intValue();
+			int jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+			Long longkey = (Long)JmsUtils.parseProperty(message, MessageConstants.SIMKEY_PROPERTY, long.class);
+
+			KeyValue simKey = new KeyValue(longkey + "");
+			Simulation sim = null;
+			try {
+				User user = dispatcher.getUser(simKey, username);
+				sim = dispatcher.getSimulation(user, simKey);			
+				if (sim == null) {
+					throw new RuntimeException("Null Simulation"); //wrong message	
+				}
+			} catch (DataAccessException ex) {
+				throw new RuntimeException("Null Simulation"); // wrong message
+			} catch (SQLException e) {
+				throw new RuntimeException("Null Simulation"); // wrong message
+			}
+			
+			String statusMessage = null;
+			Double progress = null;
+			Double timepoint = null;
+			
+			try {
+				statusMessage = (String)JmsUtils.parseProperty(message, WORKEREVENT_STATUSMSG, String.class);
+			} catch (MessagePropertyNotFoundException ex) {
+				// it's OK not to have status message
+			}
+
+			try {
+				progress = (Double)JmsUtils.parseProperty(message, WORKEREVENT_PROGRESS, double.class);
+				timepoint = (Double)JmsUtils.parseProperty(message, WORKEREVENT_TIMEPOINT, double.class);
+			} catch (MessagePropertyNotFoundException ex) {
+				// it's OK not to have progress or timepoint
+			}
+			
+			SimulationMessage simulationMessage = SimulationMessage.fromSerializedMessage(statusMessage);
+			if (simulationMessage == null) {			
+				switch (status) {
+				case WorkerEvent.JOB_ACCEPTED:
+					throw new RuntimeException("unexpected job_accepted status");
+				case WorkerEvent.JOB_STARTING:
+					if (statusMessage == null) {
+						simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_STARTING;
+					} else {
+						simulationMessage = SimulationMessage.workerStarting(statusMessage);
+					}
+					break;
+				case WorkerEvent.JOB_DATA:
+					simulationMessage = SimulationMessage.workerData(timepoint);
+					break;
+				case WorkerEvent.JOB_PROGRESS:
+					simulationMessage = SimulationMessage.workerProgress(progress);
+					break;
+				case WorkerEvent.JOB_FAILURE:
+					if (statusMessage == null) {
+						simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_FAILURE;
+					} else {
+						simulationMessage = SimulationMessage.workerFailure(statusMessage);
+					}
+					break;
+				case WorkerEvent.JOB_COMPLETED:
+					if (statusMessage == null) {
+						simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_COMPLETED;
+					} else {
+						simulationMessage = SimulationMessage.workerCompleted(statusMessage);
+					}
+					break;
+				case WorkerEvent.JOB_WORKER_ALIVE:
+					simulationMessage = SimulationMessage.MESSAGE_WORKEREVENT_WORKERALIVE;
+					break;
+				default:
+					throw new RuntimeException("unexpected worker event status : " + status);
+				}
+			}
+
+			workerEvent = new WorkerEvent(status, dispatcher, sim.getSimulationInfo().getAuthoritativeVCSimulationIdentifier(), jobIndex, hostname, taskID, progress, timepoint, simulationMessage);
+					
+		} catch (MessagePropertyNotFoundException ex) {
+			throw new RuntimeException("Wrong message"); //wrong message
+		} 
+	} else {
+		throw new IllegalArgumentException("Expecting object message.");
+	}
+
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendAccepted(JmsSession session, Object source, SimulationTask simTask, String hostName) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_ACCEPTED, source, simTask, hostName, SimulationMessage.MESSAGE_JOB_ACCEPTED);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendCompleted(JmsSession session, Object source, SimulationTask simTask, String hostName, double progress, double timePoint, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_COMPLETED, source, simTask, hostName, new Double(progress), new Double(timePoint), simulationMessage);		
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendFailed(JmsSession session, Object source, SimulationTask simTask, String hostName, SimulationMessage failMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_FAILURE, source, simTask,	hostName, failMessage);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendNewData(JmsSession session, Object source, SimulationTask simTask, String hostName, double progress, double timePoint, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_DATA, source, simTask, hostName, new Double(progress), new Double(timePoint), simulationMessage);		
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendProgress(JmsSession session, Object source, SimulationTask simTask, String hostName, double progress, double timePoint, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_PROGRESS, source, simTask, hostName, new Double(progress), new Double(timePoint), simulationMessage);		
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendStarting(JmsSession session, Object source, SimulationTask simTask, String hostName, SimulationMessage startMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_STARTING, source, simTask, hostName, startMessage);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public static WorkerEventMessage sendWorkerAlive(JmsSession session, Object source, SimulationTask simTask, String hostName, SimulationMessage simulationMessage) throws JMSException {
+	WorkerEvent workerEvent = new WorkerEvent(WorkerEvent.JOB_WORKER_ALIVE, source, simTask, hostName, simulationMessage);
+	WorkerEventMessage workerEventMessage = new WorkerEventMessage(workerEvent);
+	workerEventMessage.sendWorkerEvent(session);
+
+	return workerEventMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+private void sendWorkerEvent(JmsSession session) throws JMSException {
+	session.sendMessage(JmsUtils.getQueueWorkerEvent(), toMessage(session), DeliveryMode.PERSISTENT, MessageConstants.INTERVAL_SERVER_FAIL);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/20/2003 1:36:36 PM)
+ * @return javax.jms.Message
+ */
+private Message toMessage(JmsSession session) throws JMSException {		
+	Message message = session.createObjectMessage(workerEvent);
+	message.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_WORKEREVENT_VALUE);
+	
+	return message;
+}
+}
Index: src/cbit/vcell/messaging/JmsServiceProviderMessaging.java
===================================================================
--- src/cbit/vcell/messaging/JmsServiceProviderMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsServiceProviderMessaging.java	(revision 12031)
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+import static cbit.vcell.messaging.admin.ManageConstants.*;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.server.ServiceProvider;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/2/2003 3:00:11 PM)
+ * @author: Fei Gao
+ */
+public abstract class JmsServiceProviderMessaging implements ControlTopicListener {
+	protected JmsConnectionFactory jmsConnFactory = null;
+	protected org.vcell.util.SessionLog log = null;
+	protected JmsConnection jmsConn = null;
+	protected JmsSession listenTopicSession = null;
+	protected ServiceProvider jmsServiceProvider = null;
+
+/**
+ * JmsMessaging constructor comment.
+ */
+protected JmsServiceProviderMessaging(ServiceProvider serviceProvider0, org.vcell.util.SessionLog log0) throws JMSException {
+	log = log0;
+	jmsConnFactory = new JmsConnectionFactoryImpl();
+	jmsServiceProvider = serviceProvider0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 10:46:29 AM)
+ */
+private void closeJmsConnection() {
+	try {
+		if (jmsConn != null) {
+			jmsConn.close();
+		}
+	} catch (JMSException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 10:28:36 AM)
+ * @return java.lang.String
+ */
+private final String getDaemonControlFilter() {
+	return MESSAGE_TYPE_PROPERTY + " NOT IN " 
+		+ "('" + MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_IAMALIVE_VALUE + "'"
+		+ ")";		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/31/2003 11:49:03 AM)
+ * @return cbit.vcell.messaging.VCellQueueConnection
+ */
+public JmsConnection getJmsConnection() {
+	return jmsConn;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ * Got message from server_control topic 
+ */
+public void onControlTopicMessage(Message message) {
+	onDaemonMessage(listenTopicSession, message, jmsServiceProvider.getServiceInstanceStatus());
+}
+
+
+/**
+ * onMessage method comment.
+ */
+public final void onDaemonMessage(JmsSession controlSession, javax.jms.Message message, ServiceInstanceStatus serviceInstanceStatus) {
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MESSAGE_TYPE_PROPERTY, String.class);
+		String serviceID = null;
+		
+		if (msgType == null) {
+			return;
+		}
+		
+		log.print("JmsMessaging: onDaemonMessage:onMessage [" + JmsUtils.toString(message) + "]");	
+		
+		if (msgType.equals(MESSAGE_TYPE_ISSERVICEALIVE_VALUE)) {			
+			Message reply = controlSession.createObjectMessage(serviceInstanceStatus);
+			reply.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_IAMALIVE_VALUE);
+			reply.setStringProperty(SERVICE_ID_PROPERTY, serviceInstanceStatus.getID());
+			log.print("sending reply [" + JmsUtils.toString(reply) + "]");
+			if (message.getJMSReplyTo() != null) {
+				reply.setJMSCorrelationID(message.getJMSMessageID());
+				controlSession.publishMessage((Topic)message.getJMSReplyTo(), reply);
+			} else {
+				controlSession.publishMessage(JmsUtils.getTopicDaemonControl(), reply);
+			}		
+		} else if (msgType.equals(MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE)) {				
+			Message reply = controlSession.createObjectMessage(serviceInstanceStatus);
+			reply.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE);
+			reply.setStringProperty(SERVICE_ID_PROPERTY, serviceInstanceStatus.getID());
+			controlSession.publishMessage(JmsUtils.getTopicDaemonControl(), reply);			
+			log.print("sending reply [" + JmsUtils.toString(reply) + "]");
+			
+		} else if (msgType.equals(MESSAGE_TYPE_STOPSERVICE_VALUE)) {
+			serviceID = (String)JmsUtils.parseProperty(message, SERVICE_ID_PROPERTY, String.class);
+			if (serviceID != null && serviceID.equalsIgnoreCase(serviceInstanceStatus.getID()))  {
+				stopService();
+			}
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+	} catch (JMSException ex) {
+		log.exception(ex);
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+protected void reconnect() throws JMSException {
+	jmsConn = jmsConnFactory.createConnection();
+	listenTopicSession = jmsConn.getAutoSession();	
+	listenTopicSession.setupTopicListener(JmsUtils.getTopicDaemonControl(), getDaemonControlFilter(), new ControlMessageCollector(this));
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/10/2003 8:42:49 AM)
+ */
+protected void stopService() {
+	try {
+		Thread t = new Thread() {
+			public void run() {
+				jmsServiceProvider.stop();
+				closeJmsConnection();
+			}
+		};
+		t.start();
+		t.join(3000);	
+	} catch (InterruptedException ex) {
+	} finally {
+		System.exit(0);
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/JmsDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/JmsDispatcherDbManager.java	(revision 0)
+++ src/cbit/vcell/messaging/server/JmsDispatcherDbManager.java	(revision 12031)
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+
+import java.sql.Connection;
+import java.util.Date;
+import cbit.vcell.solver.SimulationMessage;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.SimulationQueueID;
+import org.vcell.util.document.VCellServerID;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:45:15 PM)
+ * @author: Fei Gao
+ */
+public class JmsDispatcherDbManager extends AbstractDispatcherDbManager implements MessagingDispatcherDbManager {
+/**
+ * JmsSimulationDispatcherDbDriver constructor comment.
+ */
+public JmsDispatcherDbManager() {
+	super();
+}
+
+
+/**
+ * updateDispatchedStatus method comment.
+ */
+public SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+		String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage startMsg) 
+			throws DataAccessException, UpdateSynchronizationException {
+
+	if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+		
+		SimulationJobStatus newJobStatus = getNewStatus_updateDispatchedStatus(oldJobStatus, computeHost, vcSimID, jobIndex, taskID, startMsg);
+
+		newJobStatus = adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+
+		return newJobStatus;
+	}
+
+	return oldJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, String hostName, SchedulerStatus status, SimulationMessage solverMsg) 
+			throws DataAccessException, UpdateSynchronizationException {
+	if (oldJobStatus == null ||  oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {		
+
+		SimulationJobStatus newJobStatus = getNewStatus_updateEndStatus(oldJobStatus, vcSimID, jobIndex, taskID, hostName, status, solverMsg);
+
+		if (oldJobStatus == null) {
+			newJobStatus = adminDbXA.insertSimulationJobStatus(con, newJobStatus);
+		} else {
+			newJobStatus = adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+		}
+
+		return newJobStatus;
+	}
+
+	return oldJobStatus;
+}
+
+
+/**
+ * updateLatestUpdateDate method comment.
+ */
+public void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+
+	if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+
+		SimulationJobStatus	newJobStatus = getNewStatus_updateLatestUpdateDate(oldJobStatus, vcSimID, jobIndex, taskID, simulationMessage);
+		
+		if (newJobStatus != null) {
+			adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+		}
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateQueueStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDb, Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationQueueID queueID, boolean firstSubmit) 
+			throws DataAccessException, UpdateSynchronizationException {
+	if (oldJobStatus == null || oldJobStatus.getSchedulerStatus().isDone() || oldJobStatus.getSchedulerStatus().isWaiting()) {	
+		// no job for the same simulation running						
+		Date submitDate = firstSubmit ? null : oldJobStatus.getSubmitDate();
+		SchedulerStatus schedulerStatus = SchedulerStatus.WAITING;
+		SimulationMessage simulationMessage = SimulationMessage.MESSAGE_JOB_WAITING;
+		if (queueID == SimulationQueueID.QUEUE_ID_SIMULATIONJOB) {
+			schedulerStatus = SchedulerStatus.QUEUED;
+			simulationMessage = SimulationMessage.MESSAGE_JOB_QUEUED;
+		}
+
+		// update the job status in the database and local memory
+		SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, jobIndex, submitDate, schedulerStatus, taskID, 
+				simulationMessage,	new SimulationQueueEntryStatus(null, MessageConstants.PRIORITY_DEFAULT, queueID), null);
+		
+		if (oldJobStatus == null) {
+			newJobStatus = adminDb.insertSimulationJobStatus(con, newJobStatus);
+		} else {
+			newJobStatus = adminDb.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+		}
+
+		return newJobStatus;
+	}
+
+	return oldJobStatus;
+		
+}
+
+
+/**
+ * updateRunningStatus method comment.
+ */
+public SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, String hostName, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, boolean hasData, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+	if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+
+		SimulationJobStatus newJobStatus = getNewStatus_updateRunningStatus(oldJobStatus, hostName, vcSimID, jobIndex, hasData, solverMsg);
+
+		if (oldJobStatus == newJobStatus) { // running statuses, don't always store into the database		
+			updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, taskID, solverMsg);
+			return oldJobStatus;
+		} else {
+			newJobStatus = adminDbXA.updateSimulationJobStatus(con, oldJobStatus, newJobStatus);
+			return newJobStatus;
+		}
+	}
+
+	return oldJobStatus;
+}
+}
Index: src/cbit/vcell/messaging/server/LocalDataSetControllerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalDataSetControllerMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalDataSetControllerMessaging.java	(revision 12031)
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.rmi.event.*;
+import cbit.vcell.solver.*;
+import cbit.vcell.client.data.OutputContext;
+import cbit.vcell.export.server.*;
+import cbit.vcell.field.FieldDataFileOperationResults;
+import cbit.vcell.field.FieldDataFileOperationSpec;
+import cbit.vcell.simdata.gui.SpatialSelection;
+import cbit.plot.*;
+import java.rmi.*;
+import java.rmi.server.*;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCDataIdentifier;
+
+import cbit.vcell.solvers.CartesianMesh;
+import cbit.vcell.server.*;
+import cbit.vcell.simdata.*;
+
+/**
+ * This interface was generated by a SmartGuide.
+ * 
+ */
+public class LocalDataSetControllerMessaging extends UnicastRemoteObject implements DataSetController {
+    private RpcDataServerProxy dataServerProxy = null;
+    private User user = null;
+    private SessionLog sessionLog = null;
+
+/**
+ * This method was created by a SmartGuide.
+ */
+public LocalDataSetControllerMessaging (SessionLog sLog, User argUser, cbit.vcell.messaging.JmsClientMessaging clientMessaging) throws RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortDataSetController,0));
+	this.sessionLog = sLog;
+	this.user = argUser;
+	try {
+		this.dataServerProxy = new RpcDataServerProxy(user, clientMessaging, sessionLog);
+	} catch (javax.jms.JMSException e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException("JMS exception creating DataServerProxy: "+e.getMessage());
+	}
+}
+
+
+
+public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.fieldDataFileOperationSpec(...)");
+	try {
+		return dataServerProxy.fieldDataFileOperation(fieldDataFileOperationSpec);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String[]
+ */
+public DataIdentifier[] getDataIdentifiers(OutputContext outputContext,VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getDataIdentifiers(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getDataIdentifiers(outputContext,vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ */
+public double[] getDataSetTimes(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getDataSetTimes(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getDataSetTimes(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/26/2004 1:05:01 PM)
+ * @param function cbit.vcell.math.Function
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+
+public cbit.vcell.solver.AnnotatedFunction[] getFunctions(OutputContext outputContext,org.vcell.util.document.VCDataIdentifier vcdataID) throws org.vcell.util.DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getFunctions(vcdataID=" + vcdataID + ")");
+	try {
+		return dataServerProxy.getFunctions(outputContext,vcdataID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.plot.PlotData
+ * @param varName java.lang.String
+ * @param spatialSelection cbit.vcell.simdata.gui.SpatialSelection
+ */
+public PlotData getLineScan(OutputContext outputContext,VCDataIdentifier vcdID, String varName, double time, SpatialSelection spatialSelection) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getLineScan(vcdID=" + vcdID + ", " + varName + ", " + time + ", at " + spatialSelection+")");
+	try {
+		return dataServerProxy.getLineScan(outputContext,vcdID, varName, time, spatialSelection);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return int[]
+ */
+public CartesianMesh getMesh(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getMesh(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getMesh(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/14/00 11:20:51 AM)
+ * @return cbit.vcell.export.data.ODESimData
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getODEData(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getODEData(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param time double
+ */
+public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getParticleDataBlock(vcdID=" + vcdID + ",time=" + time + ")");
+	try {
+		return dataServerProxy.getParticleDataBlock(vcdID,time);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return boolean
+ */
+public boolean getParticleDataExists(VCDataIdentifier vcdID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getParticleDataExists(vcdID=" + vcdID + ")");
+	try {
+		return dataServerProxy.getParticleDataExists(vcdID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param time double
+ */
+public SimDataBlock getSimDataBlock(OutputContext outputContext,VCDataIdentifier vcdID, String varName, double time) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getSimDataBlock(vcdID=" + vcdID + ", varName=" + varName + ", time=" + time + ")");
+	try {
+		return dataServerProxy.getSimDataBlock(outputContext,vcdID,varName,time);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param index int
+ */
+public org.vcell.util.document.TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext,VCDataIdentifier vcdID,org.vcell.util.document.TimeSeriesJobSpec timeSeriesJobSpec) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getTimeSeriesValues(vcdID=" + vcdID + ", " + timeSeriesJobSpec + ")");
+	try {
+		return dataServerProxy.getTimeSeriesValues(outputContext,vcdID,timeSeriesJobSpec);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @param simInfo cbit.vcell.solver.SimulationInfo
+ * @exception org.vcell.util.DataAccessException The exception description.
+ */
+public ExportEvent makeRemoteFile(OutputContext outputContext,ExportSpecs exportSpecs) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.makeRemoteFile(vcdID=" + exportSpecs.getVCDataIdentifier() + ")");
+	try {
+		return dataServerProxy.makeRemoteFile(outputContext,exportSpecs);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+
+public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdataID) throws DataAccessException {
+	sessionLog.print("LocalDataSetControllerMessaging.getDataProcessingOutput(vcdataID=" + vcdataID + ")");
+	try {
+		return dataServerProxy.getDataProcessingOutput(vcdataID);
+	} catch (DataAccessException e){
+		sessionLog.exception(e);
+		throw e;
+	} catch (Throwable e){
+		sessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+}
Index: src/cbit/vcell/messaging/server/RpcDbServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDbServerImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDbServerImpl.java	(revision 12031)
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.sql.OraclePoolingConnectionFactory;
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import org.vcell.util.DataAccessException;
+import cbit.vcell.modeldb.DatabaseServerImpl;
+import cbit.sql.OracleKeyFactory;
+/**
+ * Insert the type's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @author: Jim Schaff
+ *
+ * stateless database service for any user (should be thread safe ... reentrant)
+ *
+ */
+public class RpcDbServerImpl extends AbstractRpcServerImpl {
+	private DatabaseServerImpl dbServerImpl = null;	
+
+/**
+ * DbServerImpl constructor comment.
+ */
+public RpcDbServerImpl(org.vcell.util.SessionLog sessionLog) throws DataAccessException {
+	super(sessionLog);
+	try {
+		ConnectionFactory conFactory = new OraclePoolingConnectionFactory(log);
+		KeyFactory	keyFactory = new OracleKeyFactory();
+		dbServerImpl = new DatabaseServerImpl(conFactory, keyFactory, sessionLog);	 
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException("Error creating DBTopLevel " + e.getMessage());
+	}		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/16/2004 12:30:44 PM)
+ * @return java.lang.Object
+ */
+public java.lang.Object getServerImpl() {
+	return dbServerImpl;
+}
+}
Index: src/cbit/vcell/messaging/server/PropertyLoaderThread.java
===================================================================
--- src/cbit/vcell/messaging/server/PropertyLoaderThread.java	(revision 0)
+++ src/cbit/vcell/messaging/server/PropertyLoaderThread.java	(revision 12031)
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/17/2003 8:59:18 AM)
+ * @author: Fei Gao
+ */
+public class PropertyLoaderThread extends Thread {
+/**
+ * PropertyLoaderThread constructor comment.
+ */
+public PropertyLoaderThread() {
+	super();
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param target java.lang.Runnable
+ */
+public PropertyLoaderThread(Runnable target) {
+	super(target);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param target java.lang.Runnable
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(Runnable target, String name) {
+	super(target, name);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(String name) {
+	super(name);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param group java.lang.ThreadGroup
+ * @param target java.lang.Runnable
+ */
+public PropertyLoaderThread(ThreadGroup group, Runnable target) {
+	super(group, target);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param group java.lang.ThreadGroup
+ * @param target java.lang.Runnable
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(ThreadGroup group, Runnable target, String name) {
+	super(group, target, name);
+}
+
+
+/**
+ * PropertyLoaderThread constructor comment.
+ * @param group java.lang.ThreadGroup
+ * @param name java.lang.String
+ */
+public PropertyLoaderThread(ThreadGroup group, String name) {
+	super(group, name);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 8:59:45 AM)
+ */
+public void run() {
+	while (true){
+		//
+		// sleep for a while
+		//
+		try {
+			Thread.sleep(20 * MessageConstants.MINUTE_IN_MS);
+		} catch (InterruptedException e){
+		}
+		
+		//
+		// re-read the property file
+		//
+		System.out.println("re-read the property file");
+		try {
+			PropertyLoader.loadProperties();
+		} catch (Throwable e){
+			e.printStackTrace(System.out);
+		}
+	}		
+}
+}
Index: src/cbit/vcell/messaging/server/RpcDataServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDataServerProxy.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDataServerProxy.java	(revision 12031)
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCDataIdentifier;
+
+import cbit.vcell.client.data.OutputContext;
+import cbit.vcell.field.FieldDataFileOperationResults;
+import cbit.vcell.field.FieldDataFileOperationSpec;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.simdata.*;
+import cbit.vcell.solver.DataProcessingOutput;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/6/2001 1:51:41 PM)
+ * @author: Jim Schaff
+ */
+public class RpcDataServerProxy extends AbstractRpcServerProxy implements cbit.vcell.server.DataSetController {
+/**
+ * DataServerProxy constructor comment.
+ */
+public RpcDataServerProxy(User argUser, JmsClientMessaging clientMessaging, SessionLog log) throws javax.jms.JMSException {
+	super(argUser, clientMessaging, cbit.vcell.messaging.JmsUtils.getQueueSimDataReq(), log);
+}
+
+
+
+public FieldDataFileOperationResults fieldDataFileOperation(FieldDataFileOperationSpec fieldDataFileOperationSpec) throws org.vcell.util.DataAccessException {
+	return (FieldDataFileOperationResults)rpc("fieldDataFileOperation",new Object[]{user, fieldDataFileOperationSpec});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.simdata.DataIdentifier[] getDataIdentifiers(OutputContext outputContext,VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (DataIdentifier[])rpc("getDataIdentifiers",new Object[]{outputContext,user, vcdID});
+}
+
+public DataProcessingOutput getDataProcessingOutput(VCDataIdentifier vcdID) throws DataAccessException {
+	return (DataProcessingOutput)rpc("getDataProcessingOutput", new Object[]{user, vcdID});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public double[] getDataSetTimes(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (double[])rpc("getDataSetTimes",new Object[]{user, vcdID});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/26/2004 1:01:25 PM)
+ * @param function cbit.vcell.math.Function
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.solver.AnnotatedFunction[] getFunctions(OutputContext outputContext,org.vcell.util.document.VCDataIdentifier vcdataID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.solver.AnnotatedFunction[])rpc("getFunctions",new Object[]{outputContext,user, vcdataID});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.plot.PlotData
+ * @param variable java.lang.String
+ * @param time double
+ * @param spatialSelection cbit.vcell.simdata.gui.SpatialSelection
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.plot.PlotData getLineScan(OutputContext outputContext,VCDataIdentifier vcdID, String variable, double time, cbit.vcell.simdata.gui.SpatialSelection spatialSelection) throws org.vcell.util.DataAccessException {
+	return (cbit.plot.PlotData)rpc("getLineScan",new Object[]{outputContext,user, vcdID,variable,new Double(time),spatialSelection});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return CartesianMesh
+ */
+public cbit.vcell.solvers.CartesianMesh getMesh(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.solvers.CartesianMesh)rpc("getMesh",new Object[]{user, vcdID});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/6/2001 1:51:41 PM)
+ * @param odeSimData cbit.vcell.export.data.ODESimData
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.solver.ode.ODESimData getODEData(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.solver.ode.ODESimData)rpc("getODEData",new Object[]{user, vcdID});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return ParticleData
+ * @param time double
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public ParticleDataBlock getParticleDataBlock(VCDataIdentifier vcdID, double time) throws org.vcell.util.DataAccessException {
+	return (ParticleDataBlock)rpc("getParticleDataBlock",new Object[]{user, vcdID,new Double(time)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return boolean
+ */
+public boolean getParticleDataExists(VCDataIdentifier vcdID) throws org.vcell.util.DataAccessException {
+	Boolean bParticleDataExists = (Boolean)rpc("getParticleDataExists",new Object[]{user, vcdID});
+	return bParticleDataExists.booleanValue();
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimDataBlock getSimDataBlock(OutputContext outputContext,VCDataIdentifier vcdID, String varName, double time) throws org.vcell.util.DataAccessException {
+	return (SimDataBlock)rpc("getSimDataBlock",new Object[]{outputContext,user, vcdID,varName,new Double(time)});
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return double[]
+ * @param varName java.lang.String
+ * @param x int
+ * @param y int
+ * @param z int
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.TimeSeriesJobResults getTimeSeriesValues(OutputContext outputContext,VCDataIdentifier vcdID,org.vcell.util.document.TimeSeriesJobSpec timeSeriesJobSpec) throws org.vcell.util.DataAccessException {
+//	return (cbit.util.TimeSeriesJobResults)rpc("getTimeSeriesValues",new Object[]{user, vcdID,timeSeriesJobSpec});
+	try {
+		if(!timeSeriesJobSpec.getVcDataJobID().isBackgroundTask()){
+			return (org.vcell.util.document.TimeSeriesJobResults)rpc("getTimeSeriesValues",new Object[]{outputContext,user, vcdID,timeSeriesJobSpec});
+		}else{
+			rpc(ServiceType.DATA, "getTimeSeriesValues", new Object[]{outputContext,user, vcdID,timeSeriesJobSpec}, false);
+		}
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+	return null;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/6/2001 3:56:41 PM)
+ * @return cbit.rmi.event.ExportEvent
+ * @param exportSpecs cbit.vcell.export.server.ExportSpecs
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.rmi.event.ExportEvent makeRemoteFile(OutputContext outputContext,cbit.vcell.export.server.ExportSpecs exportSpecs) throws org.vcell.util.DataAccessException {
+	try {
+		rpc(ServiceType.DATA, "makeRemoteFile", new Object[]{outputContext,user, exportSpecs}, false, new String[]{ServiceType.DATAEXPORT.getName()}, new Object[]{new Boolean(true)});
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+	return null;
+}
+
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private Object rpc(String methodName, Object[] args) throws DataAccessException {
+	try {
+		return rpc(ServiceType.DATA, methodName, args, true);
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/Worker.java
===================================================================
--- src/cbit/vcell/messaging/server/Worker.java	(revision 0)
+++ src/cbit/vcell/messaging/server/Worker.java	(revision 12031)
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:20:06 PM)
+ * @author: Fei Gao
+ */
+public interface Worker extends ServiceProvider, cbit.vcell.messaging.ControlTopicListener, cbit.vcell.solver.SolverListener {
+	public String getJobSelector();
+	public boolean isRunning();
+}
Index: src/cbit/vcell/messaging/server/SimDataServer.java
===================================================================
--- src/cbit/vcell/messaging/server/SimDataServer.java	(revision 0)
+++ src/cbit/vcell/messaging/server/SimDataServer.java	(revision 12031)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+
+import static org.vcell.util.MessageConstants.*;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public class SimDataServer extends JmsRpcServer {
+	private RpcDataServerImpl rpcDataServerImpl = null;
+	private static String filter = "(" + MESSAGE_TYPE_PROPERTY + "='" + MESSAGE_TYPE_RPC_SERVICE_VALUE  + "') AND (" 
+		+ SERVICE_TYPE_PROPERTY + "='" + ServiceType.DATA.getName() + "')";	
+
+/**
+ * Scheduler constructor comment.
+ */
+public SimDataServer(int serviceOrdinal, boolean bExportOnly, String logdir) throws Exception {
+	super(bExportOnly ? ServiceType.DATAEXPORT : ServiceType.DATA, serviceOrdinal, JmsUtils.getQueueSimDataReq(), 
+		filter + " AND (" + ServiceType.DATAEXPORT.getName() + (bExportOnly ? " is NOT NULL)" : " is NULL)"), logdir);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/1/2003 9:34:57 AM)
+ */
+public RpcServerImpl getRpcServerImpl() throws DataAccessException {
+	if (rpcDataServerImpl == null) {
+		try {
+			rpcDataServerImpl = new RpcDataServerImpl(rpcServerMessaging, log);			
+		} catch (java.io.FileNotFoundException ex) {
+			log.exception(ex);
+			throw new org.vcell.util.DataAccessException(ex.getMessage());
+		}
+	}
+
+	return rpcDataServerImpl;
+}
+
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 1) {
+		System.out.println("Missing arguments: " + SimDataServer.class.getName() + " serviceOrdinal [EXPORTONLY] [logdir]");
+		System.exit(1);
+	}
+	
+	try {
+		PropertyLoader.loadProperties();
+		
+		int serviceOrdinal = Integer.parseInt(args[0]);		
+		String logdir = null;
+		boolean bExportOnly = false;		
+		if (args.length > 1) {
+			if (args[1].equalsIgnoreCase("EXPORTONLY")) {
+				bExportOnly = true;
+				VCMongoMessage.serviceStartup(ServiceName.export, new Integer(serviceOrdinal), args);
+				if (args.length > 2) {	
+					logdir = args[2];
+				}
+			} else {
+				VCMongoMessage.serviceStartup(ServiceName.simData, new Integer(serviceOrdinal), args);
+				logdir = args[1];
+			}
+		}
+        SimDataServer simDataServer = new SimDataServer(serviceOrdinal, bExportOnly, logdir);
+        simDataServer.start();
+    } catch (Throwable e) {
+        e.printStackTrace(System.out);
+    }
+}
+}
Index: src/cbit/vcell/messaging/server/ServiceProvider.java
===================================================================
--- src/cbit/vcell/messaging/server/ServiceProvider.java	(revision 0)
+++ src/cbit/vcell/messaging/server/ServiceProvider.java	(revision 12031)
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import org.vcell.util.MessageConstants.ServiceType;
+
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:23:36 PM)
+ * @author: Fei Gao
+ */
+public interface ServiceProvider {
+public ServiceInstanceStatus getServiceInstanceStatus();
+public String getServiceInstanceID();
+public ServiceType getServiceType();
+public void stop();
+}
Index: src/cbit/vcell/messaging/server/AbstractDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractDispatcherDbManager.java	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractDispatcherDbManager.java	(revision 12031)
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.htc.PbsJobID;
+import cbit.vcell.message.server.dispatcher.SimulationDatabase;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.server.AdminDatabaseServer;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+import cbit.vcell.messaging.db.SimulationExecutionStatus;
+
+import java.sql.SQLException;
+import java.util.Date;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.SimulationQueueID;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.solver.VCSimulationIdentifier;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/16/2004 10:52:07 AM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractDispatcherDbManager implements DispatcherDbManager {
+/**
+ * SimulationDispatcherHelper constructor comment.
+ */
+public AbstractDispatcherDbManager() {
+	super();
+}
+
+
+/**
+ * updateDispatchedStatus method comment.
+ */
+SimulationJobStatus getNewStatus_updateDispatchedStatus(SimulationJobStatus oldJobStatus, String computeHost, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+
+	// new queue status
+	SimulationQueueEntryStatus oldQueueStatus = oldJobStatus.getSimulationQueueEntryStatus();
+	SimulationQueueEntryStatus newQueueStatus = new SimulationQueueEntryStatus(oldQueueStatus.getQueueDate(), 
+		oldQueueStatus.getQueuePriority(), SimulationQueueID.QUEUE_ID_NULL);
+	
+	// new exe status
+	SimulationExecutionStatus newExeStatus = new SimulationExecutionStatus(null, computeHost, null,	null, false, startMsg.getPbsJobId());
+
+	// new job status
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), vcSimID, jobIndex, oldJobStatus.getSubmitDate(), SchedulerStatus.DISPATCHED,
+			taskID, startMsg, newQueueStatus, newExeStatus);
+
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+SimulationJobStatus getNewStatus_updateEndStatus(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimID, int jobIndex, int taskID,
+		String hostName, SchedulerStatus status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+
+	// new queue status
+	SimulationQueueEntryStatus oldQueueStatus = oldJobStatus == null ? null : oldJobStatus.getSimulationQueueEntryStatus();
+	SimulationQueueEntryStatus newQueueStatus = oldQueueStatus;
+	if (oldQueueStatus != null && oldQueueStatus.getQueueID() != SimulationQueueID.QUEUE_ID_NULL) {		
+		newQueueStatus = new SimulationQueueEntryStatus(oldQueueStatus.getQueueDate(), oldQueueStatus.getQueuePriority(), SimulationQueueID.QUEUE_ID_NULL);
+	}
+
+	// new exe status
+	SimulationExecutionStatus oldExeStatus = oldJobStatus == null ? null : oldJobStatus.getSimulationExecutionStatus();
+	SimulationExecutionStatus newExeStatus = null;
+	boolean hasData = false;
+	
+	if (oldExeStatus == null) {
+		if (status == SchedulerStatus.COMPLETED) {
+			hasData = true;
+		}
+		newExeStatus = new SimulationExecutionStatus(null, hostName, null, null, hasData, solverMsg.getPbsJobId());				
+	} else {
+		if (status == SchedulerStatus.COMPLETED) {
+			hasData = true;
+		} else {
+			hasData = oldExeStatus.hasData();
+		}
+		PbsJobID pbsJobID = oldExeStatus.getPbsJobID();
+		if (solverMsg.getPbsJobId()!=null){
+			pbsJobID = solverMsg.getPbsJobId();
+		}
+		newExeStatus = new SimulationExecutionStatus(oldExeStatus.getStartDate(), (hostName != null) ? hostName : oldExeStatus.getComputeHost(), null, null, hasData, pbsJobID);
+	}
+
+	// new job status
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, jobIndex, 
+		oldJobStatus == null ? null : oldJobStatus.getSubmitDate(), status, taskID, solverMsg,
+		newQueueStatus, newExeStatus);
+	
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+SimulationJobStatus getNewStatus_updateLatestUpdateDate(SimulationJobStatus oldJobStatus, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+
+	SimulationExecutionStatus oldExeStatus = oldJobStatus.getSimulationExecutionStatus();
+	if (oldExeStatus == null) {
+		return null;
+	}
+	
+	Date latestUpdate = oldExeStatus.getLatestUpdateDate();
+	Date sysDate = oldJobStatus.getTimeDateStamp();
+	if (sysDate.getTime() - latestUpdate.getTime() < MessageConstants.INTERVAL_PING_SERVER * 3 / 5) {
+		return null;
+	}
+	
+	// new exe status
+	PbsJobID pbsJobID = oldExeStatus.getPbsJobID();
+	if (simulationMessage.getPbsJobId()!=null){
+		pbsJobID = simulationMessage.getPbsJobId();
+	}
+	SimulationExecutionStatus newExeStatus = new SimulationExecutionStatus(oldExeStatus.getStartDate(), oldExeStatus.getComputeHost(), null, 
+			oldExeStatus.getEndDate(), oldExeStatus.hasData(), pbsJobID);
+	
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), vcSimID, jobIndex, oldJobStatus.getSubmitDate(), 
+		oldJobStatus.getSchedulerStatus(),	oldJobStatus.getTaskID(), simulationMessage, oldJobStatus.getSimulationQueueEntryStatus(), newExeStatus);
+
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+SimulationJobStatus getNewStatus_updateRunningStatus(SimulationJobStatus oldJobStatus, String hostName, VCSimulationIdentifier vcSimID, 
+		int jobIndex, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException {
+
+	// new queue status		
+	SimulationQueueEntryStatus oldQueueStatus = oldJobStatus.getSimulationQueueEntryStatus();
+	SimulationQueueEntryStatus newQueueStatus = oldQueueStatus;
+	if (oldQueueStatus.getQueueID() != SimulationQueueID.QUEUE_ID_NULL) {
+		newQueueStatus = new SimulationQueueEntryStatus(oldQueueStatus.getQueueDate(), oldQueueStatus.getQueuePriority(), SimulationQueueID.QUEUE_ID_NULL);
+	}
+
+	// new exe status
+	SimulationExecutionStatus oldExeStatus = oldJobStatus.getSimulationExecutionStatus();
+	SimulationExecutionStatus newExeStatus = null;
+	if (oldExeStatus == null) {
+		newExeStatus = new SimulationExecutionStatus(null, hostName, null, null, hasData, solverMsg.getPbsJobId());
+	} else if (!oldJobStatus.getSchedulerStatus().isRunning() || !oldExeStatus.hasData() && hasData) {
+		PbsJobID pbsJobID = oldExeStatus.getPbsJobID();
+		if (solverMsg.getPbsJobId()!=null){
+			pbsJobID = solverMsg.getPbsJobId();
+		}
+		newExeStatus = new SimulationExecutionStatus(oldExeStatus.getStartDate(), (hostName != null) ? hostName : oldExeStatus.getComputeHost(), null, null, hasData, pbsJobID);		
+	} else {
+		return oldJobStatus;
+	}
+	
+	// new job status
+	SimulationJobStatus newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), vcSimID, jobIndex, oldJobStatus.getSubmitDate(), 
+			SchedulerStatus.RUNNING, oldJobStatus.getTaskID(), solverMsg, newQueueStatus, newExeStatus);
+
+	return newJobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus[] getSimulationJobStatusArray(SimulationDatabase simDb, KeyValue simKey, int jobIndex) throws DataAccessException {
+	try {		
+		return simDb.getSimulationJobStatusArray(simKey, jobIndex);
+	} catch (SQLException ex) {
+		throw new DataAccessException("updateDispatchedStatus " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus,	SimulationDatabase simDb, String computeHost, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+	try {
+
+		if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+			
+			SimulationJobStatus newJobStatus = getNewStatus_updateDispatchedStatus(oldJobStatus, computeHost, vcSimID, jobIndex, taskID, startMsg);
+
+			newJobStatus = simDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+
+			return newJobStatus;
+		}
+
+		return oldJobStatus;
+		
+	} catch (SQLException ex) {
+		throw new DataAccessException("updateEndStatus " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID, String hostName, SchedulerStatus status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {		
+
+			SimulationJobStatus newJobStatus = getNewStatus_updateEndStatus(oldJobStatus, vcSimID, jobIndex, taskID, hostName, status, solverMsg);
+			
+			newJobStatus = simDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+
+			return newJobStatus;
+		}
+
+		return oldJobStatus;
+	} catch (SQLException ex) {
+		throw new DataAccessException("updateEndStatus " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+
+			SimulationJobStatus	newJobStatus = getNewStatus_updateLatestUpdateDate(oldJobStatus, vcSimID, jobIndex, taskID, simulationMessage);
+			
+			if (newJobStatus != null) {
+				simDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+			}
+		}
+	} catch (SQLException ex) {
+		throw new DataAccessException("updateLatestUpdateDate " + ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, String hostName, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException {
+	try {
+		if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+
+			SimulationJobStatus newJobStatus = getNewStatus_updateRunningStatus(oldJobStatus, hostName, vcSimID, jobIndex, hasData, solverMsg);
+			if (oldJobStatus == newJobStatus) { // running statuses, don't always store into the database				
+				updateLatestUpdateDate(oldJobStatus, simDb, vcSimID, jobIndex, taskID, solverMsg);
+				return oldJobStatus;
+			} else {
+				newJobStatus = simDb.updateSimulationJobStatus(oldJobStatus, newJobStatus);
+				return newJobStatus;
+			}
+		}
+
+		return oldJobStatus;
+	} catch (SQLException ex) {
+		throw new DataAccessException("updateRunningStatus " + ex.getMessage());
+	}		
+}
+}
Index: src/cbit/vcell/messaging/server/RpcServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcServerProxy.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcServerProxy.java	(revision 12031)
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import org.vcell.util.MessageConstants.ServiceType;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:16:36 PM)
+ * @author: Fei Gao
+ */
+public interface RpcServerProxy {
+	public Object rpc(ServiceType serviceType, String methodName, Object[] args, boolean returnRequired) throws Exception;
+}
Index: src/cbit/vcell/messaging/server/RpcDataServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDataServerImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDataServerImpl.java	(revision 12031)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.simdata.DataServerImpl;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+
+import cbit.vcell.simdata.Cachetable;
+import cbit.vcell.simdata.DataSetControllerImpl;
+import cbit.vcell.export.server.ExportServiceImpl;
+
+/**
+ * This interface was generated by a SmartGuide.
+ * 
+ */
+public class RpcDataServerImpl extends AbstractRpcServerImpl implements cbit.rmi.event.ExportListener,cbit.rmi.event.DataJobListener {
+	private DataServerImpl dataServerImpl = null;
+	private cbit.vcell.messaging.RpcServerMessaging rpcServerMessaging = null;
+
+/**
+ * This method was created by a SmartGuide.
+ */
+public RpcDataServerImpl (cbit.vcell.messaging.RpcServerMessaging messaging, SessionLog sessionLog) throws FileNotFoundException {
+	super(sessionLog);
+	rpcServerMessaging = messaging;
+
+	Cachetable cacheTable = new Cachetable(MessageConstants.MINUTE_IN_MS * 20);
+	DataSetControllerImpl dataSetControllerImpl = new DataSetControllerImpl(sessionLog, cacheTable, 
+			new File(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty)), 
+			new File(PropertyLoader.getRequiredProperty(PropertyLoader.secondarySimDataDirProperty)));
+	//add dataJobListener
+	dataSetControllerImpl.addDataJobListener(this);
+	
+	ExportServiceImpl exportServiceImpl = new ExportServiceImpl(log);
+	// add export listener
+	exportServiceImpl.addExportListener(this);
+	
+	dataServerImpl = new DataServerImpl(log, dataSetControllerImpl, exportServiceImpl);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/31/2006 8:48:04 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void dataJobMessage(cbit.rmi.event.DataJobEvent event) {
+	try {
+		rpcServerMessaging.publishDataStatus(event);
+	} catch (javax.jms.JMSException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 10:34:11 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void exportMessage(cbit.rmi.event.ExportEvent event) {
+	try {
+		rpcServerMessaging.publishExportStatus(event);
+	} catch (javax.jms.JMSException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/16/2004 1:02:57 PM)
+ * @return java.lang.Object
+ */
+public java.lang.Object getServerImpl() {
+	return dataServerImpl;
+}
+}
Index: src/cbit/vcell/messaging/server/SimulationDispatcher.java
===================================================================
--- src/cbit/vcell/messaging/server/SimulationDispatcher.java	(revision 0)
+++ src/cbit/vcell/messaging/server/SimulationDispatcher.java	(revision 12031)
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.solver.VCSimulationDataIdentifier;
+import cbit.rmi.event.WorkerEvent;
+import javax.jms.*;
+
+import org.vcell.util.BigString;
+import org.vcell.util.CacheException;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.SimulationQueueID;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.ExternalDataIdentifier;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.solver.Simulation;
+
+import java.sql.SQLException;
+import java.util.Date;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Collections;
+import java.util.Vector;
+
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.field.FieldFunctionArguments;
+import cbit.vcell.field.FieldUtilities;
+import cbit.vcell.modeldb.AdminDBTopLevel;
+import cbit.vcell.modeldb.DbDriver;
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.sql.DBCacheTable;
+import cbit.sql.OracleKeyFactory;
+import cbit.sql.OraclePoolingConnectionFactory;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.SimulationDispatcherMessaging;
+import cbit.vcell.messaging.JmsSession;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.xml.XmlHelper;
+import cbit.vcell.xml.XmlParseException;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.WorkerEventMessage;
+import cbit.vcell.messaging.StatusMessage;
+import java.util.HashSet;
+import cbit.vcell.modeldb.ResultSetCrawler;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public class SimulationDispatcher extends AbstractJmsServiceProvider {
+	private Map<User, RpcDbServerProxy> userDbServerMap = null;
+	private ConnectionFactory conFactory = null;
+	private KeyFactory keyFactory = null;
+	private JmsClientMessaging clientMessaging = null;
+	private AdminDBTopLevel adminDbTopLevel = null;
+	
+	private boolean bStop = false;		
+	private SimulationDispatcherMessaging dispatcherMessaging = null;
+	private DBCacheTable simulationMap = null;
+	private Map<KeyValue, User> simUserMap = Collections.synchronizedMap(new HashMap<KeyValue, User>());
+	private Map<KeyValue, FieldDataIdentifierSpec[]> simFieldDataIDMap = Collections.synchronizedMap(new HashMap<KeyValue, FieldDataIdentifierSpec[]>());
+
+	private MessagingDispatcherDbManager dispatcherDbManager = new JmsDispatcherDbManager();
+	protected HashSet<VCSimulationDataIdentifier> resultSetSavedSet = new HashSet<VCSimulationDataIdentifier>();
+	protected ResultSetCrawler rsCrawler = null;	
+
+/**
+ * Scheduler constructor comment.
+ */
+public SimulationDispatcher(int serviceOrdinal, String logdir) throws Exception {	
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID(), ServiceType.DISPATCH, serviceOrdinal, ManageUtils.getHostName(), new Date(), true);	
+	initLog(logdir);
+
+	log = new StdoutSessionLog(serviceInstanceStatus.getID());
+	
+	conFactory = new OraclePoolingConnectionFactory(log);
+	keyFactory = new OracleKeyFactory();		
+	DbDriver.setKeyFactory(keyFactory);
+	adminDbTopLevel = new AdminDBTopLevel(conFactory,log);
+	rsCrawler = new ResultSetCrawler(conFactory, adminDbTopLevel, log);	
+
+	dispatcherMessaging = new SimulationDispatcherMessaging(this, conFactory, keyFactory, log);	
+}
+
+
+private void dataMoved(VCSimulationDataIdentifier vcSimDataID, User user, double timepoint) {
+	// called by data mover thread after successful move operations
+	try {		
+		if (!resultSetSavedSet.contains(vcSimDataID)){
+			try {
+				rsCrawler.updateSimResults(user,vcSimDataID);
+				resultSetSavedSet.add(vcSimDataID);
+			} catch (Throwable exc) {
+				log.exception(exc);
+			}
+		}
+	} catch (Throwable e){
+		log.exception(e);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/27/2003 3:15:57 PM)
+ * @return cbit.vcell.server.UserMetaDbServer
+ */
+private RpcDbServerProxy getDbServerProxy(User user) throws JMSException {
+	if (clientMessaging == null) {
+		clientMessaging = new JmsClientMessaging(dispatcherMessaging.getJmsConnection(), log, null);
+	}
+
+	if (userDbServerMap == null) {
+		userDbServerMap = Collections.synchronizedMap(new HashMap<User, RpcDbServerProxy>());
+	}
+		
+	synchronized (userDbServerMap) {
+		RpcDbServerProxy dbServer = (RpcDbServerProxy)userDbServerMap.get(user);
+		
+		if (dbServer == null) {
+			dbServer = new RpcDbServerProxy(user, clientMessaging, log);
+			userDbServerMap.put(user, dbServer);
+		}
+
+		return dbServer;		
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/3/2003 2:56:43 PM)
+ * @return cbit.vcell.server.User
+ * @param simKey cbit.sql.KeyValue
+ */
+public FieldDataIdentifierSpec[] getFieldDataIdentifierSpecs(Simulation sim) throws DataAccessException, JMSException {
+	try {		
+		KeyValue simKey = sim.getKey();
+		log.print("Get FieldDataIdentifierSpec for [" + simKey + "]");	
+		FieldDataIdentifierSpec[] fieldDataIDSs = (FieldDataIdentifierSpec[])simFieldDataIDMap.get(simKey);
+
+		if (fieldDataIDSs != null) {
+			return fieldDataIDSs;
+		}
+
+		FieldFunctionArguments[] fieldFuncArgs =  FieldUtilities.getFieldFunctionArguments(sim.getMathDescription());
+		if (fieldFuncArgs == null || fieldFuncArgs.length == 0) {
+			return null;
+		}
+		
+		RpcDbServerProxy dbServerProxy = getDbServerProxy(sim.getVersion().getOwner());		
+		ExternalDataIdentifier[] externalDataIDs =
+			dbServerProxy.fieldDataDBOperation(
+					FieldDataDBOperationSpec.createGetExtDataIDsSpec(dbServerProxy.user)
+			).extDataIDArr;
+		if (externalDataIDs != null && externalDataIDs.length != 0 &&
+			fieldFuncArgs != null && fieldFuncArgs.length>0	) {
+			Vector<FieldDataIdentifierSpec> fieldDataIdV = new Vector<FieldDataIdentifierSpec>();
+			for(int j=0;fieldFuncArgs != null && j<fieldFuncArgs.length;j+= 1){
+				for(int i=0;i<externalDataIDs.length;i+= 1){
+					if(externalDataIDs[i].getName().equals(fieldFuncArgs[j].getFieldName())){
+						fieldDataIdV.add(
+								new FieldDataIdentifierSpec(fieldFuncArgs[j],externalDataIDs[i])
+								);
+						break;
+					}
+				}
+			}
+			if(fieldDataIdV.size() > 0){
+				fieldDataIDSs = new FieldDataIdentifierSpec[fieldDataIdV.size()];
+				fieldDataIdV.copyInto(fieldDataIDSs);
+			}
+		}
+
+		if (fieldDataIDSs != null){
+			simFieldDataIDMap.put(simKey, fieldDataIDSs);		
+		}
+		
+		return fieldDataIDSs;
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+		throw new DataAccessException(ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/8/2003 1:34:06 PM)
+ * @return cbit.vcell.solver.Simulation
+ * @param simInfo cbit.vcell.solver.SimulationInfo
+ */
+public Simulation getSimulation(User user, KeyValue simKey) throws JMSException, DataAccessException {
+	if (simulationMap == null) {
+		log.print("Initializaing DBCacheTable!");
+		simulationMap = new DBCacheTable(3600 * 1000);
+	}
+
+	log.print("Get simulation [" + simKey + ","  + user + "]");	
+	Simulation sim = (Simulation)simulationMap.getCloned(simKey);
+
+	if (sim != null) {
+		return sim;
+	}
+
+	RpcDbServerProxy dbServerProxy = getDbServerProxy(user);			
+	BigString simstr = dbServerProxy.getSimulationXML(simKey);	
+
+	if (simstr != null){
+		try {
+			sim = XmlHelper.XMLToSim(simstr.toString());
+		}catch (XmlParseException e){
+			e.printStackTrace(System.out);
+			throw new DataAccessException(e.getMessage());
+		}
+		if (sim != null) {
+			try {
+				simulationMap.putProtected(simKey, sim);
+			} catch (CacheException e) {
+				// if can't cache the simulation, it is ok
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	return sim;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/3/2004 8:34:36 AM)
+ * @return cbit.vcell.messaging.SimulationTask
+ * @param simKey cbit.sql.KeyValue
+ * @throws SQLException 
+ */
+public SimulationTask getSimulationTask(SimulationJobStatus jobStatus) throws DataAccessException, JMSException, SQLException {
+	VCSimulationIdentifier vcSimID = jobStatus.getVCSimulationIdentifier();
+	User user = getUser(vcSimID.getSimulationKey(), null);				
+	Simulation sim = getSimulation(user, vcSimID.getSimulationKey());
+	SimulationTask simTask = new SimulationTask(new SimulationJob(sim, jobStatus.getJobIndex(), getFieldDataIdentifierSpecs(sim)), jobStatus.getTaskID());
+
+	return simTask;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/3/2003 2:56:43 PM)
+ * @return cbit.vcell.server.User
+ * @param simKey cbit.sql.KeyValue
+ * @throws SQLException 
+ */
+public User getUser(KeyValue simKey, String username) throws DataAccessException, SQLException {
+	User user = null;
+
+	synchronized(simUserMap) {
+		user = (User)simUserMap.get(simKey);
+
+		if (user != null && username != null && !user.getName().equals(username)) {
+			throw new DataAccessException("Wrong user [" + user.getName() + "," + username + "] for the simulation [" + simKey + "]");
+		}
+			
+		if (user == null) {
+			if (username != null) {
+				user = adminDbTopLevel.getUser(username,true);
+			} else {
+				user = adminDbTopLevel.getUserFromSimulationKey(simKey,true);
+			}
+			if (user != null) {
+				simUserMap.put(simKey, user);
+			}			
+		}
+	}
+		
+	return user;
+}
+
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 1) {
+		System.out.println("Missing arguments: " + SimulationDispatcher.class.getName() + " serviceOrdinal [logdir]");
+		System.exit(1);
+	}
+	
+	try {
+		PropertyLoader.loadProperties();		
+		
+		int serviceOrdinal = Integer.parseInt(args[0]);
+		String logdir = null;
+		if (args.length > 1) {
+			logdir = args[1];
+		}
+		VCMongoMessage.serviceStartup(ServiceName.dispatch, new Integer(serviceOrdinal), args);
+
+		SimulationDispatcher simulationDispatcher = new SimulationDispatcher(serviceOrdinal, logdir);
+		simulationDispatcher.start();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/15/2003 11:34:15 AM)
+ */
+public void onWorkerEventMessage(AdminDatabaseServerXA adminDbXA, java.sql.Connection con, JmsSession statusPublisher, Message receivedMsg) throws JMSException, DataAccessException {
+	WorkerEventMessage workerEventMessage = null;
+	
+	try {
+		workerEventMessage = new WorkerEventMessage(this, receivedMsg);
+	} catch (RuntimeException ex) {
+		// parse error, wrong message
+		log.exception(ex);
+		return;
+	}
+		
+	VCMongoMessage.sendWorkerEvent(workerEventMessage);
+	
+	WorkerEvent workerEvent = workerEventMessage.getWorkerEvent();
+	String hostName = workerEvent.getHostName();
+	String userName = workerEvent.getUserName(); // as the filter of the client
+	int taskID = workerEvent.getTaskID();
+	int jobIndex = workerEvent.getJobIndex();
+	
+	log.print("onWorkerEventMessage[" + workerEvent.getEventTypeID() + "," + workerEvent.getSimulationMessage() + "][simid=" + workerEvent.getVCSimulationDataIdentifier() + ",job=" + jobIndex + "]");
+
+	VCSimulationDataIdentifier vcSimDataID = workerEvent.getVCSimulationDataIdentifier();
+	if (vcSimDataID == null) {
+		return;
+	}		
+	KeyValue simKey = vcSimDataID.getSimulationKey();
+	SimulationJobStatus oldJobStatus = adminDbXA.getSimulationJobStatus(con, simKey, jobIndex, taskID);	
+	
+	if (oldJobStatus == null || taskID != oldJobStatus.getTaskID() || oldJobStatus.getSchedulerStatus().isDone()){
+		log.print("Outdated message: taskID=" + taskID + "::" + oldJobStatus);
+		return;
+	}	
+
+	SimulationJobStatus newJobStatus = null;
+	
+	if (workerEvent.isAcceptedEvent()) {
+		if (!oldJobStatus.getSchedulerStatus().isRunning()) {			
+			newJobStatus = updateDispatchedStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, taskID, workerEvent.getSimulationMessage());
+		}
+		
+	} else if (workerEvent.isStartingEvent()) {
+		// only update database when the job event changes from started to runinng. The later progress event will not be recorded.
+		SimulationMessage startMsg = workerEvent.getSimulationMessage();
+		if (oldJobStatus.getSchedulerStatus().isQueued() || oldJobStatus.getSchedulerStatus().isDispatched()) {
+			newJobStatus = updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, taskID, false, startMsg);
+		} else if (oldJobStatus.getSchedulerStatus().isRunning()) {
+			newJobStatus = new SimulationJobStatus(oldJobStatus.getServerID(), oldJobStatus.getVCSimulationIdentifier(), oldJobStatus.getJobIndex(), oldJobStatus.getSubmitDate(), 
+				oldJobStatus.getSchedulerStatus(), oldJobStatus.getTaskID(), startMsg, oldJobStatus.getSimulationQueueEntryStatus(), oldJobStatus.getSimulationExecutionStatus());
+		}
+		
+	} else if (workerEvent.isNewDataEvent()) {
+		if (workerEvent.getTimePoint() != null) {
+			dataMoved(vcSimDataID, workerEvent.getUser(), workerEvent.getTimePoint().doubleValue());
+			newJobStatus = updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, taskID, true, workerEvent.getSimulationMessage());
+		}
+			
+	} else if (workerEvent.isProgressEvent()) {
+		newJobStatus = oldJobStatus;
+		if (oldJobStatus.getSchedulerStatus().isQueued() || oldJobStatus.getSchedulerStatus().isDispatched()) {
+			newJobStatus = updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimDataID.getVcSimID(), jobIndex, taskID, false, workerEvent.getSimulationMessage());
+		} else {
+			updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, taskID, workerEvent.getSimulationMessage());
+		}
+		
+	} else if (workerEvent.isCompletedEvent()) {			
+		newJobStatus = updateEndStatus(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, taskID, hostName, SchedulerStatus.COMPLETED, workerEvent.getSimulationMessage());
+
+	} else if (workerEvent.isFailedEvent()) {						
+		SimulationMessage failMsg = workerEvent.getSimulationMessage();
+		newJobStatus = updateEndStatus(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, taskID, hostName, SchedulerStatus.FAILED, failMsg);	
+			
+	} else if (workerEvent.isWorkerAliveEvent()) {
+		if (oldJobStatus.getSchedulerStatus().isRunning()) {
+			updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimDataID.getVcSimID(), jobIndex, taskID, workerEvent.getSimulationMessage());
+		}
+	}
+
+	if (workerEvent.isStartingEvent() && newJobStatus != null) {
+		StatusMessage msgForClient = new StatusMessage(newJobStatus, userName, null, null);
+		msgForClient.sendToClient(statusPublisher);
+		log.print("Send status to client: " + msgForClient);
+	} else if (newJobStatus != null && (!newJobStatus.compareEqual(oldJobStatus) || workerEvent.isProgressEvent() || workerEvent.isNewDataEvent())) {		
+		Double progress = workerEvent.getProgress();
+		Double timepoint = workerEvent.getTimePoint();
+		StatusMessage msgForClient = new StatusMessage(newJobStatus, userName, progress, timepoint);
+		msgForClient.sendToClient(statusPublisher);
+		log.print("Send status to client: " + msgForClient);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/9/2003 12:07:28 PM)
+ */
+public final void start() throws JMSException {	
+	log.print("Start PropertyLoader thread...");
+	new PropertyLoaderThread().start();
+
+	while (!bStop) {
+		try {
+			VCSimulationIdentifier vcSimID = dispatcherMessaging.processNextRequest();
+			if (vcSimID != null) {
+				continue;
+			}
+		} catch (Exception ex) {
+			log.exception(ex);
+		}
+		
+		try {
+			Thread.sleep(2 * MessageConstants.SECOND_IN_MS);
+		} catch (Exception ex) {
+			log.exception(ex);
+		}			
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 4:28:05 PM)
+ */
+public final void stop() {
+	log.print(this.getClass().getName() + " ending");
+	bStop = true;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateDispatchedStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateDispatchedStatus(oldJobStatus, adminDbXA, con, computeHost, vcSimID, jobIndex, taskID, startMsg);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, VCSimulationIdentifier vcSimID, int jobIndex, int taskID, String hostName, SchedulerStatus status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateEndStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateEndStatus(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, taskID, hostName, status, solverMsg);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, 
+		VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateLatestUpdateDate[" + vcSimID + "][" + jobIndex + "]");
+	dispatcherDbManager.updateLatestUpdateDate(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, taskID, simulationMessage);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationJobStatus updateQueueStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationQueueID queueID, boolean firstSubmit) throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateQueueStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateQueueStatus(oldJobStatus, adminDbXA, con, vcSimID, jobIndex, taskID, queueID, firstSubmit);		// update SimulationJobTable
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/28/2003 3:39:37 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+private SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, java.sql.Connection con, String hostName, VCSimulationIdentifier vcSimID, int jobIndex, int taskID, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException {
+//	log.print("updateExeRunningStatus[" + vcSimID + "][" + jobIndex + "]");
+	return dispatcherDbManager.updateRunningStatus(oldJobStatus, adminDbXA, con, hostName, vcSimID, jobIndex, taskID, hasData, solverMsg);
+}
+}
Index: src/cbit/vcell/messaging/server/LocalUserMetaDbServerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalUserMetaDbServerMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalUserMetaDbServerMessaging.java	(revision 12031)
@@ -0,0 +1,1175 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.solver.ode.gui.SimulationStatus;
+import cbit.vcell.field.FieldDataDBOperationResults;
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.export.server.ExportLog;
+import cbit.vcell.modeldb.*;
+import cbit.vcell.mathmodel.*;
+import cbit.vcell.biomodel.BioModelMetaData;
+import cbit.vcell.solver.SolverResultSetInfo;
+import java.rmi.*;
+import org.vcell.util.BigString;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VersionInfo;
+
+import cbit.vcell.server.UserRegistrationOP;
+import cbit.vcell.server.UserRegistrationResults;
+import cbit.vcell.dictionary.DBSpecies;
+import cbit.vcell.dictionary.DBFormalSpecies;
+import cbit.vcell.dictionary.FormalSpeciesType;
+
+
+/**
+ * This type was created in VisualAge.
+ */
+public class LocalUserMetaDbServerMessaging extends java.rmi.server.UnicastRemoteObject implements cbit.vcell.server.UserMetaDbServer {
+	private RpcDbServerProxy dbServerProxy = null;
+	private User user = null;
+	private org.vcell.util.SessionLog log = null;
+
+/**
+ * This method was created in VisualAge.
+ */
+public LocalUserMetaDbServerMessaging(cbit.vcell.messaging.JmsClientMessaging clientMessaging, User argUser, org.vcell.util.SessionLog sessionLog) throws RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortUserMetaDbServer,0));
+	this.user = argUser;
+	this.log = sessionLog;
+	try {
+		this.dbServerProxy = new RpcDbServerProxy(user, clientMessaging, log);
+	} catch (javax.jms.JMSException e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException("JMSException: "+e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VCDocumentInfo curate(org.vcell.util.document.CurateSpec curateSpec) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.curate(curatespec="+curateSpec.toString()+")");
+		return dbServerProxy.curate(curateSpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+public UserRegistrationResults userRegistrationOP(UserRegistrationOP userRegistrationOP) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.userRegistrationOP(...)");
+		return dbServerProxy.userRegistrationOP(userRegistrationOP);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteBioModel(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteBioModel(Key="+key+")");
+		dbServerProxy.deleteBioModel(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public FieldDataDBOperationResults fieldDataDBOperation(FieldDataDBOperationSpec fieldDataDBOperationSpec) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.fieldDataDBOperation(...)");
+		return dbServerProxy.fieldDataDBOperation(fieldDataDBOperationSpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteGeometry(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteGeometry(Key="+key+")");
+		dbServerProxy.deleteGeometry(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteMathModel(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteMathModel(Key="+key+")");
+		dbServerProxy.deleteMathModel(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteResultSetExport(org.vcell.util.document.KeyValue eleKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteResultSetExport(Key="+eleKey+")");
+		dbServerProxy.deleteResultSetExport(eleKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ */
+public void deleteVCImage(org.vcell.util.document.KeyValue key) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.deleteVCImage(Key="+key+")");
+		dbServerProxy.deleteVCImage(key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteOPResults doTestSuiteOP(cbit.vcell.numericstest.TestSuiteOP tsop) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.doTestSuiteOP("+tsop+")");
+		return dbServerProxy.doTestSuiteOP(tsop);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.ReferenceQueryResult findReferences(org.vcell.util.document.ReferenceQuerySpec rqs) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.findReferences(rqs="+rqs+")");
+		return dbServerProxy.findReferences(rqs);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionable method comment.
+ */
+public org.vcell.util.document.VersionableFamily getAllReferences(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getAllReferences(vType="+vType.getTypeName()+", Key="+key+")");
+		log.alert("LocalUserMetaDbServerMessaging.getAllReferences() can return 'version' objects that aren't viewable to user !!!!!!!!!!!!!!!! ");
+		return dbServerProxy.getAllReferences(vType,key);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo getBioModelInfo(org.vcell.util.document.KeyValue bioModelKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelInfo(key="+bioModelKey+")");
+		return dbServerProxy.getBioModelInfo(bioModelKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo[] getBioModelInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelInfos(bAll="+bAll+")");
+		return dbServerProxy.getBioModelInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BioModelMetaData getBioModelMetaData(KeyValue bioModelKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelMetaData(key="+bioModelKey+")");
+		BioModelMetaData bioModelMetaData = dbServerProxy.getBioModelMetaData(bioModelKey);
+		return bioModelMetaData;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BioModelMetaData[] getBioModelMetaDatas(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelMetaDatas(bAll="+bAll+")");
+		BioModelMetaData bioModelMetaDataArray[] = dbServerProxy.getBioModelMetaDatas(bAll);
+		return bioModelMetaDataArray;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getBioModelXML(KeyValue bioModelKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBioModelXML(key="+bioModelKey+")");
+		BigString bioModelXML = dbServerProxy.getBioModelXML(bioModelKey);
+		return bioModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/26/2003 3:26:10 PM)
+ */
+public DBSpecies getBoundSpecies(DBFormalSpecies dbfs) throws DataAccessException{
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getBoundSpecies");
+		return dbServerProxy.getBoundSpecies(dbfs);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/20/2003 2:11:12 PM)
+ */
+public DBFormalSpecies[] getDatabaseSpecies(String likeString,boolean isBound,FormalSpeciesType speciesType,int restrictSearch,int rowLimit,boolean bOnlyUser) throws DataAccessException{
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getDatabaseSpecies");
+		return dbServerProxy.getDatabaseSpecies(likeString,isBound,speciesType,restrictSearch,rowLimit,bOnlyUser);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getDictionaryReactions method comment.
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getDictionaryReactions(ReactionQuerySpec reactionQuerySpec) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getDictionaryReactions");
+		return dbServerProxy.getDictionaryReactions(reactionQuerySpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public ExportLog getExportLog(KeyValue simulationKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getExportLog(simulationKey="+simulationKey+")");
+		ExportLog exportLog = dbServerProxy.getExportLog(simulationKey);
+		return exportLog;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public ExportLog[] getExportLogs(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getExportLogs()");
+		ExportLog exportLogs[] = dbServerProxy.getExportLogs(bAll);
+		return exportLogs;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo getGeometryInfo(org.vcell.util.document.KeyValue geoKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getGeometryInfo(key="+geoKey+")");
+		return dbServerProxy.getGeometryInfo(geoKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo[] getGeometryInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getGeometryInfos(bAll="+bAll+")");
+		return dbServerProxy.getGeometryInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getGeometryXML(KeyValue geometryKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getGeometryXML(key="+geometryKey+")");
+		BigString geometryXML = dbServerProxy.getGeometryXML(geometryKey);
+		return geometryXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo getMathModelInfo(org.vcell.util.document.KeyValue mathModelKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelInfo(key="+mathModelKey+")");
+		return dbServerProxy.getMathModelInfo(mathModelKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo[] getMathModelInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelInfos(bAll="+bAll+")");
+		return dbServerProxy.getMathModelInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public MathModelMetaData getMathModelMetaData(KeyValue mathModelKey) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelMetaData(key="+mathModelKey+")");
+		MathModelMetaData mathModelMetaData = dbServerProxy.getMathModelMetaData(mathModelKey);
+		return mathModelMetaData;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public MathModelMetaData[] getMathModelMetaDatas(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelMetaDatas(bAll="+bAll+")");
+		MathModelMetaData mathModelMetaDataArray[] = dbServerProxy.getMathModelMetaDatas(bAll);
+		return mathModelMetaDataArray;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getMathModelXML(KeyValue mathModelKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getMathModelXML(mathModelKey="+mathModelKey+")");
+		BigString xml = dbServerProxy.getMathModelXML(mathModelKey);
+		return xml;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:51:49 PM)
+ * @return cbit.util.Preference
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.Preference[] getPreferences() throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getPreferences()");
+		org.vcell.util.Preference[] preferences = dbServerProxy.getPreferences();
+		return preferences;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getReactionStep method comment.
+ */
+public cbit.vcell.model.Model getReactionStepAsModel(org.vcell.util.document.KeyValue rxID) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getReactionStep()");
+		return dbServerProxy.getReactionStepAsModel(rxID);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getReactionStepInfos method comment.
+ */
+public cbit.vcell.model.ReactionStepInfo[] getReactionStepInfos(org.vcell.util.document.KeyValue[] reactionStepKeys) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getReactionStepInfos()");
+		return dbServerProxy.getReactionStepInfos(reactionStepKeys);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public SolverResultSetInfo[] getResultSetInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getResultSetInfos(bAll="+bAll+")");
+		SolverResultSetInfo rsInfos[] = dbServerProxy.getResultSetInfos(bAll);
+		return rsInfos;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/1/2004 11:27:01 AM)
+ * @return cbit.vcell.solver.SolverResultSetInfo
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationStatus[] getSimulationStatus(org.vcell.util.document.KeyValue simulationKeys[]) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationStatus(key="+simulationKeys+")");
+		SimulationStatus simulationStatus[] = dbServerProxy.getSimulationStatus(simulationKeys);
+		return simulationStatus;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/1/2004 11:27:01 AM)
+ * @return cbit.vcell.solver.SolverResultSetInfo
+ * @param simKey cbit.sql.KeyValue
+ */
+public SimulationStatus getSimulationStatus(org.vcell.util.document.KeyValue simulationKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationStatus(key="+simulationKey+")");
+		SimulationStatus simulationStatus = dbServerProxy.getSimulationStatus(simulationKey);
+		return simulationStatus;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getSimulationXML(KeyValue simKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationXML(simKey="+simKey+")");
+		BigString xml = dbServerProxy.getSimulationXML(simKey);
+		return xml;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteNew getTestSuite(java.math.BigDecimal getThisTS) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getTestSuite("+getThisTS+")");
+		return dbServerProxy.getTestSuite(getThisTS);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteInfoNew[] getTestSuiteInfos() throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getTestSuiteInfos()");
+		return dbServerProxy.getTestSuiteInfos();
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ * @return cbit.vcell.dictionary.ReactionDescription[]
+ * @param reactionQuerySpec cbit.vcell.modeldb.ReactionQuerySpec
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getUserReactionDescriptions(ReactionQuerySpec reactionQuerySpec) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getUserReactionDescriptions()");
+		return dbServerProxy.getUserReactionDescriptions(reactionQuerySpec);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo getVCImageInfo(org.vcell.util.document.KeyValue imgKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getVCImageInfo(key="+imgKey+")");
+		return dbServerProxy.getVCImageInfo(imgKey);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo[] getVCImageInfos(boolean bAll) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getVCImageInfos(bAll="+bAll+")");
+		return dbServerProxy.getVCImageInfos(bAll);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString getVCImageXML(KeyValue imageKey) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getSimulationXML(imageKey="+imageKey+")");
+		BigString xml = dbServerProxy.getVCImageXML(imageKey);
+		return xml;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 10:23:06 AM)
+ * @return cbit.vcell.modeldb.VCInfoContainer
+ */
+public VCInfoContainer getVCInfoContainer() throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.getVCInfoContainer()");
+		return dbServerProxy.getVCInfoContainer();
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupAddUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key,String addUserToGroup, boolean isHidden) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupAddUser(vType="+vType.getTypeName()+", Key="+key+", userToAdd="+addUserToGroup+", isHidden="+isHidden+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupAddUser(vType,key,addUserToGroup,isHidden);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupRemoveUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key,String userRemoveFromGroup,boolean isHiddenFromOwner) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupRemoveUser(vType="+vType.getTypeName()+", Key="+key+", userRemoveFromGroup="+userRemoveFromGroup+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupRemoveUser(vType,key,userRemoveFromGroup,isHiddenFromOwner);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPrivate(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupSetPrivate(vType="+vType.getTypeName()+", Key="+key+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupSetPrivate(vType,key);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPublic(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws DataAccessException, ObjectNotFoundException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.groupSetPublic(vType="+vType.getTypeName()+", Key="+key+")");
+		VersionInfo newVersionInfo = dbServerProxy.groupSetPublic(vType,key);
+		return newVersionInfo;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:51:49 PM)
+ * @param preferences cbit.util.Preference[]
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void replacePreferences(org.vcell.util.Preference[] preferences) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.replacePreferences()");
+		dbServerProxy.replacePreferences(preferences);
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveBioModel(BigString bioModelXML, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveBioModel()");
+		BigString savedBioModelXML = dbServerProxy.saveBioModel(bioModelXML, independentSims);
+		return savedBioModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveBioModelAs(BigString bioModelXML, String newName, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveBioModel(newName="+newName+")");
+		BigString savedBioModelXML = dbServerProxy.saveBioModelAs(bioModelXML,newName,independentSims);
+		return savedBioModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveGeometry(BigString geometryXML) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveGeometry()");
+		BigString savedGeometryXML = dbServerProxy.saveGeometry(geometryXML);
+		return savedGeometryXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveGeometryAs(BigString geometryXML, String newName) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveGeometryAs(newName="+newName+")");
+		BigString savedGeometryXML = dbServerProxy.saveGeometryAs(geometryXML,newName);
+		return savedGeometryXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveMathModel(BigString mathModelXML, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveMathModel()");
+		BigString savedMathModelXML = dbServerProxy.saveMathModel(mathModelXML,independentSims);
+		return savedMathModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveMathModelAs(BigString mathModelXML, String newName, String independentSims[]) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveMathModel(newName="+newName+")");
+		BigString savedMathModelXML = dbServerProxy.saveMathModelAs(mathModelXML,newName, independentSims);
+		return savedMathModelXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.BigString saveSimulation(org.vcell.util.BigString simulationXML, boolean bForceIndependent) throws org.vcell.util.DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveSimulation()");
+		BigString savedSimulationXML = dbServerProxy.saveSimulation(simulationXML,bForceIndependent);
+		return savedSimulationXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveVCImage(BigString vcImageXML) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveVCImage()");
+		BigString savedVCImageXML = dbServerProxy.saveVCImage(vcImageXML);
+		return savedVCImageXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+
+
+/**
+ * getVersionInfo method comment.
+ */
+public BigString saveVCImageAs(BigString vcImageXML, String newName) throws DataAccessException {
+	try {
+		log.print("LocalUserMetaDbServerMessaging.saveVCImage(newName="+newName+")");
+		BigString savedVCImageXML = dbServerProxy.saveVCImageAs(vcImageXML,newName);
+		return savedVCImageXML;
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw e;
+	} catch (Throwable e) {
+		log.exception(e);
+		throw new DataAccessException(e.getMessage());
+	}
+
+}
+}
Index: src/cbit/vcell/messaging/server/RpcServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcServerImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcServerImpl.java	(revision 12031)
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:12:11 PM)
+ * @author: Fei Gao
+ */
+public interface RpcServerImpl {
+public Object rpc(RpcRequest request) throws Exception;
+}
Index: src/cbit/vcell/messaging/server/RpcRequest.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcRequest.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcRequest.java	(revision 12031)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/13/2003 1:41:34 PM)
+ * @author: Fei Gao
+ */
+public class RpcRequest implements java.io.Serializable {
+	private User user = null;
+	private Object[] args = null;
+	private ServiceType requestedServiceType = null; // refer to "databaseServer", "dataServer", "***";
+	private String methodName = null;	
+/**
+ * SimpleTask constructor comment.
+ * @param argName java.lang.String
+ * @param argEstimatedSizeMB double
+ * @param argUserid java.lang.String
+ */
+public RpcRequest(User user0, ServiceType st, String methodName0, Object[] arglist) {
+	user = user0;
+	this.requestedServiceType = st;
+	methodName = methodName0;
+	this.args = arglist;	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (5/13/2003 1:56:44 PM)
+ * @return java.lang.Object[]
+ */
+public Object[] getArguments() {
+	return args;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (5/13/2003 2:43:42 PM)
+ * @return java.lang.String
+ */
+public String getMethodName() {
+	return methodName;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (12/30/2003 9:16:45 AM)
+ * @return java.lang.String
+ */
+public ServiceType getRequestedServiceType() {
+	return requestedServiceType;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (3/11/2004 8:50:08 AM)
+ * @return java.lang.String
+ */
+public org.vcell.util.document.User getUser() {
+	return user;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (3/11/2004 8:51:06 AM)
+ * @return java.lang.String
+ */
+public java.lang.String getUserName() {
+	if (user == null) {
+		return null;
+	}
+	
+	return user.getName();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/18/2001 5:12:18 PM)
+ * @return java.lang.String
+ */
+public String toString() {
+	return "[" + user + "," + requestedServiceType + "," + methodName + "]";
+}
+}
Index: src/cbit/vcell/messaging/server/AbstractRpcServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractRpcServerProxy.java	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractRpcServerProxy.java	(revision 12031)
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.mongodb.VCMongoMessage;
+
+import javax.jms.JMSException;
+
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/13/2003 2:14:50 PM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractRpcServerProxy implements RpcServerProxy {
+	private cbit.vcell.messaging.JmsClientMessaging clientMessaging = null;
+	protected org.vcell.util.document.User user;
+	private java.lang.String queueName = null;
+	protected org.vcell.util.SessionLog log = null;
+
+/**
+ * RpcServerProxy constructor comment.
+ */
+protected AbstractRpcServerProxy(User argUser, JmsClientMessaging clientMessaging0, String queueName0, SessionLog argLog) throws JMSException {
+	super();
+	this.user = argUser;
+	this.clientMessaging = clientMessaging0;
+	this.log = argLog;
+	queueName = queueName0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+public Object rpc(ServiceType serviceType, String methodName, Object[] args, boolean returnRequired) throws Exception {
+	return rpc(serviceType, methodName, args, returnRequired, null, null);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+public Object rpc(ServiceType serviceType, String methodName, Object[] args, boolean returnRequired, String[] specialProperties, Object[] specialValues) throws Exception {
+	RpcRequest request = new RpcRequest(user, serviceType, methodName, args);
+	VCMongoMessage.sendRpcRequestSent(request, clientMessaging.getUserLoginInfo());
+	return clientMessaging.rpc(request, queueName, returnRequired, specialProperties, specialValues);
+}
+}
Index: src/cbit/vcell/messaging/server/LocalSimulationControllerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalSimulationControllerMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalSimulationControllerMessaging.java	(revision 12031)
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.document.User;
+
+import cbit.vcell.solver.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/4/2003 11:08:14 PM)
+ * @author: Jim Schaff
+ */
+public class LocalSimulationControllerMessaging extends java.rmi.server.UnicastRemoteObject implements cbit.vcell.server.SimulationController {
+	private User fieldUser = null;
+	private org.vcell.util.SessionLog fieldSessionLog = null;
+	private RpcSimServerProxy simServerProxy = null;
+
+/**
+ * MessagingSimulationController constructor comment.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public LocalSimulationControllerMessaging(User user, cbit.vcell.messaging.JmsClientMessaging clientMessaging, org.vcell.util.SessionLog log) throws java.rmi.RemoteException, DataAccessException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortSimulationController,0));
+	this.fieldUser = user;
+	this.fieldSessionLog = log;
+
+	try {
+		simServerProxy = new RpcSimServerProxy(user, clientMessaging, fieldSessionLog);
+	} catch (javax.jms.JMSException e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException("JMS exception creating SimServerProxy: "+e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void startSimulation(VCSimulationIdentifier vcSimID) {
+	fieldSessionLog.print("LocalSimulationControllerMessaging.startSimulation(" + vcSimID + ")");
+	simServerProxy.startSimulation(vcSimID);
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void stopSimulation(VCSimulationIdentifier vcSimID) {
+	fieldSessionLog.print("LocalSimulationControllerMessaging.stopSimulation(" + vcSimID + ")");
+	simServerProxy.stopSimulation(vcSimID);
+}
+}
Index: src/cbit/vcell/messaging/server/LocalDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalDispatcherDbManager.java	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalDispatcherDbManager.java	(revision 12031)
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.SimulationQueueID;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.server.AdminDatabaseServer;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:45:37 PM)
+ * @author: Fei Gao
+ */
+public class LocalDispatcherDbManager extends AbstractDispatcherDbManager {
+/**
+ * NonJmsDispatcherDbDriver constructor comment.
+ */
+public LocalDispatcherDbManager() {
+	super();
+}
+
+}
Index: src/cbit/vcell/messaging/server/AbstractJmsWorker.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractJmsWorker.java	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractJmsWorker.java	(revision 12031)
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.document.VCellServerID;
+
+import java.io.FileNotFoundException;
+import java.util.Date;
+import java.util.StringTokenizer;
+
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.Solver;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.xml.XmlParseException;
+import cbit.vcell.solver.SolverEvent;
+import cbit.vcell.messaging.WorkerMessaging;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import static org.vcell.util.MessageConstants.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:30:31 PM)
+ * @author: Jim Schaff
+ */
+public abstract class AbstractJmsWorker extends AbstractJmsServiceProvider implements Worker {
+	protected int maxMemoryMB = 100;
+	protected SimulationTask currentTask = null;
+	protected Solver currentSolver = null;
+	protected boolean bStopped = true;
+	protected WorkerMessaging workerMessaging = null;
+	protected ServiceType serviceType;
+	
+public AbstractJmsWorker(ServiceType wt, int workerOrdinal, int workerMem, String logdir) throws JMSException, FileNotFoundException {
+	serviceType = wt;
+	maxMemoryMB = workerMem;	
+			
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID(), serviceType, workerOrdinal, ManageUtils.getHostName(), new Date(), true);
+	initLog(logdir);
+	
+	log = new StdoutSessionLog(serviceInstanceStatus.getID());
+	workerMessaging = new WorkerMessaging(this, log);
+}
+
+protected abstract void doJob() throws JMSException, SolverException, XmlParseException;
+
+public final String getJobSelector() {
+	String jobSelector = "(" + MessageConstants.MESSAGE_TYPE_PROPERTY + "='" + MessageConstants.MESSAGE_TYPE_SIMULATION_JOB_VALUE + "')";
+	String computeResources =  PropertyLoader.getRequiredProperty(PropertyLoader.htcComputeResources);
+	StringTokenizer st = new StringTokenizer(computeResources, " ,");	
+	jobSelector += " AND ((" + MessageConstants.COMPUTE_RESOURCE_PROPERTY + " IS NULL) OR (" + MessageConstants.COMPUTE_RESOURCE_PROPERTY + " IN (";
+	int count = 0;
+	while (st.hasMoreTokens()) {
+		if (count > 0) {
+			jobSelector = ", ";
+		}
+		jobSelector += "'" + st.nextToken() + "'";
+		count ++;
+	}
+	jobSelector += ")))";
+	
+	return jobSelector;
+}
+
+/**
+ * Invoked when the solver aborts a calculation (abnormal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverAborted(SolverEvent event) {
+	workerMessaging.sendFailed(event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver finishes a calculation (normal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverFinished(SolverEvent event) {
+	workerMessaging.sendCompleted(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverPrinted(SolverEvent event) {
+	if (!isRunning()) {
+		return;
+	}
+	workerMessaging.sendNewData(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverProgress(SolverEvent event) {
+	if (!isRunning()) {
+		return;
+	}
+	workerMessaging.sendProgress(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver begins a calculation.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStarting(SolverEvent event) {
+	workerMessaging.sendStarting(event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stops a calculation, usually because
+ * of a user-initiated stop call.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStopped(SolverEvent event) {		
+	log.print("Caught solverStopped(" + event.getSource() + ")");
+	// Don't send message anymore because the dispatcher will update the database anyway no matter if the worker responds
+	//workerMessaging.sendStopped(event.getProgress(), event.getTimePoint());
+}
+
+public final void start() {
+	bStopped = false;
+	
+	log.print("Start PropertyLoader thread...");
+	new PropertyLoaderThread().start();
+
+	while (!bStopped){
+		currentTask = null;
+		currentSolver = null;
+		
+		try {
+			currentTask = workerMessaging.getNextTask();
+			
+			if (currentTask == null || !(currentTask instanceof SimulationTask)){
+				try {
+					Thread.sleep(MessageConstants.SECOND_IN_MS);
+				} catch (Exception ex) {
+				}
+				continue;				
+			}
+			doJob();			
+		} catch (Exception ex) {			
+			workerMessaging.sendFailed(SimulationMessage.jobFailed(ex.getMessage()));
+		}			
+	}	
+	
+	log.print(serviceInstanceStatus.getSpecID() + " stopped");
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:21:10 PM)
+ */
+public final void stop() {
+	bStopped = true;
+}
+}
Index: src/cbit/vcell/messaging/server/AbstractJmsServiceProvider.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractJmsServiceProvider.java	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractJmsServiceProvider.java	(revision 12031)
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.PrintStream;
+import java.io.FileOutputStream;
+
+import org.vcell.util.MessageConstants.ServiceType;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (1/26/2004 10:08:15 AM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractJmsServiceProvider implements ServiceProvider {
+	protected ServiceInstanceStatus serviceInstanceStatus = null;
+	protected org.vcell.util.SessionLog log = null;
+	
+public AbstractJmsServiceProvider() {
+	super();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/24/2003 1:30:19 PM)
+ * @return cbit.vcell.messaging.admin.VCellService
+ */
+public ServiceInstanceStatus getServiceInstanceStatus() {
+	return serviceInstanceStatus;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (7/15/2003 10:42:52 AM)
+ * @return java.lang.String
+ */
+public String getServiceInstanceID() {
+	return serviceInstanceStatus.getID();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (7/15/2003 10:42:52 AM)
+ * @return java.lang.String
+ */
+public ServiceType getServiceType() {
+	return serviceInstanceStatus.getType();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/26/2004 9:49:08 AM)
+ */
+protected void initLog(String logDirectory) throws FileNotFoundException {
+	if (serviceInstanceStatus == null) {
+		throw new RuntimeException("initLog: serviceInstanceStatus can't be null");		
+	}
+	if (logDirectory != null) {
+		File logdir = new File(logDirectory);
+		if (!logdir.exists()) {
+			throw new RuntimeException("Log directory doesn't exist");
+		}
+			
+		// log file name:
+		// hostname_A_Data_0.log : alpha first data on hostname
+		// hostname_B_Db_0.log : beta first database on hostname
+		// hostname_R_Export_0.log : rel first export on hostname
+		File logfile = new File(logdir, getServiceInstanceID() + ".log");
+		java.io.PrintStream ps = new PrintStream(new FileOutputStream(logfile), true); // don't append, auto flush
+		System.out.println("log file is " + logfile.getAbsolutePath());
+		System.setOut(ps);
+		System.setErr(ps);
+	}	
+}
+}
Index: src/cbit/vcell/messaging/server/RpcServer.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcServer.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcServer.java	(revision 12031)
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:03:15 PM)
+ * @author: Fei Gao
+ */
+public interface RpcServer extends ServiceProvider {
+public Object dispatchRPC(RpcRequest request) throws Exception;
+}
Index: src/cbit/vcell/messaging/server/SimulationWorker.java
===================================================================
--- src/cbit/vcell/messaging/server/SimulationWorker.java	(revision 0)
+++ src/cbit/vcell/messaging/server/SimulationWorker.java	(revision 12031)
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.UnknownHostException;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.document.KeyValue;
+
+import cbit.vcell.message.server.pbs.PbsProxyLocal;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.messaging.MessagePropertyNotFoundException;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.solver.SolverStatus;
+import cbit.vcell.solvers.PBSSolver;
+import cbit.vcell.xml.XmlParseException;
+/**
+ * Insert the type's description here.
+ * Creation date: (10/25/2001 4:14:09 PM)
+ * @author: Jim Schaff
+ */
+public class SimulationWorker extends AbstractJmsWorker  {
+/**
+ * SimulationWorker constructor comment.
+ * @param argName java.lang.String
+ * @param argParentNode cbit.vcell.appserver.ComputationalNode
+ * @param argInitialContext javax.naming.Context
+ */
+public SimulationWorker(ServiceType wt, int wo, int wm, String logdir) throws JMSException, DataAccessException, FileNotFoundException, UnknownHostException {
+	super(wt, wo, wm, logdir);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/18/2001 5:06:15 PM)
+ */
+protected void doJob() throws JMSException, SolverException, XmlParseException {	
+	if (currentSolver != null){
+		throw new RuntimeException("previous task incomplete (currentSolver!=null)");
+	}
+	
+	log.print("Worker doing job [" + currentTask.getSimulationJob().getSimulationJobID() + "]");	
+
+	File userdir = new File(PropertyLoader.getRequiredProperty(PropertyLoader.primarySimDataDirProperty),currentTask.getUserName());
+	switch (serviceType) {
+		case LOCALCOMPUTE: {
+			doSolverJob(userdir);
+			break;
+		}
+		case PBSCOMPUTE: {
+			doPBSJob(userdir);
+			break;
+		}
+		default: {			
+			throw new RuntimeException("subworker can't be PBSODE or LOCAL");
+		}
+	}
+}
+
+//private void doLsfJob(int workerIndex, File userdir) throws XmlParseException, SolverException, JMSException {
+//	currentSolvers[workerIndex] = new LsfSolver(currentTasks[workerIndex], userdir,log);
+//	currentSolvers[workerIndex].addSolverListener(this);
+//	String jobid = ((LsfSolver)currentSolvers[workerIndex]).submit2Lsf();
+//
+//	// if lsf has problem with dispatching jobs, jobs that have been submitted
+//	// but are not running, will be redispatched after 5 minutes. Then we have duplicate
+//	// jobs or "failed" jobs actually running in LSF.
+//	// to avoid this, kill the job, ask the user to try again later if the jobs
+//	// are not in running status 20 seconds after submission.
+//	if (jobid != null) { 
+//		long t = System.currentTimeMillis();
+//		while (true) {
+//			try {
+//				Thread.sleep(50);
+//			} catch (InterruptedException ex) {
+//			}
+//			
+//			int status = LsfUtils.getJobStatus(jobid);
+//			if (status == LsfConstants.LSF_STATUS_DONE) {
+//				break;
+//			} else if (status == LsfConstants.LSF_STATUS_RUN) {
+//				// check to see if it exits soon after it runs
+//				try {
+//					Thread.sleep(5000);
+//				} catch (InterruptedException ex) {
+//				}
+//				status = LsfUtils.getJobStatus(jobid);
+//				if (status == cbit.htc.LsfConstants.LSF_STATUS_EXITED) {
+//					workerMessaging.sendFailed(workerIndex, "Job [" + jobid + "] exited unexpectedly: " + LsfUtils.getJobExitCode(jobid));					
+//				}
+//				break;
+//			} else if  (status == LsfConstants.LSF_STATUS_EXITED) {
+//				workerMessaging.sendFailed(workerIndex, "Job [" + jobid + "] exited unexpectedly: " + LsfUtils.getJobExitCode(jobid));
+//				break;
+//			} else if (System.currentTimeMillis() - t > 20 * MessageConstants.SECOND) {
+//				String pendingReason = cbit.htc.LsfUtils.getPendingReason(jobid);
+//				LsfUtils.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+//				workerMessaging.sendFailed(workerIndex, "LSF Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")");
+//				break;
+//			}
+//		}
+//	}
+//}
+
+private void doSolverJob(File userdir) throws SolverException {
+	currentSolver = cbit.vcell.solver.SolverFactory.createSolver(log,userdir,currentTask, true);
+	currentSolver.addSolverListener(this);
+	currentSolver.startSolver();
+	
+	while (true){
+		try { 
+			Thread.sleep(5000); 
+		} catch (InterruptedException e) {
+		}
+
+		if (!isRunning()) {
+			log.print(currentTask + " is no longer running.");
+			break;
+		}
+	}
+}
+
+public boolean isRunning() {
+	if (currentSolver == null || currentTask == null) {
+		return false;
+	}	
+	
+	if (serviceType.equals(ServiceType.PBSCOMPUTE)) {
+		return true;
+	}
+	
+	cbit.vcell.solver.SolverStatus solverStatus = currentSolver.getSolverStatus();
+	if (solverStatus != null){
+		if (solverStatus.getStatus() != SolverStatus.SOLVER_STARTING &&
+			solverStatus.getStatus() != SolverStatus.SOLVER_READY &&
+			solverStatus.getStatus() != SolverStatus.SOLVER_RUNNING){
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 3) {
+		System.out.println("Missing arguments: " + SimulationWorker.class.getName() + " {-local|-pbs} serviceOrdinal memorySizeMB [logdir]");
+		System.exit(1);
+	}
+ 		
+	//
+	// Create and install a security manager
+	//
+	try {
+		PropertyLoader.loadProperties();
+		
+		ServiceType workerType = ServiceType.LOCALCOMPUTE;
+		int serviceOrdinal = Integer.parseInt(args[1]);	
+		
+		if (args[0].equalsIgnoreCase("-pbs")) { // submit everything to PBS
+			new PbsProxyLocal().checkServerStatus();
+			workerType = ServiceType.PBSCOMPUTE;
+			VCMongoMessage.serviceStartup(ServiceName.pbsWorker, new Integer(serviceOrdinal), args);
+		} else if (args[0].equalsIgnoreCase("-local")) { // run everything locally
+			workerType = ServiceType.LOCALCOMPUTE;
+			VCMongoMessage.serviceStartup(ServiceName.localWorker, new Integer(serviceOrdinal), args);
+		} else {
+			throw new IllegalArgumentException("wrong worker type argument : " + args[0]);
+		}
+		int maxMemoryMB = Integer.parseInt(args[2]);		
+		String logdir = null;
+		if (args.length > 3) {
+			logdir = args[3];
+		}
+		SimulationWorker worker = new SimulationWorker(workerType, serviceOrdinal, maxMemoryMB, logdir);
+		worker.start();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+		System.exit(-1);
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/22/2003 2:49:54 PM)
+ * @param message javax.jms.Message
+ * @exception javax.jms.JMSException The exception description.
+ */
+public void onControlTopicMessage(Message message) throws JMSException {
+	
+	log.print("SimulationWorker::onControlTopicMessage(): " + JmsUtils.toString(message));
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+
+		if (msgType != null && msgType.equals(MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE)) {			
+			Long longkey = (Long)JmsUtils.parseProperty(message, MessageConstants.SIMKEY_PROPERTY, long.class);
+			KeyValue simKey = new KeyValue(longkey + "");
+			int jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+			
+			if (currentSolver != null && currentTask != null && simKey.equals(currentTask.getSimKey()) 
+					&& jobIndex == currentTask.getSimulationJob().getJobIndex()) {
+				currentSolver.stopSolver();
+			}
+		} 	
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+		return;
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/9/2003 8:07:04 AM)
+ */
+private void doPBSJob(File userdir) throws XmlParseException, SolverException, JMSException {
+	currentSolver = new PBSSolver(new PbsProxyLocal(), currentTask, userdir,log);
+	currentSolver.addSolverListener(this);
+	currentSolver.startSolver();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/9/2003 8:07:04 AM)
+ */
+//private void doCondorJob(File userdir) throws XmlParseException, SolverException, JMSException {
+//	currentSolver = new CondorSolver(currentTask, userdir,log);
+//	currentSolver.addSolverListener(this);
+//	String jobid = ((CondorSolver)currentSolver).submit2Condor();
+//
+//	// if condor has problem with dispatching jobs, jobs that have been submitted
+//	// but are not running, will be redispatched after 5 minutes. Then we have duplicate
+//	// jobs or "failed" jobs actually running in Condor.
+//	// to avoid this, kill the job, ask the user to try again later if the jobs
+//	// are not in running status 20 seconds after submission.
+//	if (jobid != null) { 
+//		long t = System.currentTimeMillis();
+//		while (true) {
+//			try {
+//				Thread.sleep(50);
+//			} catch (InterruptedException ex) {
+//			}
+//			
+//			int status = CondorUtils.getJobStatus(jobid);
+//			if (status == CondorConstants.CONDOR_STATUS_COMPLETED){
+//				break;
+//			} else if (status == CondorConstants.CONDOR_STATUS_RUNNING) {
+//				// check to see if it exits soon after it runs
+//				try {
+//					Thread.sleep(5000);
+//				} catch (InterruptedException ex) {
+//				}
+//				status = CondorUtils.getJobStatus(jobid);
+//				if (status == CondorConstants.CONDOR_STATUS_EXITED) {
+//					workerMessaging.sendFailed("Job [" + jobid + "] exited unexpectedly, check Condor");					
+//				}
+//				break;
+//			} else 	if (status == CondorConstants.CONDOR_STATUS_EXITED) {				
+//				workerMessaging.sendFailed("Job [" + jobid + "] exited unexpectedly, check Condor");
+//				break;
+//			} else if (System.currentTimeMillis() - t > 20 * MessageConstants.SECOND) {
+//				String pendingReason = CondorUtils.getPendingReason(jobid);
+//				CondorUtils.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+//				workerMessaging.sendFailed("Condor Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")");
+//				break;
+//			}
+//		}
+//	}
+//}
+
+}
Index: src/cbit/vcell/messaging/server/AbstractRpcServerImpl.java
===================================================================
--- src/cbit/vcell/messaging/server/AbstractRpcServerImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/server/AbstractRpcServerImpl.java	(revision 12031)
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import javax.jms.JMSException;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+
+import java.lang.reflect.InvocationTargetException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/13/2003 2:07:30 PM)
+ * @author: Fei Gao
+ */
+public abstract class AbstractRpcServerImpl implements RpcServerImpl {
+	protected org.vcell.util.SessionLog log = null;
+
+/**
+ * RpcServerImpl constructor comment.
+ */
+protected AbstractRpcServerImpl(org.vcell.util.SessionLog slog) {
+	super();
+	this.log = slog;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/16/2004 12:30:25 PM)
+ * @return java.lang.Object
+ */
+public abstract Object getServerImpl();
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 5:51:04 PM)
+ * @return java.lang.Object
+ * @param user cbit.vcell.server.User
+ * @param method java.lang.String
+ * @param args java.lang.Object[]
+ */
+public synchronized final Object rpc(RpcRequest request) throws DataAccessException, JMSException, ObjectNotFoundException {
+	String methodName = request.getMethodName();
+	Object[] arguments = request.getArguments();
+	
+	java.lang.reflect.Method methods[] = getServerImpl().getClass().getMethods();
+	java.lang.reflect.Method method = null;
+	for (int i = 0; methods != null && i < methods.length; i ++){
+		if (methods[i].getName().equals(methodName)){
+			method = methods[i];
+			
+			Class<?>[] paramTypes = method.getParameterTypes();
+			if (paramTypes.length != arguments.length) {
+				method = null;
+				continue;
+			}
+
+			// compare types one bye one
+			for (int j = 0; j < paramTypes.length; j ++){
+				// if argument is null, assume type matches
+				if (arguments[j] == null || paramTypes[j].isInstance(arguments[j])) { // if the object is instance of the parameter type, compatible, check next
+					continue;
+				}
+				
+				if (paramTypes[j].isPrimitive()) {	// if not, check if it's primitive type
+					Class<?> c = arguments[j].getClass(); 
+					Class<?> argType = null;
+
+					//unwrap primitive type
+					if (c.equals(Boolean.class)) {
+						argType = Boolean.TYPE;
+					} else if (c.equals(Character.class)) {
+						argType = Character.TYPE;
+					} else if (c.equals(Byte.class)){
+						argType = Byte.TYPE;
+					} else if (c.equals(Short.class)){
+						argType = Short.TYPE;
+					} else if (c.equals(Integer.class)){
+						argType = Integer.TYPE;
+					} else if (c.equals(Long.class)){
+						argType = Long.TYPE;
+					} else if (c.equals(Float.class)){
+						argType = Float.TYPE;
+					} else if (c.equals(Double.class)){
+						argType = Double.TYPE;
+					} else if (c.equals(Void.class)){
+						argType = Void.TYPE;
+					} else {
+						argType = null;
+					}
+
+					if (argType != null && paramTypes[j].equals(argType)) { // if it's primitive type, and the types are equal, compatible, check next
+						continue;
+					}
+				}
+				
+				method = null; // otherwise, these two types are not compatible, break
+				break;				
+			}
+
+			if (method != null) {
+				break;
+			}			
+		}
+	}	
+	
+	try {
+		if (method == null) {
+			String exceptionMessage = "No such method: " + methodName + "(";
+			for (int i = 0; i < arguments.length; i ++) {
+				exceptionMessage += arguments[i].getClass().getName();
+				if (i < arguments.length - 1) {
+					exceptionMessage += ",";
+				}
+			}
+			exceptionMessage += ")";
+			throw new DataAccessException(exceptionMessage);
+		}
+				
+		return method.invoke(getServerImpl(), request.getArguments());
+
+	} catch (InvocationTargetException ex) {
+		log.exception(ex);
+	 	Throwable targetExcepton = ex.getTargetException();
+	 	if (targetExcepton instanceof JMSException) {
+		 	throw (JMSException)targetExcepton;
+	 	} else if (targetExcepton instanceof ObjectNotFoundException) {
+		 	throw (ObjectNotFoundException)targetExcepton;
+	 	} else if (targetExcepton instanceof DataAccessException) {
+		 	throw (DataAccessException)targetExcepton;
+	 	} else {
+		 	throw new RuntimeException(targetExcepton.getMessage());
+	 	}
+	} catch (IllegalAccessException e){
+		log.exception(e);
+		throw new RuntimeException("IllegalAccessException for rpc(method=" + methodName);
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/RpcDbServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcDbServerProxy.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcDbServerProxy.java	(revision 12031)
@@ -0,0 +1,723 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.BigString;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ObjectNotFoundException;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VersionableFamily;
+
+import cbit.vcell.solver.ode.gui.SimulationStatus;
+import cbit.vcell.solver.SolverResultSetInfo;
+import cbit.vcell.mathmodel.MathModelMetaData;
+import cbit.vcell.biomodel.BioModelMetaData;
+import cbit.vcell.field.FieldDataDBOperationResults;
+import cbit.vcell.field.FieldDataDBOperationSpec;
+import cbit.vcell.server.UserRegistrationOP;
+import cbit.vcell.server.UserRegistrationResults;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.modeldb.*;
+import cbit.vcell.messaging.JmsUtils;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @author: Jim Schaff
+ *
+ * stateless database service for any user (should be thread safe ... reentrant)
+ *
+ */
+public class RpcDbServerProxy extends AbstractRpcServerProxy implements cbit.vcell.server.UserMetaDbServer {
+/**
+ * DataServerProxy constructor comment.
+ */
+public RpcDbServerProxy(User argUser, JmsClientMessaging clientMessaging, org.vcell.util.SessionLog log) throws javax.jms.JMSException {
+	super(argUser, clientMessaging, JmsUtils.getQueueDbReq(), log);
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VCDocumentInfo curate(org.vcell.util.document.CurateSpec curateSpec) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	return (org.vcell.util.document.VCDocumentInfo)rpc("curate",new Object[]{user,curateSpec});
+}
+
+
+public UserRegistrationResults userRegistrationOP(UserRegistrationOP userRegistrationOP) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	return (UserRegistrationResults)rpc("userRegistrationOP",new Object[]{user,userRegistrationOP});
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteBioModel(org.vcell.util.document.KeyValue bioModelKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteBioModel",new Object[]{user, bioModelKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public FieldDataDBOperationResults fieldDataDBOperation(FieldDataDBOperationSpec fieldDataDBOperationSpec) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (FieldDataDBOperationResults)rpc("fieldDataDBOperation",new Object[]{user, fieldDataDBOperationSpec});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteGeometry(org.vcell.util.document.KeyValue geometryKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteGeometry",new Object[]{user, geometryKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteMathModel(org.vcell.util.document.KeyValue mathModelKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteMathModel",new Object[]{user, mathModelKey});
+}
+
+
+/**
+* Insert the method's description here.
+* Creation date: (10/22/2003 10:28:00 AM)
+*/
+public void deleteResultSetExport(org.vcell.util.document.KeyValue eleKey) throws org.vcell.util.DataAccessException {
+	rpc("deleteResultSetExport",new Object[]{user, eleKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/29/2004 4:31:48 PM)
+ * @param bioModelKey cbit.sql.KeyValue
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void deleteVCImage(org.vcell.util.document.KeyValue imageKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	rpc("deleteVCImage",new Object[]{user, imageKey});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteOPResults doTestSuiteOP(cbit.vcell.numericstest.TestSuiteOP tsop) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+
+	return (cbit.vcell.numericstest.TestSuiteOPResults ) rpc("doTestSuiteOP",new Object[] {user,tsop});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.ReferenceQueryResult findReferences(org.vcell.util.document.ReferenceQuerySpec rqs) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException, java.rmi.RemoteException {
+	return (org.vcell.util.document.ReferenceQueryResult)rpc("findReferences",new Object[]{user,rqs});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.modeldb.VersionableFamily
+ * @param vType cbit.sql.VersionableType
+ * @param key cbit.sql.KeyValue
+ */
+public org.vcell.util.document.VersionableFamily getAllReferences(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (VersionableFamily)rpc("getAllReferences",new Object[]{user, vType,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo getBioModelInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.BioModelInfo)rpc("getBioModelInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.BioModelInfo[] getBioModelInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (org.vcell.util.document.BioModelInfo[])rpc("getBioModelInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.biomodel.BioModelMetaData getBioModelMetaData(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BioModelMetaData)rpc("getBioModelMetaData",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.biomodel.BioModelMetaData[] getBioModelMetaDatas(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (BioModelMetaData[])rpc("getBioModelMetaDatas",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getBioModelXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getBioModelXML",new Object[]{user, key});
+}
+
+
+/**
+ * getBoundSpecies method comment.
+ */
+public cbit.vcell.dictionary.DBSpecies getBoundSpecies(cbit.vcell.dictionary.DBFormalSpecies dbfs) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.DBSpecies)rpc("getBoundSpecies",new Object[]{user, dbfs});
+}
+
+
+/**
+ * getDatabaseSpecies method comment.
+ */
+public cbit.vcell.dictionary.DBFormalSpecies[] getDatabaseSpecies(java.lang.String likeString, boolean isBound, cbit.vcell.dictionary.FormalSpeciesType speciesType, int restrictSearch, int rowLimit, boolean bOnlyUser) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.DBFormalSpecies[])rpc("getDatabaseSpecies",new Object[]{user, likeString,new Boolean(isBound),speciesType,new Integer(restrictSearch),new Integer(rowLimit), new Boolean(bOnlyUser)});
+}
+
+
+/**
+ * getDictionaryReactions method comment.
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getDictionaryReactions(ReactionQuerySpec reactionQuerySpec) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.ReactionDescription[])rpc("getDictionaryReactions",new Object[]{user, reactionQuerySpec});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @return cbit.vcell.export.server.ExportLog
+ * @param simKey cbit.sql.KeyValue
+ */
+public cbit.vcell.export.server.ExportLog getExportLog(org.vcell.util.document.KeyValue simulationKey) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (cbit.vcell.export.server.ExportLog)rpc("getExportLog",new Object[]{user, simulationKey});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @return cbit.vcell.export.server.ExportLog[]
+ * @param simKey cbit.sql.KeyValue
+ */
+public cbit.vcell.export.server.ExportLog[] getExportLogs(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.export.server.ExportLog[])rpc("getExportLogs",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo getGeometryInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (cbit.vcell.geometry.GeometryInfo)rpc("getGeometryInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.geometry.GeometryInfo[] getGeometryInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.geometry.GeometryInfo[])rpc("getGeometryInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getGeometryXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getGeometryXML",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo getMathModelInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.MathModelInfo)rpc("getMathModelInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.MathModelInfo[] getMathModelInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (org.vcell.util.document.MathModelInfo[])rpc("getMathModelInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.mathmodel.MathModelMetaData getMathModelMetaData(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (MathModelMetaData)rpc("getMathModelMetaData",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return MathModelMetaData[]
+ * @param bAll boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.mathmodel.MathModelMetaData[] getMathModelMetaDatas(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (MathModelMetaData[])rpc("getMathModelMetaDatas",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getMathModelXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getMathModelXML",new Object[]{user, key});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:54:49 PM)
+ * @return cbit.util.Preference
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.Preference[] getPreferences() throws org.vcell.util.DataAccessException {
+	return (org.vcell.util.Preference[])rpc("getPreferences",new Object[]{user});
+}
+
+
+/**
+ * getReactionStep method comment.
+ */
+public cbit.vcell.model.Model getReactionStepAsModel(org.vcell.util.document.KeyValue rxID) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.model.Model)rpc("getReactionStepAsModel",new Object[]{user, rxID});
+}
+
+
+/**
+ * getReactionStepInfos method comment.
+ */
+public cbit.vcell.model.ReactionStepInfo[] getReactionStepInfos(org.vcell.util.document.KeyValue[] reactionStepKeys) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.model.ReactionStepInfo[])rpc("getReactionStepInfos",new Object[]{user, reactionStepKeys});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @return cbit.vcell.solver.SolverResultSetInfo
+ * @param simKey cbit.sql.KeyValue
+ */
+public cbit.vcell.solver.SolverResultSetInfo[] getResultSetInfos(boolean bAll) throws org.vcell.util.DataAccessException {
+	return (SolverResultSetInfo[])rpc("getResultSetInfos",new Object[]{user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationStatus[] getSimulationStatus(org.vcell.util.document.KeyValue simulationKeys[]) throws DataAccessException, ObjectNotFoundException {
+	return (SimulationStatus[])rpc("getSimulationStatus",new Object[]{simulationKeys});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationStatus getSimulationStatus(org.vcell.util.document.KeyValue simulationKey) throws DataAccessException, ObjectNotFoundException {
+	return (SimulationStatus)rpc("getSimulationStatus",new Object[]{simulationKey});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getSimulationXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getSimulationXML",new Object[]{user, key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteNew getTestSuite(java.math.BigDecimal getThisTS) throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+
+	return (cbit.vcell.numericstest.TestSuiteNew ) rpc("getTestSuite",new Object[] {user,getThisTS});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.vcell.numericstest.TestSuiteInfoNew[] getTestSuiteInfos() throws org.vcell.util.DataAccessException, java.rmi.RemoteException {
+
+	return (cbit.vcell.numericstest.TestSuiteInfoNew[] ) rpc("getTestSuiteInfos",new Object[] {user});
+}
+
+
+/**
+ * getUserReactionDescriptions method comment.
+ */
+public cbit.vcell.dictionary.ReactionDescription[] getUserReactionDescriptions(ReactionQuerySpec reactionQuerySpec) throws org.vcell.util.DataAccessException {
+	return (cbit.vcell.dictionary.ReactionDescription[])rpc("getUserReactionDescriptions",new Object[]{user, reactionQuerySpec});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo getVCImageInfo(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (cbit.image.VCImageInfo)rpc("getVCImageInfo",new Object[]{user,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return GeometryInfo
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public cbit.image.VCImageInfo[] getVCImageInfos(boolean bAll)
+    throws org.vcell.util.DataAccessException {
+    return (cbit.image.VCImageInfo[]) rpc(
+        "getVCImageInfos",
+        new Object[] { user, new Boolean(bAll)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Geometry
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString getVCImageXML(org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException {
+	return (BigString)rpc("getVCImageXML",new Object[]{user, key});
+}
+
+
+/**
+ * getVCInfoContainer method comment.
+ */
+public VCInfoContainer getVCInfoContainer() throws org.vcell.util.DataAccessException {
+	return (VCInfoContainer)rpc("getVCInfoContainer",new Object[]{user});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupAddUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key, java.lang.String addUserToGroup, boolean isHidden) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupAddUser",new Object[]{user, vType,key,addUserToGroup,new Boolean(isHidden)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupRemoveUser(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key, java.lang.String userRemoveFromGroup, boolean isHiddenFromOwner) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupRemoveUser",new Object[]{user, vType,key,userRemoveFromGroup,new Boolean(isHiddenFromOwner)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPrivate(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupSetPrivate",new Object[]{user, vType,key});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return void
+ * @param key KeyValue
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.document.VersionInfo groupSetPublic(org.vcell.util.document.VersionableType vType, org.vcell.util.document.KeyValue key) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (org.vcell.util.document.VersionInfo)rpc("groupSetPublic",new Object[]{user, vType,key});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/10/2004 7:54:49 PM)
+ * @param preferences cbit.util.Preference[]
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void replacePreferences(org.vcell.util.Preference[] preferences) throws org.vcell.util.DataAccessException {
+	rpc("replacePreferences",new Object[]{user, preferences});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private Object rpc(String methodName, Object[] args) throws org.vcell.util.ObjectNotFoundException, DataAccessException {
+	try {
+		return rpc(ServiceType.DB, methodName, args, true);
+	} catch (org.vcell.util.ObjectNotFoundException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (RuntimeException e){
+		log.exception(e);
+		throw e;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveBioModel(BigString bioModelXML, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveBioModel",new Object[]{user, bioModelXML, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveBioModelAs(BigString bioModelXML, java.lang.String newName, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveBioModelAs",new Object[]{user, bioModelXML, newName, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveGeometry(BigString geometryXML) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveGeometry",new Object[]{user, geometryXML});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveGeometryAs(BigString geometryXML, java.lang.String newName) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveGeometryAs",new Object[]{user, geometryXML, newName});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveMathModel(BigString mathModelXML, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveMathModel",new Object[]{user, mathModelXML, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveMathModelAs(BigString mathModelXML, java.lang.String newName, String independentSims[]) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveMathModelAs",new Object[]{user, mathModelXML, newName, independentSims});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public org.vcell.util.BigString saveSimulation(org.vcell.util.BigString simulationXML, boolean bForceIndependent) throws DataAccessException {
+	return (BigString)rpc("saveSimulation",new Object[]{user, simulationXML, new Boolean(bForceIndependent)});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveVCImage(BigString vcImageXML) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveVCImage",new Object[]{user, vcImageXML});
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return Versionable
+ * @param versionable Versionable
+ * @param bVersion boolean
+ * @exception org.vcell.util.DataAccessException The exception description.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public BigString saveVCImageAs(BigString vcImageXML, java.lang.String newName) throws org.vcell.util.DataAccessException, org.vcell.util.ObjectNotFoundException {
+	return (BigString)rpc("saveVCImageAs",new Object[]{user, vcImageXML, newName});
+}
+}
Index: src/cbit/vcell/messaging/server/JmsRpcServer.java
===================================================================
--- src/cbit/vcell/messaging/server/JmsRpcServer.java	(revision 0)
+++ src/cbit/vcell/messaging/server/JmsRpcServer.java	(revision 12031)
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.util.Date;
+
+import javax.jms.*;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.messaging.admin.ServiceInstanceStatus;
+import cbit.vcell.messaging.RpcServerMessaging;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public abstract class JmsRpcServer extends AbstractJmsServiceProvider implements RpcServer {	
+	protected RpcServerMessaging rpcServerMessaging = null;	
+
+/**
+ * Scheduler constructor comment.
+ */
+public JmsRpcServer(ServiceType serviceType, int serviceOrdinal, String queueName, String filter, String logdir) throws Exception {
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID(), serviceType, serviceOrdinal, ManageUtils.getHostName(), new Date(), true);
+	initLog(logdir);
+	
+	log = new org.vcell.util.StdoutSessionLog(serviceInstanceStatus.getID());	
+	rpcServerMessaging = new RpcServerMessaging(this, queueName, filter, log);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (1/3/2002 5:41:53 PM)
+ * @return java.lang.Object
+ * @param user cbit.vcell.server.User
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+public final Object dispatchRPC(RpcRequest request) throws Exception {
+	return getRpcServerImpl().rpc(request);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2003 2:01:52 PM)
+ * @return cbit.vcell.messaging.RpcServerImpl
+ */
+public abstract RpcServerImpl getRpcServerImpl() throws DataAccessException;
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/9/2003 12:07:28 PM)
+ */
+public final void start() throws JMSException {
+	log.print(getClass().getName() + " starting");
+	rpcServerMessaging.startListening();
+	
+	log.print("Start PropertyLoader thread...");
+	new PropertyLoaderThread().start();	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 4:28:05 PM)
+ */
+public final void stop() {
+	log.print(this.getClass().getName() + " ending");
+}
+}
Index: src/cbit/vcell/messaging/server/MessagingDispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/MessagingDispatcherDbManager.java	(revision 0)
+++ src/cbit/vcell/messaging/server/MessagingDispatcherDbManager.java	(revision 12031)
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.sql.Connection;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants.SimulationQueueID;
+
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.solver.SimulationMessage;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/23/2004 10:42:53 AM)
+ * @author: Fei Gao
+ */
+public interface MessagingDispatcherDbManager extends DispatcherDbManager {
+	SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+			String computeHost, VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int taskID, String hostName, SchedulerStatus status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateQueueStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDb, Connection con, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationQueueID queueID, boolean firstSubmit) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, AdminDatabaseServerXA adminDbXA, Connection con, String hostName, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int taskID, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException;
+}
Index: src/cbit/vcell/messaging/server/RpcSimServerProxy.java
===================================================================
--- src/cbit/vcell/messaging/server/RpcSimServerProxy.java	(revision 0)
+++ src/cbit/vcell/messaging/server/RpcSimServerProxy.java	(revision 12031)
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.User;
+
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.JmsUtils;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/5/2001 12:00:10 PM)
+ * @author: Jim Schaff
+ *
+ * stateless database service for any user (should be thread safe ... reentrant)
+ *
+ */
+public class RpcSimServerProxy extends AbstractRpcServerProxy implements cbit.vcell.server.SimulationController {
+/**
+ * DataServerProxy constructor comment.
+ */
+public RpcSimServerProxy(User argUser, JmsClientMessaging clientMessaging, org.vcell.util.SessionLog log) throws javax.jms.JMSException {
+	super(argUser, clientMessaging, JmsUtils.getQueueSimReq(), log);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private Object rpc(String methodName, Object[] args) throws DataAccessException {
+	try {
+		return rpc(ServiceType.DISPATCH, methodName, args, true);
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/5/2001 9:39:03 PM)
+ * @return java.lang.Object
+ * @param methodName java.lang.String
+ * @param args java.lang.Object[]
+ * @exception java.lang.Exception The exception description.
+ */
+private void rpcNoWait(String methodName, Object[] args) throws DataAccessException {
+	try {
+		rpc(ServiceType.DISPATCH, methodName, args, false);
+	} catch (DataAccessException ex) {
+		log.exception(ex);
+		throw ex;
+	} catch (Exception e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void startSimulation(VCSimulationIdentifier vcSimID) {
+	try {
+		rpcNoWait("startSimulation",new Object[]{vcSimID});
+	}catch (DataAccessException e){
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public void stopSimulation(VCSimulationIdentifier vcSimID) {
+	try {
+		rpcNoWait("stopSimulation",new Object[]{vcSimID});
+	} catch (DataAccessException e) {
+		log.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+}
Index: src/cbit/vcell/messaging/server/DispatcherDbManager.java
===================================================================
--- src/cbit/vcell/messaging/server/DispatcherDbManager.java	(revision 0)
+++ src/cbit/vcell/messaging/server/DispatcherDbManager.java	(revision 12031)
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.document.KeyValue;
+
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.message.server.dispatcher.SimulationDatabase;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.solver.SimulationMessage;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/20/2004 3:38:59 PM)
+ * @author: Fei Gao
+ */
+public interface DispatcherDbManager {
+	SimulationJobStatus[] getSimulationJobStatusArray(SimulationDatabase simDb, KeyValue simKey, int jobIndex) throws DataAccessException;
+
+
+	SimulationJobStatus updateDispatchedStatus(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, String computeHost, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int taskID, SimulationMessage startMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateEndStatus(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID, String hostName, SchedulerStatus status, SimulationMessage solverMsg) throws DataAccessException, UpdateSynchronizationException;
+
+
+	void updateLatestUpdateDate(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, VCSimulationIdentifier vcSimID, 
+			int jobIndex, int taskID, SimulationMessage simulationMessage) throws DataAccessException, UpdateSynchronizationException;
+
+
+	SimulationJobStatus updateRunningStatus(SimulationJobStatus oldJobStatus, SimulationDatabase simDb, String hostName, 
+			VCSimulationIdentifier vcSimID, int jobIndex, int taskID, boolean hasData, SimulationMessage solverMsg)	throws DataAccessException, UpdateSynchronizationException;
+}
Index: src/cbit/vcell/messaging/server/JavaSimulationExecutable.java
===================================================================
--- src/cbit/vcell/messaging/server/JavaSimulationExecutable.java	(revision 0)
+++ src/cbit/vcell/messaging/server/JavaSimulationExecutable.java	(revision 12031)
@@ -0,0 +1,353 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+
+import java.io.File;
+import javax.jms.JMSException;
+import javax.jms.Message;
+
+import org.vcell.util.FileUtils;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.ControlMessageCollector;
+import cbit.vcell.messaging.ControlTopicListener;
+import cbit.vcell.messaging.JmsConnection;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsConnectionFactoryImpl;
+import cbit.vcell.messaging.JmsSession;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.messaging.MessagePropertyNotFoundException;
+import cbit.vcell.messaging.WorkerEventMessage;
+import cbit.vcell.messaging.admin.ManageUtils;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.Solver;
+import cbit.vcell.solver.SolverEvent;
+import cbit.vcell.solver.SolverException;
+import cbit.vcell.solver.SolverFactory;
+import cbit.vcell.solver.SolverListener;
+import cbit.vcell.solver.SolverStatus;
+import cbit.vcell.xml.XmlHelper;
+
+public class JavaSimulationExecutable implements ControlTopicListener, SolverListener  {
+	String[] arguments = null;
+	
+	private boolean bProgress = true;	
+	private SimulationTask simulationTask = null;
+	private Solver solver = null;
+	private long lastMsgTimeStamp = 0;
+
+	private JmsConnection jmsConn = null;
+	private JmsSession workerEventSession = null;
+	
+	private String userDirectory = null;
+	private String inputFile = null;
+	int jobIndex = 0;
+	int taskID = 0;
+	
+	SessionLog log = null;
+	
+	class KeepAliveThread extends Thread {
+		public KeepAliveThread() {
+			super();
+			setName("KeepAliveThread_Compute");
+		}	
+		public void run() {
+			while (true) {
+				try {
+					sleep(MessageConstants.INTERVAL_PING_SERVER);
+				} catch (InterruptedException ex) {
+				}
+		
+				long t = System.currentTimeMillis();
+				if (lastMsgTimeStamp != 0 && t - lastMsgTimeStamp > MessageConstants.INTERVAL_PING_SERVER) {
+					log.print("@@@@Worker:Sending alive message");
+					sendAlive();
+				}
+			}
+		}	
+	}	
+	
+/**
+ * SimulationWorker constructor comment.
+ * @param argName java.lang.String
+ * @param argParentNode cbit.vcell.appserver.ComputationalNode
+ * @param argInitialContext javax.naming.Context
+ */
+public JavaSimulationExecutable(String[] args) {
+	arguments = args;
+}
+
+private void start() {
+	try {		
+		reconnect();
+		
+		if (arguments.length != 6) {
+			throw new RuntimeException("Missing arguments: " + JavaSimulationExecutable.class.getName() + "{alpha|beta|rel} userDir inputFile jobIndex -tid taskID");
+		}
+		
+		int argCount = 0;
+		String serverID = arguments[argCount ++];
+		if (!serverID.equalsIgnoreCase(VCellServerID.getSystemServerID().toString())) {
+			throw new IllegalArgumentException("wrong server id : " + arguments[argCount]);
+		}
+		userDirectory = arguments[argCount ++];
+		inputFile = arguments[argCount ++];
+		jobIndex = Integer.parseInt(arguments[argCount ++]);
+		String tid = arguments[argCount ++];
+		if (tid.equals("-tid")) {
+			taskID = Integer.parseInt(arguments[argCount ++]);
+		} else {
+			throw new IllegalArgumentException("wrong arguments : " + tid);
+		}
+		
+		String xmlString = FileUtils.readFileToString(new File(userDirectory, inputFile));
+		Simulation simulation = XmlHelper.XMLToSim(xmlString);
+		simulationTask = new SimulationTask(new SimulationJob(simulation, jobIndex, null), taskID);
+		
+		log = new StdoutSessionLog(simulationTask.getSimulationJobID());	
+		
+		log.print("Start keep alive thread");
+		new KeepAliveThread().start();
+		
+		runSimulation();
+		
+		try {
+			if (jmsConn != null) {
+				jmsConn.close();
+			}
+		} catch (Exception ex) {
+			log.exception(ex);
+		}
+	} catch (Throwable ex) {
+		ex.printStackTrace();
+		sendFailed(SimulationMessage.solverAborted(ex.getMessage()));
+	}
+}
+
+protected void reconnect() throws JMSException {
+	JmsConnectionFactory jmsConnectorFactory = new JmsConnectionFactoryImpl();
+	jmsConn = jmsConnectorFactory.createConnection();
+	workerEventSession = jmsConn.getAutoSession();		
+	
+	JmsSession serviceListenTopicSession = jmsConn.getAutoSession();
+	serviceListenTopicSession.setupTopicListener(JmsUtils.getTopicServiceControl(), null, new ControlMessageCollector(this));
+	jmsConn.startConnection();
+}
+
+private void runSimulation() throws SolverException {
+	solver = SolverFactory.createSolver(log, new File(userDirectory), simulationTask, true);
+	solver.addSolverListener(this);
+	solver.startSolver();
+	
+	while (true){
+		try { 
+			Thread.sleep(500); 
+		} catch (InterruptedException e) {
+		}
+
+		cbit.vcell.solver.SolverStatus solverStatus = solver.getSolverStatus();
+		if (solverStatus != null) {
+			if (solverStatus.getStatus() != SolverStatus.SOLVER_STARTING &&
+				solverStatus.getStatus() != SolverStatus.SOLVER_READY &&
+				solverStatus.getStatus() != SolverStatus.SOLVER_RUNNING){
+				break;
+			}
+		}		
+	}
+}
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(String[] args) {	
+	try {
+		PropertyLoader.loadProperties();
+		VCMongoMessage.enabled = false;
+		JavaSimulationExecutable worker = new JavaSimulationExecutable(args);
+		worker.start();
+	} catch (Throwable ex) {
+		ex.printStackTrace();
+	} finally {
+		System.exit(0);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/22/2003 2:49:54 PM)
+ * @param message javax.jms.Message
+ * @exception javax.jms.JMSException The exception description.
+ */
+public void onControlTopicMessage(Message message) throws JMSException {
+	
+	log.print("JavaSimulationExecutable::onControlTopicMessage(): " + JmsUtils.toString(message));
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+
+		if (msgType != null && msgType.equals(MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE)) {			
+			Long longkey = (Long)JmsUtils.parseProperty(message, MessageConstants.SIMKEY_PROPERTY, long.class);
+			KeyValue simKey = new KeyValue(longkey + "");
+			int jobIndex = ((Integer)JmsUtils.parseProperty(message, MessageConstants.JOBINDEX_PROPERTY, int.class)).intValue();
+			
+			if (simKey.equals(simulationTask.getSimKey()) && jobIndex == simulationTask.getSimulationJob().getJobIndex()) {
+				solver.stopSolver();
+			}
+		} 	
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+		return;
+	}
+}
+
+private void sendAlive() {
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendWorkerAlive(" + simulationTask.getSimulationJobID() + ")");
+		WorkerEventMessage.sendWorkerAlive(workerEventSession, this, simulationTask, ManageUtils.getHostName(), SimulationMessage.MESSAGE_WORKEREVENT_WORKERALIVE);
+		
+		lastMsgTimeStamp = System.currentTimeMillis();
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+private void sendFailed(SimulationMessage failureMessage) {		
+	try {
+		log.print("sendFailure(" + simulationTask.getSimulationJobID() + "," + failureMessage +")");
+		WorkerEventMessage.sendFailed(workerEventSession, this, simulationTask, ManageUtils.getHostName(), failureMessage);
+	} catch (JMSException ex) {
+        log.exception(ex);
+	}
+}
+
+private void sendNewData(double progress, double timeSec, SimulationMessage simulationMessage) {	
+	try {
+		long t = System.currentTimeMillis();
+		if (bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE) { // don't send data message too frequently
+			log.print("sendNewData(" + simulationTask.getSimulationJobID() + "," + (progress * 100) + "%," + timeSec + ")");		
+			WorkerEventMessage.sendNewData(workerEventSession, this, simulationTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+		
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = false;
+		}
+	} catch (JMSException e) {
+		e.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/22/2001 11:20:37 PM)
+ */
+private void sendProgress(double progress, double timeSec, SimulationMessage simulationMessage) {
+	try {
+		long t = System.currentTimeMillis();
+		if (!bProgress || t - lastMsgTimeStamp > MessageConstants.INTERVAL_PROGRESS_MESSAGE 
+				|| ((int)(progress * 100)) % 25 == 0) { // don't send progress message too frequently
+			log.print("sendProgress(" + simulationTask.getSimulationJobID() + "," + (progress * 100) + "%," + timeSec + ")");
+			WorkerEventMessage.sendProgress(workerEventSession, this, simulationTask, ManageUtils.getHostName(), progress, timeSec, simulationMessage);
+			
+			lastMsgTimeStamp = System.currentTimeMillis();
+			bProgress = true;
+		}
+	} catch (JMSException e) {
+		log.exception(e);
+	}
+}
+
+private void sendCompleted(double progress, double timeSec, SimulationMessage simulationMessage) {
+	// have to keep sending the messages because it's important
+	try {
+		log.print("sendComplete(" + simulationTask.getSimulationJobID() + ")");
+		WorkerEventMessage.sendCompleted(workerEventSession, this, simulationTask, ManageUtils.getHostName(),  progress, timeSec, simulationMessage);
+	} catch (JMSException jmse) {
+        log.exception(jmse);
+	}
+}
+
+private void sendStarting(SimulationMessage startingMessage) {
+	try {
+		log.print("sendStarting(" + simulationTask.getSimulationJobID() + ")");
+		WorkerEventMessage.sendStarting(workerEventSession, this, simulationTask, ManageUtils.getHostName(), startingMessage);
+	} catch (JMSException e) {
+        log.exception(e);
+	}
+}
+
+/**
+ * Invoked when the solver aborts a calculation (abnormal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverAborted(SolverEvent event) {
+	sendFailed(event.getSimulationMessage());
+}
+
+/**
+ * Invoked when the solver finishes a calculation (normal termination).
+ * @param event indicates the solver and the event type
+ */
+public final void solverFinished(SolverEvent event) {
+	sendCompleted(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverPrinted(SolverEvent event) {
+	// can never get data messages here
+	sendNewData(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stores values in the result set.
+ * @param event indicates the solver and the event type
+ */
+public final void solverProgress(SolverEvent event) {
+	// can never get progress message here
+	sendProgress(event.getProgress(), event.getTimePoint(), event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver begins a calculation.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStarting(SolverEvent event) {
+	sendStarting(event.getSimulationMessage());
+}
+
+
+/**
+ * Invoked when the solver stops a calculation, usually because
+ * of a user-initiated stop call.
+ * @param event indicates the solver and the event type
+ */
+public final void solverStopped(SolverEvent event) {		
+	log.print("Caught solverStopped(" + event.getSource() + ")");
+	// Don't send message anymore because the dispatcher will update the database anyway no matter if the worker responds
+	//workerMessaging.sendStopped(event.getProgress(), event.getTimePoint());
+}
+
+}
Index: src/cbit/vcell/messaging/server/DatabaseServer.java
===================================================================
--- src/cbit/vcell/messaging/server/DatabaseServer.java	(revision 0)
+++ src/cbit/vcell/messaging/server/DatabaseServer.java	(revision 12031)
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.PropertyLoader;
+
+import static org.vcell.util.MessageConstants.*;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.modeldb.DatabasePolicySQL;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:11 PM)
+ * @author: Jim Schaff
+ */
+public class DatabaseServer extends JmsRpcServer {
+	private RpcDbServerImpl rpcDbServerImpl = null;
+	private static String filter =  "(" + MESSAGE_TYPE_PROPERTY + "='" + MESSAGE_TYPE_RPC_SERVICE_VALUE  + "') AND (" 
+		+ SERVICE_TYPE_PROPERTY + "='" + ServiceType.DB.getName() + "')";
+
+/**
+ * Scheduler constructor comment.
+ */
+public DatabaseServer(int serviceOrdinal, String logdir) throws Exception {	
+	super(ServiceType.DB, serviceOrdinal, JmsUtils.getQueueDbReq(), filter, logdir);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2003 8:17:51 AM)
+ * @return cbit.vcell.messaging.RpcServerImpl
+ * @param user cbit.vcell.server.User
+ */
+public RpcServerImpl getRpcServerImpl() throws DataAccessException {
+	try {
+		if (rpcDbServerImpl == null) {
+			rpcDbServerImpl = new RpcDbServerImpl(log);
+		}
+
+		return rpcDbServerImpl;
+	} catch (Exception ex) {
+		log.exception(ex);
+		throw new DataAccessException(ex.getMessage());
+	}
+}
+
+
+/**
+ * Starts the application.
+ * @param args an array of command-line arguments
+ */
+public static void main(java.lang.String[] args) {
+	if (args.length < 1) {
+		System.out.println("Missing arguments: " + DatabaseServer.class.getName() + " serviceOrdinal [logdir]");
+		System.exit(1);
+	}
+	
+	try {
+		PropertyLoader.loadProperties();
+		DatabasePolicySQL.bSilent = true;
+		
+		int serviceOrdinal = Integer.parseInt(args[0]);
+		String logdir = null;
+		if (args.length > 1) {
+			logdir = args[1];
+		}
+		VCMongoMessage.serviceStartup(ServiceName.database, new Integer(serviceOrdinal), args);
+        DatabaseServer databaseServer = new DatabaseServer(serviceOrdinal, logdir);       
+        databaseServer.start();        
+    } catch (Throwable e) {
+	    e.printStackTrace(System.out); 
+    }
+}
+}
Index: src/cbit/vcell/messaging/server/LocalVCellConnectionMessaging.java
===================================================================
--- src/cbit/vcell/messaging/server/LocalVCellConnectionMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/server/LocalVCellConnectionMessaging.java	(revision 12031)
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.server;
+import java.io.FileNotFoundException;
+import java.net.URL;
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+import org.vcell.util.BeanUtils;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+
+import cbit.rmi.event.DataJobListener;
+import cbit.rmi.event.ExportEvent;
+import cbit.rmi.event.ExportListener;
+import cbit.rmi.event.MessageEvent;
+import cbit.rmi.event.PerformanceMonitorEvent;
+import cbit.rmi.event.SimpleMessageService;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.JmsConnection;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsMessageCollector;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.server.DataSetController;
+import cbit.vcell.server.LocalVCellServer;
+import cbit.vcell.server.PerformanceMonitoringFacility;
+import cbit.vcell.server.SimulationController;
+import cbit.vcell.server.URLFinder;
+import cbit.vcell.server.UserLoginInfo;
+import cbit.vcell.server.UserMetaDbServer;
+import cbit.vcell.server.VCellConnection;
+import cbit.vcell.visit.VisitConnectionInfo;
+
+/**
+ * The user's connection to the Virtual Cell.  It is obtained from the VCellServer
+ * after the user has been authenticated.
+ * Creation date: (Unknown)
+ * @author: Jim Schaff.
+ */
+@SuppressWarnings("serial")
+public class LocalVCellConnectionMessaging extends UnicastRemoteObject implements VCellConnection, ExportListener ,DataJobListener{
+	private long MAX_TIME_WITHOUT_POLLING_MS = 10*MessageConstants.MINUTE_IN_MS;
+	private LocalDataSetControllerMessaging dataSetControllerMessaging = null;
+	private LocalSimulationControllerMessaging simulationControllerMessaging = null;
+	private LocalUserMetaDbServerMessaging userMetaDbServerMessaging = null;
+	private SimpleMessageService messageService = null;
+
+	private JmsConnection jmsConn = null;
+	private JmsMessageCollector jmsMessageCollector = null;
+	
+	private UserLoginInfo userLoginInfo;
+	
+	private SessionLog fieldSessionLog = null;
+	private LocalVCellServer fieldLocalVCellServer = null;
+	private String fieldHost = null;
+
+	private JmsClientMessaging dbClientMessaging = null;
+	private JmsClientMessaging dataClientMessaging = null;
+	private JmsClientMessaging simClientMessaging = null;
+	private PerformanceMonitoringFacility performanceMonitoringFacility;
+
+	public LocalVCellConnectionMessaging(UserLoginInfo userLoginInfo, String host, 
+		SessionLog sessionLog, JmsConnectionFactory jmsConnFactory, LocalVCellServer aLocalVCellServer) 
+		throws RemoteException, java.sql.SQLException, FileNotFoundException, javax.jms.JMSException {
+	super(PropertyLoader.getIntProperty(PropertyLoader.rmiPortVCellConnection,0));
+	this.userLoginInfo = userLoginInfo;
+	this.fieldHost = host;
+	this.fieldSessionLog = sessionLog;
+	this.fieldLocalVCellServer = aLocalVCellServer;
+	jmsConn = jmsConnFactory.createConnection();
+	jmsMessageCollector = new JmsMessageCollector(jmsConn, userLoginInfo.getUser(), fieldSessionLog);
+	
+	messageService = new SimpleMessageService();
+	jmsMessageCollector.addMessageListener(messageService);
+	
+	sessionLog.print("new LocalVCellConnectionMessaging(" + userLoginInfo.getUser().getName() + ")");	
+	fieldLocalVCellServer.getExportServiceImpl().addExportListener(this);
+	fieldLocalVCellServer.getDataSetControllerImpl().addDataJobListener(this);
+	
+	performanceMonitoringFacility = new PerformanceMonitoringFacility(userLoginInfo.getUser(), sessionLog);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/16/2004 10:42:29 AM)
+ */
+public void close() throws java.rmi.RemoteException {
+	try {
+		jmsConn.close();
+	} catch (javax.jms.JMSException ex) {
+		fieldSessionLog.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2006 3:32:25 PM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void dataJobMessage(cbit.rmi.event.DataJobEvent event) {
+	// if it's from one of our jobs, pass it along so it will reach the client
+	if (getUserLoginInfo().getUser().equals(event.getUser())) {
+		messageService.messageEvent(event);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/2/2001 2:59:05 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+public void exportMessage(ExportEvent event) {
+	// if it's from one of our jobs, pass it along so it will reach the client
+	if (getUserLoginInfo().getUser().equals(event.getUser())) {
+		messageService.messageEvent(event);
+	}
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.server.DataSetController
+ * @exception java.lang.Exception The exception description.
+ */
+public DataSetController getDataSetController() throws RemoteException, DataAccessException {
+	fieldSessionLog.print("LocalVCellConnectionMessaging.getDataSetController()");
+	if (dataSetControllerMessaging == null) {
+		try {
+			dataClientMessaging = new JmsClientMessaging(jmsConn, fieldSessionLog, getUserLoginInfo());
+			dataSetControllerMessaging = new LocalDataSetControllerMessaging(fieldSessionLog, getUserLoginInfo().getUser(), dataClientMessaging);
+			fieldSessionLog.print("new dataClientMessaging=" + dataClientMessaging);
+		} catch (javax.jms.JMSException ex) {
+			fieldSessionLog.exception(ex);
+			throw new DataAccessException(ex.getMessage());
+		}
+	}
+	
+	return dataSetControllerMessaging;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/17/2004 4:34:02 PM)
+ * @return cbit.vcell.messaging.event.SimpleMessageServiceMessaging
+ */
+SimpleMessageService getMessageService() {
+	return messageService;
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return cbit.vcell.solvers.MathController
+ * @param mathDesc cbit.vcell.math.MathDescription
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public SimulationController getSimulationController() throws RemoteException {
+	if (simulationControllerMessaging == null){
+		try {
+			simClientMessaging = new JmsClientMessaging(jmsConn, fieldSessionLog, getUserLoginInfo());
+			simulationControllerMessaging = new LocalSimulationControllerMessaging(getUserLoginInfo().getUser(), simClientMessaging, fieldSessionLog);
+			fieldSessionLog.print("new simClientMessaging=" + simClientMessaging);
+		} catch (DataAccessException ex) {
+			fieldSessionLog.exception(ex);
+			throw new RuntimeException(ex.getMessage());
+		} catch (javax.jms.JMSException ex) {
+			fieldSessionLog.exception(ex);
+			throw new RuntimeException(ex.getMessage());
+		}
+	}
+
+	return simulationControllerMessaging;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/2/01 11:15:49 PM)
+ * @return cbit.vcell.server.URLFinder
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public URLFinder getURLFinder() {
+	try {
+		return new URLFinder(	new URL(PropertyLoader.getRequiredProperty(PropertyLoader.tutorialURLProperty)),
+								new URL(PropertyLoader.getRequiredProperty(PropertyLoader.userGuideURLProperty)));
+	} catch (java.net.MalformedURLException e){
+		fieldSessionLog.exception(e);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+public VisitConnectionInfo createNewVisitConnection() {
+	VisitConnectionInfo visitConnectionInfo = VisitConnectionInfo.createHardCodedVisitConnectionInfo(getUserLoginInfo().getUser());
+	return visitConnectionInfo;
+}
+
+/**
+ * This method was created by a SmartGuide.
+ * @return java.lang.String
+ */
+public UserLoginInfo getUserLoginInfo() {
+	return userLoginInfo;
+}
+
+
+/**
+ * This method was created by a SmartGuide.
+ * @return DBManager
+ * @param userid java.lang.String
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public UserMetaDbServer getUserMetaDbServer() throws RemoteException, DataAccessException {
+	fieldSessionLog.print("LocalVCellConnectionMessaging.getUserMetaDbServer(" + getUserLoginInfo().getUser() + ")");
+	if (userMetaDbServerMessaging == null) {
+		try {
+			dbClientMessaging = new JmsClientMessaging(jmsConn, fieldSessionLog, getUserLoginInfo());
+			userMetaDbServerMessaging = new LocalUserMetaDbServerMessaging(dbClientMessaging, getUserLoginInfo().getUser(), fieldSessionLog);
+			fieldSessionLog.print("new dbClientMessaging=" + dbClientMessaging);
+		} catch (javax.jms.JMSException ex) {
+			fieldSessionLog.exception(ex);
+			throw new DataAccessException(ex.getMessage());
+		}			
+	}
+	return userMetaDbServerMessaging;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/16/2004 11:22:31 AM)
+ */
+public boolean isTimeout() throws java.rmi.RemoteException {
+	return messageService.timeSinceLastPoll() > MAX_TIME_WITHOUT_POLLING_MS;
+}
+
+
+public void sendErrorReport(Throwable exception) throws RemoteException {
+	VCMongoMessage.sendClientException(exception, getUserLoginInfo());
+	BeanUtils.sendErrorReport(exception);
+}
+
+public MessageEvent[] getMessageEvents() throws RemoteException {
+	MessageEvent[] messageEvents = messageService.getMessageEvents();
+	VCMongoMessage.sendClientMessageEventsDelivered(messageEvents, getUserLoginInfo());
+	return messageEvents;
+}
+
+
+public void reportPerformanceMonitorEvent(PerformanceMonitorEvent performanceMonitorEvent) throws RemoteException {
+	performanceMonitoringFacility.performanceMonitorEvent(performanceMonitorEvent);
+	
+}
+
+}
Index: src/cbit/vcell/messaging/SimulationDispatcherMessaging.java
===================================================================
--- src/cbit/vcell/messaging/SimulationDispatcherMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/SimulationDispatcherMessaging.java	(revision 12031)
@@ -0,0 +1,887 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.StringTokenizer;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.ObjectMessage;
+
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.SimulationQueueID;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.vcell.field.FieldDataIdentifierSpec;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.messaging.db.SimulationJobStatus.SchedulerStatus;
+import cbit.vcell.messaging.db.SimulationJobStatusInfo;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.messaging.server.RpcRequest;
+import cbit.vcell.messaging.server.SimulationDispatcher;
+import cbit.vcell.messaging.server.SimulationTask;
+import cbit.vcell.modeldb.AbstractDBTopLevel;
+import cbit.vcell.modeldb.AdminDatabaseServerXAImpl;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.server.AdminDatabaseServerXA;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.solver.SimulationJob;
+import cbit.vcell.solver.SimulationMessage;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.transaction.JtaDbConnection;
+import cbit.vcell.transaction.JtaOracleConnection;
+import cbit.vcell.transaction.JtaTransactionManager;
+import cbit.vcell.xml.XmlParseException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:45 PM)
+ * @author: Jim Schaff
+ */
+public class SimulationDispatcherMessaging extends JmsServiceProviderMessaging implements ControlTopicListener {
+
+	public static final String METHOD_NAME_STARTSIMULATION = "startSimulation";
+	public static final String METHOD_NAME_STOPSIMULATION = "stopSimulation";
+	
+	private ConnectionFactory conFactory = null;
+	private KeyFactory keyFactory = null;
+		
+	private JmsXAConnection jmsXAConn = null;
+
+	private SimulationDispatcher simDispatcher = null;
+	private JmsXASession mainJobDispatcher = null;
+
+	private AdminDatabaseServerXA jobAdminXA = null;
+	private String jobSelector = null;
+	
+
+	class SimulationMonitorThread extends Thread {
+	
+		public SimulationMonitorThread() {
+			super();
+			setName(simDispatcher.getServiceInstanceID() + "_MT");
+		}
+		
+		public void run() {
+			javax.transaction.TransactionManager tm = new JtaTransactionManager();
+			
+			JtaDbConnection obsoleteJobDbConnection = null;
+			JmsXASession obsoleteJobDispatcher = null;	
+			boolean join = true;
+			SimulationJobStatus jobStatus = null;
+				
+			while (true) {
+				try {
+					obsoleteJobDispatcher = jmsXAConn.getXASession();
+					break;
+					
+				} catch (Exception e) {
+					log.exception(e);
+					try {
+						Thread.sleep(MessageConstants.SECOND_IN_MS);
+					} catch (InterruptedException ex) {
+						log.exception(ex);
+					}
+				}
+			}
+			
+			while (true) { // first while(true);
+				log.print("##MT");
+				while (true) { // second while(true), check one by one
+					try {	
+						
+						//
+						// for first 10 minutes of dispatcher uptime, don't check for obsolete messages.
+						// as a startup transient, let the dispatchers catch up with worker messages before passing
+						// judgement on the health of jobs.
+						//
+						long uptime = System.currentTimeMillis() - VCMongoMessage.getServiceStartupTime();
+						final int UPTIME_WAIT = 1000*60*10;
+						if (uptime < UPTIME_WAIT){
+							try {
+								Thread.sleep(UPTIME_WAIT - uptime);
+							}catch (Exception e){
+							}
+							continue;  // for first 10 minutes of uptime, don't obsolete
+						}
+						
+						obsoleteJobDbConnection = new JtaOracleConnection(conFactory);
+
+						jobStatus = jobAdminXA.getNextObsoleteSimulation(obsoleteJobDbConnection.getConnection(), MessageConstants.INTERVAL_DATABASE_SERVER_FAIL);								
+						if (jobStatus == null) {
+							log.print("##MT OK");
+							break; // no obsolete simulation, no transaction here. go back to sleep
+						}				
+
+						tm.begin();	
+						join = obsoleteJobDbConnection.joinTransaction(tm);
+
+						if (!join) {
+							throw new RuntimeException("##MT: join failed");
+						} else {
+							join = obsoleteJobDispatcher.joinTransaction(tm);
+
+							if (!join) {
+								throw new RuntimeException("##MT: join failed");
+							} else {
+								// too many retries
+								if ((jobStatus.getTaskID() & MessageConstants.TASKID_RETRYCOUNTER_MASK) >= MessageConstants.TASKID_MAX_RETRIES) {							
+									log.print("##MT too many retries " + jobStatus);
+
+									// new job status is failed.
+									SimulationJobStatus	newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), jobStatus.getSubmitDate(),
+										SchedulerStatus.FAILED, jobStatus.getTaskID(),
+										SimulationMessage.MESSAGE_JOB_FAILED_TOOMANYRETRIES,
+										jobStatus.getSimulationQueueEntryStatus(), jobStatus.getSimulationExecutionStatus());
+									//update the database
+									jobAdminXA.updateSimulationJobStatus(obsoleteJobDbConnection.getConnection(), jobStatus, newJobStatus);
+									// tell client
+									StatusMessage statusMsg = new StatusMessage(newJobStatus, jobStatus.getVCSimulationIdentifier().getOwner().getName(), null, null);
+									statusMsg.sendToClient(obsoleteJobDispatcher);
+									
+								} else {
+									SimulationTask simTask = simDispatcher.getSimulationTask(jobStatus);
+									
+									log.print("##MT requeued " + simTask);
+
+									// increment taskid, new job status is queued
+									SimulationJobStatus newJobStatus = new SimulationJobStatus(VCellServerID.getSystemServerID(), jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), jobStatus.getSubmitDate(), 
+											SchedulerStatus.QUEUED, jobStatus.getTaskID() + 1, 
+										SimulationMessage.MESSAGE_JOB_QUEUED_RETRY, jobStatus.getSimulationQueueEntryStatus(), null);
+									
+									//update the database
+									jobAdminXA.updateSimulationJobStatus(obsoleteJobDbConnection.getConnection(), jobStatus, newJobStatus);
+									// send to simulation queue
+									Simulation sim = simTask.getSimulationJob().getSimulation();
+									SimulationTask newSimTask = new SimulationTask(new SimulationJob(sim, newJobStatus.getJobIndex(), simDispatcher.getFieldDataIdentifierSpecs(sim)), newJobStatus.getTaskID());
+									SimulationTaskMessage taskMsg = new SimulationTaskMessage(newSimTask);
+									taskMsg.sendSimulationTask(obsoleteJobDispatcher);
+									// tell client
+									StatusMessage statusMsg = new StatusMessage(newJobStatus, newSimTask.getUserName(), null, null);
+									statusMsg.sendToClient(obsoleteJobDispatcher);
+								}
+								tm.commit();
+								
+								yield();
+								continue;
+							}
+						}
+					} catch (Exception e){
+						log.exception(e);
+						
+						try {
+							tm.rollback();
+						} catch (Exception ex) {
+							log.exception(ex);
+						}
+
+						try {
+							if (obsoleteJobDbConnection != null && AbstractDBTopLevel.isBadConnection(obsoleteJobDbConnection.getConnection(), log)) {
+								obsoleteJobDbConnection.closeOnFailure();
+								obsoleteJobDbConnection = null;
+							}
+						} catch (SQLException sqlex) {
+							log.exception(sqlex);
+						}
+					} finally {
+						try {
+							if (obsoleteJobDbConnection != null) {
+								obsoleteJobDbConnection.close();
+								obsoleteJobDbConnection = null;
+							}
+						} catch (SQLException ex) {
+							log.exception(ex);
+						}
+					}
+				} // second while (true)
+				
+				// start next check after some time
+				try {
+					sleep(MessageConstants.INTERVAL_PING_SERVER);
+				} catch (InterruptedException ex) {
+					log.exception(ex);
+				}
+				
+			} // first while (true);
+		}
+	}
+
+	class DispatchThread extends Thread {
+		public DispatchThread() {
+			super();
+			setName(simDispatcher.getServiceInstanceID() + "_DT");
+		}
+	
+		public void run() {
+			SimulationJobStatus jobStatus = null;
+			SimulationTask simTask = null;
+			boolean foundOne = false;
+			
+			javax.transaction.TransactionManager tm = null;
+			JmsXASession waitingJobDispatcher = null;
+			JtaDbConnection waitingJobDbConnection = null;	
+			SimulationJobStatusInfo[] allActiveJobs = null;
+		
+			while (true) {
+				try {
+					waitingJobDispatcher = jmsXAConn.getXASession();
+					break;
+					
+				} catch (Exception e) {
+					log.exception(e);
+					try {
+						Thread.sleep(MessageConstants.SECOND_IN_MS);
+					} catch (InterruptedException ex) {
+						log.exception(ex);
+					}
+				}
+			}
+			tm = new JtaTransactionManager();
+			boolean join = true;
+			
+			while (true) {
+				foundOne = false;	
+				jobStatus = null;
+				
+				try {			
+					waitingJobDbConnection = new JtaOracleConnection(conFactory);
+					allActiveJobs = jobAdminXA.getActiveJobs(waitingJobDbConnection.getConnection(), getHTCPartitionShareServerIDs());
+					
+					if (allActiveJobs != null && allActiveJobs.length > 0) {				
+						SimulationJobStatusInfo firstQualifiedJob = BatchScheduler.schedule(allActiveJobs, getHTCPartitionMaximumJobs(), 
+							JmsUtils.getMaxOdeJobsPerUser(), JmsUtils.getMaxPdeJobsPerUser(), VCellServerID.getSystemServerID(), log);
+						if (firstQualifiedJob != null) {
+							foundOne = true;					
+							jobStatus = firstQualifiedJob.getSimJobStatus();					
+							Simulation sim = simDispatcher.getSimulation(firstQualifiedJob.getUser(), jobStatus.getVCSimulationIdentifier().getSimulationKey());							
+							simTask = new SimulationTask(new SimulationJob(sim, jobStatus.getJobIndex(), simDispatcher.getFieldDataIdentifierSpecs(sim)), jobStatus.getTaskID());
+							log.print("**DT: going to dispatch " + simTask);
+						}
+					}
+				} catch (Exception ex) {
+					log.exception(ex);
+					allActiveJobs = null;
+					
+					try {
+						if (waitingJobDbConnection != null && AbstractDBTopLevel.isBadConnection(waitingJobDbConnection.getConnection(), log)) {
+							waitingJobDbConnection.closeOnFailure();
+							waitingJobDbConnection = null;
+						}
+					} catch (java.sql.SQLException sqlex) {
+						log.exception(sqlex);
+					}
+				} finally {
+					try {
+						if (waitingJobDbConnection != null) {
+							waitingJobDbConnection.close();
+							waitingJobDbConnection = null;
+						}
+					} catch (SQLException ex) {
+						log.exception(ex);				
+					}			
+				}
+				
+					
+				if (foundOne) {
+					try {
+						// A Distributed Transaction for dispatcher change the status of a waiting job in the database and sends it to simulation queue 							
+						tm.begin();
+						
+						waitingJobDbConnection = new JtaOracleConnection(conFactory);
+						
+						join = waitingJobDbConnection.joinTransaction(tm) && waitingJobDispatcher.joinTransaction(tm);
+
+						if (!join) {
+							throw new RuntimeException("**DT: join failed");
+						} else {
+							double requiredMemMB = simTask.getEstimatedMemorySizeMB();
+							if (requiredMemMB > Double.parseDouble(PropertyLoader.getRequiredProperty(PropertyLoader.limitJobMemoryMB))) {						
+								SimulationJobStatus newJobStatus = simDispatcher.updateEndStatus(jobStatus, jobAdminXA, waitingJobDbConnection.getConnection(), 
+										jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), jobStatus.getTaskID(), null, SchedulerStatus.FAILED, 
+										SimulationMessage.jobFailed("Simulation [" + simTask.getSimulationInfo().getName() + ", " + jobStatus.getJobIndex() + "] requires approximately " + requiredMemMB + "mb memory. Exceeds current memory limit."));
+								
+								// tell client
+								StatusMessage message = new StatusMessage(newJobStatus, simTask.getUserName(), null, null);
+								message.sendToClient(waitingJobDispatcher);
+							} else {
+								SimulationTaskMessage taskMsg = new SimulationTaskMessage(simTask);
+								// send the job the job queue
+								taskMsg.sendSimulationTask(waitingJobDispatcher);
+								//update database
+								SimulationJobStatus newJobStatus = simDispatcher.updateQueueStatus(jobStatus, jobAdminXA, waitingJobDbConnection.getConnection(), 
+									jobStatus.getVCSimulationIdentifier(), jobStatus.getJobIndex(), jobStatus.getJobIndex(), SimulationQueueID.QUEUE_ID_SIMULATIONJOB, false);						
+								// tell client
+								StatusMessage statusMsg = new StatusMessage(newJobStatus, simTask.getUserName(), null, null);
+								statusMsg.sendToClient(waitingJobDispatcher);
+								
+								log.print("**DT: queued " + simTask);
+							}
+						
+							tm.commit();
+							yield();
+							continue;
+						}
+					} catch (Exception ex) { // transaction exception
+						log.exception(ex);
+						
+						try {
+							tm.rollback();
+						} catch (Exception ex1) {
+							log.exception(ex1);
+						}
+						try {
+							if (waitingJobDbConnection != null && AbstractDBTopLevel.isBadConnection(waitingJobDbConnection.getConnection(), log)) {
+								waitingJobDbConnection.closeOnFailure();
+								waitingJobDbConnection = null;
+							}
+						} catch (SQLException sqlex) {
+							log.exception(sqlex);
+						}						
+					} finally {
+						try {
+							if (waitingJobDbConnection != null) {
+								waitingJobDbConnection.close();
+								waitingJobDbConnection = null;
+							}
+						} catch (java.sql.SQLException ex) {
+							log.exception(ex);
+						}
+					}
+						
+				} // if (foundOne)
+
+				// if there are no messages or no qualified jobs or exceptions, sleep for a while
+				try {
+					if (foundOne) {
+						sleep(100);
+					} else {
+						sleep(1 * MessageConstants.SECOND_IN_MS);
+					}
+				} catch (InterruptedException ex) {
+					log.exception(ex);
+				}
+			} // while(true)
+		
+		}
+	}
+
+	public class StatusThread extends Thread {
+		public StatusThread() {
+			super();
+			setName(simDispatcher.getServiceInstanceID() + "_ST");
+		}
+
+	
+		public void run() {
+			javax.transaction.TransactionManager tm = null;
+			JmsXASession statusReceiver = null;
+			JtaDbConnection statusDbConnection = null;
+			
+			while (true) {
+				try {
+					statusReceiver = jmsXAConn.getXASession();
+					break;			
+				} catch (Exception e) {
+					log.exception(e);
+					try {
+						Thread.sleep(MessageConstants.SECOND_IN_MS);
+					} catch (InterruptedException ex) {
+						log.exception(ex);
+					}
+				}
+			}
+		
+			tm = new JtaTransactionManager();
+			Message recievedMsg = null;
+			boolean join = true;
+			
+			while (true) {
+				try {
+					//log.print("--ST");
+					tm.begin();
+					
+					join = statusReceiver.joinTransaction(tm);
+
+					if (!join) {
+						throw new RuntimeException("--ST: join failed");
+					} else {
+						recievedMsg = statusReceiver.receiveMessage(JmsUtils.getQueueWorkerEvent(), 100);
+
+						if (recievedMsg == null) {
+							try {
+								tm.rollback();
+							} catch (Exception ex) {
+								log.exception(ex);
+							}
+						} else {
+							statusDbConnection = new JtaOracleConnection(conFactory);							
+							join = statusDbConnection.joinTransaction(tm);
+							if (!join) {
+								throw new RuntimeException("--ST: join failed");
+							} else {
+								simDispatcher.onWorkerEventMessage(jobAdminXA, statusDbConnection.getConnection(), statusReceiver, recievedMsg);
+								tm.commit();
+
+								yield();
+								continue;
+							}
+						}
+					}
+
+				} catch (Exception ex) { // transaction error
+					log.exception(ex);
+					try {
+						tm.rollback();
+					} catch (Exception ex1) {
+						log.exception(ex1);
+					}
+
+					try {
+						if (statusDbConnection != null && AbstractDBTopLevel.isBadConnection(statusDbConnection.getConnection(), log)) {
+							statusDbConnection.closeOnFailure();
+							statusDbConnection = null;
+						}
+					} catch (java.sql.SQLException sqlex) {
+						log.exception(sqlex);
+					}
+				} finally {
+					try {
+						if (statusDbConnection != null) {
+							statusDbConnection.close();
+							statusDbConnection = null;
+						}
+					} catch (SQLException ex) {
+						log.exception(ex);
+					}
+				}
+				
+				// if there are no messages or exceptions, sleep for a while
+				try {
+					sleep(5 * MessageConstants.SECOND_IN_MS);
+				} catch (InterruptedException ex) {
+					log.exception(ex);
+				}
+			} // while (true)
+		}
+	}
+
+/**
+ * Client constructor comment.
+ */
+public SimulationDispatcherMessaging(SimulationDispatcher simDispatcher0, ConnectionFactory conFactory0, KeyFactory keyFactory0, SessionLog log0) 
+	throws java.sql.SQLException, JMSException, DataAccessException {
+	super(simDispatcher0, log0);
+	simDispatcher = simDispatcher0;
+	conFactory = conFactory0;
+	keyFactory = keyFactory0;
+	jobAdminXA = new AdminDatabaseServerXAImpl(keyFactory, log);
+		
+	reconnect();
+
+	log.print("Starting dispatch thread..");
+	new DispatchThread().start();	
+
+	log.print("Starting status thread..");
+	new StatusThread().start();
+
+	log.print("Starting monitor thread...");
+	new SimulationMonitorThread().start();		
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void do_failed(Connection con, SimulationJobStatus oldJobStatus, String username, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID, SimulationMessage failMsg) throws JMSException, DataAccessException, UpdateSynchronizationException {
+	
+	// if the job is in simJob queue, get it out	
+	
+	// update database
+	SimulationJobStatus newJobStatus = simDispatcher.updateEndStatus(oldJobStatus, jobAdminXA, con, vcSimID, jobIndex, taskID, null, SchedulerStatus.FAILED, failMsg);
+	
+	// tell client
+	StatusMessage message = new StatusMessage(newJobStatus, username, null, null);
+	message.sendToClient(mainJobDispatcher);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void do_start(Connection con, SimulationJobStatus oldJobStatus, SimulationTask simTask, SimulationQueueID queueID) 
+	throws JMSException, DataAccessException, XmlParseException {
+	// send to simulation queue, for waiting jobs, only update the database
+	if (queueID == SimulationQueueID.QUEUE_ID_SIMULATIONJOB) {
+		SimulationTaskMessage taskMsg = new SimulationTaskMessage(simTask);
+		taskMsg.sendSimulationTask(mainJobDispatcher);
+		log.print("do_start(): send job " + simTask.getSimulationJobID() + " to simJob queue");
+	} else {
+		log.print("do_start(): job " + simTask.getSimulationJobID() + " pending");
+	}
+
+	// update database
+	VCSimulationIdentifier vcSimID = new VCSimulationIdentifier(simTask.getSimKey(), simTask.getSimulationJob().getSimulation().getVersion().getOwner());
+	SimulationJobStatus newJobStatus = simDispatcher.updateQueueStatus(oldJobStatus, jobAdminXA, con, vcSimID, simTask.getSimulationJob().getJobIndex(), simTask.getTaskID(), queueID, true);
+
+	// tell client
+	if (!newJobStatus.compareEqual(oldJobStatus)) {
+		StatusMessage message = new StatusMessage(newJobStatus, simTask.getUserName(), null, null);
+		message.sendToClient(mainJobDispatcher);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void do_stop(Connection con, SimulationJobStatus oldJobStatus, String username, VCSimulationIdentifier vcSimID, 
+		int jobIndex, int taskID) throws JMSException, DataAccessException, UpdateSynchronizationException {
+	
+	// if the job is in simJob queue, get it out
+	KeyValue simKey = vcSimID.getSimulationKey();
+	if (oldJobStatus.getSchedulerStatus().isQueued()) {
+		String queueName = JmsUtils.getQueueSimJob();
+		String filter =  MessageConstants.USERNAME_PROPERTY + "='" + username + "' AND " + MessageConstants.SIMKEY_PROPERTY + "=" + simKey
+			+ " AND " + MessageConstants.JOBINDEX_PROPERTY + "=" + jobIndex;		
+		log.print("Remove job from " + queueName + " queue [" + filter + "]");	
+		// get the message out
+		mainJobDispatcher.receiveMessage(queueName, filter, 100);
+	}
+	
+	// update database
+	SimulationJobStatus newJobStatus = simDispatcher.updateEndStatus(oldJobStatus, jobAdminXA, con, vcSimID, jobIndex, taskID, null, 
+			SchedulerStatus.STOPPED, SimulationMessage.MESSAGE_JOB_STOPPED);
+	
+	// tell client
+	if (!newJobStatus.compareEqual(oldJobStatus)) {
+		StatusMessage message = new StatusMessage(newJobStatus, username, null, null);
+		message.sendToClient(mainJobDispatcher);
+	}
+
+	// send stopSimulation to serviceControl topic
+	log.print("send " + MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE + " to " + JmsUtils.getTopicServiceControl() + " topic");
+	Message msg = mainJobDispatcher.createMessage();		
+	msg.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_STOPSIMULATION_VALUE);
+	msg.setLongProperty(MessageConstants.SIMKEY_PROPERTY, Long.parseLong(simKey + ""));
+	msg.setIntProperty(MessageConstants.JOBINDEX_PROPERTY, jobIndex);
+	mainJobDispatcher.publishMessage(JmsUtils.getTopicServiceControl(), msg);	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+public VCSimulationIdentifier processNextRequest() {
+	// A Distributed Transaction for dispatcher sends job to simulation queue directly
+	javax.transaction.TransactionManager tm = new JtaTransactionManager();
+	boolean join = true;
+	JtaDbConnection mainJobDbConnection = null;
+	
+	//log.print("++PNR");
+	
+	try {	
+		tm.begin();
+	
+		join = mainJobDispatcher.joinTransaction(tm);
+		if (!join) {
+			throw new RuntimeException("++PNR: join failed");
+		} else {
+			Message message = mainJobDispatcher.receiveMessage(JmsUtils.getQueueSimReq(), jobSelector, 100);
+			if (message == null) {			
+				try {
+					tm.rollback();
+				} catch (Exception ex) {
+					log.exception(ex);
+				}
+
+				return null;
+			} 
+			
+			if (!(message instanceof ObjectMessage)) {
+				tm.commit(); // ignore the bad messages
+				return null;
+			}
+
+			Object obj = ((ObjectMessage) message).getObject();
+			if (!(obj instanceof RpcRequest)) {
+				tm.commit(); // ignore the bad messages
+				return null;
+			}			
+			RpcRequest request = (RpcRequest)obj;			
+			VCSimulationIdentifier vcSimID = (VCSimulationIdentifier)request.getArguments()[0];
+			User user = request.getUser();
+
+			VCMongoMessage.sendRpcRequestReceived(request);
+			log.print("++PNR: " + request);
+
+			mainJobDbConnection = new JtaOracleConnection(conFactory);	
+			
+			join = mainJobDbConnection.joinTransaction(tm);
+
+			if (!join) {
+				throw new RuntimeException("++PNR: join failed");
+			} else {
+				if (request.getMethodName().equals(METHOD_NAME_STARTSIMULATION)) {
+					startSimulation(mainJobDbConnection.getConnection(), user, vcSimID);
+				} else if (request.getMethodName().equals(METHOD_NAME_STOPSIMULATION)) {
+					stopSimulation(mainJobDbConnection.getConnection(), user, vcSimID);
+				}	
+
+				tm.commit();
+			}
+			
+			return vcSimID;
+		}
+			
+	} catch (Exception e){
+		log.exception(e);
+		
+		try {
+			tm.rollback();
+		} catch (Exception ex) {
+			log.exception(ex);
+		}
+
+		try {
+			if (mainJobDbConnection != null && AbstractDBTopLevel.isBadConnection(mainJobDbConnection.getConnection(), log)) {
+				mainJobDbConnection.closeOnFailure();
+				mainJobDbConnection = null;
+			}
+		} catch (java.sql.SQLException sqlex) {
+			log.exception(sqlex);
+		}
+	} finally {
+		try {
+			if (mainJobDbConnection != null) {
+				mainJobDbConnection.close();
+				mainJobDbConnection = null;
+			}
+		} catch (SQLException ex) {
+			log.exception(ex);
+		}
+	}
+
+	return null;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+protected void reconnect() throws JMSException {
+	// msg filter selector 
+	jobSelector =  MessageConstants.MESSAGE_TYPE_PROPERTY + "='" + MessageConstants.MESSAGE_TYPE_RPC_SERVICE_VALUE  + "' AND " 
+		+ MessageConstants.SERVICE_TYPE_PROPERTY + "='" + simDispatcher.getServiceType() + "'";	
+	
+	super.reconnect();
+	
+	jmsXAConn = jmsConnFactory.createXAConnection();
+	mainJobDispatcher = jmsXAConn.getXASession();		
+	jmsXAConn.startConnection();
+	
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void startSimulation(Connection con, User user, VCSimulationIdentifier vcSimID) throws JMSException, DataAccessException, XmlParseException {
+	if (!user.equals(vcSimID.getOwner())) {
+		log.alert(user + " is not authorized to start simulation " + vcSimID);
+		StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, 0, null, 
+				SchedulerStatus.FAILED, 0, SimulationMessage.MESSAGE_JOB_FAILED_NOTAUTHORIZED, null, null), user.getName(), null, null);
+		message.sendToClient(mainJobDispatcher);
+	} else {
+		KeyValue simKey = vcSimID.getSimulationKey();
+		Simulation simulation = null;
+		FieldDataIdentifierSpec[] fdis = null;
+		try {
+			simulation = simDispatcher.getSimulation(user, simKey);
+		} catch (DataAccessException ex) {
+			log.alert("Bad simulation " + vcSimID);
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+					SchedulerStatus.FAILED, 0, SimulationMessage.jobFailed("Failed to dispatch simuation: " + ex.getMessage()), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+			return;
+		}
+		if (simulation != null) {
+			if (simulation.getScanCount() > Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.maxJobsPerScan))) {
+				log.alert("Too many simulations (" + simulation.getScanCount() + ") for parameter scan." + vcSimID);
+				StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+						SchedulerStatus.FAILED, 0, SimulationMessage.jobFailed("Too many simulations (" + simulation.getScanCount() 
+							+ ") for parameter scan."), null, null), user.getName(), null, null);
+				message.sendToClient(mainJobDispatcher);
+				return;
+			}
+			for (int jobID = 0; jobID < simulation.getScanCount(); jobID++){
+				// right now, we submit a regular task for each scan job...
+				// should get smarter in the future for load balancing, quotas, priorities...
+				SimulationJobStatus[] oldJobStatusArray = jobAdminXA.getSimulationJobStatusArray(con, simKey, jobID);
+				int taskID = -1;
+				SimulationJobStatus oldJobStatus = null;
+				if (oldJobStatusArray!=null){
+					for (SimulationJobStatus simulationJobStatus : oldJobStatusArray){
+						if (simulationJobStatus.getTaskID() > taskID){
+							taskID = simulationJobStatus.getTaskID();
+							oldJobStatus = simulationJobStatus;
+						}
+					}
+				}
+				try {
+					fdis = simDispatcher.getFieldDataIdentifierSpecs(simulation);
+				} catch (DataAccessException ex) {
+					do_failed(con, oldJobStatus, user.getName(), vcSimID, jobID, taskID, SimulationMessage.jobFailed(ex.getMessage()));
+					return;
+				}
+				// if already started by another thread
+				if (oldJobStatus != null && !oldJobStatus.getSchedulerStatus().isDone()) {
+					log.alert("Can't start, simulation[" + vcSimID + "] job [" + jobID + "] is running already");
+				} else {
+					int newTaskID = oldJobStatus == null ? 0 : (oldJobStatus.getTaskID() & MessageConstants.TASKID_USERCOUNTER_MASK) + MessageConstants.TASKID_USERINCREMENT;
+					SimulationTask simTask = new SimulationTask(new SimulationJob(simulation, jobID, fdis), newTaskID);
+					SimulationQueueID queueID = SimulationQueueID.QUEUE_ID_WAITING;
+					// put all the jobs to waiting first, let dispatch thread decide which to dispatch
+					do_start(con, oldJobStatus, simTask, queueID);
+				}
+			}
+		} else {
+			log.alert("Can't start, simulation [" + vcSimID + "] doesn't exist in database");
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+					SchedulerStatus.FAILED, 0, SimulationMessage.jobFailed("Can't start, simulation [" + vcSimID + "] doesn't exist"), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/2/2004 2:16:06 PM)
+ */
+protected void stopService() {	
+	try {
+		if (jmsXAConn != null) {
+			jmsXAConn.close();
+		}
+	} catch (JMSException ex) {
+		log.exception(ex);
+	}
+	super.stopService();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void stopSimulation(java.sql.Connection con, User user, VCSimulationIdentifier vcSimID) throws SQLException, JMSException, DataAccessException {
+	log.print("Stopping simulation");
+	if (!user.equals(vcSimID.getOwner())) {
+		log.alert(user + " is not authorized to stop simulation " + vcSimID);
+		StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, 0, null, 
+				SchedulerStatus.FAILED, 0, SimulationMessage.jobFailed("You are not authorized to stop this simulation!"), null, null), user.getName(), null, null);
+		message.sendToClient(mainJobDispatcher);			
+	} else {
+		KeyValue simKey = vcSimID.getSimulationKey();
+		Simulation simulation = null;
+		try {
+			simulation = simDispatcher.getSimulation(user, simKey);
+		} catch (DataAccessException ex) {
+			log.alert("Bad simulation " + vcSimID);
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+					SchedulerStatus.FAILED, 0, SimulationMessage.jobFailed(ex.getMessage()), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+			return;
+		}
+		if (simulation != null) {
+			for (int jobID = 0; jobID < simulation.getScanCount(); jobID++){
+				SimulationJobStatus[] jobStatusArray = jobAdminXA.getSimulationJobStatusArray(con, vcSimID.getSimulationKey(), jobID);
+
+				if (jobStatusArray != null) {
+					for (SimulationJobStatus simulationJobStatus : jobStatusArray){
+						if (!simulationJobStatus.getSchedulerStatus().isDone()) {
+							do_stop(con, simulationJobStatus, user.getName(), vcSimID, jobID, simulationJobStatus.getTaskID());
+						} else {
+							log.alert("Can't stop, simulation [" + vcSimID + "] job [" + jobID + "] already finished");
+						}			
+					}
+				}  else {
+					log.alert("Can't stop, simulation [" + vcSimID + "] job [" + jobID + "] never ran");
+				}
+			}
+		} else {
+			log.alert("Can't stop, simulation [" + vcSimID + "] doesn't exist in database");
+			StatusMessage message = new StatusMessage(new SimulationJobStatus(VCellServerID.getSystemServerID(), vcSimID, -1, null, 
+					SchedulerStatus.FAILED, 0, SimulationMessage.jobFailed("Can't stop, simulation [" + 
+						vcSimID + "] doesn't exist"), null, null), user.getName(), null, null);
+			message.sendToClient(mainJobDispatcher);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/21/2006 8:59:36 AM)
+ * @return int
+ */
+private static int getHTCPartitionMaximumJobs() {
+	return Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.htcPartitionMaximumJobs));
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/21/2006 9:01:20 AM)
+ * @return cbit.vcell.messaging.db.VCellServerID[]
+ */
+private static VCellServerID[] getHTCPartitionShareServerIDs() {
+	try {
+		String lsfPartitionShareServerIDs = PropertyLoader.getRequiredProperty(PropertyLoader.htcPartitionShareServerIDs);
+		StringTokenizer st = new StringTokenizer(lsfPartitionShareServerIDs, " ,");
+		VCellServerID[] serverIDs = new VCellServerID[st.countTokens() + 1]; // include the current system ServerID
+		serverIDs[0] = VCellServerID.getSystemServerID();
+		
+		int count = 1;
+		while (st.hasMoreTokens()) {			
+			serverIDs[count] = VCellServerID.getServerID(st.nextToken());
+			count ++;			
+		}
+		return serverIDs;
+	} catch (Exception ex) {
+		return null;
+	}
+}
+}
Index: src/cbit/vcell/messaging/QueueListener.java
===================================================================
--- src/cbit/vcell/messaging/QueueListener.java	(revision 0)
+++ src/cbit/vcell/messaging/QueueListener.java	(revision 12031)
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/22/2003 2:26:44 PM)
+ * @author: Fei Gao
+ */
+public interface QueueListener {
+/**
+ * Insert the method's description here.
+ * Creation date: (5/22/2003 2:27:23 PM)
+ */
+void onQueueMessage(javax.jms.Message message) throws JMSException;
+}
Index: src/cbit/vcell/messaging/ControlMessageCollector.java
===================================================================
--- src/cbit/vcell/messaging/ControlMessageCollector.java	(revision 0)
+++ src/cbit/vcell/messaging/ControlMessageCollector.java	(revision 12031)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/21/2003 9:26:26 AM)
+ * @author: Fei Gao
+ */
+public class ControlMessageCollector extends TopicListenerImpl {
+	private ControlTopicListener controlTopicListener = null;
+/**
+ * ControlTopicListener constructor comment.
+ * @param jFactory cbit.vcell.messaging.JmsFactory
+ * @param tname java.lang.String
+ * @param selector java.lang.String
+ * @param slog cbit.vcell.server.SessionLog
+ * @exception javax.naming.NamingException The exception description.
+ * @exception javax.jms.JMSException The exception description.
+ */
+public ControlMessageCollector(ControlTopicListener listener) throws javax.jms.JMSException {
+	super();	
+	//super(MessageConstants.SERVER_CONTROL_TOPIC, slog);
+	this.controlTopicListener = listener;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (5/21/2003 9:26:26 AM)
+ * @param message javax.jms.Message
+ */
+public void onTopicMessage(javax.jms.Message message) throws javax.jms.JMSException {
+	if (controlTopicListener != null) {
+		controlTopicListener.onControlTopicMessage(message);
+	}
+}
+}
Index: src/cbit/vcell/messaging/JmsSession.java
===================================================================
--- src/cbit/vcell/messaging/JmsSession.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsSession.java	(revision 12031)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 1:13:29 PM)
+ * @author: Fei Gao
+ */
+public interface JmsSession {
+	// for queue and topic
+	public void close() throws JMSException;
+	public void commit() throws JMSException;
+	public Message createMessage() throws JMSException;
+	public ObjectMessage createObjectMessage(java.io.Serializable obj) throws JMSException;
+	public Message createTextMessage(String text) throws JMSException;
+	public void rollback() throws JMSException;		
+	void setupOnException();
+	void setupSession() throws JMSException;
+	
+	// for queue
+	//public List<?> browseAllMessages(String queueName, String msgSelector) throws JMSException;
+	public Message receiveMessage(String queueName, long timeout) throws JMSException;
+	public Message receiveMessage(String queueName, String selector, long timeout) throws JMSException;
+	public Message queueRequest(Object source, String queueName, Message message, int deliveryMode, long timeout) throws JMSException;
+	public void sendMessage(String queueName, Message message, int deliveryMode, long timeToLive) throws JMSException;	
+	public void sendMessage(Queue queue, Message message, int deliveryMode, long timeToLive) throws JMSException;	
+	public void setPrefetchCount(int pc) throws JMSException;	
+	public void setPrefetchThreshold(int pt) throws JMSException;
+	public void setupQueueListener(String queueName, String msgSelector, MessageListener listener) throws JMSException;
+	
+	// for topic
+	public void publishMessage(String topicName, Message message) throws JMSException;
+	public void publishMessage(Topic topic, Message message) throws JMSException;
+	public Message topicRequest(Object source, String topicName, Message message, long timeout) throws JMSException;
+	public void setupTopicListener(String topicName, String msgSelector, MessageListener listener) throws JMSException;
+}
Index: src/cbit/vcell/messaging/SonicMQJmsProvider.java
===================================================================
--- src/cbit/vcell/messaging/SonicMQJmsProvider.java	(revision 0)
+++ src/cbit/vcell/messaging/SonicMQJmsProvider.java	(revision 12031)
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/16/2001 9:54:16 AM)
+ * @author: Jim Schaff
+ */
+public class SonicMQJmsProvider extends AbstractJmsProvider {
+	private String BROKER = "localhost:2506";
+	//private final static int DEFAULT_PREFETCH_COUNT = 3;
+	//private final static int DEFAULT_PREFETCH_THRESHOLD = 1;
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/16/2001 5:04:13 PM)
+ * @param host java.lang.String
+ * @param userid java.lang.String
+ * @param password java.lang.String
+ */
+public SonicMQJmsProvider(String url, String userid, String password) {
+	super(userid,password);
+	BROKER = (url.indexOf(":") >= 0) ? url : url + ":2506";
+}
+
+
+public Connection createConnection() throws JMSException {
+	if (connectionFactory == null) {
+		connectionFactory = new progress.message.jclient.QueueConnectionFactory(BROKER,null,fieldUserid,fieldPassword);
+	}
+
+	return connectionFactory.createConnection();
+}
+
+public XAConnection createXAConnection() throws JMSException {
+	if (xaConnectionFactory == null) {
+		xaConnectionFactory = new progress.message.jclient.xa.XAQueueConnectionFactory(BROKER, null,fieldUserid, fieldPassword);		
+	}
+	
+	return xaConnectionFactory.createXAConnection();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/6/2003 11:52:07 AM)
+ * @return int
+ */
+public int getErrorCode(JMSException ex) {
+	if (progress.message.jclient.ErrorCodes.testException(ex, progress.message.jclient.ErrorCodes.ERR_CONNECTION_DROPPED)) {
+		return JmsErrorCode.ERR_CONNECTION_DROPPED;
+	}
+
+	return JmsErrorCode.ERR_UNKNOWN;
+}
+
+public Connection getConnection(XAConnection xaConnection) throws JMSException {
+	return ((progress.message.jclient.xa.XAConnection)xaConnection).getConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/12/2003 10:26:16 AM)
+ * @param pingInterval int
+ */
+public void setPingInterval(int pingInterval, Connection connection) {
+	((progress.message.jclient.Connection)connection).setPingInterval(pingInterval);
+}
+
+
+public void setPrefetchCount(MessageConsumer qr, int pc) throws JMSException {
+	if (qr != null) {
+		((progress.message.jclient.MessageConsumer)qr).setPrefetchCount(pc);
+	}
+}
+
+
+public void setPrefetchThreshold(MessageConsumer qr, int pt) throws javax.jms.JMSException {
+	if (qr != null) {
+		((progress.message.jclient.MessageConsumer)qr).setPrefetchThreshold(pt);
+	}	
+}
+}
Index: src/cbit/vcell/messaging/JmsSessionImp.java
===================================================================
--- src/cbit/vcell/messaging/JmsSessionImp.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsSessionImp.java	(revision 12031)
@@ -0,0 +1,642 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+import javax.jms.Queue;
+
+import org.vcell.util.MessageConstants;
+
+import java.io.Serializable;
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 10:45:11 AM)
+ * @author: Fei Gao
+ */
+public class JmsSessionImp implements JmsSession {
+	/**
+	 * A session is a single-threaded context for producing and consuming messages. 
+	 * You use sessions to create message producers, message consumers, and messages. 
+	 * Sessions serialize the execution of message listeners;
+	 */
+	
+	protected List<MessageProducer> producerList = null;
+	protected List<Destination> destList = null;
+	protected Map<Object, TemporaryQueue> tempQueueMap = null;
+	protected Map<Object, TemporaryTopic> tempTopicMap = null;
+	protected List<MessageConsumer> consumerList = null;
+	protected boolean transactional = false;
+	protected int ackMode = Session.AUTO_ACKNOWLEDGE;
+	protected List<MessageConsumer> listenerList = null;
+
+	protected Session session = null;
+	
+	private JmsConnection vcConn = null;
+	private int prefetchCount = -1; // use default value
+	private int prefetchThreshold = -1; // use default value
+
+/**
+ * JmsSession constructor comment.
+ */
+protected JmsSessionImp() {
+	super();
+}
+
+protected JmsSessionImp(JmsConnection c, boolean transac, int ackMode0) {
+	super();
+	vcConn = c;
+	transactional = transac;
+	ackMode = ackMode0;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/9/2003 11:45:24 AM)
+ * @param queueConn cbit.vcell.messaging.VCellQueueConnection
+ */
+protected final void clearLists() {
+	if (destList != null) {
+		synchronized (destList) {
+			destList.clear();			
+		}
+	}
+	if (tempQueueMap != null) {
+		synchronized (tempQueueMap) {
+			tempQueueMap.clear();			
+		}
+	}	
+	if (tempTopicMap != null) {
+		synchronized (tempTopicMap) {
+			tempTopicMap.clear();			
+		}
+	}	
+	if (producerList != null) {
+		synchronized (producerList) {
+			producerList.clear();			
+		}
+	}
+	if (consumerList != null) {
+		synchronized (consumerList) {
+			consumerList.clear();	
+		}		
+	}
+}
+
+public void close() throws JMSException {
+	synchronized (this) {
+		session.close();	
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 10:55:52 AM)
+ */
+public final void commit() throws JMSException {
+	if (transactional) {
+		synchronized (this) {			
+			session.commit();
+		}
+	} else {
+		throw new JMSException("Commiting back on a non-transactional session");
+	}
+}
+
+public final void rollback() throws JMSException {
+	if (transactional) {
+		synchronized (this) {
+			session.rollback();	
+		}
+	} else {
+		throw new JMSException("Rolling back on a non-transactional session");
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 10:49:27 AM)
+ * @return javax.jms.QueueReceiver
+ * @param queueName java.lang.String
+ */
+protected void closeAConsumer(MessageConsumer mc) throws JMSException {
+	if (consumerList == null) {
+		return;
+	}
+	
+	synchronized(consumerList) {
+		consumerList.remove(mc);	
+	}
+
+	synchronized (mc) {
+		mc.close();
+		mc = null;
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected final MessageConsumer createConsumer(Destination dest, String msgSelector) throws JMSException {
+	synchronized (this) {
+		MessageConsumer qr = session.createConsumer(dest, msgSelector);
+		if (prefetchCount > 0) {
+			vcConn.getJmsProvider().setPrefetchCount(qr, prefetchCount);
+		}
+		if (prefetchThreshold >= 0) {
+			vcConn.getJmsProvider().setPrefetchThreshold(qr, prefetchThreshold);
+		}
+		return qr;
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected final Queue createQueue(String destName) throws JMSException {
+	synchronized (this) {
+		return session.createQueue(destName);		
+	}
+}
+
+protected final Topic createTopic(String topicName) throws JMSException {
+	synchronized (this) {
+		return session.createTopic(topicName);		
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected final MessageProducer createProducer(Destination dest) throws JMSException {	
+	synchronized (this) {
+		return session.createProducer(dest);		
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+protected  final TemporaryQueue createTempQueue() throws JMSException {
+	//checkConnection();
+	
+	synchronized (this) {
+		return session.createTemporaryQueue();	
+	}	
+}
+
+protected  final TemporaryTopic createTempTopic() throws JMSException {
+	//checkConnection();
+	
+	synchronized (this) {
+		return session.createTemporaryTopic();	
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 10:49:27 AM)
+ * @return javax.jms.QueueReceiver
+ * @param queueName java.lang.String
+ */
+protected final MessageConsumer getConsumer(Destination dest, String msgSelector) throws JMSException {
+	if (dest == null) {
+		return null;
+	}
+	if (consumerList == null) {
+		consumerList = Collections.synchronizedList(new ArrayList<MessageConsumer>());
+	}	
+	
+	synchronized(consumerList) {
+		for (MessageConsumer mc : consumerList) {
+			if (mc == null) {
+				continue;
+			}				
+			if (getDestinationName(mc).equals(getDestinationName(dest)) && 
+					(mc.getMessageSelector() == null && msgSelector == null || mc.getMessageSelector() != null && msgSelector != null && mc.getMessageSelector().equals(msgSelector))) {
+				return mc;
+			}
+		}
+
+		MessageConsumer mc = createConsumer(dest, msgSelector);
+		consumerList.add(mc);
+		return mc;		
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param destName java.lang.String
+ */
+protected final Destination getQueue(String destName) throws JMSException {
+	if (destList == null) {
+		destList = Collections.synchronizedList(new ArrayList<Destination>());
+	}
+
+	synchronized(destList) {	
+		for (Destination dest : destList) {
+			if (dest instanceof Queue && destName.equals(getDestinationName(dest))) {
+				return dest;
+			}
+		}
+
+		Destination dest = createQueue(destName);	
+		destList.add(dest);	
+		return dest;		
+	}
+}
+
+protected final Destination getTopic(String destName) throws JMSException {
+	if (destList == null) {
+		destList = Collections.synchronizedList(new ArrayList<Destination>());
+	}
+
+	synchronized(destList) {	
+		for (Destination dest : destList) {
+			if (dest instanceof Topic && destName.equals(getDestinationName(dest))) {
+				return dest;
+			}
+		}
+
+		Destination dest = createTopic(destName);	
+		destList.add(dest);	
+		return dest;		
+	}
+}
+
+private String getDestinationName(Destination dest) throws JMSException {
+	if (dest == null) {
+		return null;
+	}		
+	return (dest instanceof Queue) ? ((Queue)dest).getQueueName() : ((Topic)dest).getTopicName();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:55:24 AM)
+ * @return java.lang.String
+ * @param dest javax.jms.Destination
+ */
+private String getDestinationName(MessageConsumer mc) throws JMSException {
+	if (mc == null) {
+		return null;
+	}		
+	return (mc instanceof QueueReceiver) ? ((QueueReceiver)mc).getQueue().getQueueName() : ((TopicSubscriber)mc).getTopic().getTopicName();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:55:24 AM)
+ * @return java.lang.String
+ * @param dest javax.jms.Destination
+ */
+private String getDestinationName(MessageProducer mp) throws JMSException {
+	if (mp == null) {
+		return null;
+	}
+		
+	return (mp instanceof QueueSender) ? ((QueueSender)mp).getQueue().getQueueName() : ((TopicPublisher)mp).getTopic().getTopicName();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+protected final MessageProducer getProducer(Destination dest) throws JMSException {
+	if (dest == null) {
+		return null;
+	}	
+	if (producerList == null) {
+		producerList = Collections.synchronizedList(new ArrayList<MessageProducer>());
+	}
+		
+	synchronized(producerList) {	
+		for (MessageProducer mp : producerList) {
+			if (mp == null) {
+				continue;
+			}				
+			if (getDestinationName(dest).equals(getDestinationName(mp))) {
+				return mp;
+			}
+		}
+
+		MessageProducer mp =  createProducer(dest);	
+		producerList.add(mp);
+		return mp;			
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+protected final TemporaryQueue getTempQueue(Object source) throws JMSException {
+	if (tempQueueMap == null) {
+		tempQueueMap = Collections.synchronizedMap(new HashMap<Object, TemporaryQueue>());
+	}
+
+	TemporaryQueue tempQueue = null;
+	synchronized(tempQueueMap) {
+		tempQueue = tempQueueMap.get(source);
+		if (tempQueue == null) {
+			tempQueue = createTempQueue();	
+			tempQueueMap.put(source, tempQueue);	
+		}
+	}
+
+	return tempQueue;
+}
+
+protected final TemporaryTopic getTempTopic(Object source) throws JMSException {
+	if (tempTopicMap == null) {
+		tempTopicMap = Collections.synchronizedMap(new HashMap<Object, TemporaryTopic>());
+	}
+
+	TemporaryTopic tempTopic = null;
+	synchronized(tempTopicMap) {
+		tempTopic = tempTopicMap.get(source);
+		if (tempTopic == null) {
+			tempTopic = createTempTopic();	
+			tempTopicMap.put(source, tempTopic);	
+		}
+	}
+
+	return tempTopic;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/21/2003 1:54:28 PM)
+ */
+public synchronized void setupOnException() {	
+	try {
+		clearLists();
+		setupSession();
+			
+		if (listenerList != null) {
+			List<MessageConsumer> tempList = new ArrayList<MessageConsumer>();
+			tempList.addAll(listenerList);
+			listenerList.clear();
+
+			for (MessageConsumer mc : tempList) {
+				setupListener(mc);
+			}
+			
+			tempList.clear();
+		}
+			
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+public final void setupQueueListener(String queueName, String msgSelector, MessageListener listener) throws JMSException {
+	Destination dest = getQueue(queueName);
+	setupListener(dest, msgSelector, listener);
+}
+
+public final void setupTopicListener(String topicName, String msgSelector, MessageListener listener) throws JMSException {
+	Destination	dest = getTopic(topicName);
+	setupListener(dest, msgSelector, listener);
+}
+
+
+public final void setupListener(Destination dest, String msgSelector, MessageListener listener) throws JMSException {
+	MessageConsumer mc = createConsumer(dest, msgSelector);
+	mc.setMessageListener(listener);	
+
+	if (listenerList == null) {
+		listenerList = Collections.synchronizedList(new ArrayList<MessageConsumer>());
+	}
+
+	synchronized (listenerList) {
+		listenerList.add(mc);
+	}		
+	System.out.println("----Set up Listener:[" + dest + ", " + mc.getMessageSelector() + "]");
+}
+
+public final void setupListener(MessageConsumer mc) throws JMSException {
+	Destination dest = null;
+	String destName = null;
+	if (mc instanceof QueueReceiver) {
+		destName = ((QueueReceiver)mc).getQueue().getQueueName();
+		dest = getQueue(destName);
+	} else {
+		destName = ((TopicSubscriber)mc).getTopic().getTopicName();
+		dest = getTopic(destName);
+	}
+	setupListener(dest, mc.getMessageSelector(), mc.getMessageListener());
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/13/2003 9:25:41 AM)
+ * @return javax.jms.Destination
+ */
+public synchronized void setupSession() throws JMSException {
+	session = vcConn.getConnection().createSession(transactional, ackMode);
+}
+
+public final Message createMessage() throws JMSException {
+	//checkConnection();
+
+	synchronized (this) {
+		return session.createMessage();	
+	}	
+}
+
+public final ObjectMessage createObjectMessage(Serializable obj) throws JMSException {
+	//checkConnection();
+
+	synchronized (this) {
+		return session.createObjectMessage(obj);			
+	}	
+}
+
+public final Message createTextMessage(String text) throws JMSException {
+	//checkConnection();
+
+	synchronized (this) {
+		return session.createTextMessage(text);			
+	}	
+}
+
+public final Message receiveMessage(String queueName, long timeout) throws JMSException {
+	return receiveMessage(queueName, null, timeout);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+public final Message receiveMessage(String queueName, String selector, long timeout) throws JMSException {
+	//checkConnection();
+	
+	MessageConsumer qr = getConsumer(getQueue(queueName), selector);
+	synchronized (this) {
+		return qr.receive(timeout);			
+	}	
+}
+
+public void sendMessage(String queueName, javax.jms.Message message, int deliveryMode, long timeToLive) throws javax.jms.JMSException {
+	sendMessage((Queue)getQueue(queueName), message, deliveryMode, Message.DEFAULT_PRIORITY, timeToLive);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+private final void sendMessage(Queue queue, Message message, int deliveryMode, int priority, long timeToLive) throws JMSException {
+	//checkConnection();
+	
+	MessageProducer qs = getProducer(queue);	
+	synchronized (this) {
+		qs.send(message, deliveryMode, priority, timeToLive);			
+	}
+}
+
+
+/**
+ * sendMessage method comment.
+ */
+public void sendMessage(Queue queue, javax.jms.Message message, int deliveryMode, long timeToLive) throws javax.jms.JMSException {
+	sendMessage(queue, message, deliveryMode, Message.DEFAULT_PRIORITY, timeToLive);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (6/16/2003 11:49:46 AM)
+ * @return javax.jms.Message
+ * @param message javax.jms.Message
+ * @exception javax.jms.JMSException The exception description.
+ */
+public final Message queueRequest(Object source, String queueName, Message message, int deliveryMode, long timeout) throws JMSException {
+	//checkConnection();
+
+	Destination tempDest = getTempQueue(source);		
+	message.setJMSReplyTo(tempDest);
+	sendMessage((Queue)getQueue(queueName), message, deliveryMode, Message.DEFAULT_PRIORITY, timeout);
+	
+	String filter = MessageConstants.JMSCORRELATIONID_PROPERTY + "='" + message.getJMSMessageID() + "'";
+	MessageConsumer qr = getConsumer(tempDest, filter);
+	Message reply = null;
+	synchronized (this) {
+		reply = qr.receive(timeout);
+		closeAConsumer(qr);
+	}
+
+	if (reply == null) {
+		System.out.println("Request timed out");
+		deleteTempQueue(source);
+	}
+
+	return reply;
+}
+		
+public final Message topicRequest(Object source, String topicName, Message message, long timeout) throws JMSException {
+	Destination tempDest = getTempTopic(source);		
+	message.setJMSReplyTo(tempDest);
+	MessageConsumer ts = getConsumer(tempDest, null); // since topic messages don't get retained, have to create receiver before publish the messages
+	publishMessage(topicName, message);	 // message id gets set after the message is sent, so can't set filter before publishing the message
+
+	Message reply = null;
+	synchronized (this) {
+		reply = ts.receive(timeout);
+	}
+	if (reply != null) {		
+		String corrID = reply.getJMSCorrelationID();
+		if (corrID != null && corrID.equals(message.getJMSMessageID())) {
+			return reply;
+		}
+	}	
+
+	return null;	
+}
+
+private void deleteTempQueue(Object source) throws JMSException {
+	if (tempQueueMap == null) {
+		return;
+	}
+
+	TemporaryQueue tq = null;
+	synchronized(tempQueueMap) {
+		tq = tempQueueMap.remove(source);	
+	}
+
+	if (tq != null) {
+		tq.delete();
+	}
+}
+
+public final void publishMessage(String topicName, Message message) throws JMSException {
+	publishMessage((Topic)getTopic(topicName), message);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/16/2003 2:20:38 PM)
+ * @return javax.jms.QueueSender
+ * @param queueName java.lang.String
+ */
+public final void publishMessage(Topic topic, Message message) throws JMSException {
+	//checkConnection();
+	
+	MessageProducer tp = getProducer(topic);	
+	synchronized (this) {			
+		tp.send(message);
+	}
+}
+
+public void setPrefetchCount(int pc) throws javax.jms.JMSException {
+	prefetchCount = pc;
+}
+
+
+public void setPrefetchThreshold(int pt) throws javax.jms.JMSException {
+	prefetchThreshold = pt;
+}
+}
Index: src/cbit/vcell/messaging/JmsProvider.java
===================================================================
--- src/cbit/vcell/messaging/JmsProvider.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsProvider.java	(revision 12031)
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/24/2004 10:31:52 AM)
+ * @author: Fei Gao
+ */
+public interface JmsProvider {
+	public final static String SONICMQ = "SonicMQ";
+	//public final static String JBOSSMQ = "JBossMQ";
+
+	public abstract Connection createConnection() throws JMSException;
+	public abstract XAConnection createXAConnection() throws JMSException;
+	public abstract int getErrorCode(JMSException ex);
+	public abstract Connection getConnection(XAConnection xaConnection) throws JMSException;
+	public boolean isBadConnection(JMSException ex);
+	public abstract void setPingInterval(int pingInterval, Connection connection);
+	public abstract void setPrefetchCount(MessageConsumer qr, int pc) throws JMSException;
+	public abstract void setPrefetchThreshold(MessageConsumer qr, int pt) throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsMessageCollector.java
===================================================================
--- src/cbit/vcell/messaging/JmsMessageCollector.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsMessageCollector.java	(revision 12031)
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import cbit.vcell.solver.*;
+import javax.swing.event.EventListenerList;
+
+import org.vcell.util.BigString;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.User;
+
+import cbit.vcell.messaging.admin.ManageConstants;
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.rmi.event.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/9/2003 12:05:19 PM)
+ * @author: Fei Gao
+ */
+public class JmsMessageCollector implements ControlTopicListener, MessageCollector {
+	private EventListenerList listenerList = new EventListenerList();	
+	private User user = null;	
+	private JmsConnection jmsConn = null;
+	private SessionLog log = null;
+
+	private long timeSinceLastMessage = System.currentTimeMillis();
+
+/**
+ * ClientStatusMonitor constructor comment.
+ * @param jmsFactory cbit.vcell.messaging.JmsFactory
+ * @param serviceName java.lang.String
+ * @param queueName java.lang.String
+ */
+public JmsMessageCollector(JmsConnection aTopicConn, User user0, SessionLog log0) throws javax.jms.JMSException {
+	jmsConn = aTopicConn;
+	user = user0;
+	log = log0;
+	
+	reconnect();	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/5/2004 9:28:52 AM)
+ * @param listener cbit.rmi.event.MessageListener
+ */
+public void addMessageListener(MessageListener listener) {
+	listenerList.add(MessageListener.class, listener);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/17/2000 11:43:22 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+protected synchronized void fireExportEvent(ExportEvent event) {
+	fireMessageEvent(event);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/17/2000 11:43:22 AM)
+ * @param event cbit.rmi.event.ExportEvent
+ */
+protected synchronized void fireMessageEvent(MessageEvent event) {
+	// Guaranteed to return a non-null array
+	Object[] listeners = listenerList.getListenerList();
+	// Reset the source to allow proper wiring
+	event.setSource(this);
+	// Process the listeners last to first, notifying
+	// those that are interested in this event
+	for (int i = listeners.length - 2; i >= 0; i -= 2) {
+		if (listeners[i] == MessageListener.class) {
+			((MessageListener) listeners[i + 1]).messageEvent(event);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/13/2000 2:44:30 PM)
+ * @param event cbit.rmi.event.JobProgressEvent
+ */
+protected synchronized void fireSimulationJobStatusEvent(SimulationJobStatusEvent event) {
+	fireMessageEvent(event);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 1:05:20 PM)
+ * @return long
+ */
+public long getTimeSinceLastMessage() {
+	return timeSinceLastMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public void onControlTopicMessage(javax.jms.Message message0) throws javax.jms.JMSException {	
+	
+	if (message0 == null) {
+		return;
+	}
+	if(!(message0 instanceof javax.jms.ObjectMessage)){
+		throw new javax.jms.JMSException(this.getClass().getName()+".onControlTopicMessage: unimplemented message class "+message0.getClass().getName());
+	}
+	javax.jms.ObjectMessage message = (javax.jms.ObjectMessage) message0;
+	
+	setTimeSinceLastMessage(System.currentTimeMillis());
+
+	try{
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		if(msgType == null){
+			throw new javax.jms.JMSException(this.getClass().getName()+".onControlTopicMessage: message type NULL for message "+message);
+		}
+		if (msgType.equals(MessageConstants.MESSAGE_TYPE_SIMSTATUS_VALUE)) {
+					
+			StatusMessage statusMessage = new StatusMessage(message);
+			
+			SimulationJobStatus newJobStatus = statusMessage.getJobStatus();
+			if (newJobStatus == null) {
+				return;
+			}
+			
+			VCSimulationIdentifier vcSimID = newJobStatus.getVCSimulationIdentifier();
+			Double progress = statusMessage.getProgress();
+			Double timePoint = statusMessage.getTimePoint();
+			log.print("---onTopicMessage[" + newJobStatus + ", progress=" + progress + ", timepoint=" + timePoint + "]");
+			
+			fireSimulationJobStatusEvent(new SimulationJobStatusEvent(this, vcSimID.getID(), newJobStatus, progress, timePoint));		
+
+		} else if(msgType.equals(MessageConstants.MESSAGE_TYPE_EXPORT_EVENT_VALUE)) {			
+			ExportEvent event = (ExportEvent)((javax.jms.ObjectMessage)message).getObject();
+			log.print("---onTopicMessage[ExportEvent[" + event.getVCDataIdentifier().getID() + "," + event.getProgress() + "]]");
+			fireExportEvent(event);
+		} else if(msgType.equals(MessageConstants.MESSAGE_TYPE_DATA_EVENT_VALUE)){
+			DataJobEvent event = (DataJobEvent)message.getObject();
+			log.print("---onTopicMessage[DataEvent[vcdid=" + event.getVCDataIdentifier().getID() + "," + event.getProgress() + "]]");
+			fireMessageEvent(event);
+		} else if (msgType.equals(ManageConstants.MESSAGE_TYPE_BROADCASTMESSAGE_VALUE)) {
+			fireMessageEvent(new VCellMessageEvent(this, System.currentTimeMillis() + "", new MessageData((BigString)message.getObject()), VCellMessageEvent.VCELL_MESSAGEEVENT_TYPE_BROADCAST));
+		} else{
+			throw new javax.jms.JMSException(this.getClass().getName()+".onControlTopicMessage: Unimplemented message "+message);
+		}
+	}catch(Exception e){
+		if(e instanceof javax.jms.JMSException){throw (javax.jms.JMSException)e;}
+		
+	}
+}
+
+
+/**
+ * onException method comment.
+ */
+private void reconnect() throws javax.jms.JMSException {	
+	JmsSession statusReceiver = jmsConn.getAutoSession();
+	String clientMessageFilter = (user == null ? "" : MessageConstants.USERNAME_PROPERTY + "='" + user.getName() + "' OR ");
+	clientMessageFilter += MessageConstants.USERNAME_PROPERTY + "='All'";
+			
+	statusReceiver.setupTopicListener(JmsUtils.getTopicClientStatus(), clientMessageFilter, new ControlMessageCollector(this));
+	
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/5/2004 9:28:52 AM)
+ * @param listener cbit.rmi.event.MessageListener
+ */
+public void removeMessageListener(MessageListener listener) {}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 1:05:20 PM)
+ * @param newTimeSinceLastMessage long
+ */
+public void setTimeSinceLastMessage(long newTimeSinceLastMessage) {
+	timeSinceLastMessage = newTimeSinceLastMessage;
+}
+
+public void simulationJobStatusChanged(SimulationJobStatusEvent simJobStatusEvent) {
+	// jms message collector doesn't listen for SimulationJobStatusEvent
+}
+
+public void onWorkerEvent(WorkerEvent event) {	
+	// jms message collector doesn't listen for WorkerEvent
+}
+}
Index: src/cbit/vcell/messaging/JmsXASessionImpl.java
===================================================================
--- src/cbit/vcell/messaging/JmsXASessionImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsXASessionImpl.java	(revision 12031)
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+import javax.transaction.TransactionManager;
+import javax.transaction.xa.XAResource;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 11:36:23 AM)
+ * @author: Fei Gao
+ */
+public class JmsXASessionImpl extends JmsSessionImp implements JmsXASession {
+	private XASession xaSession = null;
+	private JmsXAConnection vcXAConn = null;
+/**
+ * JmsXAQueueSession constructor comment.
+ * @param queueConn javax.jms.QueueConnection
+ * @exception javax.jms.JMSException The exception description.
+ */
+public JmsXASessionImpl(JmsXAConnection xaconn) throws JMSException {
+	super();
+	vcXAConn = xaconn;
+}
+
+@Override
+public void close() throws JMSException {
+	synchronized (this) {
+		session.close();
+		xaSession.close();		
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/28/2003 3:48:42 PM)
+ */
+public boolean joinTransaction(TransactionManager ttmm) throws JMSException {
+	if (vcXAConn.isConnectionDropped()) {
+		return false;
+	}
+
+	try {
+		XAResource xaRes = xaSession.getXAResource();
+		if (xaRes == null || !ttmm.getTransaction().enlistResource(xaRes)) {
+			return false;
+		}
+		return true;		
+	} catch (Exception ex) {
+		throw new JMSException(ex + ":" + ex.getMessage());
+	}
+}
+
+@Override
+public synchronized void setupOnException() {
+	try {
+		clearLists();
+		setupXASession();		
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/8/2003 12:02:14 PM)
+ * @param queueConnl javax.jms.QueueConnection
+ */
+public synchronized void setupXASession() throws JMSException {	
+	xaSession = vcXAConn.getXAConnection().createXASession();
+	session = xaSession.getSession();
+}
+}
Index: src/cbit/vcell/messaging/JmsXAConnectionImp.java
===================================================================
--- src/cbit/vcell/messaging/JmsXAConnectionImp.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsXAConnectionImp.java	(revision 12031)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+public class JmsXAConnectionImp extends AbstractJmsConnectionImpl implements JmsXAConnection {
+	private XAConnection xaConnection = null;	
+
+	public JmsXAConnectionImp(JmsProvider jmsProvider0) throws JMSException {
+		super(jmsProvider0);
+		setupConnection();
+	}
+	
+	public XAConnection getXAConnection() {
+		return xaConnection;
+	}
+	
+	public JmsXASession getXASession() throws JMSException {
+		JmsXASession session = new JmsXASessionImpl(this);
+		session.setupXASession();
+		synchronized (sessionList) {
+			sessionList.add(session);	
+		}
+		
+		return session;	
+	}
+
+	@Override
+	protected void setupConnection() {
+		xaConnection = null;	
+		while (xaConnection == null) {
+			try {		
+				xaConnection = jmsProvider.createXAConnection();
+				connection = jmsProvider.getConnection(xaConnection);
+				jmsProvider.setPingInterval(JMSCONNECTION_PING_INTERVAL, connection);
+				connection.setExceptionListener(this);
+				System.out.println(this + ": Connection established.");
+	 		} catch (Exception jmse) {
+				System.out.println(this + ": Cannot connect to Message Server [" + jmse.getMessage() + "], Pausing " + JMSCONNECTION_RETRY_INTERVAL/1000 + " seconds before retry.");
+				try {
+					Thread.sleep(JMSCONNECTION_RETRY_INTERVAL);
+				} catch (InterruptedException ie) {
+					ie.printStackTrace(System.out);
+				}
+			}
+		}		
+	}
+}
Index: src/cbit/vcell/messaging/admin/Performance.java
===================================================================
--- src/cbit/vcell/messaging/admin/Performance.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/Performance.java	(revision 12031)
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/20/2003 8:28:58 AM)
+ * @author: Fei Gao
+ */
+public abstract class Performance implements java.io.Serializable {
+	protected long freeJavaMemoryBytes = -1;
+	protected long totalJavaMemoryBytes = -1;
+	protected long maxJavaMemoryBytes = -1;	
+/**
+ * PerformanceStatus constructor comment.
+ */
+public Performance() {
+	super();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/28/01 7:04:11 PM)
+ * @return long
+ */
+public long getAvaillableJavaMemoryBytes() {
+
+	double JVM_MEMORY_TRUST_FACTOR = 0.8;
+	long currentJVMUsage = getTotalJavaMemoryBytes()-getFreeJavaMemoryBytes();
+	
+	return (long)(JVM_MEMORY_TRUST_FACTOR*(getMaxJavaMemoryBytes() - currentJVMUsage));
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getFreeJavaMemoryBytes() {
+	return freeJavaMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getMaxJavaMemoryBytes() {
+	return maxJavaMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getTotalJavaMemoryBytes() {
+	return totalJavaMemoryBytes;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/20/2003 8:47:17 AM)
+ * @return java.lang.String[]
+ */
+public abstract Object[] toObjects();
+}
Index: src/cbit/vcell/messaging/admin/LogDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/LogDialog.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/LogDialog.java	(revision 12031)
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/3/2003 11:21:06 AM)
+ * @author: Fei Gao
+ */
+public class LogDialog extends javax.swing.JDialog {
+	IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private javax.swing.JPanel ivjJPanel1 = null;
+	private javax.swing.JScrollPane ivjJScrollPane1 = null;
+	private javax.swing.JTextArea ivjLogTextArea = null;
+	private javax.swing.JButton ivjCloseButton = null;
+
+class IvjEventHandler implements java.awt.event.ActionListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			if (e.getSource() == LogDialog.this.getCloseButton()) 
+				connEtoC1(e);
+		};
+	};
+/**
+ * LogDialog constructor comment.
+ */
+public LogDialog() {
+	super();
+	initialize();
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ */
+public LogDialog(java.awt.Dialog owner) {
+	super(owner);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ */
+public LogDialog(java.awt.Dialog owner, String title) {
+	super(owner, title);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Dialog owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Dialog owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public LogDialog(java.awt.Frame owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ */
+public LogDialog(java.awt.Frame owner, String title) {
+	super(owner, title);
+	initialize();
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Frame owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * LogDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param modal boolean
+ */
+public LogDialog(java.awt.Frame owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * Comment
+ */
+public void closeButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	dispose();
+	return;
+}
+/**
+ * connEtoC1:  (JButton1.action.actionPerformed(java.awt.event.ActionEvent) --> LogDialog.jButton1_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.closeButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * Return the JButton1 property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getCloseButton() {
+	if (ivjCloseButton == null) {
+		try {
+			ivjCloseButton = new javax.swing.JButton();
+			ivjCloseButton.setName("CloseButton");
+			ivjCloseButton.setText("Close");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjCloseButton;
+}
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(new java.awt.BorderLayout());
+			getJDialogContentPane().add(getJScrollPane1(), "Center");
+			getJDialogContentPane().add(getJPanel1(), "South");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+/**
+ * Return the JPanel1 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel1() {
+	if (ivjJPanel1 == null) {
+		try {
+			ivjJPanel1 = new javax.swing.JPanel();
+			ivjJPanel1.setName("JPanel1");
+			ivjJPanel1.setLayout(new java.awt.FlowLayout());
+			getJPanel1().add(getCloseButton(), getCloseButton().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel1;
+}
+/**
+ * Return the JScrollPane1 property value.
+ * @return javax.swing.JScrollPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JScrollPane getJScrollPane1() {
+	if (ivjJScrollPane1 == null) {
+		try {
+			ivjJScrollPane1 = new javax.swing.JScrollPane();
+			ivjJScrollPane1.setName("JScrollPane1");
+			ivjJScrollPane1.setVerticalScrollBarPolicy(javax.swing.JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
+			ivjJScrollPane1.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
+			getJScrollPane1().setViewportView(getLogTextArea());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJScrollPane1;
+}
+/**
+ * Return the LogTextArea property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getLogTextArea() {
+	if (ivjLogTextArea == null) {
+		try {
+			ivjLogTextArea = new javax.swing.JTextArea();
+			ivjLogTextArea.setName("LogTextArea");
+			ivjLogTextArea.setLineWrap(true);
+			ivjLogTextArea.setWrapStyleWord(true);
+			ivjLogTextArea.setBounds(0, 0, 160, 120);
+			ivjLogTextArea.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjLogTextArea;
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getCloseButton().addActionListener(ivjEventHandler);
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("LogDialog");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+		setSize(679, 484);
+		setModal(true);
+		setTitle("");
+		setContentPane(getJDialogContentPane());
+		initConnections();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		LogDialog aLogDialog;
+		aLogDialog = new LogDialog();
+		aLogDialog.setModal(true);
+		aLogDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aLogDialog.show();
+		java.awt.Insets insets = aLogDialog.getInsets();
+		aLogDialog.setSize(aLogDialog.getWidth() + insets.left + insets.right, aLogDialog.getHeight() + insets.top + insets.bottom);
+		aLogDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 11:25:33 AM)
+ * @param log java.lang.String
+ */
+public void setFile(java.io.File file) throws java.io.IOException {
+	java.io.FileReader reader = new java.io.FileReader(file);
+	char[] content = new char[10000];
+	String out = "";
+	getLogTextArea().setText(null);	
+	while (true) {
+		int n = reader.read(content, 0, 10000);
+		if (n == -1) {
+			break;
+		} else if (n > 0) {
+			out = new String(content, 0, n);
+			getLogTextArea().append(out);
+		}
+	}
+	reader.close();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 11:25:33 AM)
+ * @param log java.lang.String
+ */
+public void setText(String log) {
+	getLogTextArea().setText(null);
+	getLogTextArea().setText(log);
+}
+/**
+ * 
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private static void getBuilderData() {
+/*V1.1
+**start of data**
+	D0CB838494G88G88GFBFBB0B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135DA8FD09C67F5A7AEF16CD453520912E057CED5D9C9F0CA92F52C0CE9C6E9D557131058CE8815DACDC76EE8EAB5210EDB4B93B555F418E46F0EC3202088594441E35CE0590E11F41C0E3F02630F6E6010C0A0B8F1E7A0AE92DA3865B8D8EECFFB0BC0C8083E777D59DB0EBB30DC0919476E773E7F6F7D5E7B5E777604325FEE321A4CE502E0328A6C6F0CC990822785A17527C33BB82F697D5CE2417077
+	B650B1614F2F9440339B6A1E7EA03738D4783B5BC5D09E05F28614FF836F2F895937DDF6F8C9B2CFB95439BE7D39485A739C1E64739CA26517EDA5707C9550D56061B373FD1C7FD0F5B96327B2BEA71399F8D55866F8F585636D07B6C540F381792BE8FB991EF4811FF4B631F623FF12A19C781EEABE026398466474AC6B3B1FBDAB057FB6251F4039FA2BCBD81FAAA8DF85424DDB041F3CF7921E2D5E19E07B44F8C833DF1F10E459BEABC523E2B0948E5A4540ECA86CF476A9C1CFC81415A0086FA40E77196AA2
+	52DF907640D81B886F51F61CE3845EA3C08F1C647C40D9646F0377FC2032D3FCDFED6F3732F50F5CFCD258D9BBDBF0B4493EEC2768FE7C27E27B8ACCBFEFFE036860C290E51D86F55B003201DE82AA3165965B005EA43A3FB4097BF40FEB1D4A6C2C92F6C7A29DF2C03D2884A4995E1DCE28E13CC1E9C2D18302C075FB295A16E0BDEB916DB7F6477D28CCB26A382EB3873FA66CF962F366C389E432A7632659E32332983545E4C267CECFBA77AD5BCAAC2E1CFBD8B04E1D5A3F4BE2CDB0772616DD16B4B64E9643
+	5CBBED286BE3C457CF433B096103725FA47C726A981F6272B10299ACD7C15D06EA0E0D11DF71357495EC96CAEBBE1FD08E69CFEDB06F2F26EBA832472FE5B719335E9E3F16FFA1FC0FBDFEAD53E779DA7CD01785C471658B211DD61C4EADEE827282CD81BDG3485A86BB44758431327BFA2463C222AF54C056400248A342FAF78BABC2585CD95FB42D1CD8CCFC8C3229A9247E5A9AA30B623C11441780AFEA2417E844CF1DE8ACB2A280514B00CAE4ECA1A24C6E91B6960B1EC23CA24569F826B5644D9F4F434DE
+	8D3E86CFD90CEA9FC48222A645DA507A45A06A643AB884A342G70CE6512B20D725A8D7B5F8FA4B8389C7E130C57AB29E1C9C657214C4CC57C3893416BC0B9FF1D780EB2F837B9380CEF4DA0EFA314B375F1ECD32F9A467104A6F07922FA035B58EF4E22AF5E616018790F910E994F112F8A36DD1FCD08193256DD165D8E66A79D713673B6999357C54B0F370F5C219DFF945A416625F3BCF5CF663030A7156F0BB2313F1A5C62FAA0FF8D17F1F02A12E236C30CCA9C2583AAGCC8A44A4CE57794FC4B6A6FD5DF9
+	24AC57F0D9C54E0EA410775DA2BA4703E48E4BBD1A034A64F2884FA1693A9456BCD2C48A8760A54A6A82A1449A3353C9C56FB3CD7891306BCEB024284E0F045076C4CDD3C363F31A6413B48D0E55D87D8219ABBAB79E093984BE57F2887D2FB28FF62D37CF8D21CDCCA86130C41423F7E17577931B14E4E996965D294C05B54A5FB00D3A1A11EEB01F10B6DDA820CD4BF368DFE8AC30D57CA56EC18D4D024A51C589F9B5E82F5F56E399240D404318E6BBBCF3EA386D4D3F43ED6F5D4547059DE391F32233A37D0B
+	FFECF654D26CFBEAE336C75774091944EB7F94718D0C9F25EBCD9B46F98DE1894379BBE19CA3GE3AFG2555F21CDBE42C673E04813CD311E5AAC6DD3E7B65D25407F4EDCE82970CCE2BD71759FF492F46558DB179517ADF48A8BF59606F266AD0FEEF38F81C17816B59813437164A30320E4A006EE9709A2E1144E25362F5F1419E1D872CB81D9774BD52584BE1C7F9607E375571986B85876E7BA5A897546796D754F33D7C70880F31B64EE488D787F6DA12450E7575F4ADA3750658F1F85EC265BA2B601C69D0
+	17D14FE53AB8EB74736EE8D4198811A3064963C45828B74A33078F43F3B224C6359EB02C85AE3B7AB02E974FA046E6E7F2072B0449E7BB4CFBGE8C383721FE8ABB32C5D86BCBF508210050C77382B966D0EA857CE9FDEC91DD454D9A9D00552350B731A1D58385DCD2A3B707D84574511571DE8E7329215BA66B4CD890F39638669CBBECA4B09A19ED3EDFE4D4556786C57B68B2D4BD74C09E25C870ECE19F7B6D03967B74464BF7243674DB29075FD8DF60C6B3A9B9347F0230C9FE14FD4F852F8E73886E5185E
+	989F8709041F51989F877D1B0347C1D9D0D7F1061F5179917483A9D0FE84E89B5033C0AF8115B4F1CCEC8F57896B44C0BDE188CD42226CDB6174F8AC22D8281FE2656B0A157BA9011F815D2E7878362AE925CCBCF1E55AEFE8D53F7F09ABCF457523D8B86ACBE2179499D0C77D643FBA0DFEB285465A82148D3487085A6E0BEDC5EC5C83CD5CC6174E99EDF47B51A573AF1358282D192E2F2FB906113413BFE3B67AA5957D4C86284BG5A813487C8F0028E01DCCE2EA3A152361E0E880C7DCAA7703A411FF5461F
+	B7501F46F2FD4497DD0531D301A86FB142CB0772D61DF75C013C1DD04E53F9B304178F6552969EC3DC2E41F32AC2AF87C99965486E5B0E3B9DAB61DCABF1D2D4F33767B046ABD48756EB49E30C12EB09E30CD72FA50EB14A2F9D23FC9843F83360751557560EC12A2EA50AC15EA26B7E6E6BC74958512894A52070081A486AFE2C7DDAC8900B744365036D99E298D7B1EB5325A91DB53ACD7D74C4F9E21B720AF01AD0FBCA2F0937A70C4BDBC1DF5E96EECFEF35F0FB1AEA61E7614FDB51FFED02F296D00E0E2517
+	5B925D0B73187E73DBD67BD5EAD7559A1EB5252DB0BF1087E89468D6AB37273F3E362E4F6BDAD84367EDD513E361C9B5B1963E2562B99ED5665489A9DE5FCF2B65FADD4CF2FBB4E996D5C35BBCC77AEB229A14D661E5A769CF6B1275FFDECD06A92A7789BBE2A3A0CD0AF3B240950E5101883B1E229FE8C5BD5D36F35DBD524A73D1FFB90F3EEF92AE30B01CAFA2CD8819ED58761BF60E05F2A85B007A00E4208DED7C4CEFF6609833CAC01475B93C8E1E27BA20373B0F3453C21A0CB8ADE847BC5F311B023E767E
+	DE0C73D85485825008DD05A59EFF5DDF4B575D5D4EB1672BC74C25C0B99DE8EBBB475C7116F84CE53747F03627FDB56668592C3661F87B5B634F6CDB04AF1C0DBF338B5A7819DD8AF55AD96EE38B5BF12D3B211C2773E65A39FFBEF016E338C1CB0E41D6ADB186BB34447E28DBDB5B9FF935353173D99267985C02FDB8948EA873208A4C0CE8D13B2747679D70F50D8D740FF576418BBDC7B74D9B7324CD076FCBF887A198F2D1395B58B37F578F1B28EE7792CCE21FG54BD62C21EFC5A98EB629A3F8B7F6C08DB
+	D27F05957538B788A38D75B9AB6AF12D83D6E33D59E12C379A7A53FDBD739E0F8F721F59AA485FC8CD1A7F5D4776D364264F34FD8F197CDFDE34D039869DF816EA6A1CC4477D417F9A65D57A30ECB6A5995745466BF34767CB7E30B69E5FA96E9826B73A13617BBB44DEB25C9447D61D1FCB785B8DFC0A6F5F5773FBC08E5455F7F0ACB7937F1F8E65CC1D77C4AB47F7CE87374305B65CFB3EDE3E0F1471AEC64B075B121D7958677FFB7E53B95EC9BA475D48E7D09D3F55CEF48C46CA7D5A9BCB286932CE144BFD
+	6D65EB7427E75D371748F793E83F5049FD43504DD3709C92275949569588E90ACA0EB6E0FAD585BC3BF603F2490D186D377374474B017F6DA10E77ED5F7C0A10F53FA7E9BC1C5EC9F513451ED5AFBCE40A6D45310C7B4D033A82CFEEF195108B488FA4FB785E9E3D09EB44939A166F56B4F1E20A5CD67941BD941266E3ECBC10D8CE182C140E71424D77124987C638GFEECE0FC9A8ED13F08F7F80A514D359C37A99E0E5B376BB9EE37F8B8AE1FA33CECA86F55F93B896F00075EF95977067A35E2D66C7BD1641F
+	1D249D3321B567305E81CE1363772FEAB1AFA50BB714B98D6E30DDA81771967D6C073283E884C86E227B5FCB5AFC2F35F20DB91F6D227B22F37C4D886229B3F637E7384B3EEC7433152786927A590317974DD56718BFBC97730742EC2505626119A56469679BB58906155CA5747521F0C80368A234C882A29FB48C87A92E3EE8427A94987791209DC0BB01724E6936F87BB845EB822CF6850292BFA379FC4D4B494FF557727A5F9CFA16B1DFB32E0018E6F1FC4E9FD8C6CCE8CA04B0A94F3F0CF2D4C341A90DB6E5
+	7C8F17912F32B4C958D427B935DC27856761FE8A64819AB9CF6F4C1173582629FEADFFC5F5196347F36102EFC2D5E49903349A968B12EFA574B6D1436E67079B0C63E53139764173A090BDE7BE5D423F1316F66796F7F77338342EF6C58EG73BECE67B9D9196FE3D0E531E1EE8B0F9FD23AF9ECA8107BC89614F300723A793DFF61F79CEF19DF5AAC78FB936766767A174CC28F45593BBDB13CADCCBFEF26FB7DF1AB2E51874B1892388F1D17785895FF7118D071DB1779D80231112E32B1B798460E79505B9614
+	598E285B83A4DC48ADAE873281F9AEF0CC6E942A0464678395904125AA06F8CE772B2664385CE6DA9F175FB2115CA26049FFA3426EA4CF1950F7A81313D1C9477FF7CC25BA2FA76AD522A134B82A6B0335DC57A33017348BDC57BF323F39DA579D8A660C1936292EDDF5DC575997382E43F5A4BE6F85B981B9FA392E27E70C7AC099A70B613AFB59777F5E157A20EB8BF63DA5A43CB747ACC047E2C7832E8F6DA033172FEF3411FC0B07F2BED0D99FBFBF52D65DD356A35A6F8B9F335FBF5EF1BF9A9FEA4416ECFD
+	B4BEB4697CA542EFB270290E8BDB390EBDD0175147F319472D086B120B9097G3900C6009600B6DE64389EB5BB04F56E75FEA55287A0168D579CE6B70515704C00311E864A83927AC15EC0B6A09750C8BF1F67B173DA76C30197EFBF1F32A4371FBF322CEFBF1F37A4766B0FDAD67B754D1644FEBD43E2746BD42FBFDFF59F78E8F8A8297BF87D3A6E389F7B8DG31D32DBF9EC7BFA17C147EF89CE9F59CC79B20EEFFBF47510F8EA10E7C83F0E681ED844A845A8134FB006B372520EE8D7D8EAA8A49AEE0228174
+	EBD4B55B6379863E4717E0CC413BB2C6AB73A63BE36590DB2F724667907E09701B3C71B90471C61EC368063ACCAF778D0B683A58DA7E4070DE52FAAF3EDB2F546FFB77F48E2A1FD3566436D4EBCD1C7BE832A64EFD34DB574E351E33A67F5EFB513A7AFB6F0305495716D6383E1DBFD418584E7F2CF0351DEFA9CCEC67DFA9B45AB965FD1D0D2B6A89DF4A7FC6A11EEBB4FE3FA80645A0598B7B3DC0DD8CBB2F985E976B6EBD0EBEF3CF6720FBFF79D0F2DD7D6C507A3A7A4521443A32962D56556122443AAAADB2
+	6A0A5EAB2F10B82074D2EEF17DA5FE57FC12703A219C51F9479A797DB37592377DFFE844FC42D63D3C1714337572D4635D14AB4E33DAF71F382BF3445FBFE98CBD57003F913DAE29DAE8C214E9B055A12ADEC58ECD5CE03964B4A233EA203CCBBC177C7D86BC872694B534087EFBD5CF1E07FE1174F583D58D72BBEBD5E3659A6B1C9AB45ED9B3A3F8E76DD302FE4010DB15C401FE87BFF64618BB3C85FDB0AF30E5102F6F4B8D784D4518CBB5C40A76212EC1FFCF273BEF4C57B9B8505757619E9CF3778D3BFF6F
+	5367B5B5562D513FFBE030674301FEFF2291E87F2EC60C49BBA57C664BE3586716D644573198D65F9B0DDF3B4F705FB9E48DF23CDDBC03E7617E4198CE8AFC3177F2F83779D6E208E2BBC046F2C11D5F47717EDAB37226201C2A732EB4F39BC857F98FBA11379D4AB9BEAE571BE4BC994E6BE1D50CD09D9FEC625F9A76696DCEB623BF1C07B6BE6D06AC8D131F16B2CCF4B66B5FA620BD7D4EB1572C5F0B7DF007GEA829A81DA7073B1B7B9695DA724217B20E3BD6964F711F43D5D51E61E6F25658F75B2156F1F
+	B6736F9819FE1E6B7E7B6678DC77AB02B1D7EDF546673ACDAB6A4FB863F35DEE1331BE640C4FF5737E4C1E1C481B9465E86CFB7F26E6E30C378F56FA503FF6BE0B79B8323F128FF20BF18D14371D705E855EAB82472378BB0CFBD8CEE6B8945026A83FE261C80C5FAD212F05B27DAD7968E57475197FAED8012789D612CDE2F76F934B463C7A41CFCEA47D8ED1B4C477D1B1943B6B5138B2FD8C57B982FCED084711F9D75077A44BB37AE6C5D9868FB4638E87B06758F1C313E2F14723E3B8FE1437E1156C5C9FAB
+	E6B64E7B7C9FD0CB878820C4CB798C91GG0CAFGGD0CB818294G94G88G88GFBFBB0B620C4CB798C91GG0CAFGG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGGC691GGGG
+**end of data**/
+}
+}
Index: src/cbit/vcell/messaging/admin/ServerManageConsole.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServerManageConsole.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServerManageConsole.java	(revision 12031)
@@ -0,0 +1,3123 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_ISSERVICEALIVE_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_PROPERTY;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE;
+import static cbit.vcell.messaging.admin.ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE;
+
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.FlowLayout;
+import java.awt.Font;
+import java.awt.GridLayout;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.ItemEvent;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.sql.SQLException;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.Vector;
+
+import javax.jms.JMSException;
+import javax.jms.Message;
+import javax.jms.ObjectMessage;
+import javax.swing.BorderFactory;
+import javax.swing.Box;
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JMenuItem;
+import javax.swing.JPanel;
+import javax.swing.JPopupMenu;
+import javax.swing.JProgressBar;
+import javax.swing.JScrollPane;
+import javax.swing.JSplitPane;
+import javax.swing.JTabbedPane;
+import javax.swing.JTable;
+import javax.swing.JTextArea;
+import javax.swing.JTextField;
+import javax.swing.ListSelectionModel;
+import javax.swing.SwingUtilities;
+import javax.swing.Timer;
+
+import org.vcell.util.BigString;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.UserCancelException;
+import org.vcell.util.document.KeyValue;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+import org.vcell.util.gui.DateRenderer;
+import org.vcell.util.gui.DialogUtils;
+import org.vcell.util.gui.sorttable.JSortTable;
+
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.vcell.messaging.ControlMessageCollector;
+import cbit.vcell.messaging.ControlTopicListener;
+import cbit.vcell.messaging.JmsClientMessaging;
+import cbit.vcell.messaging.JmsConnection;
+import cbit.vcell.messaging.JmsConnectionFactory;
+import cbit.vcell.messaging.JmsConnectionFactoryImpl;
+import cbit.vcell.messaging.JmsSession;
+import cbit.vcell.messaging.JmsUtils;
+import cbit.vcell.messaging.db.SimulationJobTable;
+import cbit.vcell.messaging.server.RpcDbServerProxy;
+import cbit.vcell.messaging.server.RpcSimServerProxy;
+import cbit.vcell.modeldb.AdminDBTopLevel;
+import cbit.vcell.modeldb.DbDriver;
+import cbit.vcell.modeldb.UserTable;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.server.ServerInfo;
+import cbit.vcell.server.UserLoginInfo;
+import cbit.vcell.server.VCellBootstrap;
+import cbit.vcell.server.VCellServer;
+import cbit.vcell.solver.Simulation;
+import cbit.vcell.xml.XmlHelper;
+
+import com.mongodb.BasicDBObject;
+import com.mongodb.DB;
+import com.mongodb.DBCollection;
+import com.mongodb.DBCursor;
+import com.mongodb.DBObject;
+import com.mongodb.Mongo;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/15/2003 4:19:19 PM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class ServerManageConsole extends JFrame implements ControlTopicListener {
+	private VCellBootstrap vcellBootstrap = null;
+	private VCellServer vcellServer = null;
+	private SessionLog log = null;
+	private List<SimpleUserConnection> userList = Collections.synchronizedList(new LinkedList<SimpleUserConnection>());
+	private List<ServiceStatus> serviceConfigList = Collections.synchronizedList(new LinkedList<ServiceStatus>());
+	private List<ServiceInstanceStatus> serviceInstanceStatusList = Collections.synchronizedList(new LinkedList<ServiceInstanceStatus>());
+	private JPanel ivjJFrameContentPane = null;
+	private IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private JmsConnection jmsConn = null;
+	private JmsSession topicSession = null;
+	private JmsConnectionFactory jmsConnFactory = null;
+	private JTabbedPane ivjTabbedPane = null;
+	private JPanel ivjServiceStatusPage = null;
+	private JPanel ivjConfigPage = null;
+	private JSortTable ivjConfigTable = null;
+	private JSortTable ivjServiceStatusTable = null;
+	private JButton ivjStartServiceButton = null;
+	private JButton ivjStopServiceButton = null;
+	private JPanel ivjQueryInputPanel = null;
+	private JSplitPane ivjJSplitPane1 = null;
+	private JPanel ivjQueryPage = null;
+	private JSortTable ivjQueryResultTable = null;
+	private JPanel ivjQueryStatusPanel = null;
+	private JCheckBox ivjQueryCompletedCheck = null;
+	private JCheckBox ivjQueryFailedCheck = null;
+	private JCheckBox ivjQueryRunningCheck = null;
+	private JCheckBox ivjQueryWaitingCheck = null;
+	private JTextField ivjQueryHostField = null;
+	private JTextField ivjQuerySimField = null;
+	private JTextField ivjQueryUserField = null;
+	private JCheckBox ivjQueryAllStatusCheck = null;
+	private JButton ivjQueryGoButton = null;
+	private JButton ivjQueryResetButton = null;
+	private AdminDBTopLevel adminDbTop = null;
+	private List<JCheckBox> statusChecks = new ArrayList<JCheckBox>();
+	private JCheckBox ivjQueryStartDateCheck = null;
+	private JCheckBox ivjQuerySubmitDateCheck = null;
+	private JLabel ivjNumResultsLabel = null;
+	private JLabel ivjNumConfigsLabel = null;
+	private JCheckBox ivjQueryEndDateCheck = null;
+	private DatePanel ivjQueryEndFromDate = null;
+	private DatePanel ivjQueryEndToDate = null;
+	private DatePanel ivjQueryStartFromDate = null;
+	private DatePanel ivjQuerySubmitToDate = null;
+	private DatePanel ivjQueryStartToDate = null;
+	private JPanel ivjQuerySubmitDatePanel = null;
+	private JPanel ivjQueryEndDatePanel = null;
+	private JPanel ivjQueryStartDatePanel = null;
+	private DatePanel ivjQuerySubmitFromDate = null;
+	private JLabel ivjNumServiceLabel = null;
+	private JCheckBox ivjQueryQueuedCheck = null;
+	private JCheckBox ivjQueryStoppedCheck = null;
+	private JCheckBox ivjQueryDispatchedCheck = null;
+	private HashMap<User, RpcDbServerProxy> dbProxyHash = null;
+	private HashMap<User, RpcSimServerProxy> simProxyHash = null;
+	private JButton ivjExitButton = null;
+	private JButton ivjRefreshButton = null;
+	private JButton ivjRemoveFromListButton = null;
+	private JButton ivjSubmitSelectedButton = null;
+	private JTextField ivjQueryServerIDField = null;
+	private JPanel ivjUserConnectionPage = null;
+	private org.vcell.util.gui.sorttable.JSortTable ivjUserConnectionTable = null;
+	private JLabel ivjNumUserConnectionLabel = null;
+	private JPanel ivjBroadcastPanel = null;
+	private JButton ivjMessageResetButton = null;
+	private JButton ivjSendMessageButton = null;
+	private JTextArea ivjBroadcastMessageTextArea = null;
+	private JTextField ivjBroadcastMessageToTextField = null;
+	private JButton ivjNewServiceButton = null;
+	private JButton ivjDeleteServiceButton = null;
+	private JButton ivjModifyServiceButton = null;
+	private JButton ivjRefreshServerManagerButton = null;
+	private JProgressBar ivjProgressBar = null;
+	private JLabel ivjNumSelectedLabel = null;
+	
+	private JButton ivjStopSelectedButton = null;
+	
+	private class IvjEventHandler implements java.awt.event.ActionListener, java.awt.event.ItemListener, java.awt.event.MouseListener, javax.swing.event.ChangeListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getStopServiceButton()) 
+					stopServiceButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getStartServiceButton()) 
+					startServiceButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryGoButton()) 
+					queryGoButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryResetButton()) 
+					queryResetButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getRefreshButton()) 
+					refreshButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getExitButton()) 
+					exitButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getRemoveFromListButton()) 
+					removeFromListButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getSubmitSelectedButton()) 
+					submitSelectedButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getSendMessageButton()) 
+					sendMessageButton_ActionPerformed(e);
+				if (e.getSource() == ServerManageConsole.this.getMessageResetButton()) 
+					messageResetButton_ActionEvents();
+				if (e.getSource() == getNewServiceButton()) {
+					newService();
+				}
+				if (e.getSource() == getDeleteServiceButton()) {
+					deleteService();
+				}
+				if (e.getSource() == getModifyServiceButton()) {
+					modifyService();
+				}
+				if (e.getSource() == getRefreshServerManagerButton()) {
+					refreshServerManager();
+				}
+				if (e.getSource() == ServerManageConsole.this.getStopSelectedButton()) { 
+					stopSelectedButton_ActionPerformed(e);
+				}
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};		
+		public void itemStateChanged(java.awt.event.ItemEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getQueryWaitingCheck())
+					queryWaitingCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryQueuedCheck()) 
+					queryQueuedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryFailedCheck()) 
+					queryFailedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryRunningCheck()) 
+					queryRunningCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryStoppedCheck()) 
+					queryStoppedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryCompletedCheck()) 
+					queryCompletedCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryAllStatusCheck()) 
+					queryAllStatusCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQuerySubmitDateCheck()) 
+					querySubmitDateCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryStartDateCheck()) 
+					queryStartDateCheck_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryEndDateCheck()) 
+					queryEndDateSubmit_ItemStateChanged(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryDispatchedCheck()) 
+					queryDispatchedCheck_ItemStateChanged(e);
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};
+		public void mouseClicked(java.awt.event.MouseEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getServiceStatusTable()) 
+					serviceStatusTable_MouseClicked(e);
+				if (e.getSource() == ServerManageConsole.this.getQueryResultTable()) 
+					queryResultTable_MouseClicked(e);
+				if (e.getSource() == ServerManageConsole.this.getConfigTable()) {
+					configTable_mouseClicked(e);
+				}
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};
+		public void mouseEntered(java.awt.event.MouseEvent e) {};
+		public void mouseExited(java.awt.event.MouseEvent e) {};
+		public void mousePressed(java.awt.event.MouseEvent e) {};
+		public void mouseReleased(java.awt.event.MouseEvent e) {};
+		public void stateChanged(javax.swing.event.ChangeEvent e) {
+			try {
+				if (e.getSource() == ServerManageConsole.this.getTabbedPane())
+					tabbedPane_ChangeEvents();
+			} catch (java.lang.Throwable ivjExc) {
+				handleException(ivjExc);
+			}
+		};
+	};
+
+/**
+ * ServerManageConsole constructor comment.
+ */
+public ServerManageConsole() throws java.io.IOException, java.io.FileNotFoundException, org.jdom.JDOMException, javax.jms.JMSException {
+	super();
+	initialize();
+}
+
+void newService() {	
+	AddNewServiceDialog dialog = new AddNewServiceDialog(this);
+	dialog.setLocationRelativeTo(this);
+	dialog.setVisible(true);
+	
+	if (dialog.isAction()) {
+		ServiceSpec ss = dialog.getServiceSpec();
+		ServiceStatus config = new ServiceStatus(ss, null, ManageConstants.SERVICE_STATUS_NOTRUNNING, "newly created",	null);
+		try {
+			config = adminDbTop.insertServiceStatus(config, true);
+		} catch (Exception e) {
+			e.printStackTrace();
+			javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}
+		refresh();
+	}	
+}
+
+private void deleteService() {
+	int srow = getConfigTable().getSelectedRow();
+	ServiceStatus config = (ServiceStatus)((ServiceStatusTableModel)getConfigTable().getModel()).getValueAt(srow);
+	int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are going to delete " + config + ". Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+	if (n == javax.swing.JOptionPane.NO_OPTION) {
+		return;
+	}
+	
+	try {
+		adminDbTop.deleteServiceStatus(config, true);
+		stopService(config.getServiceSpec());
+	} catch (Exception e) {
+		e.printStackTrace();
+		javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+	refresh();
+}
+
+private void modifyService() {	
+	int srow = getConfigTable().getSelectedRow();
+	ServiceStatus oldConfig = (ServiceStatus)((ServiceStatusTableModel)getConfigTable().getModel()).getValueAt(srow);
+	ServiceSpec oldSpec = oldConfig.getServiceSpec();
+	
+	AddNewServiceDialog dialog = new AddNewServiceDialog(this);
+	dialog.modifyService(oldSpec);
+	dialog.setLocationRelativeTo(this);
+	dialog.setVisible(true);
+	
+	if (dialog.isAction()) {
+		ServiceSpec newSpec = dialog.getServiceSpec();
+		if (newSpec.getMemoryMB() == oldSpec.getMemoryMB() && newSpec.getStartupType() == oldSpec.getStartupType()) {
+			return;
+		}
+		ServiceStatus newConfig = new ServiceStatus(newSpec, null, ManageConstants.SERVICE_STATUS_NOTRUNNING, "newly modified",	null);
+		try {
+			newConfig = adminDbTop.modifyServiceStatus(oldConfig, newConfig, true);
+			stopService(newConfig.getServiceSpec());						
+		} catch (Exception e) {
+			e.printStackTrace();
+			javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}
+		refresh();
+	}
+	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (7/6/2004 1:36:54 PM)
+ */
+private void clearServiceStatusTab() {
+	getServiceStatusTable().clearSelection();
+	getStopServiceButton().setEnabled(false);
+	getStartServiceButton().setEnabled(false);
+}
+
+/**
+ * Comment
+ */
+public void exitButton_ActionPerformed(ActionEvent actionEvent) {
+	dispose();
+	System.exit(0);
+	return;
+}
+
+/**
+ * Return the BroadcastMessageTextArea property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getBroadcastMessageTextArea() {
+	if (ivjBroadcastMessageTextArea == null) {
+		try {
+			ivjBroadcastMessageTextArea = new javax.swing.JTextArea();
+			ivjBroadcastMessageTextArea.setName("BroadcastMessageTextArea");
+			ivjBroadcastMessageTextArea.setLineWrap(true);
+			ivjBroadcastMessageTextArea.setWrapStyleWord(true);
+			ivjBroadcastMessageTextArea.setText("");
+			ivjBroadcastMessageTextArea.setFont(new java.awt.Font("Arial", 1, 12));
+			ivjBroadcastMessageTextArea.setBounds(0, 0, 376, 68);
+			ivjBroadcastMessageTextArea.setMargin(new java.awt.Insets(5, 5, 5, 5));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjBroadcastMessageTextArea;
+}
+
+/**
+ * Return the BroadcastMessageToTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getBroadcastMessageToTextField() {
+	if (ivjBroadcastMessageToTextField == null) {
+		try {
+			ivjBroadcastMessageToTextField = new javax.swing.JTextField();
+			ivjBroadcastMessageToTextField.setName("BroadcastMessageToTextField");
+			ivjBroadcastMessageToTextField.setFont(new java.awt.Font("Arial", 1, 12));
+			ivjBroadcastMessageToTextField.setText("All");
+			ivjBroadcastMessageToTextField.setMargin(new java.awt.Insets(0, 10, 0, 0));
+			ivjBroadcastMessageToTextField.setColumns(59);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjBroadcastMessageToTextField;
+}
+
+/**
+ * Return the BroadcastPanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getBroadcastPanel() {
+	if (ivjBroadcastPanel == null) {
+		try {
+			ivjBroadcastPanel = new javax.swing.JPanel();
+			ivjBroadcastPanel.setName("BroadcastPanel");
+			ivjBroadcastPanel.setPreferredSize(new java.awt.Dimension(495, 500));
+			//ivjBroadcastPanel.setLayout(new java.awt.BorderLayout());
+			ivjBroadcastPanel.setLayout(new javax.swing.BoxLayout(ivjBroadcastPanel, javax.swing.BoxLayout.Y_AXIS));
+			
+			JPanel panel14 = new javax.swing.JPanel();
+			panel14.setPreferredSize(new java.awt.Dimension(610, 270));
+			panel14.setLayout(new java.awt.FlowLayout());			
+			JScrollPane scrollPane5 = new javax.swing.JScrollPane();
+			scrollPane5.setPreferredSize(new java.awt.Dimension(700, 250));
+			scrollPane5.setViewportView(getBroadcastMessageTextArea());			
+			panel14.add(scrollPane5);			
+			getBroadcastPanel().add(panel14);
+			
+			JPanel panel13 = new javax.swing.JPanel();
+			panel13.setLayout(new java.awt.BorderLayout());
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new java.awt.FlowLayout());
+			panel.add(getSendMessageButton(), getSendMessageButton().getName());
+			panel.add(getMessageResetButton(), getMessageResetButton().getName());			
+			panel13.add(panel, "Center");			
+			
+			panel = new javax.swing.JPanel();
+			panel.setLayout(new java.awt.FlowLayout());			
+			panel.add(new javax.swing.JLabel("To:      "));
+			panel.add(getBroadcastMessageToTextField(), getBroadcastMessageToTextField().getName());			
+			panel13.add(panel, "North");			
+			getBroadcastPanel().add(panel13);
+			
+			
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjBroadcastPanel;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:44:01 PM)
+ * @return cbit.vcell.messaging.server.RpcDbServerProxy
+ */
+private RpcDbServerProxy getDbProxy(User user) throws JMSException, DataAccessException, java.rmi.RemoteException {
+	if (dbProxyHash == null) {
+		dbProxyHash = new HashMap<User, RpcDbServerProxy>();
+	}
+
+	RpcDbServerProxy dbProxy = (RpcDbServerProxy)dbProxyHash.get(user);
+
+	if (dbProxy == null) {
+		JmsClientMessaging jmsClientMessaging = new JmsClientMessaging(jmsConn, log, null);		
+		dbProxy = new RpcDbServerProxy(user, jmsClientMessaging, log);
+		dbProxyHash.put(user, dbProxy);
+	}
+	
+	return dbProxy;
+}
+
+
+/**
+ * Return the ExitButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getExitButton() {
+	if (ivjExitButton == null) {
+		try {
+			ivjExitButton = new javax.swing.JButton();
+			ivjExitButton.setText("Exit");
+			ivjExitButton.setForeground(java.awt.Color.red);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjExitButton;
+}
+
+/**
+ * Return the JFrameContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJFrameContentPane() {
+	if (ivjJFrameContentPane == null) {
+		try {
+			ivjJFrameContentPane = new javax.swing.JPanel();
+			ivjJFrameContentPane.setName("JFrameContentPane");
+			ivjJFrameContentPane.setLayout(new java.awt.BorderLayout());
+			getJFrameContentPane().add(getTabbedPane(), "Center");
+			
+			JPanel panel = new javax.swing.JPanel();			
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));
+			panel.add(getExitButton());
+			panel.add(getRefreshButton(), getRefreshButton().getName());
+			
+			final JLabel timeLabel = new JLabel("      ");
+			timeLabel.setFont(new Font(timeLabel.getFont().getName(), Font.BOLD, timeLabel.getFont().getSize()));
+			Box box = Box.createHorizontalBox();
+			box.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createRaisedBevelBorder(), BorderFactory.createLoweredBevelBorder()));
+			box.add(panel);
+			box.add(Box.createHorizontalGlue());	
+			box.add(timeLabel);
+			box.add(Box.createHorizontalGlue());
+			box.add(getProgressBar());
+			final DateFormat df =  new SimpleDateFormat("HH:mm:ss    EEEE    MMM dd, yyyy");
+	        new Timer(1000,new ActionListener()
+	        {
+	            public void actionPerformed(ActionEvent e)
+	            {
+	                timeLabel.setText(df.format(new Date()));
+	            }
+	        }).start();			
+			
+			getJFrameContentPane().add(box, "North");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJFrameContentPane;
+}
+
+private JProgressBar getProgressBar() {
+	if (ivjProgressBar == null) {
+		ivjProgressBar = new JProgressBar();
+	}
+	return ivjProgressBar;
+}
+/**
+ * Return the JPanel3 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryInputPanel() {
+	if (ivjQueryInputPanel == null) {
+		try {
+			ivjQueryInputPanel = new javax.swing.JPanel();
+			ivjQueryInputPanel.setName("JPanel3");
+			ivjQueryInputPanel.setLayout(new javax.swing.BoxLayout(ivjQueryInputPanel, javax.swing.BoxLayout.Y_AXIS));
+			ivjQueryInputPanel.setBounds(0, 0, 160, 120);
+			
+			JPanel panel4 = new javax.swing.JPanel();
+			panel4.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label3 = new javax.swing.JLabel("Simulation ID");
+			label3.setMaximumSize(new java.awt.Dimension(70, 14));
+			label3.setPreferredSize(new java.awt.Dimension(70, 14));
+			label3.setMinimumSize(new java.awt.Dimension(70, 14));
+			label3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);			
+			panel4.add(label3);
+			panel4.add(getQuerySimField(), getQuerySimField().getName());			
+			ivjQueryInputPanel.add(panel4);
+			
+			
+			JPanel panel9 = new javax.swing.JPanel();
+			panel9.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new javax.swing.JLabel("Compute Host");
+			label.setMaximumSize(new java.awt.Dimension(70, 14));
+			label.setPreferredSize(new java.awt.Dimension(70, 14));
+			label.setMinimumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);			
+			panel9.add(label);
+			panel9.add(getQueryHostField(), getQueryHostField().getName());			
+			ivjQueryInputPanel.add(panel9);
+			
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));
+			
+			label = new javax.swing.JLabel("Server ID");
+			label.setMaximumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
+			label.setPreferredSize(new java.awt.Dimension(70, 14));
+			label.setMinimumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			
+			panel.add(label);
+			panel.add(getQueryServerIDField(), getQueryServerIDField().getName());
+			
+			ivjQueryInputPanel.add(panel);
+			
+			panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			label = new javax.swing.JLabel("User ID");
+			label.setMaximumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
+			label.setPreferredSize(new java.awt.Dimension(70, 14));
+			label.setMinimumSize(new java.awt.Dimension(70, 14));
+			label.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);			
+			panel.add(label);
+			panel.add(getQueryUserField(), getQueryUserField().getName());			
+			ivjQueryInputPanel.add(panel);
+			
+			ivjQueryInputPanel.add(getQueryStatusPanel(), getQueryStatusPanel().getName());
+			ivjQueryInputPanel.add(getQuerySubmitDatePanel(), getQuerySubmitDatePanel().getName());
+			ivjQueryInputPanel.add(getQueryStartDatePanel(), getQueryStartDatePanel().getName());
+			ivjQueryInputPanel.add(getQueryEndDatePanel(), getQueryEndDatePanel().getName());
+			
+			JPanel panel15 = new javax.swing.JPanel();
+			panel15.setLayout(new java.awt.FlowLayout());
+			panel15.add(getQueryGoButton(), getQueryGoButton().getName());
+			panel15.add(getQueryResetButton(), getQueryResetButton().getName());		
+			ivjQueryInputPanel.add(panel15);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryInputPanel;
+}
+
+/**
+ * Return the JSplitPane1 property value.
+ * @return javax.swing.JSplitPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JSplitPane getJSplitPane1() {
+	if (ivjJSplitPane1 == null) {
+		try {
+			ivjJSplitPane1 = new javax.swing.JSplitPane(javax.swing.JSplitPane.HORIZONTAL_SPLIT);
+			ivjJSplitPane1.setName("JSplitPane1");
+			ivjJSplitPane1.setDividerSize(2);
+			ivjJSplitPane1.setLastDividerLocation(1);
+			ivjJSplitPane1.setComponentOrientation(java.awt.ComponentOrientation.UNKNOWN);
+			ivjJSplitPane1.setDividerLocation(220);
+
+			JScrollPane scrollPane3 = new javax.swing.JScrollPane();
+			scrollPane3.setViewportView(getQueryInputPanel());			
+			getJSplitPane1().add(scrollPane3, "left");
+						
+			JPanel panel7 = new javax.swing.JPanel();
+			panel7.setLayout(new java.awt.BorderLayout());			
+			JPanel panel8 = new javax.swing.JPanel();
+			panel8.setLayout(new java.awt.BorderLayout());
+			JPanel textPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
+			textPanel.add(getNumResultsLabel());
+			textPanel.add(new JLabel(" returned    "));
+			textPanel.add(getNumSelectedLabel());
+			textPanel.add(new JLabel(" selected "));
+			panel8.add(textPanel, "West");
+			JPanel panel = new JPanel();
+			panel.add(getStopSelectedButton());
+			panel.add(getSubmitSelectedButton());
+			panel.add(getRemoveFromListButton());
+			panel8.add(panel, "East");			
+			panel7.add(panel8, "North");			
+			panel7.add(getQueryResultTable().getEnclosingScrollPane(), "Center");			
+			getJSplitPane1().add(panel7, "right");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJSplitPane1;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/5/2006 10:07:25 AM)
+ * @return java.lang.String
+ */
+private String getLocalVCellBootstrapUrl() {
+	String rmiHost = "ms3.vcell.uchc.edu";
+	int rmiPort = PropertyLoader.getIntProperty(PropertyLoader.rmiPortRegistry, 1099);
+	return "//" + rmiHost + ":" + rmiPort + "/VCellBootstrapServer";
+}
+
+
+/**
+ * Return the MessageResetButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getMessageResetButton() {
+	if (ivjMessageResetButton == null) {
+		try {
+			ivjMessageResetButton = new javax.swing.JButton();
+			ivjMessageResetButton.setName("MessageResetButton");
+			ivjMessageResetButton.setText("Reset");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjMessageResetButton;
+}
+
+
+/**
+ * Return the NumResultsLabel property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumResultsLabel() {
+	if (ivjNumResultsLabel == null) {
+		try {
+			ivjNumResultsLabel = new javax.swing.JLabel();
+			ivjNumResultsLabel.setText("0");
+			ivjNumResultsLabel.setForeground(java.awt.Color.red);
+			ivjNumResultsLabel.setFont(new Font(ivjNumResultsLabel.getFont().getName(), Font.BOLD, ivjNumResultsLabel.getFont().getSize()));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumResultsLabel;
+}
+
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumSelectedLabel() {
+	if (ivjNumSelectedLabel == null) {
+		try {
+			ivjNumSelectedLabel = new javax.swing.JLabel();
+			ivjNumSelectedLabel.setText("0");
+			ivjNumSelectedLabel.setForeground(java.awt.Color.blue);
+			ivjNumSelectedLabel.setFont(new Font(ivjNumSelectedLabel.getFont().getName(), Font.BOLD, ivjNumSelectedLabel.getFont().getSize()));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumSelectedLabel;
+}
+
+/**
+ * Return the NumServiceLabel property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumServiceLabel() {
+	if (ivjNumServiceLabel == null) {
+		try {
+			ivjNumServiceLabel = new javax.swing.JLabel();
+			ivjNumServiceLabel.setName("NumServiceLabel");
+			ivjNumServiceLabel.setPreferredSize(new java.awt.Dimension(100, 14));
+			ivjNumServiceLabel.setText("0");
+			ivjNumServiceLabel.setMaximumSize(new java.awt.Dimension(100, 14));
+			ivjNumServiceLabel.setForeground(java.awt.Color.red);
+			ivjNumServiceLabel.setMinimumSize(new java.awt.Dimension(100, 14));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumServiceLabel;
+}
+
+/**
+ * Return the TotalUserConnectionLabel property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getNumUserConnectionLabel() {
+	if (ivjNumUserConnectionLabel == null) {
+		try {
+			ivjNumUserConnectionLabel = new javax.swing.JLabel();
+			ivjNumUserConnectionLabel.setName("NumUserConnectionLabel");
+			ivjNumUserConnectionLabel.setText("0");
+			ivjNumUserConnectionLabel.setForeground(java.awt.Color.red);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumUserConnectionLabel;
+}
+
+/**
+ * Return the QueryAllCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryAllStatusCheck() {
+	if (ivjQueryAllStatusCheck == null) {
+		try {
+			ivjQueryAllStatusCheck = new javax.swing.JCheckBox();
+			ivjQueryAllStatusCheck.setName("QueryAllStatusCheck");
+			ivjQueryAllStatusCheck.setSelected(true);
+			ivjQueryAllStatusCheck.setFont(new java.awt.Font("Arial", 1, 12));
+			ivjQueryAllStatusCheck.setText("All");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryAllStatusCheck;
+}
+
+/**
+ * Return the JCheckBox7 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryCompletedCheck() {
+	if (ivjQueryCompletedCheck == null) {
+		try {
+			ivjQueryCompletedCheck = new javax.swing.JCheckBox();
+			ivjQueryCompletedCheck.setName("QueryCompletedCheck");
+			ivjQueryCompletedCheck.setSelected(true);
+			ivjQueryCompletedCheck.setText("Completed");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryCompletedCheck;
+}
+
+/**
+ * Return the QueryDispatchedCheckBox property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryDispatchedCheck() {
+	if (ivjQueryDispatchedCheck == null) {
+		try {
+			ivjQueryDispatchedCheck = new javax.swing.JCheckBox();
+			ivjQueryDispatchedCheck.setName("QueryDispatchedCheck");
+			ivjQueryDispatchedCheck.setSelected(true);
+			ivjQueryDispatchedCheck.setText("Dispatched");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryDispatchedCheck;
+}
+
+/**
+ * Return the QueryEndDateCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryEndDateCheck() {
+	if (ivjQueryEndDateCheck == null) {
+		try {
+			ivjQueryEndDateCheck = new javax.swing.JCheckBox();
+			ivjQueryEndDateCheck.setName("QueryEndDateCheck");
+			ivjQueryEndDateCheck.setText("End Between");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndDateCheck;
+}
+
+/**
+ * Return the QueryEndDatePanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryEndDatePanel() {
+	if (ivjQueryEndDatePanel == null) {
+		try {
+			ivjQueryEndDatePanel = new javax.swing.JPanel();
+			ivjQueryEndDatePanel.setName("QueryEndDatePanel");
+			ivjQueryEndDatePanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder()));
+			ivjQueryEndDatePanel.setLayout(new GridLayout(3, 0));
+			getQueryEndDatePanel().add(getQueryEndDateCheck(), getQueryEndDateCheck().getName());
+			getQueryEndDatePanel().add(getQueryEndFromDate(), getQueryEndFromDate().getName());
+			getQueryEndDatePanel().add(getQueryEndToDate(), getQueryEndToDate().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndDatePanel;
+}
+
+/**
+ * Return the DatePanel3 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryEndFromDate() {
+	if (ivjQueryEndFromDate == null) {
+		try {
+			ivjQueryEndFromDate = new DatePanel();
+			ivjQueryEndFromDate.setName("QueryEndFromDate");
+			ivjQueryEndFromDate.setLayout(new FlowLayout());
+			ivjQueryEndFromDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndFromDate;
+}
+
+/**
+ * Return the QueryEndToDate property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryEndToDate() {
+	if (ivjQueryEndToDate == null) {
+		try {
+			ivjQueryEndToDate = new DatePanel();
+			ivjQueryEndToDate.setName("QueryEndToDate");
+			ivjQueryEndToDate.setLayout(new FlowLayout());
+			ivjQueryEndToDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryEndToDate;
+}
+
+/**
+ * Return the JCheckBox4 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryFailedCheck() {
+	if (ivjQueryFailedCheck == null) {
+		try {
+			ivjQueryFailedCheck = new javax.swing.JCheckBox();
+			ivjQueryFailedCheck.setName("QueryFailedCheck");
+			ivjQueryFailedCheck.setSelected(true);
+			ivjQueryFailedCheck.setText("Failed");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryFailedCheck;
+}
+
+/**
+ * Return the JButton1 property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getQueryGoButton() {
+	if (ivjQueryGoButton == null) {
+		try {
+			ivjQueryGoButton = new javax.swing.JButton();
+			ivjQueryGoButton.setName("QueryGoButton");
+			ivjQueryGoButton.setText("Go!");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryGoButton;
+}
+
+/**
+ * Return the JTextField2 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQueryHostField() {
+	if (ivjQueryHostField == null) {
+		try {
+			ivjQueryHostField = new javax.swing.JTextField();
+			ivjQueryHostField.setName("QueryHostField");
+			ivjQueryHostField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryHostField;
+}
+
+/**
+ * Return the QueryPage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryPage() {
+	if (ivjQueryPage == null) {
+		try {
+			ivjQueryPage = new javax.swing.JPanel();
+			ivjQueryPage.setName("QueryPage");
+			ivjQueryPage.setLayout(new java.awt.BorderLayout());
+			getQueryPage().add(getJSplitPane1(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryPage;
+}
+
+
+/**
+ * Return the JCheckBox2 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryQueuedCheck() {
+	if (ivjQueryQueuedCheck == null) {
+		try {
+			ivjQueryQueuedCheck = new javax.swing.JCheckBox();
+			ivjQueryQueuedCheck.setName("QueryQueuedCheck");
+			ivjQueryQueuedCheck.setSelected(true);
+			ivjQueryQueuedCheck.setText("Queued");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryQueuedCheck;
+}
+
+/**
+ * Return the JButton2 property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getQueryResetButton() {
+	if (ivjQueryResetButton == null) {
+		try {
+			ivjQueryResetButton = new javax.swing.JButton();
+			ivjQueryResetButton.setName("QueryResetButton");
+			ivjQueryResetButton.setText("Reset");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryResetButton;
+}
+
+/**
+ * Return the QueryResultTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private JSortTable getQueryResultTable() {
+	if (ivjQueryResultTable == null) {
+		try {
+			ivjQueryResultTable = new JSortTable();
+			ivjQueryResultTable.setName("QueryResultTable");
+			ivjQueryResultTable.setModel(new JobTableModel());
+			ivjQueryResultTable.disableUneditableForeground();
+			
+			final JPopupMenu popup = new JPopupMenu();
+			JMenuItem viewMongoMenuItem = new JMenuItem("View Mongo Log Info...");
+		    popup.add(viewMongoMenuItem);
+
+		    viewMongoMenuItem.addActionListener(new ActionListener() {
+				public void actionPerformed(ActionEvent e) {
+					try {
+						Number simID = (Number)ivjQueryResultTable.getModel().getValueAt(ivjQueryResultTable.getSelectedRow(), JobTableModel.columnIndex_SimID);
+						String userid = (String)ivjQueryResultTable.getModel().getValueAt(ivjQueryResultTable.getSelectedRow(), JobTableModel.columnIndex_UserID);
+						System.out.println("----- user="+userid+" simID="+simID);
+						String mongoDbHost = PropertyLoader.getRequiredProperty(PropertyLoader.mongodbHost);
+						int mongoDbPort = Integer.parseInt(PropertyLoader.getRequiredProperty(PropertyLoader.mongodbPort)); // default 27017
+						Mongo m = new Mongo(mongoDbHost,mongoDbPort);
+						String mongoDbDatabaseName = PropertyLoader.getRequiredProperty(PropertyLoader.mongodbDatabase);
+						DB db = m.getDB(mongoDbDatabaseName);
+						String mongoDbLoggingCollectionName = PropertyLoader.getRequiredProperty(PropertyLoader.mongodbLoggingCollection);
+						DBCollection dbCollection = db.getCollection(mongoDbLoggingCollectionName);
+
+						BasicDBObject query = new BasicDBObject();
+
+						query.put(VCMongoMessage.MongoMessage_simId, simID.intValue()+"");
+
+						DBCursor cur = dbCollection.find(query);
+						TreeMap<String, Integer> mapKeyToColumnIndex = new TreeMap<String, Integer>();
+						Vector<DBObject> dbObjV = new Vector<DBObject>();
+						while(cur.hasNext()) {
+							DBObject dbObject = cur.next();
+							dbObjV.add(dbObject);
+						    Set<String> keys = dbObject.keySet();
+						    Iterator<String> iter = keys.iterator();
+						    while(iter.hasNext()){
+						    	String key = iter.next();
+						    	Integer columnIndex = mapKeyToColumnIndex.get(key);
+						    	if(columnIndex == null){
+						    		columnIndex = mapKeyToColumnIndex.size();
+						    		mapKeyToColumnIndex.put(key, columnIndex);
+						    	}
+						    }
+						}
+						int msgTimeColumnIndex = -1;
+						if(mapKeyToColumnIndex.size()>0){
+							String[] columnNames = new String[mapKeyToColumnIndex.size()];
+							Iterator<String> keyIter = mapKeyToColumnIndex.keySet().iterator();
+							while(keyIter.hasNext()){
+								String key = keyIter.next();
+								int columnIndex = mapKeyToColumnIndex.get(key);
+								columnNames[columnIndex] = key;
+								if(key.equals(VCMongoMessage.MongoMessage_msgTime)){
+									msgTimeColumnIndex = columnIndex;
+								}
+							}
+//							//Ask which columns to view
+//							Object[][] colrowdata = new Object[columnNames.length][1];
+//							for (int i = 0; i < colrowdata.length; i++) {
+//								colrowdata[i][0] = columnNames[i];
+//							}
+//							int[] showcolArr =
+//									DialogUtils.showComponentOKCancelTableList(ServerManageConsole.this, "Select Columns to View...", new String[] {"Column Names"}, colrowdata, ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
+							
+							Object[][] rowData = new Object[dbObjV.size()][columnNames.length];
+							for (int i = 0; i < rowData.length; i++) {
+								DBObject dbObj = dbObjV.get(i);
+								Set<String> keys = dbObj.keySet();
+							    Iterator<String> iter = keys.iterator();
+							    while(iter.hasNext()){
+							    	String key = iter.next();
+							    	rowData[i][mapKeyToColumnIndex.get(key)] = dbObj.get(key);
+							    }
+							}
+							//sort by msgtime
+							final int msgTimeColumnIndexFinal = msgTimeColumnIndex;
+							if(msgTimeColumnIndex != -1){
+								Arrays.sort(rowData, new Comparator<Object[]>() {
+									public int compare(Object[] o1, Object[] o2) {
+										Long o1Long = (Long)o1[msgTimeColumnIndexFinal];
+										Long o2Long = (Long)o2[msgTimeColumnIndexFinal];
+										int result = (int)(o2Long-o1Long);
+										return result;
+									}
+								});
+							}
+							DialogUtils.showComponentOptionsTableList(ServerManageConsole.this, "Mongo Log Info ("+rowData.length+") "+userid+" "+simID, columnNames, rowData, ListSelectionModel.SINGLE_SELECTION,null,null,null,null,false);
+						}else{
+							DialogUtils.showWarningDialog(ServerManageConsole.this, "No Mongo Log Info found for simID="+simID.intValue());
+						}
+					}  catch (UserCancelException uce) {
+						//ignore
+					}catch (Exception e1) {
+						e1.printStackTrace();
+					}
+
+				}
+			});
+
+			ivjQueryResultTable.addMouseListener( new MouseAdapter() {
+			    public void mouseReleased(MouseEvent e) 
+			    { 
+			        if (e.isPopupTrigger()) 
+			        { 
+			            JTable source = (JTable)e.getSource(); 
+			            int row = source.rowAtPoint( e.getPoint() ); 
+			            int column = source.columnAtPoint( e.getPoint() ); 
+			 
+			            if (! source.isRowSelected(row)) 
+			                source.changeSelection(row, column, false, false); 
+			 
+			            popup.show(e.getComponent(), e.getX(), e.getY()); 
+			        } 
+			    } 
+			}); 
+
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryResultTable;
+}
+
+
+/**
+ * Return the JCheckBox1 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryRunningCheck() {
+	if (ivjQueryRunningCheck == null) {
+		try {
+			ivjQueryRunningCheck = new javax.swing.JCheckBox();
+			ivjQueryRunningCheck.setName("QueryRunningCheck");
+			ivjQueryRunningCheck.setSelected(true);
+			ivjQueryRunningCheck.setText("Running");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryRunningCheck;
+}
+
+/**
+ * Return the QueryServerIDField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQueryServerIDField() {
+	if (ivjQueryServerIDField == null) {
+		try {
+			ivjQueryServerIDField = new javax.swing.JTextField();
+			ivjQueryServerIDField.setName("QueryServerIDField");
+			ivjQueryServerIDField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryServerIDField;
+}
+
+
+/**
+ * Return the JTextField1 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQuerySimField() {
+	if (ivjQuerySimField == null) {
+		try {
+			ivjQuerySimField = new javax.swing.JTextField();
+			ivjQuerySimField.setName("QuerySimField");
+			ivjQuerySimField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySimField;
+}
+
+/**
+ * Return the QueryStartDateCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryStartDateCheck() {
+	if (ivjQueryStartDateCheck == null) {
+		try {
+			ivjQueryStartDateCheck = new javax.swing.JCheckBox();
+			ivjQueryStartDateCheck.setName("QueryStartDateCheck");
+			ivjQueryStartDateCheck.setText("Start Between");
+			ivjQueryStartDateCheck.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartDateCheck;
+}
+
+/**
+ * Return the QueryStartDatePanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryStartDatePanel() {
+	if (ivjQueryStartDatePanel == null) {
+		try {
+			ivjQueryStartDatePanel = new javax.swing.JPanel();
+			ivjQueryStartDatePanel.setName("QueryStartDatePanel");
+			ivjQueryStartDatePanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder()));
+			ivjQueryStartDatePanel.setLayout(new java.awt.GridLayout(3, 0));
+			getQueryStartDatePanel().add(getQueryStartDateCheck(), getQueryStartDateCheck().getName());
+			getQueryStartDatePanel().add(getQueryStartFromDate(), getQueryStartFromDate().getName());
+			getQueryStartDatePanel().add(getQueryStartToDate(), getQueryStartToDate().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartDatePanel;
+}
+
+/**
+ * Return the DatePanel2 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryStartFromDate() {
+	if (ivjQueryStartFromDate == null) {
+		try {
+			ivjQueryStartFromDate = new DatePanel();
+			ivjQueryStartFromDate.setName("QueryStartFromDate");
+			ivjQueryStartFromDate.setLayout(new FlowLayout());
+			ivjQueryStartFromDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartFromDate;
+}
+
+/**
+ * Return the DatePanel1 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQueryStartToDate() {
+	if (ivjQueryStartToDate == null) {
+		try {
+			ivjQueryStartToDate = new DatePanel();
+			ivjQueryStartToDate.setName("QueryStartToDate");
+			ivjQueryStartToDate.setLayout(new FlowLayout());
+			ivjQueryStartToDate.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStartToDate;
+}
+
+/**
+ * Return the QueryStatusPanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQueryStatusPanel() {
+	if (ivjQueryStatusPanel == null) {
+		try {
+			ivjQueryStatusPanel = new javax.swing.JPanel();
+			ivjQueryStatusPanel.setName("QueryStatusPanel");
+			ivjQueryStatusPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), "Status"));
+			ivjQueryStatusPanel.setLayout(new java.awt.GridLayout(0, 2));
+			getQueryStatusPanel().add(getQueryWaitingCheck(), getQueryWaitingCheck().getName());
+			getQueryStatusPanel().add(getQueryQueuedCheck(), getQueryQueuedCheck().getName());
+			getQueryStatusPanel().add(getQueryDispatchedCheck(), getQueryDispatchedCheck().getName());
+			getQueryStatusPanel().add(getQueryRunningCheck(), getQueryRunningCheck().getName());
+			getQueryStatusPanel().add(getQueryCompletedCheck(), getQueryCompletedCheck().getName());
+			getQueryStatusPanel().add(getQueryFailedCheck(), getQueryFailedCheck().getName());
+			getQueryStatusPanel().add(getQueryStoppedCheck(), getQueryStoppedCheck().getName());
+			getQueryStatusPanel().add(getQueryAllStatusCheck(), getQueryAllStatusCheck().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStatusPanel;
+}
+
+/**
+ * Return the JCheckBox6 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryStoppedCheck() {
+	if (ivjQueryStoppedCheck == null) {
+		try {
+			ivjQueryStoppedCheck = new javax.swing.JCheckBox();
+			ivjQueryStoppedCheck.setName("QueryStoppedCheck");
+			ivjQueryStoppedCheck.setSelected(true);
+			ivjQueryStoppedCheck.setText("Stopped");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryStoppedCheck;
+}
+
+/**
+ * Return the QuerySubmitDateCheck property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQuerySubmitDateCheck() {
+	if (ivjQuerySubmitDateCheck == null) {
+		try {
+			ivjQuerySubmitDateCheck = new javax.swing.JCheckBox();
+			ivjQuerySubmitDateCheck.setName("QuerySubmitDateCheck");
+			ivjQuerySubmitDateCheck.setSelected(true);
+			ivjQuerySubmitDateCheck.setText("Submit Between");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitDateCheck;
+}
+
+/**
+ * Return the QuerySubmitDatePanel property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getQuerySubmitDatePanel() {
+	if (ivjQuerySubmitDatePanel == null) {
+		try {
+			ivjQuerySubmitDatePanel = new javax.swing.JPanel();
+			ivjQuerySubmitDatePanel.setName("QuerySubmitDatePanel");
+			ivjQuerySubmitDatePanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder()));
+			ivjQuerySubmitDatePanel.setLayout(new java.awt.GridLayout(3, 0));
+			getQuerySubmitDatePanel().add(getQuerySubmitDateCheck(), getQuerySubmitDateCheck().getName());
+			getQuerySubmitDatePanel().add(getQuerySubmitFromDate(), getQuerySubmitFromDate().getName());
+			getQuerySubmitDatePanel().add(getQuerySubmitToDate(), getQuerySubmitToDate().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitDatePanel;
+}
+
+/**
+ * Return the DatePanel1 property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQuerySubmitFromDate() {
+	if (ivjQuerySubmitFromDate == null) {
+		try {
+			ivjQuerySubmitFromDate = new DatePanel();
+			ivjQuerySubmitFromDate.setName("QuerySubmitFromDate");
+			ivjQuerySubmitFromDate.setLayout(new FlowLayout());
+			ivjQuerySubmitFromDate.setEnabled(true);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitFromDate;
+}
+
+/**
+ * Return the QuerySubmitToDate property value.
+ * @return cbit.vcell.messaging.admin.DatePanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private DatePanel getQuerySubmitToDate() {
+	if (ivjQuerySubmitToDate == null) {
+		try {
+			ivjQuerySubmitToDate = new DatePanel();
+			ivjQuerySubmitToDate.setName("QuerySubmitToDate");
+			ivjQuerySubmitToDate.setLayout(new FlowLayout());
+			ivjQuerySubmitToDate.setEnabled(true);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQuerySubmitToDate;
+}
+
+/**
+ * Return the JTextField3 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getQueryUserField() {
+	if (ivjQueryUserField == null) {
+		try {
+			ivjQueryUserField = new javax.swing.JTextField();
+			ivjQueryUserField.setName("QueryUserField");
+			ivjQueryUserField.setColumns(13);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryUserField;
+}
+
+/**
+ * Return the JCheckBox3 property value.
+ * @return javax.swing.JCheckBox
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JCheckBox getQueryWaitingCheck() {
+	if (ivjQueryWaitingCheck == null) {
+		try {
+			ivjQueryWaitingCheck = new javax.swing.JCheckBox();
+			ivjQueryWaitingCheck.setName("QueryWaitingCheck");
+			ivjQueryWaitingCheck.setSelected(true);
+			ivjQueryWaitingCheck.setText("Waiting");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjQueryWaitingCheck;
+}
+
+/**
+ * Return the RefreshButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getRefreshButton() {
+	if (ivjRefreshButton == null) {
+		try {
+			ivjRefreshButton = new javax.swing.JButton();
+			ivjRefreshButton.setName("RefreshButton");
+			ivjRefreshButton.setText("Refresh");
+			ivjRefreshButton.setForeground(java.awt.Color.blue);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjRefreshButton;
+}
+
+/**
+ * Return the RemoveFromListButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getRemoveFromListButton() {
+	if (ivjRemoveFromListButton == null) {
+		try {
+			ivjRemoveFromListButton = new javax.swing.JButton();
+			ivjRemoveFromListButton.setName("RemoveFromListButton");
+			ivjRemoveFromListButton.setText("Remove From List");
+			ivjRemoveFromListButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjRemoveFromListButton;
+}
+
+
+/**
+ * Return the RemoveFromListButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getSubmitSelectedButton() {
+	if (ivjSubmitSelectedButton == null) {
+		try {
+			ivjSubmitSelectedButton = new javax.swing.JButton();
+			ivjSubmitSelectedButton.setName("SubmitSelected");
+			ivjSubmitSelectedButton.setText("Submit selected jobs");
+			ivjSubmitSelectedButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSubmitSelectedButton;
+}
+
+private javax.swing.JButton getStopSelectedButton() {
+	if (ivjStopSelectedButton == null) {
+		try {
+			ivjStopSelectedButton = new javax.swing.JButton();
+			ivjStopSelectedButton.setText("Stop selected jobs");
+			ivjStopSelectedButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStopSelectedButton;
+}
+
+/**
+ * Return the SendMessageButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getSendMessageButton() {
+	if (ivjSendMessageButton == null) {
+		try {
+			ivjSendMessageButton = new javax.swing.JButton();
+			ivjSendMessageButton.setName("SendMessageButton");
+			ivjSendMessageButton.setText("Send");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSendMessageButton;
+}
+
+/**
+ * Return the ServicePage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getServiceStatusPage() {
+	if (ivjServiceStatusPage == null) {
+		try {
+			ivjServiceStatusPage = new javax.swing.JPanel();
+			ivjServiceStatusPage.setName("ServiceStatusPage");
+			ivjServiceStatusPage.setLayout(new java.awt.BorderLayout());
+			
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new javax.swing.JLabel("Total Services:");
+			label.setForeground(java.awt.Color.red);			
+			panel.add(label);
+			panel.add(getNumServiceLabel());
+			ivjServiceStatusPage.add(panel, "North");
+			
+			ivjServiceStatusPage.add(getServiceStatusTable().getEnclosingScrollPane(), "Center");
+			
+			JPanel panel6 = new javax.swing.JPanel();
+			panel6.setLayout(new java.awt.FlowLayout());
+			panel6.add(getStartServiceButton(), getStartServiceButton().getName());
+			panel6.add(getStopServiceButton(), getStopServiceButton().getName());	
+	
+			ivjServiceStatusPage.add(panel6, "South");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjServiceStatusPage;
+}
+
+/**
+ * Return the ServiceStatusTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+private JSortTable getConfigTable() {
+	if (ivjConfigTable == null) {
+		try {
+			ivjConfigTable = new JSortTable();
+			ivjConfigTable.setModel(new ServiceStatusTableModel());
+			ivjConfigTable.disableUneditableForeground();
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjConfigTable;
+}
+
+/**
+ * Return the ServiceStatusTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private JSortTable getServiceStatusTable() {
+	if (ivjServiceStatusTable == null) {
+		try {
+			ivjServiceStatusTable = new JSortTable();
+			ivjServiceStatusTable.setModel(new ServiceInstanceStatusTableModel());
+			ivjServiceStatusTable.disableUneditableForeground();
+			//ivjServiceStatusTable.setBounds(0, 0, 200, 200);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjServiceStatusTable;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:44:01 PM)
+ * @return cbit.vcell.messaging.server.RpcsimServerProxy
+ */
+private RpcSimServerProxy getSimProxy(User user) throws JMSException, DataAccessException, java.rmi.RemoteException {
+	if (simProxyHash == null) {
+		simProxyHash = new HashMap<User, RpcSimServerProxy>();
+	}
+
+	RpcSimServerProxy simProxy = (RpcSimServerProxy)simProxyHash.get(user);
+
+	if (simProxy == null) {
+		JmsClientMessaging jmsClientMessaging = new JmsClientMessaging(jmsConn, log, null);		
+		simProxy = new RpcSimServerProxy(user, jmsClientMessaging, log);
+		simProxyHash.put(user, simProxy);
+	}
+	
+	return simProxy;
+}
+
+/**
+ * Return the StartServiceButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getStartServiceButton() {
+	if (ivjStartServiceButton == null) {
+		try {
+			ivjStartServiceButton = new javax.swing.JButton();
+			ivjStartServiceButton.setName("StartServiceButton");
+			ivjStartServiceButton.setText("Start Service");
+			ivjStartServiceButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStartServiceButton;
+}
+
+/**
+ * Return the StopServiceButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getStopServiceButton() {
+	if (ivjStopServiceButton == null) {
+		try {
+			ivjStopServiceButton = new javax.swing.JButton();
+			ivjStopServiceButton.setName("StopServiceButton");
+			ivjStopServiceButton.setText("Stop Service");
+			ivjStopServiceButton.setEnabled(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStopServiceButton;
+}
+
+/**
+ * Return the JTabbedPane1 property value.
+ * @return javax.swing.JTabbedPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTabbedPane getTabbedPane() {
+	if (ivjTabbedPane == null) {
+		try {
+			ivjTabbedPane = new javax.swing.JTabbedPane();
+			ivjTabbedPane.setName("TabbedPane");			
+			ivjTabbedPane.insertTab("Configurations", null, getConfigPage(), "services in the database", 0);
+			ivjTabbedPane.insertTab("Runtime Services", null, getServiceStatusPage(), "realtime services", 1);
+			ivjTabbedPane.insertTab("Active Users", null, getUserConnectionPage(), "Connected users", 2);
+			ivjTabbedPane.insertTab("Query", null, getQueryPage(), "query simulation status", 3);
+			ivjTabbedPane.insertTab("Broadcast Message", null, getBroadcastPanel(), "send broadcast message", 4);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjTabbedPane;
+}
+
+/**
+ * Return the ServicePage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getConfigPage() {
+	if (ivjConfigPage == null) {
+		try {
+			ivjConfigPage = new javax.swing.JPanel();
+			ivjConfigPage.setName("ConfigurationPage");
+			ivjConfigPage.setLayout(new BorderLayout());
+			
+			JPanel panel = new JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new JLabel("Total services : ");
+			label.setForeground(Color.red);			
+			panel.add(label);
+			panel.add(getNumConfigsLabel());			
+			ivjConfigPage.add(panel, "North");
+			
+			ivjConfigPage.add(getConfigTable().getEnclosingScrollPane(), "Center");
+			
+			Box box = Box.createHorizontalBox();
+			box.add(Box.createHorizontalGlue());
+			box.add(getNewServiceButton());
+			box.add(getModifyServiceButton());
+			box.add(getDeleteServiceButton());
+			box.add(Box.createHorizontalGlue());
+			box.add(getRefreshServerManagerButton());
+			ivjConfigPage.add(box, "South");
+			
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjConfigPage;
+}
+
+private JButton getNewServiceButton() {
+	if (ivjNewServiceButton == null) {
+		ivjNewServiceButton = new JButton("New");
+	}
+	return ivjNewServiceButton;
+}
+
+private JButton getDeleteServiceButton() {
+	if (ivjDeleteServiceButton == null) {
+		ivjDeleteServiceButton = new JButton("Delete");
+		ivjDeleteServiceButton.setEnabled(false);
+	}
+	return ivjDeleteServiceButton;
+}
+
+private JButton getRefreshServerManagerButton() {
+	if (ivjRefreshServerManagerButton == null) {
+		ivjRefreshServerManagerButton = new JButton("Refresh Server Manager");
+		ivjRefreshServerManagerButton.setEnabled(true);
+	}
+	return ivjRefreshServerManagerButton;
+}
+
+private JButton getModifyServiceButton() {
+	if (ivjModifyServiceButton == null) {
+		ivjModifyServiceButton = new JButton("Modify");
+		ivjModifyServiceButton.setEnabled(false);
+	}
+	return ivjModifyServiceButton;
+}
+
+private javax.swing.JLabel getNumConfigsLabel() {
+	if (ivjNumConfigsLabel == null) {
+		try {
+			ivjNumConfigsLabel = new javax.swing.JLabel();
+			ivjNumConfigsLabel.setName("NumConfigsLabel");
+			ivjNumConfigsLabel.setPreferredSize(new java.awt.Dimension(100, 14));
+			ivjNumConfigsLabel.setText("0");
+			ivjNumConfigsLabel.setMaximumSize(new java.awt.Dimension(100, 14));
+			ivjNumConfigsLabel.setForeground(java.awt.Color.red);
+			ivjNumConfigsLabel.setMinimumSize(new java.awt.Dimension(100, 14));
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNumConfigsLabel;
+}
+
+
+/**
+ * Return the UserConnectionPage property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getUserConnectionPage() {
+	if (ivjUserConnectionPage == null) {
+		try {
+			ivjUserConnectionPage = new javax.swing.JPanel();
+			ivjUserConnectionPage.setName("UserConnectionPage");
+			ivjUserConnectionPage.setLayout(new java.awt.BorderLayout());
+			
+			JPanel panel = new javax.swing.JPanel();
+			panel.setLayout(new FlowLayout(FlowLayout.LEFT));			
+			JLabel label = new javax.swing.JLabel("Total Active Users:");
+			label.setForeground(java.awt.Color.red);			
+			panel.add(label);
+			panel.add(getNumUserConnectionLabel(), getNumUserConnectionLabel().getName());			
+			getUserConnectionPage().add(panel, "North");
+			
+			getUserConnectionPage().add(getUserConnectionTable().getEnclosingScrollPane(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjUserConnectionPage;
+}
+
+/**
+ * Return the UserConnectionTable property value.
+ * @return cbit.vcell.messaging.admin.sorttable.JSortTable
+ */
+private JSortTable getUserConnectionTable() {
+	if (ivjUserConnectionTable == null) {
+		try {
+			ivjUserConnectionTable = new JSortTable();
+			ivjUserConnectionTable.setModel(new UserConnectionTableModel());
+			ivjUserConnectionTable.disableUneditableForeground();
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjUserConnectionTable;
+}
+
+
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	 exception.printStackTrace(System.out);
+}
+
+
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getStopServiceButton().addActionListener(ivjEventHandler);
+	getStartServiceButton().addActionListener(ivjEventHandler);
+	getTabbedPane().addChangeListener(ivjEventHandler);
+	getQueryWaitingCheck().addItemListener(ivjEventHandler);
+	getQueryQueuedCheck().addItemListener(ivjEventHandler);
+	getQueryFailedCheck().addItemListener(ivjEventHandler);
+	getQueryRunningCheck().addItemListener(ivjEventHandler);
+	getQueryStoppedCheck().addItemListener(ivjEventHandler);
+	getQueryCompletedCheck().addItemListener(ivjEventHandler);
+	getQueryAllStatusCheck().addItemListener(ivjEventHandler);
+	getQueryGoButton().addActionListener(ivjEventHandler);
+	getQueryResetButton().addActionListener(ivjEventHandler);
+	getServiceStatusTable().addMouseListener(ivjEventHandler);
+	getQueryResultTable().addMouseListener(ivjEventHandler);
+	getConfigTable().addMouseListener(ivjEventHandler);
+	getQuerySubmitDateCheck().addItemListener(ivjEventHandler);
+	getQueryStartDateCheck().addItemListener(ivjEventHandler);
+	getQueryEndDateCheck().addItemListener(ivjEventHandler);
+	getQueryDispatchedCheck().addItemListener(ivjEventHandler);
+	getRefreshButton().addActionListener(ivjEventHandler);
+	getExitButton().addActionListener(ivjEventHandler);
+	getRemoveFromListButton().addActionListener(ivjEventHandler);
+	getSubmitSelectedButton().addActionListener(ivjEventHandler);
+	getSendMessageButton().addActionListener(ivjEventHandler);
+	getMessageResetButton().addActionListener(ivjEventHandler);
+	getNewServiceButton().addActionListener(ivjEventHandler);
+	getDeleteServiceButton().addActionListener(ivjEventHandler);
+	getModifyServiceButton().addActionListener(ivjEventHandler);
+	getRefreshServerManagerButton().addActionListener(ivjEventHandler);
+	getStopSelectedButton().addActionListener(ivjEventHandler);
+}
+
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		try {
+			log = new StdoutSessionLog("Console");
+			setTitle("Virtual Cell Management Console -- " + VCellServerID.getSystemServerID());
+			reconnect();
+			
+			try {
+				KeyFactory keyFactory = new cbit.sql.OracleKeyFactory();	
+				DbDriver.setKeyFactory(keyFactory);
+				ConnectionFactory conFactory = new cbit.sql.OraclePoolingConnectionFactory(log);
+				adminDbTop = new AdminDBTopLevel(conFactory,log);
+			} catch (SQLException e) {
+				e.printStackTrace();
+			} catch (IllegalAccessException e) {
+				e.printStackTrace();
+			} catch (InstantiationException e) {
+				e.printStackTrace();
+			} catch (ClassNotFoundException e) {
+				e.printStackTrace();
+			}		
+		} catch (JMSException ex) {
+		}	
+		// user code end
+		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+		setSize(1200, 700);
+		add(getJFrameContentPane());
+		
+		statusChecks.add(getQueryWaitingCheck());
+		statusChecks.add(getQueryQueuedCheck());
+		statusChecks.add(getQueryDispatchedCheck());
+		statusChecks.add(getQueryRunningCheck());
+		statusChecks.add(getQueryCompletedCheck());
+		statusChecks.add(getQueryStoppedCheck());
+		statusChecks.add(getQueryFailedCheck());
+
+		DateRenderer dateRenderer = new DateRenderer();
+		dateRenderer.disableUneditableForeground();
+		getQueryResultTable().setDefaultRenderer(Date.class, dateRenderer);
+		getQueryResultTable().setDefaultRenderer(Long.class, dateRenderer);
+		getConfigTable().setDefaultRenderer(Date.class, dateRenderer);
+		getServiceStatusTable().setDefaultRenderer(Date.class, dateRenderer);
+		initConnections();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}	
+	// user code end
+}
+
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {		
+		PropertyLoader.loadProperties();
+		
+		javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());
+		ServerManageConsole aServerManageConsole = new ServerManageConsole();		
+
+		aServerManageConsole.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		java.awt.Insets insets = aServerManageConsole.getInsets();
+		aServerManageConsole.setSize(aServerManageConsole.getWidth() + insets.left + insets.right, aServerManageConsole.getHeight() + insets.top + insets.bottom);
+		aServerManageConsole.setLocation(200, 200);		
+		aServerManageConsole.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JFrame");
+		exception.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void messageResetButton_ActionEvents() {
+	getBroadcastMessageTextArea().setText("The Virtual Cell is going to reboot in 5 minutes due to technical requirements. Please save your work and logout." 
+		+ " We are sorry for any inconvenience." 
+		+ " If you have any questions, please contact the Virtual Cell at VCell_Support@uchc.edu.");
+	getBroadcastMessageToTextField().setText("All");
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/10/2003 2:27:25 PM)
+ * @param service cbit.vcell.messaging.admin.VCellService
+ */
+private void onArrivingService(ServiceInstanceStatus arrivingService) {
+	if (arrivingService.getType().equals(ServiceType.SERVERMANAGER)) {
+		serviceInstanceStatusList.add(0, arrivingService);
+	} else {
+		boolean bDefined = false;
+		List<ServiceInstanceStatus> tempList = new ArrayList<ServiceInstanceStatus>(serviceInstanceStatusList);
+		for (int i = 0; i < tempList.size(); i ++) {
+			ServiceInstanceStatus sis = tempList.get(i);
+			if (sis.getSpecID().equals(arrivingService.getSpecID())) {
+				if (sis.isRunning()) {
+					serviceInstanceStatusList.add(arrivingService);
+				} else {
+					serviceInstanceStatusList.set(i, arrivingService);
+				}
+				bDefined = true;
+				break;
+			} 
+		}
+		if (!bDefined) {
+			serviceInstanceStatusList.add(arrivingService);
+		}
+	}
+	showServices(serviceInstanceStatusList);
+}
+
+
+/**
+ * onMessage method comment.
+ */
+public void onControlTopicMessage(Message message) {		
+	try {
+		log.print("onMessage [" + JmsUtils.toString(message) + "]");	
+		String msgType = (String)JmsUtils.parseProperty(message, ManageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		
+		if (msgType == null) {
+			return;
+		}
+		
+		if (msgType.equals(ManageConstants.MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE) && message instanceof ObjectMessage) {			
+			Object obj = ((ObjectMessage)message).getObject();			
+			if (obj instanceof ServiceInstanceStatus) {
+				final ServiceInstanceStatus serviceInfo = (ServiceInstanceStatus)obj;
+				SwingUtilities.invokeLater(new Runnable() {
+					public void run() {
+						onArrivingService(serviceInfo);
+					}
+				});
+			}
+		}		
+	} catch (Exception ex) {
+		log.exception(ex);
+	}	
+}
+
+public SimpleJobStatus getReturnedSimulationJobStatus(int selectedRow) {	
+	return (SimpleJobStatus)((JobTableModel)getQueryResultTable().getModel()).getValueAt(selectedRow);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+private void pingAll(int waitingTimeSec) {
+	try {
+		Message msg = topicSession.createMessage();			
+		msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE);		
+		log.print("sending ping message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);			
+		try {
+			Thread.sleep(waitingTimeSec * MessageConstants.SECOND_IN_MS);
+		} catch (InterruptedException ex) {
+			log.exception(ex);
+		}		
+	} catch (Exception ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/3/2003 8:00:07 AM)
+ */
+private void query() {	
+	boolean bOtherConditions = false;
+	
+	getRemoveFromListButton().setEnabled(false);
+	getSubmitSelectedButton().setEnabled(false);
+	getStopSelectedButton().setEnabled(false);
+	StringBuffer conditions = new StringBuffer();
+	String text = getQuerySimField().getText();
+	if (text != null && text.trim().length() > 0) {
+		try {
+			bOtherConditions = true;
+			int simID = Integer.parseInt(text);
+			conditions.append(SimulationJobTable.table.simRef.getQualifiedColName() + "=" + simID);
+		} catch (NumberFormatException ex) {
+		}
+	}
+
+	text = getQueryHostField().getText();
+	if (text != null && text.trim().length() > 0) {
+		bOtherConditions = true;
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("lower(" + SimulationJobTable.table.computeHost.getQualifiedColName() + ")='" + text.toLowerCase() + "'");
+	}
+
+	text = getQueryServerIDField().getText();
+	if (text != null && text.trim().length() > 0) {
+		bOtherConditions = true;
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("lower(" + SimulationJobTable.table.serverID.getQualifiedColName() + ")='" + text.toLowerCase() + "'");
+	}
+		
+	text = getQueryUserField().getText();
+	if (text != null && text.trim().length() > 0) {
+		bOtherConditions = true;
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append(UserTable.table.userid.getQualifiedColName() + "='" + text + "'");
+	}
+
+	StringBuffer status = new StringBuffer();
+	int index = 0;	
+	if (!getQueryAllStatusCheck().isSelected()) {
+		Iterator<JCheckBox> iter = statusChecks.iterator();
+		for (; iter.hasNext() ; index ++) {
+			JCheckBox box = iter.next();	
+			if (box.isSelected()) {
+				if (status.length() > 0) {
+					status.append(" OR ");
+				}					
+				status.append(SimulationJobTable.table.schedulerStatus.getQualifiedColName() + "=" + index);		
+			}
+		}			
+	}
+
+	if (status.length() > 0) {
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + status + ")");
+	}
+
+	java.text.SimpleDateFormat df = new java.text.SimpleDateFormat("MM/dd/yyyy", java.util.Locale.US);
+	
+	if (getQuerySubmitDateCheck().isSelected()) {
+		bOtherConditions = true;
+		String d1 = df.format(getQuerySubmitFromDate().getDate());
+		String d2 = df.format(getQuerySubmitToDate().getDate());
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + SimulationJobTable.table.submitDate.getQualifiedColName() 
+			+ " BETWEEN to_date('" + d1 + " 00:00:00', 'mm/dd/yyyy HH24:MI:SS') AND to_date('" + d2 + " 23:59:59', 'mm/dd/yyyy HH24:MI:SS'))");		
+	}
+	
+	if (getQueryStartDateCheck().isSelected()) {
+		bOtherConditions = true;
+		String d1 = df.format(getQueryStartFromDate().getDate());
+		String d2 = df.format(getQueryStartToDate().getDate());
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + SimulationJobTable.table.startDate.getQualifiedColName() 
+			+ " BETWEEN to_date('" + d1 + "00:00:00', 'mm/dd/yyyy HH24:MI:SS') AND to_date('" + d2 + " 23:59:59', 'mm/dd/yyyy HH24:MI:SS'))");		
+	}
+		
+	if (getQueryEndDateCheck().isSelected()) {
+		bOtherConditions = true;
+		String d1 = df.format(getQueryEndFromDate().getDate());
+		String d2 = df.format(getQueryEndToDate().getDate());
+		if (conditions.length() > 0) {
+			conditions.append(" AND ");
+		}
+		conditions.append("(" + SimulationJobTable.table.endDate.getQualifiedColName() 
+			+ " BETWEEN to_date('" + d1 + "00:00:00', 'mm/dd/yyyy HH24:MI:SS') AND to_date('" + d2 + " 23:59:59', 'mm/dd/yyyy HH24:MI:SS'))");		
+	}
+	
+	if (getQueryCompletedCheck().isSelected() && !bOtherConditions) {
+		int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are gonna get all the completed simulation jobs in the database, which is gonna be huge . Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+		if (n == javax.swing.JOptionPane.NO_OPTION) {
+			getNumResultsLabel().setText("0");
+			getNumSelectedLabel().setText("0");
+			((JobTableModel)getQueryResultTable().getModel()).setData(null);			
+			return;
+		}
+	}
+	
+	try {
+		List<SimpleJobStatus> resultList = adminDbTop.getSimulationJobStatus(conditions.toString(), true);
+		getNumResultsLabel().setText("" + resultList.size());
+		getNumSelectedLabel().setText("0");
+		((JobTableModel)getQueryResultTable().getModel()).setData(resultList);
+	} catch (Exception ex) {
+		getNumResultsLabel().setText("Query failed, please try again!");
+		((JobTableModel)getQueryResultTable().getModel()).setData(null);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void queryAllStatusCheck_ItemStateChanged(ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryCompletedCheck_ItemStateChanged(ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryDispatchedCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryEndDateSubmit_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	if (itemEvent.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+		getQueryEndFromDate().setEnabled(true);
+		getQueryEndToDate().setEnabled(true);
+	} else {
+		getQueryEndFromDate().setEnabled(false);
+		getQueryEndToDate().setEnabled(false);
+	}
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryFailedCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryGoButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	query();
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryQueuedCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+private void submitSelectedButton_ActionPerformed(ActionEvent e) {
+	int srows[] = getQueryResultTable().getSelectedRows();
+	if (srows==null || srows.length==0) {
+		return;
+	}
+	final String SUBMIT_JOBS_OPTION = "submit jobs";
+	final String CANCEL_OPTION = "cancel";
+	String response = DialogUtils.showWarningDialog(this, "Are you sure you want to submit "+srows.length+" simulation job(s)? (see console for progress printed to stdout)", new String[] { SUBMIT_JOBS_OPTION, CANCEL_OPTION }, CANCEL_OPTION);
+	if (response.equals(SUBMIT_JOBS_OPTION)){
+		for (int i = 0; i < srows.length; i++) {
+			int selectedRow = srows[i];
+			SimpleJobStatus jobStatus = getReturnedSimulationJobStatus(selectedRow);
+			String statusString = "["+ jobStatus.getVCSimulationIdentifier() + ", " + jobStatus.getStatusMessage() + "]";
+			if (jobStatus.isDone()) {
+				log.print("Submitting job (" + (i+1) + " of " + srows.length + ") : " + statusString);
+				resubmitSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+			} else {
+				log.print("Submitting job ("+(i+1)+" of "+srows.length+") : " + statusString + ", is still running, skipping...");
+			}
+		}
+	}
+}
+
+private void stopSelectedButton_ActionPerformed(ActionEvent e) {
+	int srows[] = getQueryResultTable().getSelectedRows();
+	if (srows==null || srows.length==0) {
+		return;
+	}
+	final String STOP_JOBS_OPTION = "stop jobs";
+	final String CANCEL_OPTION = "cancel";
+	String response = DialogUtils.showWarningDialog(this, "Are you sure you want to stop "
+			+srows.length+" simulation job(s)? (see console for progress printed to stdout)", 
+			new String[] { STOP_JOBS_OPTION, CANCEL_OPTION }, CANCEL_OPTION);
+	if (response.equals(STOP_JOBS_OPTION)){
+		for (int i = 0; i < srows.length; i++) {
+			int selectedRow = srows[i];
+			SimpleJobStatus jobStatus = getReturnedSimulationJobStatus(selectedRow);
+			String statusString = "["+ jobStatus.getVCSimulationIdentifier() + ", " + jobStatus.getStatusMessage() + "]";
+			if (!jobStatus.isDone()) {
+				log.print("Stopping job ("+(i+1)+" of "+srows.length+") : "+statusString);	
+				stopSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+			} else {
+				log.print("***Stopping job ("+(i+1)+" of "+srows.length+") : "+statusString + ", is already finished, skipping");
+			}
+		}
+	}
+}
+
+/**
+ * Comment
+ */
+public void queryResetButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	getQuerySimField().setText(null);
+	getQueryHostField().setText(null);
+	getQueryUserField().setText(null);
+	getQueryAllStatusCheck().setSelected(true);
+	getQueryStartFromDate().reset();
+	getQueryStartToDate().reset();
+	getQueryEndFromDate().reset();	
+	getQueryEndToDate().reset();
+	getQuerySubmitFromDate().reset();
+	getQuerySubmitToDate().reset();
+	getQuerySubmitDateCheck().setSelected(true);
+	getQueryStartDateCheck().setSelected(false);
+	getQueryEndDateCheck().setSelected(false);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryResultTable_MouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	int srow = getQueryResultTable().getSelectedRow();
+	if (srow < 0) {
+		getRemoveFromListButton().setEnabled(false);
+		getSubmitSelectedButton().setEnabled(false);
+		getStopSelectedButton().setEnabled(false);
+		return;
+	}
+	if (mouseEvent.getClickCount() == 1) {
+		getRemoveFromListButton().setEnabled(true);
+		getSubmitSelectedButton().setEnabled(true);
+		getStopSelectedButton().setEnabled(true);
+		getNumSelectedLabel().setText("" + getQueryResultTable().getSelectedRowCount());
+	} else if (mouseEvent.getClickCount() == 2) {
+		SimulationJobStatusDetailDialog dialog = new SimulationJobStatusDetailDialog(this, getQueryResultTable().getRowCount(), srow);
+		dialog.setLocationRelativeTo(this);
+		dialog.setVisible(true);
+	}
+}
+
+public void configTable_mouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	int srow = getConfigTable().getSelectedRow();
+	if (srow < 0) {
+		getDeleteServiceButton().setEnabled(false);
+		getModifyServiceButton().setEnabled(false);
+	}
+	
+	getDeleteServiceButton().setEnabled(true);
+	getModifyServiceButton().setEnabled(true);
+	
+	if (mouseEvent.getClickCount() == 2) {
+		modifyService();
+	}
+}
+
+/**
+ * Comment
+ */
+public void queryRunningCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryStartDateCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	if (itemEvent.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+		getQueryStartFromDate().setEnabled(true);
+		getQueryStartToDate().setEnabled(true);
+	} else {
+		getQueryStartFromDate().setEnabled(false);
+		getQueryStartToDate().setEnabled(false);
+	}	
+	return;
+}
+
+/**
+ * Comment
+ */
+public void queryStoppedCheck_ItemStateChanged(ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void querySubmitDateCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	if (itemEvent.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+		getQuerySubmitFromDate().setEnabled(true);
+		getQuerySubmitToDate().setEnabled(true);
+	} else {
+		getQuerySubmitFromDate().setEnabled(false);
+		getQuerySubmitToDate().setEnabled(false);
+	}
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void queryWaitingCheck_ItemStateChanged(java.awt.event.ItemEvent itemEvent) {
+	updateChecks(itemEvent);
+	return;
+}
+
+
+/**
+ * Comment
+ */
+private void reconnect() throws JMSException {
+	jmsConnFactory = new JmsConnectionFactoryImpl();
+	
+	jmsConn = jmsConnFactory.createConnection();
+	
+	topicSession = jmsConn.getAutoSession();
+	JmsSession listenSession = jmsConn.getAutoSession();
+	String filter = MESSAGE_TYPE_PROPERTY + " NOT IN " 
+		+ "('" + MESSAGE_TYPE_IAMALIVE_VALUE + "'" 
+		+ ",'" + MESSAGE_TYPE_ISSERVICEALIVE_VALUE + "'" 
+		+ ",'" + MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE + "'"
+		+ ",'" + MESSAGE_TYPE_STOPSERVICE_VALUE + "'"
+		+ ")";
+	listenSession.setupTopicListener(JmsUtils.getTopicDaemonControl(), filter, new ControlMessageCollector(this));
+	jmsConn.startConnection();
+}
+
+private String VCellDBAdminpassword;
+private void refresh () {
+	int count = getServiceStatusTable().getRowCount();
+	boolean bAll = false;
+	if (count == 0) {
+		bAll = true;
+	}
+	int tabIndex = getTabbedPane().getSelectedIndex();
+	if (tabIndex == 0 || tabIndex == 1) {
+		final int waitingTimeSec = 5;
+		
+		Thread t = new Thread(new Runnable() {
+			public void run() {
+				getProgressBar().setMaximum(waitingTimeSec);
+				getProgressBar().setMinimum(0);
+				SwingUtilities.invokeLater(new Runnable() {
+					public void run() {
+						getProgressBar().setIndeterminate(true);
+						getRefreshButton().setEnabled(false);
+					}			
+				});									
+			}
+		});
+		t.setName("Refresh Thread");
+		t.start();
+		
+		try {
+			serviceConfigList = adminDbTop.getAllServiceStatus(true);
+		} catch (Exception e) {			
+			e.printStackTrace();
+			javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}	
+		
+		showConfigs(serviceConfigList);
+		getModifyServiceButton().setEnabled(false);
+		getDeleteServiceButton().setEnabled(false);
+		
+		if (!bAll && tabIndex == 0) {		
+			Thread t1 = new Thread(new Runnable() {
+				public void run() {
+					SwingUtilities.invokeLater(new Runnable() {
+						public void run() {
+							getProgressBar().setIndeterminate(false);
+							getProgressBar().setValue(waitingTimeSec);
+							getRefreshButton().setEnabled(true);
+						}			
+					});					
+				}
+			});			
+			t1.setName("Refresh Thread");
+			t1.start();			
+		} else {		
+			((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).setData(null);
+			serviceInstanceStatusList.clear();
+			
+			for (int i = 0; i < serviceConfigList.size(); i ++) {
+				ServiceSpec ss = serviceConfigList.get(i).getServiceSpec();
+				serviceInstanceStatusList.add(new ServiceInstanceStatus(ss.getServerID(), ss.getType(), ss.getOrdinal(), null, null, false));
+			}
+			
+			showServices(serviceInstanceStatusList);
+			Thread pingThread = new Thread(new Runnable() {
+				public void run() {			
+					pingAll(waitingTimeSec);	
+					SwingUtilities.invokeLater(new Runnable() {
+						public void run() {
+							getProgressBar().setIndeterminate(false);
+							getProgressBar().setValue(waitingTimeSec);
+							getRefreshButton().setEnabled(true);
+						}			
+					});					
+				}
+			});
+			pingThread.setName("Refresh Thread");
+			pingThread.start();
+		}		
+	} else if (tabIndex == 2) {
+		userList.clear();
+		try {
+			if (vcellBootstrap == null) {
+				vcellBootstrap = (VCellBootstrap) java.rmi.Naming.lookup(getLocalVCellBootstrapUrl());
+				String clearTextPassword = null;
+				if(VCellDBAdminpassword == null){
+					clearTextPassword = DialogUtils.showInputDialog0(this, "Enter VCell DB Administrator password", "AdminPassword");
+				}
+				vcellServer = vcellBootstrap.getVCellServer(new User(PropertyLoader.ADMINISTRATOR_ACCOUNT,new KeyValue(PropertyLoader.ADMINISTRATOR_ID)), new UserLoginInfo.DigestedPassword(clearTextPassword));
+				//everything OK, save cache password
+				VCellDBAdminpassword = clearTextPassword;
+			}		
+			
+			ServerInfo serverInfo = vcellServer.getServerInfo();
+			User[] users = serverInfo.getConnectedUsers();
+			for (int i = 0; i < users.length; i ++) {
+				userList.add(new SimpleUserConnection(users[i], new Date()));
+			}
+		} catch (Exception ex) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Exception:" + ex.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		}
+		showUsers(userList);
+	}
+		
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void refreshButton_ActionPerformed(ActionEvent actionEvent) {
+	refresh();
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void removeFromListButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	int[] indexes = getQueryResultTable().getSelectedRows();
+	((JobTableModel)getQueryResultTable().getModel()).removeRowsAt(indexes);
+	getNumResultsLabel().setText("" + getQueryResultTable().getRowCount());
+	getNumSelectedLabel().setText("0");
+	return;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:32:52 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public void resubmitSimulation(String userid, KeyValue simKey) {
+	try {
+		User user = adminDbTop.getUser(userid, true);
+		RpcDbServerProxy dbProxy = getDbProxy(user);
+		BigString simxml = dbProxy.getSimulationXML(simKey);
+		if (simxml == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		Simulation sim = XmlHelper.XMLToSim(simxml.toString());
+		if (sim == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		RpcSimServerProxy simProxy = getSimProxy(user);
+		simProxy.startSimulation(sim.getSimulationInfo().getAuthoritativeVCSimulationIdentifier());		
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Resubmitting simulation failed:" + ex.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void sendMessageButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	try {
+		int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are going to send message to " + getBroadcastMessageToTextField().getText() + ". Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+		if (n == javax.swing.JOptionPane.NO_OPTION) {
+			return;
+		}	
+		
+		Message msg = topicSession.createObjectMessage(new BigString(getBroadcastMessageTextArea().getText()));
+		String username = getBroadcastMessageToTextField().getText();
+
+		if (username.equalsIgnoreCase("All")) {
+			username = "All";
+		}
+			
+		msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_BROADCASTMESSAGE_VALUE);
+		msg.setStringProperty(MessageConstants.USERNAME_PROPERTY, username);
+		
+		log.print("sending broadcast message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicClientStatus(), msg);		
+
+	} catch (Exception ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void serverManageConsole_WindowClosed(java.awt.event.WindowEvent windowEvent) {
+	try {
+		dispose();
+		if (jmsConn != null) {
+			jmsConn.close();
+		}
+	} catch (JMSException ex) {
+		log.exception(ex);
+	} finally {
+ 		System.exit(0);	
+ 	}	
+}
+
+/**
+ * Comment
+ */
+public void serverStatusTable_MouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	}
+
+
+/**
+ * Comment
+ */
+public void serviceStatusTable_MouseClicked(java.awt.event.MouseEvent mouseEvent) {
+	int selectedCount = getServiceStatusTable().getSelectedRowCount();
+	int[] selectedRows = getServiceStatusTable().getSelectedRows();
+	if (selectedRows == null || selectedCount < 1) {
+		return;
+	}
+
+	getStopServiceButton().setEnabled(false);
+	getStartServiceButton().setEnabled(false);
+
+	for (int i = 0; i < selectedCount; i ++){	
+		int row = selectedRows[i];
+		ServiceInstanceStatus serviceInstanceStatus = (ServiceInstanceStatus)((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).getValueAt(row);		
+		if (serviceInstanceStatus.isRunning()) {
+			getStopServiceButton().setEnabled(true);
+		} else {
+			//getStartServiceButton().setEnabled(true);
+		}
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/31/2005 1:20:48 PM)
+ * @return cbit.vcell.messaging.admin.SimpleJobStatus
+ */
+public void setSelectedReturnedSimulationJobStatus(int selectedRow) {	
+	getQueryResultTable().setRowSelectionInterval(selectedRow, selectedRow);
+}
+
+
+/**
+ * Method generated to support the promotion of the userConnectionTableModel attribute.
+ * @param arg1 cbit.vcell.messaging.admin.sorttable.SortTableModel
+ */
+public void setUserConnectionTableModel(org.vcell.util.gui.sorttable.SortTableModel arg1) {
+	getUserConnectionTable().setModel(arg1);
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/17/2004 1:21:46 PM)
+ * @param serviceList0 java.util.List
+ */
+private void showServices(final List<ServiceInstanceStatus> serviceList0) {
+	SwingUtilities.invokeLater(new Runnable() {
+		public void run() {
+			((ServiceInstanceStatusTableModel)(getServiceStatusTable().getModel())).setData(serviceList0);
+			getNumServiceLabel().setText(serviceList0.size() + "");
+		}
+	});
+}
+
+private void showConfigs(List<ServiceStatus> configList0) {
+	((ServiceStatusTableModel)(getConfigTable().getModel())).setData(configList0);
+	getNumConfigsLabel().setText(configList0.size() + "");
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/17/2004 1:21:46 PM)
+ * @param serviceList0 java.util.List
+ */
+private void showUsers(List<SimpleUserConnection> userList0) {
+	((UserConnectionTableModel)(getUserConnectionTable().getModel())).setData(userList0);
+	getNumUserConnectionLabel().setText(userList0.size() + "");
+}
+
+/**
+ * Comment
+ */
+public void startServiceButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	startServices();
+	return;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/20/2003 1:15:33 PM)
+ */
+private void startServices() {
+//	try
+//	} catch (Exception ex) {
+//		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+//	}
+}
+
+/**
+ * Comment
+ */
+public void stopServiceButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	stopServices();
+	return;
+}
+
+private void refreshServerManager() {
+	try {
+		int n = javax.swing.JOptionPane.showConfirmDialog(this, "You are going to refresh server manager. Continue?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+		if (n == javax.swing.JOptionPane.NO_OPTION) {
+			return;
+		}			
+		Message msg = topicSession.createMessage();
+			
+		msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE);
+			
+		log.print("sending refresh server manager message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);			
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}	
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/20/2003 1:15:33 PM)
+ */
+private void stopServices() {
+	try {
+		int selectedCount = getServiceStatusTable().getSelectedRowCount();
+		int[] selectedRows = getServiceStatusTable().getSelectedRows();
+		if (selectedRows == null || selectedCount < 1) {
+			return;
+		}
+
+		for (int i = 0; i < selectedCount; i ++){					
+			int row = selectedRows[i];
+			ServiceInstanceStatus serviceInstanceStatus = (ServiceInstanceStatus)((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).getValueAt(row);		
+			if (!serviceInstanceStatus.isRunning()) {
+				continue;
+			}			
+			
+			sendStopMessage(serviceInstanceStatus.getID());		
+		}
+		refresh();
+		clearServiceStatusTab();
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}	
+}
+
+private void sendStopMessage(String serviceInstanceID) throws JMSException {
+	Message msg = topicSession.createMessage();
+	
+	msg.setStringProperty(ManageConstants.MESSAGE_TYPE_PROPERTY, ManageConstants.MESSAGE_TYPE_STOPSERVICE_VALUE);
+	msg.setStringProperty(ManageConstants.SERVICE_ID_PROPERTY, serviceInstanceID);
+	
+	log.print("sending stop service message [" + JmsUtils.toString(msg) + "]");		
+	topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);		
+}
+
+private void stopService(ServiceSpec ss) {
+	try {	
+		int count = getServiceStatusTable().getRowCount();
+		for (int i = 0; i < count; i ++){					
+			ServiceInstanceStatus serviceInstanceStatus = (ServiceInstanceStatus)((ServiceInstanceStatusTableModel)getServiceStatusTable().getModel()).getValueAt(i);
+			if (!serviceInstanceStatus.isRunning() || !serviceInstanceStatus.getSpecID().equals(ss.getID())) {
+				continue;
+			}
+			
+			sendStopMessage(serviceInstanceStatus.getID());
+		}
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Failed!!: " + ex.getMessage(), "Bad News", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:32:52 PM)
+ * @param simKey cbit.sql.KeyValue
+ */
+public void stopSimulation(String userid, KeyValue simKey) {
+	try {
+		User user = adminDbTop.getUser(userid, true);
+		RpcDbServerProxy dbProxy = getDbProxy(user);
+		BigString simxml = dbProxy.getSimulationXML(simKey);
+		if (simxml == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		cbit.vcell.solver.Simulation sim = cbit.vcell.xml.XmlHelper.XMLToSim(simxml.toString());
+		if (sim == null) {
+			javax.swing.JOptionPane.showMessageDialog(this, "Simulation [" + simKey + "] doesn't exit, might have been deleted.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+			return;
+		}
+		cbit.vcell.messaging.server.RpcSimServerProxy simProxy = getSimProxy(user);
+		simProxy.stopSimulation(sim.getSimulationInfo().getAuthoritativeVCSimulationIdentifier());		
+	} catch (Exception ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Resubmitting simulation failed:" + ex.getMessage(), "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void tabbedPane_ChangeEvents() {    
+    switch (getTabbedPane().getSelectedIndex()) {
+        case 0 :
+        case 1 :
+        case 2 :
+        	if (!getProgressBar().isIndeterminate()) {
+        		getRefreshButton().setEnabled(true);
+        	}
+            break;
+            
+        case 3 :
+            getRefreshButton().setEnabled(false);
+            break;
+        case 4:
+        	ivjBroadcastMessageTextArea.setText("Dear User,\n\n" 
+					+ "VCell is shutting down for update in 5 minutes. Please save your work and logout.\n\n"
+					+ "We are sorry for the inconvenience. Please come back in 15 minutes.\n\n\n"
+					+ "VCell team\n" 
+					+ new Date());	
+        	break;
+    }
+
+    return;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/29/2003 4:57:15 PM)
+ */
+private void updateChecks(java.awt.event.ItemEvent event) {
+	if (event.getSource() == getQueryAllStatusCheck()) {
+		if (event.getStateChange() == java.awt.event.ItemEvent.SELECTED) {
+			getQueryWaitingCheck().setSelected(true);
+			getQueryQueuedCheck().setSelected(true);
+			getQueryDispatchedCheck().setSelected(true);
+			getQueryRunningCheck().setSelected(true);
+			getQueryCompletedCheck().setSelected(true);
+			getQueryFailedCheck().setSelected(true);
+			getQueryStoppedCheck().setSelected(true);
+		}
+	} else if (event.getStateChange() == java.awt.event.ItemEvent.DESELECTED) {
+		if (getQueryAllStatusCheck().isSelected())
+			getQueryAllStatusCheck().setSelected(false);		 
+	}
+}
+}
Index: src/cbit/vcell/messaging/admin/JobTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/JobTableModel.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/JobTableModel.java	(revision 12031)
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.util.Comparator;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/28/2003 1:38:32 PM)
+ * @author: Fei Gao
+ */
+public class JobTableModel extends VCellSortTableModel<ComparableObject> {
+	public final static int columnIndex_UserID = 0;
+	public final static int columnIndex_SimID = 1;
+	private final static int columnIndex_JobIndex = 2;
+	private final static int columnIndex_SolverType = 3;
+	private final static int columnIndex_Status = 4;
+	private final static int columnIndex_ComputeHost = 5;
+	private final static int columnIndex_ServerID = 6;
+	private final static int columnIndex_TaskID = 7;
+	private final static int columnIndex_SubmitDate = 8;
+	private final static int columnIndex_StartDate = 9;
+	private final static int columnIndex_EndDate = 10;
+	private final static int columnIndex_ElapsedTime = 11;
+
+/**
+ * JobTableModel constructor comment.
+ */
+public JobTableModel() {
+	super(new String[]{"User ID", "Sim ID", "Job Index", "Solver Type", "Status", "Compute Host", "Server ID", "Task ID", "Submit Date", "Start Date", "End Date", "Elapsed (h:m:s)"});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2003 2:14:05 PM)
+ * @return java.lang.Class
+ * @param columnIndex int
+ */
+public Class getColumnClass(int columnIndex) {
+	if (columnIndex == columnIndex_SimID || columnIndex == columnIndex_TaskID || columnIndex == columnIndex_JobIndex) {
+		return Number.class;
+	} else if (columnIndex == columnIndex_SubmitDate || columnIndex == columnIndex_StartDate || columnIndex == columnIndex_EndDate) {
+		return Date.class;
+	} else if (columnIndex == columnIndex_ElapsedTime){
+		return Long.class;
+	} else {		
+		return String.class;
+	}
+}
+
+/**
+ * getValueAt method comment.
+ */
+public Object getValueAt(int row, int col) {
+	ComparableObject jobStatus = getValueAt(row);
+	Object[] values = jobStatus.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+
+}
Index: src/cbit/vcell/messaging/admin/AddNewServiceDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/AddNewServiceDialog.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/AddNewServiceDialog.java	(revision 12031)
@@ -0,0 +1,501 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.awt.Color;
+
+import javax.swing.*;
+
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/22/2003 3:43:58 PM)
+ * @author: Fei Gao
+ */
+public class AddNewServiceDialog extends javax.swing.JDialog {
+	private javax.swing.JButton ivjNewButton = null;
+	private javax.swing.JButton ivjCancelButton = null;
+	private javax.swing.JComboBox ivjOrdinalCombo = null;
+	private javax.swing.JTextField ivjSiteField = null;
+	private javax.swing.JComboBox ivjTypeCombo = null;	
+	private javax.swing.JComboBox ivjStartupCombo = null;
+	private javax.swing.JTextField ivjMemoryMBField = null;
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private JPanel ivjMainPanel = null;
+	public boolean action = false;
+	IvjEventHandler ivjEventHandler = new IvjEventHandler();
+
+class IvjEventHandler implements java.awt.event.ActionListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			if (e.getSource() == AddNewServiceDialog.this.getNewButton()) 
+				connEtoC1(e);
+			if (e.getSource() == AddNewServiceDialog.this.getCancelButton()) 
+				connEtoC2(e);
+		}
+	};
+/**
+ * AddNewServiceDialog constructor comment.
+ */
+public AddNewServiceDialog() {
+	super();
+	initialize();
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ */
+public AddNewServiceDialog(java.awt.Dialog owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ */
+public AddNewServiceDialog(java.awt.Dialog owner, String title) {
+	super(owner, title);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Dialog owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Dialog owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public AddNewServiceDialog(java.awt.Frame owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ */
+public AddNewServiceDialog(java.awt.Frame owner, String title) {
+	super(owner, title);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Frame owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * AddNewServiceDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param modal boolean
+ */
+public AddNewServiceDialog(java.awt.Frame owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * Comment
+ */
+public void newButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {	
+	if (getTypeCombo().getSelectedIndex() < 0 
+			|| getOrdinalCombo().getSelectedItem() == null || getStartupCombo().getSelectedIndex() < 0
+			|| getMemoryMBField().getText().length() == 0) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Some fields are missing!", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		return;
+	}
+	
+	try {
+		int ordinal = Integer.parseInt("" + getOrdinalCombo().getSelectedItem());
+	} catch (NumberFormatException ex) {
+		javax.swing.JOptionPane.showMessageDialog(this, "Ordinal must be a number!", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
+		return;
+	}
+	
+	action = true;
+	dispose();
+	return;
+}
+/**
+ * Comment
+ */
+public void cancelButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	action = false;
+	dispose();
+	return;
+}
+
+/**
+ * connEtoC1:  (AddNewAddButton.action.actionPerformed(java.awt.event.ActionEvent) --> AddNewServiceDialog.addNewAddButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.newButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * connEtoC2:  (AddNewCancelButton.action.actionPerformed(java.awt.event.ActionEvent) --> AddNewServiceDialog.addNewCancelButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC2(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.cancelButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * Return the AddNewAddButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getNewButton() {
+	if (ivjNewButton == null) {
+		try {
+			ivjNewButton = new javax.swing.JButton();
+			ivjNewButton.setText("New");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNewButton;
+}
+
+/**
+ * Return the AddNewCancelButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getCancelButton() {
+	if (ivjCancelButton == null) {
+		try {
+			ivjCancelButton = new javax.swing.JButton();
+			ivjCancelButton.setText("Cancel");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjCancelButton;
+}
+
+/**
+ * Return the AddNewLogFileField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getMemoryMBField() {
+	if (ivjMemoryMBField == null) {
+		try {
+			ivjMemoryMBField = new javax.swing.JTextField();
+			ivjMemoryMBField.setText("100");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjMemoryMBField;
+}
+
+/**
+ * Return the AddNewServiceNameField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JComboBox getOrdinalCombo() {
+	if (ivjOrdinalCombo == null) {
+		try {
+			ivjOrdinalCombo = new javax.swing.JComboBox();
+			for (int i = 0; i < 20; i ++) {
+				ivjOrdinalCombo.addItem(i);
+			}
+			ivjOrdinalCombo.setSelectedIndex(-1);
+			ivjOrdinalCombo.setEditable(true);
+			
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjOrdinalCombo;
+}
+
+private javax.swing.JTextField getSiteField() {
+	if (ivjSiteField == null) {
+		try {
+			ivjSiteField = new javax.swing.JTextField();
+			ivjSiteField.setText(VCellServerID.getSystemServerID().toString());
+			ivjSiteField.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSiteField;
+}
+
+private javax.swing.JComboBox getStartupCombo() {
+	if (ivjStartupCombo == null) {
+		try {
+			ivjStartupCombo = new javax.swing.JComboBox();
+			for (int i = 0; i < ManageConstants.SERVICE_STARTUP_TYPES.length; i ++) {
+				ivjStartupCombo.addItem(ManageConstants.SERVICE_STARTUP_TYPES[i]);
+			}			
+			ivjStartupCombo.setSelectedIndex(0);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStartupCombo;
+}
+
+private javax.swing.JComboBox getTypeCombo() {
+	if (ivjTypeCombo == null) {
+		try {
+			ivjTypeCombo = new javax.swing.JComboBox();
+			for (ServiceType st : ServiceType.values()) {
+				if (!st.equals(ServiceType.SERVERMANAGER)) {
+					ivjTypeCombo.addItem(st);
+				}
+			}			
+			ivjTypeCombo.setSelectedIndex(-1);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjTypeCombo;
+}
+
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(new java.awt.BorderLayout());
+			
+			JPanel panel3 = new JPanel(new java.awt.FlowLayout());
+			panel3.add(getNewButton());
+			panel3.add(getCancelButton());
+			
+			getJDialogContentPane().add(panel3, "South");
+			getJDialogContentPane().add(getMainPanel(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+
+/**
+ * Return the JPanel4 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getMainPanel() {
+	if (ivjMainPanel == null) {
+		try {
+			ivjMainPanel = new javax.swing.JPanel();
+			ivjMainPanel.setLayout(new java.awt.GridLayout(5, 2));
+			ivjMainPanel.add(new JLabel("Site"));
+			ivjMainPanel.add(getSiteField());
+			ivjMainPanel.add(new JLabel("Type"));
+			ivjMainPanel.add(getTypeCombo());
+			ivjMainPanel.add(new JLabel("Ordinal"));
+			ivjMainPanel.add(getOrdinalCombo());
+			ivjMainPanel.add(new JLabel("Startup Type"));
+			ivjMainPanel.add(getStartupCombo());
+			ivjMainPanel.add(new JLabel("Memory MB"));
+			ivjMainPanel.add(getMemoryMBField());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjMainPanel;
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/22/2003 4:07:31 PM)
+ * @return cbit.vcell.messaging.admin.VCellServiceConfig
+ */
+public ServiceSpec getServiceSpec() {
+	VCellServerID site = VCellServerID.getServerID(getSiteField().getText());
+	ServiceType stype = (ServiceType)getTypeCombo().getSelectedItem();
+	int ordinal = 0;
+	try {
+		ordinal = Integer.parseInt("" + getOrdinalCombo().getSelectedItem());
+	} catch (NumberFormatException ex) {
+		throw new RuntimeException("Ordinal must be a number!");		
+	}
+	int startup = getStartupCombo().getSelectedIndex();
+	int memoryMB = Integer.parseInt(getMemoryMBField().getText());
+
+	return new ServiceSpec(site, stype, ordinal, startup, memoryMB);
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getNewButton().addActionListener(ivjEventHandler);
+	getCancelButton().addActionListener(ivjEventHandler);
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setTitle("Add new service");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
+		setSize(471, 225);
+		setModal(true);
+		setResizable(false);
+		setContentPane(getJDialogContentPane());
+		initConnections();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+
+public void modifyService(ServiceSpec ss) {
+	this.setTitle("Modify Service");
+	getNewButton().setText("Modify");	 
+	getSiteField().setText(ss.getServerID().toString());
+	getSiteField().setEditable(false);
+	getSiteField().setBackground(Color.white);
+	getTypeCombo().setSelectedItem(ss.getType());
+	getTypeCombo().setEnabled(false);
+	getTypeCombo().setBackground(Color.white);
+	getOrdinalCombo().setSelectedItem(ss.getOrdinal());
+	getOrdinalCombo().setEnabled(false);
+	getOrdinalCombo().setBackground(Color.white);
+	getStartupCombo().setSelectedIndex(ss.getStartupType());
+	getMemoryMBField().setText(ss.getMemoryMB() + "");
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/22/2003 5:10:29 PM)
+ * @return boolean
+ */
+public boolean isAction() {
+	return action;
+}
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		AddNewServiceDialog aAddNewServiceDialog;
+		aAddNewServiceDialog = new AddNewServiceDialog();
+		aAddNewServiceDialog.setModal(true);
+		aAddNewServiceDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aAddNewServiceDialog.setVisible(true);
+		java.awt.Insets insets = aAddNewServiceDialog.getInsets();
+		aAddNewServiceDialog.setSize(aAddNewServiceDialog.getWidth() + insets.left + insets.right, aAddNewServiceDialog.getHeight() + insets.top + insets.bottom);
+		aAddNewServiceDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceStatus.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceStatus.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceStatus.java	(revision 12031)
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.io.Serializable;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.Compare;
+import org.vcell.util.Matchable;
+
+import cbit.htc.PbsJobID;
+
+import static cbit.vcell.messaging.admin.ManageConstants.*;
+
+public class ServiceStatus implements ComparableObject, Matchable, Serializable {
+	private ServiceSpec serviceSpec = null;
+	private Date date = null;
+	private int status;
+	private String statusMsg;
+	private PbsJobID pbsJobId;
+	
+	public ServiceStatus(ServiceSpec ss, Date d, int s, String sm, PbsJobID pbsJobID) {
+		super();
+		this.serviceSpec = ss;
+		this.date = d;
+		this.status = s;
+		this.statusMsg = sm;
+		this.pbsJobId = pbsJobID;
+	}
+
+	public Date getDate() {
+		return date;
+	}
+
+	public ServiceSpec getServiceSpec() {
+		return serviceSpec;
+	}
+
+	public int getStatus() {
+		return status;
+	}
+
+	public String getStatusMsg() {
+		return statusMsg;
+	}
+	
+	public boolean isRunning() {
+		return status == ManageConstants.SERVICE_STATUS_RUNNING;
+	}
+	public Object[] toObjects(){
+		return new Object[]{serviceSpec.getServerID(), serviceSpec.getType(), serviceSpec.getOrdinal(), 
+				SERVICE_STARTUP_TYPES[serviceSpec.getStartupType()], serviceSpec.getMemoryMB(), date, SERVICE_STATUSES[status], statusMsg, pbsJobId};		
+	}
+
+	public boolean equals(Object obj) {
+		if (obj instanceof Matchable) {
+			return compareEqual((Matchable)obj);
+		}
+		return false;
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof ServiceStatus) {
+			ServiceStatus ss = (ServiceStatus)obj;
+		
+			if (!serviceSpec.compareEqual(ss.serviceSpec)) {
+				return false;
+			}
+			if (!date.equals(ss.date)) {
+				return false;
+			}
+			if (status != ss.status) {
+				return false;
+			}
+			if (!statusMsg.equals(ss.statusMsg)) {
+				return false;
+			}
+			if (!Compare.isEqualOrNull(pbsJobId, ss.pbsJobId)) {
+				return false;
+			}
+			return true;
+		}
+		return false;
+	}
+
+	public PbsJobID getPbsJobId() {
+		return pbsJobId;
+	}
+	
+	public String toString() {
+		return serviceSpec.toString();
+	}
+}
Index: src/cbit/vcell/messaging/admin/UserConnectionTimeCellRenderer.java
===================================================================
--- src/cbit/vcell/messaging/admin/UserConnectionTimeCellRenderer.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/UserConnectionTimeCellRenderer.java	(revision 12031)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+/**
+ * Insert the type's description here.
+ * Creation date: (4/5/2006 9:48:52 AM)
+ * @author: Fei Gao
+ */
+public class UserConnectionTimeCellRenderer extends javax.swing.table.DefaultTableCellRenderer {
+/**
+ * UserConnectionTimeCellRenderer constructor comment.
+ */
+public UserConnectionTimeCellRenderer() {
+	super();
+}
+
+
+	/**
+	 *  This method is sent to the renderer by the drawing table to
+	 *  configure the renderer appropriately before drawing.  Return
+	 *  the Component used for drawing.
+	 *
+	 * @param	table		the JTable that is asking the renderer to draw.
+	 *				This parameter can be null.
+	 * @param	value		the value of the cell to be rendered.  It is
+	 *				up to the specific renderer to interpret
+	 *				and draw the value.  eg. if value is the
+	 *				String "true", it could be rendered as a
+	 *				string or it could be rendered as a check
+	 *				box that is checked.  null is a valid value.
+	 * @param	isSelected	true is the cell is to be renderer with
+	 *				selection highlighting
+	 * @param	row	        the row index of the cell being drawn.  When
+	 *				drawing the header the rowIndex is -1.
+	 * @param	column	        the column index of the cell being drawn
+	 */
+public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+	super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
+	if (value != null) {
+		int connTime = ((Integer)value).intValue()/1000;
+		int hour = connTime/3600;
+		int min = (connTime - hour * 3600) / 60;
+		int sec = connTime - hour * 3600 - min * 60;
+		setText("" + (hour < 10 ? "0" : "") + hour + " : " + (min < 10 ? "0" : "") + min + " : " + (sec < 10 ? "0" : "") + sec);
+	}
+	return this;
+}
+}
Index: src/cbit/vcell/messaging/admin/GatherInfoDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/GatherInfoDialog.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/GatherInfoDialog.java	(revision 12031)
@@ -0,0 +1,428 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/22/2003 4:11:19 PM)
+ * @author: Fei Gao
+ */
+public class GatherInfoDialog extends javax.swing.JDialog {
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private javax.swing.JLabel ivjJLabel16 = null;
+	private javax.swing.JLabel ivjJLabel18 = null;
+	private javax.swing.JPanel ivjJPanel18 = null;
+	private javax.swing.JPanel ivjJPanel19 = null;
+	private javax.swing.JPanel ivjJPanel20 = null;
+	private java.awt.FlowLayout ivjJPanel20FlowLayout = null;
+	private javax.swing.JPanel ivjJPanel21 = null;
+	private javax.swing.JProgressBar ivjProgressBar = null;
+	public int max;
+/**
+ * GatherInfoDialog constructor comment.
+ */
+public GatherInfoDialog() {
+	super();
+	initialize();
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ */
+public GatherInfoDialog(java.awt.Dialog owner) {
+	super(owner);
+	initialize();
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ */
+public GatherInfoDialog(java.awt.Dialog owner, String title) {
+	super(owner, title);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Dialog owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Dialog
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Dialog owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public GatherInfoDialog(java.awt.Frame owner, int max0) {
+	super(owner);
+	max = max0;
+	initialize();
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ */
+public GatherInfoDialog(java.awt.Frame owner, String title) {
+	super(owner, title);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param title java.lang.String
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Frame owner, String title, boolean modal) {
+	super(owner, title, modal);
+}
+/**
+ * GatherInfoDialog constructor comment.
+ * @param owner java.awt.Frame
+ * @param modal boolean
+ */
+public GatherInfoDialog(java.awt.Frame owner, boolean modal) {
+	super(owner, modal);
+}
+/**
+ * connEtoC1:  (GatherInfoDialog.initialize() --> GatherInfoDialog.gatherInfoDialog_Initialize()V)
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1() {
+	try {
+		// user code begin {1}
+		// user code end
+		this.gatherInfoDialog_Initialize();
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+/**
+ * Comment
+ */
+public void gatherInfoDialog_Initialize() {
+	getProgressBar().setMaximum(max);
+	return;
+}
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(new javax.swing.BoxLayout(getJDialogContentPane(), javax.swing.BoxLayout.X_AXIS));
+			getJDialogContentPane().add(getJPanel18(), getJPanel18().getName());
+			getJDialogContentPane().add(getJPanel19(), getJPanel19().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+/**
+ * Return the JLabel16 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel16() {
+	if (ivjJLabel16 == null) {
+		try {
+			ivjJLabel16 = new javax.swing.JLabel();
+			ivjJLabel16.setName("JLabel16");
+			ivjJLabel16.setIcon(new javax.swing.ImageIcon(getClass().getResource("/icons/planet.gif")));
+			ivjJLabel16.setText("");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel16;
+}
+/**
+ * Return the JLabel18 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel18() {
+	if (ivjJLabel18 == null) {
+		try {
+			ivjJLabel18 = new javax.swing.JLabel();
+			ivjJLabel18.setName("JLabel18");
+			ivjJLabel18.setText("Please wait while we gather information for you");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel18;
+}
+/**
+ * Return the JPanel18 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel18() {
+	if (ivjJPanel18 == null) {
+		try {
+			ivjJPanel18 = new javax.swing.JPanel();
+			ivjJPanel18.setName("JPanel18");
+			ivjJPanel18.setLayout(new java.awt.FlowLayout());
+			getJPanel18().add(getJLabel16(), getJLabel16().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel18;
+}
+/**
+ * Return the JPanel19 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel19() {
+	if (ivjJPanel19 == null) {
+		try {
+			ivjJPanel19 = new javax.swing.JPanel();
+			ivjJPanel19.setName("JPanel19");
+			ivjJPanel19.setLayout(new java.awt.BorderLayout());
+			getJPanel19().add(getJPanel20(), "North");
+			getJPanel19().add(getJPanel21(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel19;
+}
+/**
+ * Return the JPanel20 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel20() {
+	if (ivjJPanel20 == null) {
+		try {
+			ivjJPanel20 = new javax.swing.JPanel();
+			ivjJPanel20.setName("JPanel20");
+			ivjJPanel20.setLayout(getJPanel20FlowLayout());
+			getJPanel20().add(getJLabel18(), getJLabel18().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel20;
+}
+/**
+ * Return the JPanel20FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel20FlowLayout() {
+	java.awt.FlowLayout ivjJPanel20FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel20FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel20FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel20FlowLayout;
+}
+/**
+ * Return the JPanel21 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel21() {
+	if (ivjJPanel21 == null) {
+		try {
+			ivjJPanel21 = new javax.swing.JPanel();
+			ivjJPanel21.setName("JPanel21");
+			ivjJPanel21.setLayout(new java.awt.BorderLayout());
+			getJPanel21().add(getProgressBar(), "North");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel21;
+}
+/**
+ * Return the ProgressBar property value.
+ * @return javax.swing.JProgressBar
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JProgressBar getProgressBar() {
+	if (ivjProgressBar == null) {
+		try {
+			ivjProgressBar = new javax.swing.JProgressBar();
+			ivjProgressBar.setName("ProgressBar");
+			ivjProgressBar.setMaximum(100);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjProgressBar;
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("GatherInfoDialog");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
+		setTitle("Gather Info");
+		setSize(400, 84);
+		setModal(true);
+		setResizable(false);
+		setContentPane(getJDialogContentPane());
+		initConnections();
+		connEtoC1();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}	
+	// user code end
+}
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		GatherInfoDialog aGatherInfoDialog;
+		aGatherInfoDialog = new GatherInfoDialog();
+		aGatherInfoDialog.setModal(true);
+		aGatherInfoDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aGatherInfoDialog.show();
+		java.awt.Insets insets = aGatherInfoDialog.getInsets();
+		aGatherInfoDialog.setSize(aGatherInfoDialog.getWidth() + insets.left + insets.right, aGatherInfoDialog.getHeight() + insets.top + insets.bottom);
+		aGatherInfoDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/22/2003 4:15:20 PM)
+ * @param value int
+ */
+public void setValue(int value) {
+	getProgressBar().setValue(value);
+}
+/**
+ * 
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private static void getBuilderData() {
+/*V1.1
+**start of data**
+	D0CB838494G88G88GD9FBB0B6GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135DB8DD49C57F5CE9D522313239EABADCE08A327D4F69A94D3D529F162B81C9CD22B2E1C5093056044CE712952D2D7CE649C3B25290E43E906BF8B2CBFE4C936D2E1FBADE39BD9E88101EC04100C7891A02D8496C82C508A18E587F658591D556CG0B0420773DB7F7F6181D8589C91CF34F1BF75FFB775DF75FFD77FEEFF660F63F13D814173F1B63720AB86D6F13BC0ECBBB46F1FBBE0E9FC5DE7D0799
+	A51C616FDD201D5CB4DF88E58734595C99A525DC5C0DE2283B201EB614D172A6BC6F62D6F4BB0F42C30CF92A216D597EE73C734F7303A11CE7B32D9775ED05F2BB509070C8197CA1197F2D3E3D9ABFCE63A36565F35C528A52273E2FCC633D84FD0A015781642AE07DD5A81982DFE828577A393E1444657CC8495FC66498E4A2E5EAE3B7E9250DFBA5AF71G190B27FA12B155D07782114597F027159AA89B3BFD23A7065D22EA1F9896A4496E97C2A1FED48C0C5AF90FDF8CB4B434732AD7D0BA83A3F22B48CBB2
+	590C320F085C15FD45D48E47E5034CA44A7B528419EB881E43C04BBEC23EF31270B742F361410C123203383E639FB6EA7ABB2FFF174BBC6CAF5C91E3FDF587593ADC87A36B5BA8BD177FC73A977F4B931BA7C0DBAA50BA209C205D1599A5F5C07B288F94719FC1F9522D3648FE3F9CB8998CB6CB9E652C6C91A4F8EEE800960DF7DE9816958F4731FD9E6D2B3450E7BEE26346EFF99C33C9D2AD6EF97279D5DC56A3DF4E5FECE1132C246B790ECAE68BCFE544A6EC6ED5B1670E2B1C6B13F3676E630CF3D7BE7BF4
+	C111455C9DCFBEDD102049C9B64C1DD5C9763A086EF5BABC67E97E4178BBA85FF6A842E77E79956AB324DE8DED710750B71C5BD197C7618A2E3466AB16F6C8787B25791B8EB19DCA6DE6DD52691C0DF633AEBF27FC075D2C4B40A46A620236B4A066DF1BBD643C16D7E514B481B90102C04B001201522A50474E71D5B769E35D3C22B60F0B12C7D0B8B6F6337B8DA805302A701D01104A8706050B3CA272EEC988F1DA1FD2B73101FB4E38BDEE627B43B0C73B909094DE9565GC8677D02AAA8A15667ED77CE52C7
+	91E8EB2F8827DC657DC18E65FE605E85254407548BC18F2F8A119E2C5D6EA6FBB241DF8409A0G1E19DD6A84E22F75307ECDC04555E80715D45E99C18988D2C303C316FD6341DE32924ED9CD6C7C8FB4F61441F3DDB55A38FA047016C3BDC517335E7D3AC1CE2BB8CC546715A9BCE3DBA6C9CCDEDB0DBE73DBA77ACC6B363F61AA1F3E4F52E7D241FF332B192F64D61B4F4E9EAA1368456A8FCCB8EF719CEF57F43A79D8711DC54DD1F0137D18FD3FBECA762A3C86FC98E82886ED3CEF5846FC36198F896825DD8A
+	B8186009D81C6919C1ED13276B1DC56B619A3415E752E9E16FBBC5EC0E9BF40E1BDD7B2D923349CE8F49C3420490D0DB0520907040C3C8EB5B6BA13E261D5391D99F73B6658761DC3740C18A697CF28FB9FB3C2AAA22FBDC95FA84D505749AE92F24F305465D41C8C84039EABDA47E4A13F02E757E759EF2A60665C0C0201B238F515A9B681994A4418FCA3748638115711B8432D7BEE1CA0B892D422B9CB95352B809AF8C932C663710B5A8229F361C04A8AE27061C57AC9D5390CA849E41B6EB214C2A4133B779
+	9E1E3D72EBAB393441E03ED56EC878463D790D07595968BE9CB9FBCC27A3A3563A9F2331C16307182E775417C2E906A74C57FF61A5F202A0BF8EE879E174756F0E10F60CA71A1337481244CC295B7821D1A2BBA4DC9D97A08C1340F5C6375B43232F1B5AAEEAB6E46D0F0C929BCA0618D7DACBEC38AD0C18AF65B033DF3AD6E6EBF6E06BBAFF1568C8F15998BF41076D21C97017060653A67CF54AC9ECC266F255A24E7A7DE5326EF828A7832D29453D7969B644D9713EA42E7817198531F0E4D6AD53052B0B6CCD
+	4A17A78B18DD5F9DA3F3B6C1DBF79D5A546EB5467A132110BCAC52B4235963B92FF16F986FDF3D2FC1B9A2AAA135938ED798ED3741CB74A5F9C8E3EBF9796370D64DBE9E18F7B9D0816D7FG650B81D1855B0857040A834C06FF61FE9B4AD113EF8CF69ABADEC44C33E2D713367674D5AB38465901FCAB8C3AE407B7BFD333C92E41B66BFF76DCFE8E900BCDE71C84F7F59C81ACFFA4BA7E87B5DE1CD6A6C04970086CA26BC8BEE246A9D3141FFA440CD372DC08D352212D7AE34C212BFD641C46C3FDB550DA2075
+	C05CA7F0B77A8477ABA856F28BE0144EGC007GAF754C89CA0895468AD89C516A9F0D95E19C61B0C6B7064D783371133976F01A6AEC5C6928F1F6D3FD5AB40E2DFB3B1F1C2DF8E8DB8D3496A89B2838BE23249C28239E571EB2F6FC21353711205FAB37G2F834EF00BB94E925DA906F15373678559CB01986FF14ACB04FA0A4E1B39C4F8E9D0FFC6677DE5BF6165C23D74A872B6D0DEB9549B0FE2BE9DF711185D2D57E7E9BD2857B73B96039B66A3B2575CBD315D71B90C391B6D4B77FC3173ED1A4FBA5FBE69
+	334E37693E1D0C8FB20CA89B5BB3FD736763AC1FD5BEFE0B6A7D549BBB286CD0C888D1C7E965D5DEEB7B8FF58FE711174F819057563C0B8B05CB34BEED2A5CD2234F39579FFB7D6F782D577F3E1F447010BC2E8C8B66B5D67A776AED918F6ED485BFD1C74B35F43C4AAB23C2140D9A69F85696EBFC1BBF169D59DA271C449E9EE1049F17E00B64105095542EA740DFF71478FCBCBDAFA436459F45187ED3A709A72A28CA44EE3B9B483B1877D4F854726337A7C94E9B018B8ECC57939406390D8DC456FD179023B8
+	21AE81AD85CA86CAEFC0595F69A7B27C320717F49D7E299F5FE3549D43FEFF68A7B6D70410F80DE6F06C7B66E55437D56F5BD0CE7000161D41D8AA753BG8CE258E9354B081D1C47581DE79A4AE53A0C071D645EE8C87776BEB16011A7C19C39892AA1FBEB5760392E5E0E4EF36D03DD6786DB9CDDBDEDDA7ECA1CB43EA32AFF6D9ECB5CC5A86998BB5B29DA193B677EBCA663A7170DB2CA6F177273E248485146F20D119C48704877AF21ED6A20CDEAA43C97AE6DB61D7B159C0B692CFDDF3F311D785301B96DE7
+	673493DD5FADB0364F4EE9AFB20CE76B7A717B08FBF2FF3C1A139E0D0B797EACC5DB4FB3DA39AC7B2BF941672F95307D496EA7F1D7D546852DFE194CB542CBA1C1774B7FBAC07659823791E710180DB6380A357E25479133BDBAC0F2F9875407004247B117BFB8CE7AAE03FA72F14CDFDE75A0149779B1ADF335F9C4D5D6E86A82E637A24389D327981722D23C7BCDF07A59DE253E9FCB86243F5320FA17FB8C8EFCAFCF30A64B81E9179677AE6B071B517EA90FFF0BFB6CCFDB73374430FF7AF1E6770DDAD971EF
+	DF4D0B64777F19A436ADBB11D1D28F6482D20116GA51EC05B6428C4C71241E1C1A7D5159F76D24409AB3BA88A1391B6899CECEDAF3A4CEBCBB9914901EBCFC463B8064D8E8C12FD4BBA4130D9114E2F237C178CFC06593EBF00983670530C926F2728F752B8112947D136ED5ADE7D6DB871EF9D5F526059839D835ABD677894E9CF87D99B0036B6814E832AEBC259EFCD6EE7B63130C71BE7D440780273F16158F9E8F378A65ECF05892EF74B2AAA7B09FC643F91A636D665A0E5EA6F9DE8AED444D12F4A3AEA7C
+	F743446FA5E1043299B6AA3CC2F85D30AECF9362254F8FA02EDA5204F828EA107012211E26739AA8AF936A1BF45E8F870C1806743D9DBC135CE405E5FFB9E70E225B10EF46CC915C54B695FB3F9CD38B6F5705A9FAB783BB77CE85353C5EBFC55E8B48A3A3A1C1770B4129D21D57996A16C3A271C4968B77DDA17DA5FECA9E077ECBCE123DB9FC85F3DE99546B00DCC0C1C210C75751BE778F6CDDE03D3B38C3FE229F0B20B5750C9758EF609DE5B9D69AB467D8B24F5E660C12CAA05627D1346A538A6DCEA0F6C6
+	7B2F60EFA5C160A5B563EFA567BB089D22E3FB339CF6300533783E628A6640754D985F57D119FBDB601E86545102F7727087989B137FFA85177B34751DFCFD6F0D7C21966D5E589249391C7F39FCA6E74C07F24A9EFE1036454AF1E95A78EC039CBA0E6A7950A0662672D654BD05A73A3B202E82AD85E2FDD5917BBE24773D57C763A154F300363661D99B3A32385FCF820B9C774DDB9E4762F6AB0D4F65EDACEE67697C3314DFED60B3DF79396EAB0D50165806F97B7D6B444F8ACFC1AC862A876A868A82ADBD25
+	672A29EAEE01FBE82F9CF44041168CD798A6FFF61A48CF84D929C06B01B681EDED073BEEBB4ABFF10D5C71E361047332CC91AA812B3C9890941A8694F8D4B59B2E9CB45B303EBD92639C6D31F2E2051B7E7E57EEFE0FF11872036D6677980F73789E63F350165D0EBEB3A51A676F68084C696A08B5FF01C46769B067646D149F57E14E497779B0A7A7C0DBEE874EFFFA00537D2947701CF565CE5F05237D773F6F6A9C5ABB3B6B317346116B56774DE3572D6F5BA72F4FFF1F6E3C9E7B7DF6777568775BCB26E36B
+	F66F7442B9ADE15A9A03FCFDBA9A03BCB8ED0DC1D6CEC7E310B49A9F07BAA196F6A2867914C78C1250093EE3F7133BC22ADE2F2775F5FABD0D1FEFFF49385B7721E7671D63F6FFBBE1EBDFC6F340CB20EF61E934477F79509E9527F13DA59261B920BE2473F6D31E8A75841D77B5DFAC1D49386D1A0C5B33CBCA4CB9901F5D0EED98BE7945E0B49E7A2D0ECFD2E18D19C039C025E7609930E363995267A20FFDAA4EC42F13497EF508E29F876F866C73F1AA9DA73A0DF760B8CDE65299FC3770CDB1DA1F9F68D828
+	5081B99D28954869E0981969D36343BEC1C7ACFDDEBE9E41E2072BB55EA1832F06E12FD31299FB11F962C0EE028371593E20D51F55503E4601786C0DA14C39D9405BFD9671D96D61B93F195879C935216114A4CFEA688CB14E409062B347D944ADCB294CB828AF87CAB90B98E71AC70C13FE96B15B5AAB4677893603DD166F93B6DD3916DFF8CE3B471E0BE02D8D322DC0FBD7B09263DD815DD9B67F2B1EE24DEFDD67F07E9B270C3F63246E389173BE9D2F4D1BE218FF63233FABE0F6FCDEC4BB66C0FBE5975A71
+	F97B9C1C4B6C58AC135F496660DC7B985A515305F6F40D91194B211E82145E05F66C73219D33F55E0C043C32EE9CBF9DA063FB21AE8145F5E35F1EA076DD2E772DD3C85FCC28EF84AA7C8CE3C8595062B063C70B9CB7FC4B63989E61A86EA97B4C0CB5CBA83F62B3B3567CF35D6F6B20ADC1DF6F1F704679F301DFFAFE7E9849B064508C713FF2685B8464811A86DA8614F49EB164519B95DCEC8C495CA1829C356FB1BCC41FD4138E6B34FA3605EECC1F9F4D129836895AF77700BF823582F9FAD017FBEEAC781B
+	D5DB5872B7AB265746A8BCF9F37B7B4AA247550EAD4EAF7E191E21389E33DFE4D37E329E33DF384750AF16C39B570BFE6172996777GBF5CBB3FDF30F11F174CFAAFB50CCB34104174FB091E5D14DEB36EFF057257741AF17FBD81447D1950D6FF8175F6864D73AF3F9019F37505D873A751F8306602F97E3FE3F16202F97E8685674F06360E0BB87F2BBC275BE20761B9E1686E637EEF5F55B998BECB20B9AD99567BE7BA6F814ADB833CDF65A17E95E7E2E370604C4298FCEA469A034F4EC4E3703899EB8C7E45
+	19E88C3E1F664475206BCB9791F3FE03FEDFD0588731238FF92F0908C3EDFD98C3B2E6E32F6959D96BBB4F3F4CDA5FF97EFDF67E5F98DF1C0DF5A7E2FB7D2B3108EF7D5A706C9D3B7BFE36742E4E416C9F72211FDDA8C0DE58E774B3463BDF42BBC42B3EF7B5815CBBEF9F1E4B5F85489DAADE2FF3B229A76975A5812BB5117EF74EEEFFE5B9471D7A8E0D2DDD8E22BD566A76F861AA5AE3233E5ED58AD97FDEA7569F2375EA3D5E245C4E9E93398B5B6352ED4D31105D989E65BFB0FC5F53A7FAD4AF63170537C5
+	789D82099D9C5EC90EFA08AD44E1B940FE336D22B1239B5664F2621DA855CBFF4F03834FFEDF9EA46901E3771EF745795ECB337B53937AFDE635135D6756C21985C46E344517C81F0E00ED9EB9B91A0D19BE7B9B8D773AFAF62F2B114D77BAA23B9BE4B39D92747B1267923B43CDC3396C923BD3B39DB8E5BE9D12AE99F5C82EA1F709EEC59ED504D02819D7B826478B0AD10FD4CD7E86A8196D7E118C57E4AC731E02B2A0CC5A0C3FE5F77A79D12193B62402FCCEC082E94581BBBC1E9758978A957B2B48F6052A
+	0292DC9AD57B28B8327F40814C553F11906364421CF57DF8AF2875636F76D2BF5E8BE67C246FC3D0CF854A6C477D968244EF4E490ACA7E49C37BDED1B03EB7AFFB27A9FFA7E7FD175A584F6C34773255FBF32F0C779347E53C272685D167B86025DEC61D0B2F623DA967B26A7C71D552375285B1904865C21D5FD2483D3DC5A05FE261F958D6C53EEB337A0D5930ED1ADE36906A253AB0AE3C9C056FEEAE767DE111636A7D46F1492E0563B143ED7FC977B14DE546413F277CF41799874779515E4FC0DB6395FC97
+	7FF2A1717FC42827822D875A8434F5A023249C289E28FBG71411642796EBB6C92EC3E6F78E5AB3BC883EC1D1F9B08DEAF9B77E4944E3DB9FBE6AEF25C362B0B3B0FFC0B7AE67C00F99F9E217C448173BEB4DE45FDC8063652C1743B5F0CDB4D2F8EB27BAC990C36934BFDDD740CAF9FE473B0D91B7C1C7E1C9708BCFF51FF77315303F7F58E6607390531F1EAC1514258FBEB11B576FE3DA89AFB3FD9E40D3D5FAAB2E2EF465B2F49D5740F5A983F220864E276FE71AC9F00D09F79C6B20E464694583FB503BA1E
+	11914F2C537DE3755548BEFE4F705CFC756E6F69653BBA87DBF37E84D9F38E2C37F8886DF0E6826DD0B604B1FF04FE6B47CB62E800FC2B41E1DE7D1ABC972F2CA229C143ABDCF0BE3C42467FF1022C554F07C57F38DF7B162D1A4E7F94D0479062857704ED9ED9F3B1CB7B84A9EB2A2BB976BF164F8F7642A1CDFE11ABD239AD6C33FC9B39CC41AAC28A775E306C370BEE3FFDFC42EF675D2ADD0070EAA7FE645161C17F93C30FF91F5A33BF1FAB6A64360C0802646921G41411552DA2B909AD644A07976C065DE
+	F71094D88510E1340AFD93F34C416D247D90D89071D739992E40416DB208BBA5CAC2A052345D50F4613CC36536B349GC52A20FEACCC7ECFAACF65AA6DF6574596C112ECFCB0A8094374EB9CDBC8D0A68445C5810CAB82E0D4EEE79428A1733D9AD4392AEEC960C302ED1297D55B24973431CD8AB676353ACD8413A9FEA69B1EECF02C98DEB9B0EB7CC6EF539706E3FE6767F133FD8A3BA3F8056543101B1EC7602FF3E35EFB02BF44457E9E2C474FCB124ACB3E13818F79B62CF9CA95A27760301B488FE19F2DD1
+	3B6B537F999BB30C79FFD0CB8788FD131210B094GG68BBGGD0CB818294G94G88G88GD9FBB0B6FD131210B094GG68BBGG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGGEA94GGGG
+**end of data**/
+}
+}
Index: src/cbit/vcell/messaging/admin/SimpleUserConnection.java
===================================================================
--- src/cbit/vcell/messaging/admin/SimpleUserConnection.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/SimpleUserConnection.java	(revision 12031)
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.document.User;
+/**
+ * Insert the type's description here.
+ * Creation date: (4/5/2006 9:39:11 AM)
+ * @author: Fei Gao
+ */
+public class SimpleUserConnection implements ComparableObject {
+	private User user = null;
+	private Date connectedTime = null;
+	private int elapsedTime = 0;
+
+/**
+ * SimpleUserConnection constructor comment.
+ */
+public SimpleUserConnection(User arg_user, Date arg_connectedTime) {
+	super();
+	user = arg_user;
+	connectedTime = arg_connectedTime;
+	elapsedTime = (int)(System.currentTimeMillis() - connectedTime.getTime());
+}
+
+
+/**
+ * toObjects method comment.
+ */
+public java.lang.Object[] toObjects() {
+	return new Object[] {user.getName(), connectedTime, new Integer(elapsedTime)};
+}
+}
Index: src/cbit/vcell/messaging/admin/ManageUtils.java
===================================================================
--- src/cbit/vcell/messaging/admin/ManageUtils.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ManageUtils.java	(revision 12031)
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.net.UnknownHostException;
+import java.util.StringTokenizer;
+
+import org.vcell.util.Executable;
+import org.vcell.util.PropertyLoader;
+
+import cbit.vcell.resource.ResourceUtil;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/11/2003 11:41:43 AM)
+ * @author: Fei Gao
+ */
+public class ManageUtils {
+	private static java.text.SimpleDateFormat dateTimeFormatter = new java.text.SimpleDateFormat(" yyyy_MM_dd 'at' HH-mm-ss", java.util.Locale.US);
+
+/**
+ * ManageUtils constructor comment.
+ */
+public ManageUtils() {
+	super();
+}
+
+public static String getHostName() {
+	try {
+		String hostname = cbit.vcell.messaging.admin.ManageUtils.getLocalHostName();
+		StringTokenizer st = new StringTokenizer(hostname, ".");
+		hostname = st.nextToken(); // abbr hostname
+		return hostname;
+	} catch (UnknownHostException ex) {
+		ex.printStackTrace();
+		return "UnknownHost";
+	}	 
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/26/2001 5:49:02 PM)
+ * @return boolean
+ * @param file java.io.File
+ * @param archiveDirectory java.io.File
+ */
+public static void archiveByDateAndTime(String fileName, String arcDir) {
+	try {
+		if (fileName == null) {
+			return;
+		}
+		
+		java.io.File archiveDirectory = null;
+		java.io.File file = new java.io.File(fileName);
+			
+		if (arcDir == null) {
+			archiveDirectory = new java.io.File("." + java.io.File.separator);
+		} else {
+			archiveDirectory = new java.io.File(arcDir);
+		}
+		
+		archiveDirectory.mkdir(); // in case it isn't there...
+		if (file.exists()) {
+			String archivedName = file.getName() + dateTimeFormatter.format(new java.util.Date());
+			file.renameTo(new java.io.File(archiveDirectory, archivedName));
+		}
+	} catch (Throwable exc) {
+		exc.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return cbit.vcell.server.ProcessStatus
+ * @exception java.rmi.RemoteException The exception description.
+ */
+public static ServerPerformance getDaemonPerformance() {
+	try {
+		String PROGRAM = null;
+		try {
+			PROGRAM = System.getProperty(org.vcell.util.PropertyLoader.serverStatisticsProperty);
+		} catch (Exception e){
+			throw new RuntimeException("required System property \""+org.vcell.util.PropertyLoader.serverStatisticsProperty+"\" not defined");
+		}
+
+		long memoryBytes = -1;
+		float fractionCPU = 0.9999999f;
+		long javaFreeMemoryBytes = Runtime.getRuntime().freeMemory();
+		long javaTotalMemoryBytes = Runtime.getRuntime().totalMemory();
+		long maxJavaMemoryBytes = -1;
+		try {
+			maxJavaMemoryBytes = Long.parseLong(PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty));
+		}catch (NumberFormatException e){
+			System.out.println("error reading property '"+org.vcell.util.PropertyLoader.maxJavaMemoryBytesProperty+"', "+e.getMessage());
+		}
+		try {
+			Executable executable = new Executable(new String[]{PROGRAM});
+			executable.start();
+			String stdout = executable.getStdoutString();
+			java.util.StringTokenizer tokens = new java.util.StringTokenizer(stdout);
+			memoryBytes = Long.parseLong(tokens.nextToken());
+			int cpuPercent = Integer.parseInt (tokens.nextToken());
+			fractionCPU = cpuPercent/100.0f;
+		} catch (Exception e) {
+			e.printStackTrace(System.out);
+		}
+
+		return new ServerPerformance(fractionCPU,memoryBytes,javaFreeMemoryBytes,javaTotalMemoryBytes,maxJavaMemoryBytes);
+	} catch (Throwable e){
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/25/2003 8:43:41 AM)
+ * @return java.lang.String
+ * @param keyword java.lang.String
+ */
+public static String getEnvVariable(String keyword, org.vcell.util.SessionLog log) {
+	String value = null;
+	String[] command = null;
+	
+	if (ResourceUtil.bWindows) {
+		command = new String[]{"cmd.exe", "/c" , "echo %" + keyword + "%"};
+	} else {
+		command = new String[]{"echo", "$" + keyword};
+	}
+	
+	try {
+		Executable exe = new Executable(command);
+		exe.start();
+		value = exe.getStdoutString().trim();
+	} catch (Exception e) {
+		log.exception(e);
+	}
+	
+	return value;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 9:32:25 AM)
+ * @return java.lang.String
+ */
+public static String getFullLocalHostName() throws java.net.UnknownHostException {
+	java.net.InetAddress inet = java.net.InetAddress.getLocalHost();	
+	String hostName = java.net.InetAddress.getByName(inet.getHostAddress()).getHostName();
+	return hostName;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/3/2003 9:32:25 AM)
+ * @return java.lang.String
+ */
+public static String getLocalHostName() throws java.net.UnknownHostException {
+	String hostName = java.net.InetAddress.getLocalHost().getHostName();
+	if (hostName != null) {
+		hostName = hostName.toLowerCase();
+	}
+	return hostName;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/4/2003 7:38:11 AM)
+ * @return java.lang.String
+ */
+public static String readLog(java.io.File file) throws java.io.IOException {
+	java.io.FileReader reader = new java.io.FileReader(file);
+	char[] content = new char[10000];
+	String out = "";
+	while (true) {
+		int n = reader.read(content, 0, 10000);
+		if (n == -1) {
+			break;
+		} else
+			if (n > 0) {
+				out += new String(content, 0, n);
+			}
+	}
+	reader.close();
+	return out;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceSpec.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceSpec.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceSpec.java	(revision 12031)
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import static cbit.vcell.messaging.admin.ManageConstants.SERVICE_STARTUP_TYPES;
+import java.io.Serializable;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.Matchable;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+
+public class ServiceSpec implements Matchable, Serializable, ComparableObject {
+	private VCellServerID serverID;
+	private ServiceType type;
+	private int ordinal;
+	private int startupType;
+	private int memoryMB;	
+	
+	public ServiceSpec(VCellServerID sID, ServiceType t, int o, int st, int mm) {
+		super();
+		this.serverID = sID;
+		this.type = t;
+		this.ordinal = o;
+		this.startupType = st;
+		this.memoryMB = mm;
+	}
+	
+	public int getMemoryMB() {
+		return memoryMB;
+	}
+
+	public int getOrdinal() {
+		return ordinal;
+	}
+
+	public VCellServerID getServerID() {
+		return serverID;
+	}
+
+	public ServiceType getType() {
+		return type;
+	}
+	
+	public String toString() {
+		return "[" + serverID + "," + type + "," + ordinal + "," + ManageConstants.SERVICE_STARTUP_TYPES[startupType] + "," + memoryMB + "M]";
+	}
+
+	public int getStartupType() {
+		return startupType;
+	}
+
+	public String getID() {
+		return getServiceID(serverID, type, ordinal);
+	}
+	public static String getServiceID(VCellServerID serverID, ServiceType type, int ordinal) {
+		return serverID + "_" + type.getName() + "_" + ordinal;
+	}
+	
+	public Object[] toObjects() {
+		return new Object[] {serverID, type, ordinal, SERVICE_STARTUP_TYPES[startupType], memoryMB};
+	}
+		
+	public boolean equals(Object obj) {
+		if (obj instanceof Matchable) {
+			return compareEqual((Matchable)obj);
+		}
+		return false;
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof ServiceSpec) {
+			ServiceSpec ss = (ServiceSpec)obj;
+		
+			if (!serverID.equals(ss.serverID)) {
+				return false;
+			}
+			if (!type.equals(ss.type)) {
+				return false;
+			}
+			if (ordinal != ss.ordinal) {
+				return false;
+			}			
+			return true;
+		}		
+		return false;
+	}
+}
Index: src/cbit/vcell/messaging/admin/ServicePerformance.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServicePerformance.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServicePerformance.java	(revision 12031)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * This type was created in VisualAge.
+ */
+public class ServicePerformance extends Performance {
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServicePerformance() {		
+}
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServicePerformance(long aFreeJavaMemoryBytes, long aTotalJavaMemoryBytes, long aMaxJavaMemoryBytes) {		
+	this.freeJavaMemoryBytes = aFreeJavaMemoryBytes;
+	this.totalJavaMemoryBytes = aTotalJavaMemoryBytes;
+	this.maxJavaMemoryBytes = aMaxJavaMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public Object[] toObjects() {
+	return new Object[] {		
+		new Long(getFreeJavaMemoryBytes()), new Long(getTotalJavaMemoryBytes()), new Long(getMaxJavaMemoryBytes())
+	};
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public String toString() {
+	return "ServicePerformanceStatus: "+ "JVM Memory (free="+getFreeJavaMemoryBytes() 
+		+", total="+getTotalJavaMemoryBytes()+", max="+getMaxJavaMemoryBytes()+") bytes";
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceInstanceStatusTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceInstanceStatusTableModel.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceInstanceStatusTableModel.java	(revision 12031)
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.util.Comparator;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/19/2003 10:46:32 AM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class ServiceInstanceStatusTableModel extends VCellSortTableModel<ComparableObject> {
+
+public ServiceInstanceStatusTableModel() {
+	super(new String[]{"Site", "Type", "Ordinal", "Host", "Start Date", "Running"});
+}
+
+public Class<?> getColumnClass(int columnIndex) {
+	if (columnIndex == 0 || columnIndex == 3) {
+		return String.class;
+	}		
+	if (columnIndex == 1) {
+		return ServiceType.class;
+	}
+	if (columnIndex == 5) {
+		return Boolean.class;
+	}
+	if (columnIndex == 2) {
+		return Number.class;
+	}
+	if (columnIndex == 4) {
+		return Date.class;
+	}
+	return Object.class;
+}
+
+public Object getValueAt(int row, int col) {
+	ComparableObject status = getValueAt(row);
+	Object[] values = status.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+}
Index: src/cbit/vcell/messaging/admin/UserConnectionDateRenderer.java
===================================================================
--- src/cbit/vcell/messaging/admin/UserConnectionDateRenderer.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/UserConnectionDateRenderer.java	(revision 12031)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+/**
+ * Insert the type's description here.
+ * Creation date: (7/8/2004 2:17:40 PM)
+ * @author: Fei Gao
+ */
+public class UserConnectionDateRenderer extends javax.swing.table.DefaultTableCellRenderer {
+/**
+ * DateRenderer constructor comment.
+ */
+public UserConnectionDateRenderer() {
+	super();
+}
+	/**
+	 *  This method is sent to the renderer by the drawing table to
+	 *  configure the renderer appropriately before drawing.  Return
+	 *  the Component used for drawing.
+	 *
+	 * @param	table		the JTable that is asking the renderer to draw.
+	 *				This parameter can be null.
+	 * @param	value		the value of the cell to be rendered.  It is
+	 *				up to the specific renderer to interpret
+	 *				and draw the value.  eg. if value is the
+	 *				String "true", it could be rendered as a
+	 *				string or it could be rendered as a check
+	 *				box that is checked.  null is a valid value.
+	 * @param	isSelected	true is the cell is to be renderer with
+	 *				selection highlighting
+	 * @param	row	        the row index of the cell being drawn.  When
+	 *				drawing the header the rowIndex is -1.
+	 * @param	column	        the column index of the cell being drawn
+	 */
+public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+	super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
+	if (value == null) {
+		return this;
+	}
+	
+	java.text.SimpleDateFormat ddtf = new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss", java.util.Locale.US);
+	
+	setText(ddtf.format(value));
+	return this;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServerManagerDaemon.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServerManagerDaemon.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServerManagerDaemon.java	(revision 12031)
@@ -0,0 +1,439 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import static cbit.vcell.messaging.admin.ManageConstants.*;
+import java.io.*;
+import java.sql.SQLException;
+import java.util.*;
+import javax.jms.*;
+
+import oracle.ucp.UniversalConnectionPoolException;
+
+import org.vcell.util.ConfigurationException;
+import org.vcell.util.DataAccessException;
+import org.vcell.util.ExecutableException;
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.StdoutSessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.htc.PBSConstants.PBSJobStatus;
+import cbit.htc.PbsJobID;
+import cbit.sql.ConnectionFactory;
+import cbit.sql.KeyFactory;
+import cbit.vcell.message.server.pbs.PbsProxy;
+import cbit.vcell.message.server.pbs.PbsProxy.PbsJobNotFoundException;
+import cbit.vcell.message.server.pbs.PbsProxyLocal;
+import cbit.vcell.messaging.*;
+import cbit.vcell.messaging.db.UpdateSynchronizationException;
+import cbit.vcell.modeldb.AdminDBTopLevel;
+import cbit.vcell.modeldb.DbDriver;
+import cbit.vcell.mongodb.VCMongoMessage;
+import cbit.vcell.mongodb.VCMongoMessage.ServiceName;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/7/2003 1:53:27 PM)
+ * @author: Fei Gao
+ */
+public class ServerManagerDaemon implements ControlTopicListener {
+	private PbsProxy pbsProxy = new PbsProxyLocal();
+	private org.vcell.util.SessionLog log = null;
+	private JmsConnection jmsConn = null;
+	private JmsConnectionFactory jmsConnFactory = null;
+	private boolean stopped = false;
+	private List<ServiceInstanceStatus> serviceAliveList = Collections.synchronizedList(new ArrayList<ServiceInstanceStatus>());
+	private List<ServiceStatus> serviceList = Collections.synchronizedList(new ArrayList<ServiceStatus>());
+	private JmsSession topicSession = null;
+	private JmsSession listenSession = null;
+	
+	ServiceInstanceStatus serviceInstanceStatus = null;
+	
+	private ConnectionFactory conFactory = null;
+	private KeyFactory keyFactory = null;
+	private AdminDBTopLevel adminDbTop = null;	
+
+/**
+ * ServerManagerMessaging constructor comment.
+ */
+public ServerManagerDaemon() throws IOException, SQLException, javax.jms.JMSException {
+	super();	
+	
+	serviceInstanceStatus = new ServiceInstanceStatus(VCellServerID.getSystemServerID(), ServiceType.SERVERMANAGER, 0, ManageUtils.getHostName(), new Date(), true); 
+	log = new StdoutSessionLog(serviceInstanceStatus.getID());
+	try {
+		conFactory = new cbit.sql.OraclePoolingConnectionFactory(log);
+	} catch (ClassNotFoundException e) {
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	} catch (IllegalAccessException e) {
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	} catch (InstantiationException e) {
+		e.printStackTrace(System.out);
+		throw new RuntimeException(e.getMessage());
+	} catch (ConfigurationException e) {
+		e.printStackTrace();
+		throw new RuntimeException(e.getMessage());
+	} catch (UniversalConnectionPoolException e) {
+		e.printStackTrace();
+		throw new RuntimeException(e.getMessage());
+	}
+	keyFactory = new cbit.sql.OracleKeyFactory();	
+	DbDriver.setKeyFactory(keyFactory);
+	adminDbTop = new AdminDBTopLevel(conFactory,log);
+	
+	reconnect();
+}
+
+private void reconnect() throws JMSException {
+	jmsConnFactory = new JmsConnectionFactoryImpl();
+	
+	jmsConn = jmsConnFactory.createConnection();
+	topicSession = jmsConn.getAutoSession();
+	
+	listenSession = jmsConn.getAutoSession();
+	listenSession.setupTopicListener(JmsUtils.getTopicDaemonControl(), getMessageFilter(), new ControlMessageCollector(this));
+	jmsConn.startConnection();	
+}
+
+private void startAllServices() throws JMSException, SQLException, DataAccessException {
+	log.print("Starting all the services");
+	serviceList = Collections.synchronizedList(adminDbTop.getAllServiceStatus(true));	
+	
+	pingAll();	
+
+	Iterator<ServiceStatus> iter = serviceList.iterator();
+	while (iter.hasNext()) {
+		ServiceStatus service = iter.next();		
+		if (service.getServiceSpec().getStartupType() == SERVICE_STARTUPTYPE_AUTOMATIC) {			
+			boolean alive = false;
+			ServiceInstanceStatus foundSis = null; 
+			Iterator<ServiceInstanceStatus> aliveIter = serviceAliveList.iterator();
+			while (aliveIter.hasNext()) {
+				ServiceInstanceStatus sis = aliveIter.next();
+				if (sis.getSpecID().equals(service.getServiceSpec().getID())) {
+					if (alive) { // there are more than instances for the same service
+						if (foundSis.getStartDate().compareTo(sis.getStartDate()) > 0) { // kill the service with earlier start date
+							stopService(sis);
+						} else {
+							stopService(foundSis);
+							foundSis = sis;
+						}
+					} else {
+						alive = true;
+						foundSis = sis;
+					}
+				}
+			}
+			
+			if (!alive) {
+				try {
+					startAService(service);
+				} catch (Exception ex) {
+					ex.printStackTrace();
+				}
+			}
+		}
+	}	
+}
+
+private void stopService(ServiceInstanceStatus sis) {
+	try {			
+		Message msg = topicSession.createMessage();
+			
+		msg.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_STOPSERVICE_VALUE);
+		msg.setStringProperty(SERVICE_ID_PROPERTY, sis.getID());
+		
+		log.print("sending stop service message [" + JmsUtils.toString(msg) + "]");		
+		topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);		
+		
+	} catch (Exception ex) {
+		ex.printStackTrace();
+	}	
+}
+
+private void startAService(ServiceStatus service) throws UpdateSynchronizationException, SQLException {
+	log.print("starting service " + service);
+	AdminDBTopLevel.TransactionalServiceOperation tso = new AdminDBTopLevel.TransactionalServiceOperation() {
+		public ServiceStatus doOperation(ServiceStatus oldStatus) throws Exception {
+			PbsJobID jobid = submit2PBS(oldStatus);
+			ServiceStatus newServiceStatus = null;
+			if (jobid == null) {
+				newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_FAILED, "unknown pbs exception",	jobid);
+			} else {
+				long t = System.currentTimeMillis();
+				PBSJobStatus status;
+				while (true) {
+					try {
+						Thread.sleep(1000);
+					} catch (InterruptedException ex) {
+					}
+					
+					status = pbsProxy.getJobStatus(jobid);
+					if (status!=null && status.isExiting()){
+						// should never happen
+						newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_FAILED, "exit immediately after submit", jobid);	
+						break;
+					} else if (status!=null && status.isRunning()) {						
+						newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_RUNNING, "running", jobid);	
+						break;
+					} else if (System.currentTimeMillis() - t > 30 * MessageConstants.SECOND_IN_MS) {
+						String pendingReason = pbsProxy.getPendingReason(jobid);
+						pbsProxy.killJob(jobid); // kill the job if it takes too long to dispatch the job.
+						newServiceStatus = new ServiceStatus(oldStatus.getServiceSpec(), null, SERVICE_STATUS_FAILED, 
+								"PBS Job scheduler timed out. Please try again later. (Job [" + jobid + "]: " + pendingReason + ")",
+								jobid);						
+						break;
+					}
+				}
+			} 			
+			return newServiceStatus;
+		}
+	};
+	
+	adminDbTop.updateServiceStatus(service, tso, true);
+}	
+
+private PbsJobID submit2PBS(ServiceStatus service) throws IOException, ExecutableException {
+	try {
+		killService(service);
+	}catch (PbsJobNotFoundException e){
+		log.alert(service.toString()+" not found, cannot kill job");
+	}
+	
+	String executable = PropertyLoader.getRequiredProperty(PropertyLoader.serviceSubmitScript);
+	
+	ServiceType type = service.getServiceSpec().getType();
+	int ordinal = service.getServiceSpec().getOrdinal();
+	// site, type, ordinal, memory
+	String[] command = new String[] {
+			executable,
+			VCellServerID.getSystemServerID().toString().toLowerCase(),
+			type.getName(),
+			String.valueOf(ordinal),
+			String.valueOf(service.getServiceSpec().getMemoryMB())};
+	File sub_file = File.createTempFile("service", ".pbs.sub");
+	log.print("PBS sub file  for service " + service.getServiceSpec() + " is " + sub_file.getAbsolutePath());
+	return pbsProxy.submitServiceJob((String)null, service.getServiceSpec().getID(), sub_file.getAbsolutePath(), command, 1, service.getServiceSpec().getMemoryMB());
+}
+/**
+ * This method was created in VisualAge.
+ * @return int
+ */
+private java.lang.String getMessageFilter() {
+	return MESSAGE_TYPE_PROPERTY + " NOT IN (" 
+		+ "'" + MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE + "'" 
+		+ ")";
+//		+ " OR (" + ManageConstants.MESSAGE_TYPE_PROPERTY + "='" + ManageConstants.MESSAGE_TYPE_IAMALIVE_VALUE + "'"
+//		+ " AND " + ManageConstants.SERVER_NAME_PROPERTY + " IS NOT NULL"
+//		+ ")";
+}
+
+/**
+ * onMessage method comment.
+ */
+public void onControlTopicMessage(Message message) {
+	try {		
+		log.print("onMessage [" + JmsUtils.toString(message) + "]");		
+			
+		String msgType = (String)JmsUtils.parseProperty(message, MESSAGE_TYPE_PROPERTY, String.class);
+		
+		if (msgType.equals(MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE)) {
+			Message reply = topicSession.createObjectMessage(serviceInstanceStatus);
+			reply.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE);
+			reply.setStringProperty(SERVICE_ID_PROPERTY, serviceInstanceStatus.getID());
+			topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), reply);			
+			log.print("sending reply [" + JmsUtils.toString(reply) + "]");			
+		} else if (msgType.equals(MESSAGE_TYPE_IAMALIVE_VALUE)) {
+			on_iamalive(message);			
+		} else if (msgType.equals(MESSAGE_TYPE_STOPSERVICE_VALUE)) {
+			on_stopservice(message);
+		} else if (msgType.equals(MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE)) {
+			synchronized (this) {
+				notify();
+			}						
+		}
+	} catch (Exception ex) {
+		log.exception(ex);
+	}
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 4:47:40 PM)
+ * @param args java.lang.String[]
+ */
+public static void main(String[] args) {	
+	try {
+		if (args.length > 1) {
+			System.out.println("Missing arguments: " + ServerManagerDaemon.class.getName() + " [logdir]");
+			System.exit(1);
+		}
+		
+		if (args.length == 1) {
+			File logdir = new File(args[0]);
+			if (!logdir.exists()) {
+				throw new RuntimeException("Log directory doesn't exist");
+			}
+				
+			// log file name:
+			// hostname_A_Data_0.log : alpha first data on hostname
+			// hostname_B_Db_0.log : beta first database on hostname
+			// hostname_R_Export_0.log : rel first export on hostname
+			File logfile = new File(logdir, "ServerManager_" + ManageUtils.getHostName() + ".log");
+			java.io.PrintStream ps = new PrintStream(new FileOutputStream(logfile), true); // don't append
+			System.setOut(ps);
+			System.setErr(ps);			
+		}
+		org.vcell.util.PropertyLoader.loadProperties();
+		VCMongoMessage.serviceStartup(ServiceName.serverManager, new Integer(0), args);
+		new ServerManagerDaemon().start();		
+	} catch (Throwable exc) {
+		exc.printStackTrace(System.out);
+		System.exit(1);
+	}
+}
+
+private void on_iamalive(Message message) throws JMSException  {
+	Object obj = ((ObjectMessage)message).getObject();			
+	if (obj instanceof ServiceInstanceStatus) {
+		ServiceInstanceStatus status = (ServiceInstanceStatus)obj;			
+		serviceAliveList.add(status);			
+	}
+}
+
+/**
+* This method was created in VisualAge.
+* @return int
+*/
+private void on_stopservice(Message message) throws JMSException {
+	try {
+		String serviceID = (String)JmsUtils.parseProperty(message, SERVICE_ID_PROPERTY, String.class);
+		
+		if (serviceID != null) {
+			if (serviceID.equals(serviceInstanceStatus.getID())) { // stop myself
+				System.exit(0);
+			}
+			Iterator<ServiceStatus> iter = serviceList.iterator();
+			while (iter.hasNext()) {
+				ServiceStatus service = iter.next();		
+				if (service.getServiceSpec().getID().equals(serviceID)) {
+					PbsJobID pbsJobId = service.getPbsJobId();
+					if (pbsJobId != null){
+						try {
+							PBSJobStatus pbsJobStatus = pbsProxy.getJobStatus(pbsJobId);
+							if (pbsJobStatus!=null && pbsJobStatus.isRunning()) {
+								try {
+									Thread.sleep(5 * MessageConstants.SECOND_IN_MS); // wait 5 seconds
+								} catch (InterruptedException ex) {							
+								}					
+								// if the service is not stopped, kill it from PBS
+								pbsJobStatus = pbsProxy.getJobStatus(pbsJobId);
+								if (pbsJobStatus!=null && pbsJobStatus.isRunning()) {
+									pbsProxy.killJob(pbsJobId);
+								}
+							}
+						} catch (Exception e) {
+							log.exception(e);
+						}
+					}
+					break;
+				}
+			}
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		log.exception(ex);
+	}
+}
+
+
+/**
+* onMessage method comment.
+*/
+private boolean ping(ServiceSpec service) throws JMSException {
+	Message msg = topicSession.createMessage();
+		
+	msg.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_ISSERVICEALIVE_VALUE);
+	msg.setStringProperty(SERVICE_ID_PROPERTY, service.getID());
+
+	log.print("sending ping message [" + JmsUtils.toString(msg) + "]");
+	
+	Message reply = topicSession.topicRequest(this, JmsUtils.getTopicDaemonControl(), msg, ManageConstants.INTERVAL_PING_RESPONSE);
+
+	log.print("got reply message [" + JmsUtils.toString(reply) + "]");
+
+	if (reply == null) {
+		return false;
+	} else {
+		try {
+			String msgType = (String)JmsUtils.parseProperty(reply, MESSAGE_TYPE_PROPERTY, String.class);
+			if (!msgType.equals(MESSAGE_TYPE_IAMALIVE_VALUE)) {
+				return false;
+			}
+		} catch (MessagePropertyNotFoundException ex) {
+			log.exception(ex);
+			return false;
+		}
+	}
+		
+	return true;
+}
+
+
+/**
+* onMessage method comment.
+*/
+private void pingAll() throws JMSException {
+	
+	serviceAliveList.clear();
+	
+	Message msg = topicSession.createMessage();
+		
+	msg.setStringProperty(MESSAGE_TYPE_PROPERTY, MESSAGE_TYPE_ISSERVICEALIVE_VALUE);
+
+	log.print("sending ping message [" + JmsUtils.toString(msg) + "]");
+	
+	topicSession.publishMessage(JmsUtils.getTopicDaemonControl(), msg);
+
+	try {
+		Thread.sleep(INTERVAL_PING_RESPONSE);
+	} catch (InterruptedException ex) {
+		ex.printStackTrace();
+	}
+}
+
+private void killService(ServiceStatus service) throws ExecutableException, PbsJobNotFoundException {
+	if (service.getPbsJobId() != null) {
+		pbsProxy.killJob(service.getPbsJobId());
+	}
+}
+/**
+* Insert the method's description here.
+* Creation date: (8/7/2003 5:12:22 PM)
+*/
+public void start() {
+	while (!stopped) {			
+		try {
+			startAllServices();
+		} catch (Throwable exc) {
+			log.exception(exc);
+		}		
+		try {
+			synchronized (this) {			
+				wait(INTERVAL_PING_SERVICE);
+			}
+		} catch (InterruptedException exc) {
+		}			
+	}
+}
+}
Index: src/cbit/vcell/messaging/admin/ManageConstants.java
===================================================================
--- src/cbit/vcell/messaging/admin/ManageConstants.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ManageConstants.java	(revision 12031)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import org.vcell.util.MessageConstants;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/8/2003 10:23:15 AM)
+ * @author: Fei Gao
+ */
+public interface ManageConstants {
+	public static final long INTERVAL_PING_SERVICE = 10 * MessageConstants.MINUTE_IN_MS; // in minutes
+	public static final long INTERVAL_PING_RESPONSE = 10 * MessageConstants.SECOND_IN_MS; // in milliseconds
+
+	public static final String MESSAGE_TYPE_PROPERTY = MessageConstants.MESSAGE_TYPE_PROPERTY;
+	public static final String MESSAGE_TYPE_ISSERVICEALIVE_VALUE	= "IsServiceAlive";
+	public static final String MESSAGE_TYPE_IAMALIVE_VALUE	= "IAmAlive";		
+	public static final String MESSAGE_TYPE_ASKPERFORMANCESTATUS_VALUE	= "AskPerformance";
+	public static final String MESSAGE_TYPE_REFRESHSERVERMANAGER_VALUE	= "RefreshServerManager";
+	public static final String MESSAGE_TYPE_REPLYPERFORMANCESTATUS_VALUE	= "ReplyPerformance";
+//	public static final String MESSAGE_TYPE_STARTSERVICE_VALUE	= "StartService";
+	public static final String MESSAGE_TYPE_STOPSERVICE_VALUE	= "StopService";
+
+	public static final String MESSAGE_TYPE_BROADCASTMESSAGE_VALUE	= "BroadcastMessage";
+	public static final String BROADCASTMESSAGE_CONTENT_PROPERTY = "BroadcastMessageContent";
+
+	public static final String FILE_NAME_PROPERTY = "FileName";
+	public static final String FILE_LENGTH_PROPERTY = "FileLength";
+	
+	public static final int SERVICE_STARTUPTYPE_AUTOMATIC = 0;	// restart it if the service is dead 
+	public static final int SERVICE_STARTUPTYPE_MANUAL = 1;
+	
+	public static final String[] SERVICE_STARTUP_TYPES = {"automatic", "manual"};
+
+	public static final int SERVICE_STATUS_RUNNING = 0;	// restart it if the service is dead 
+	public static final int SERVICE_STATUS_NOTRUNNING = 1;	// restart it if the service is dead
+	public static final int SERVICE_STATUS_FAILED = 2; 	
+
+	public static final String[] SERVICE_STATUSES = {"running", "not running", "failed"};
+	
+	public static final String SERVICE_ID_PROPERTY	= "ServiceID";
+	
+	public static final String SERVERID_RELEASE = "REL";
+	public static final String SERVERID_ALPHA = "ALPHA";
+	public static final String SERVERID_BETA = "BETA";
+	
+	public static final String AllSites[] = {SERVERID_ALPHA, SERVERID_BETA, SERVERID_RELEASE};	
+}
Index: src/cbit/vcell/messaging/admin/SimulationJobStatusDetailDialog.java
===================================================================
--- src/cbit/vcell/messaging/admin/SimulationJobStatusDetailDialog.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/SimulationJobStatusDetailDialog.java	(revision 12031)
@@ -0,0 +1,1727 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import javax.swing.BorderFactory;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (3/29/2004 1:36:39 PM)
+ * @author: Fei Gao
+ */
+public class SimulationJobStatusDetailDialog extends javax.swing.JDialog {
+	private static java.text.SimpleDateFormat dateTimeFormatter = new java.text.SimpleDateFormat("MM/dd/yyyy HH:mm:ss", java.util.Locale.US);
+	private javax.swing.JPanel ivjJDialogContentPane = null;
+	private javax.swing.JLabel ivjJLabel1 = null;
+	private javax.swing.JLabel ivjJLabel2 = null;
+	private javax.swing.JLabel ivjJLabel3 = null;
+	private javax.swing.JLabel ivjJLabel4 = null;
+	private javax.swing.JLabel ivjJLabel5 = null;
+	private javax.swing.JLabel ivjJLabel6 = null;
+	private javax.swing.JPanel ivjJPanel1 = null;
+	private javax.swing.JPanel ivjJPanel2 = null;
+	private javax.swing.JPanel ivjJPanel3 = null;
+	private javax.swing.JScrollPane ivjJScrollPane1 = null;
+	private javax.swing.JTextField ivjComputeHostTextField = null;
+	private javax.swing.JTextField ivjEndDateTextField = null;
+	private javax.swing.JTextField ivjSimIDTextField = null;
+	private javax.swing.JTextField ivjStartDateTextField = null;
+	private javax.swing.JTextArea ivjStatusMessageTextArea = null;
+	private javax.swing.JTextField ivjSubmitDateTextField = null;
+	private javax.swing.JTextField ivjUserTextField = null;
+	private javax.swing.JPanel ivjJPanel4 = null;
+	private javax.swing.JPanel ivjJPanel5 = null;
+	private javax.swing.JPanel ivjJPanel6 = null;
+	private javax.swing.JPanel ivjJPanel7 = null;
+	private javax.swing.JPanel ivjJPanel8 = null;
+	private javax.swing.JPanel ivjJPanel9 = null;
+	private javax.swing.JButton ivjCloseButton = null;
+	IvjEventHandler ivjEventHandler = new IvjEventHandler();
+	private javax.swing.JPanel ivjJPanel10 = null;
+	private javax.swing.JPanel ivjJPanel11 = null;
+	private java.awt.GridLayout ivjJPanel11GridLayout = null;
+	private javax.swing.JScrollPane ivjJScrollPane2 = null;
+	private javax.swing.JTextArea ivjSolverDescTextArea = null;
+	private java.awt.BorderLayout ivjJDialogContentPaneBorderLayout = null;
+	private java.awt.GridLayout ivjJPanel1GridLayout = null;
+	private java.awt.GridLayout ivjJPanel2GridLayout = null;
+	private java.awt.GridLayout ivjJPanel3GridLayout = null;
+	private java.awt.FlowLayout ivjJPanel4FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel5FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel6FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel7FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel8FlowLayout = null;
+	private java.awt.FlowLayout ivjJPanel9FlowLayout = null;
+	private javax.swing.JButton ivjResubmitButton = null;
+	private javax.swing.JButton ivjStopButton = null;
+	private SimpleJobStatus jobStatus = null;
+	private ServerManageConsole smConsole = null;
+	private javax.swing.JPanel ivjJPanel12 = null;
+	private java.awt.FlowLayout ivjJPanel12FlowLayout = null;
+	private javax.swing.JPanel ivjJPanel13 = null;
+	private java.awt.FlowLayout ivjJPanel13FlowLayout = null;
+	private int currentSelected = -1;
+	private int totalNumber = 0;
+	private javax.swing.JButton ivjNextButton = null;
+	private javax.swing.JButton ivjPrevButton = null;
+	private javax.swing.JLabel ivjJLabel7 = null;
+	private javax.swing.JLabel ivjJLabel8 = null;
+	private javax.swing.JPanel ivjJPanel14 = null;
+	private java.awt.FlowLayout ivjJPanel14FlowLayout = null;
+	private javax.swing.JPanel ivjJPanel15 = null;
+	private java.awt.FlowLayout ivjJPanel15FlowLayout = null;
+	private javax.swing.JTextField ivjServerIDTextField = null;
+	private javax.swing.JTextField ivjTaskIDTextField = null;
+	private javax.swing.JTextField ivjJobIndexTextField = null;
+
+class IvjEventHandler implements java.awt.event.ActionListener {
+		public void actionPerformed(java.awt.event.ActionEvent e) {
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getCloseButton()) 
+				connEtoC1(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getStopButton()) 
+				connEtoC2(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getResubmitButton()) 
+				connEtoC3(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getNextButton()) 
+				connEtoC5(e);
+			if (e.getSource() == SimulationJobStatusDetailDialog.this.getPrevButton()) 
+				connEtoC6(e);
+		};
+	};
+
+/**
+ * SimulationJobStatusDetailDialog constructor comment.
+ */
+public SimulationJobStatusDetailDialog() {
+	super();
+	initialize();
+}
+
+/**
+ * SimulationJobStatusDetailDialog constructor comment.
+ * @param owner java.awt.Frame
+ */
+public SimulationJobStatusDetailDialog(ServerManageConsole console, int total, int selected) {
+	super(console, true);
+	smConsole = console;
+	totalNumber = total;
+	currentSelected = selected;
+	setStatus();
+	initialize();
+}
+
+
+/**
+ * Comment
+ */
+public void closeButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	dispose();
+	return;
+}
+
+
+/**
+ * connEtoC1:  (CloseButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.closeButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC1(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.closeButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC2:  (StopButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.stopButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC2(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.stopButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC3:  (ResubmitButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.resubmitButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC3(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.resubmitButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC4:  (SimulationJobStatusDetailDialog.initialize() --> SimulationJobStatusDetailDialog.simulationJobStatusDetailDialog_Initialize()V)
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC4() {
+	try {
+		// user code begin {1}
+		// user code end
+		this.simulationJobStatusDetailDialog_Initialize();
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC5:  (NextButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.nextButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC5(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.nextButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * connEtoC6:  (PrevButton.action.actionPerformed(java.awt.event.ActionEvent) --> SimulationJobStatusDetailDialog.prevButton_ActionPerformed(Ljava.awt.event.ActionEvent;)V)
+ * @param arg1 java.awt.event.ActionEvent
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void connEtoC6(java.awt.event.ActionEvent arg1) {
+	try {
+		// user code begin {1}
+		// user code end
+		this.prevButton_ActionPerformed(arg1);
+		// user code begin {2}
+		// user code end
+	} catch (java.lang.Throwable ivjExc) {
+		// user code begin {3}
+		// user code end
+		handleException(ivjExc);
+	}
+}
+
+
+/**
+ * Return the CloseButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getCloseButton() {
+	if (ivjCloseButton == null) {
+		try {
+			ivjCloseButton = new javax.swing.JButton();
+			ivjCloseButton.setName("CloseButton");
+			ivjCloseButton.setText("Close");
+			ivjCloseButton.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjCloseButton;
+}
+
+/**
+ * Return the JTextField5 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getComputeHostTextField() {
+	if (ivjComputeHostTextField == null) {
+		try {
+			ivjComputeHostTextField = new javax.swing.JTextField();
+			ivjComputeHostTextField.setName("ComputeHostTextField");
+			ivjComputeHostTextField.setEditable(false);
+			ivjComputeHostTextField.setColumns(18);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjComputeHostTextField;
+}
+
+/**
+ * Return the JTextField6 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getEndDateTextField() {
+	if (ivjEndDateTextField == null) {
+		try {
+			ivjEndDateTextField = new javax.swing.JTextField();
+			ivjEndDateTextField.setName("EndDateTextField");
+			ivjEndDateTextField.setEditable(false);
+			ivjEndDateTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjEndDateTextField;
+}
+
+/**
+ * Return the JDialogContentPane property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJDialogContentPane() {
+	if (ivjJDialogContentPane == null) {
+		try {
+			ivjJDialogContentPane = new javax.swing.JPanel();
+			ivjJDialogContentPane.setName("JDialogContentPane");
+			ivjJDialogContentPane.setLayout(getJDialogContentPaneBorderLayout());
+			getJDialogContentPane().add(getJPanel1(), "North");
+			getJDialogContentPane().add(getJPanel10(), "South");
+			getJDialogContentPane().add(getJPanel11(), "Center");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJDialogContentPane;
+}
+
+/**
+ * Return the JDialogContentPaneBorderLayout property value.
+ * @return java.awt.BorderLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.BorderLayout getJDialogContentPaneBorderLayout() {
+	java.awt.BorderLayout ivjJDialogContentPaneBorderLayout = null;
+	try {
+		/* Create part */
+		ivjJDialogContentPaneBorderLayout = new java.awt.BorderLayout();
+		ivjJDialogContentPaneBorderLayout.setVgap(5);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJDialogContentPaneBorderLayout;
+}
+
+/**
+ * Return the JLabel1 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel1() {
+	if (ivjJLabel1 == null) {
+		try {
+			ivjJLabel1 = new javax.swing.JLabel();
+			ivjJLabel1.setName("JLabel1");
+			ivjJLabel1.setText("User ID");
+			ivjJLabel1.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel1.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel1.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel1;
+}
+
+/**
+ * Return the JLabel2 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel2() {
+	if (ivjJLabel2 == null) {
+		try {
+			ivjJLabel2 = new javax.swing.JLabel();
+			ivjJLabel2.setName("JLabel2");
+			ivjJLabel2.setText("Sim ID");
+			ivjJLabel2.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel2.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel2.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel2.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel2;
+}
+
+/**
+ * Return the JLabel3 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel3() {
+	if (ivjJLabel3 == null) {
+		try {
+			ivjJLabel3 = new javax.swing.JLabel();
+			ivjJLabel3.setName("JLabel3");
+			ivjJLabel3.setText("Compute Host");
+			ivjJLabel3.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel3.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel3.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel3.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel3;
+}
+
+/**
+ * Return the JLabel4 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel4() {
+	if (ivjJLabel4 == null) {
+		try {
+			ivjJLabel4 = new javax.swing.JLabel();
+			ivjJLabel4.setName("JLabel4");
+			ivjJLabel4.setText("Submit Date");
+			ivjJLabel4.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel4.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel4.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel4.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel4;
+}
+
+/**
+ * Return the JLabel5 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel5() {
+	if (ivjJLabel5 == null) {
+		try {
+			ivjJLabel5 = new javax.swing.JLabel();
+			ivjJLabel5.setName("JLabel5");
+			ivjJLabel5.setText("Start Date");
+			ivjJLabel5.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel5.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel5.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel5.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel5;
+}
+
+/**
+ * Return the JLabel6 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel6() {
+	if (ivjJLabel6 == null) {
+		try {
+			ivjJLabel6 = new javax.swing.JLabel();
+			ivjJLabel6.setName("JLabel6");
+			ivjJLabel6.setText("End Date");
+			ivjJLabel6.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel6.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel6.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel6.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel6;
+}
+
+/**
+ * Return the JLabel7 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel7() {
+	if (ivjJLabel7 == null) {
+		try {
+			ivjJLabel7 = new javax.swing.JLabel();
+			ivjJLabel7.setName("JLabel7");
+			ivjJLabel7.setText("Server ID");
+			ivjJLabel7.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel7.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel7.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel7.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel7;
+}
+
+/**
+ * Return the JLabel8 property value.
+ * @return javax.swing.JLabel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JLabel getJLabel8() {
+	if (ivjJLabel8 == null) {
+		try {
+			ivjJLabel8 = new javax.swing.JLabel();
+			ivjJLabel8.setName("JLabel8");
+			ivjJLabel8.setText("Task ID");
+			ivjJLabel8.setMaximumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel8.setPreferredSize(new java.awt.Dimension(70, 14));
+			ivjJLabel8.setMinimumSize(new java.awt.Dimension(70, 14));
+			ivjJLabel8.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJLabel8;
+}
+
+/**
+ * Return the JobIndexTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getJobIndexTextField() {
+	if (ivjJobIndexTextField == null) {
+		try {
+			ivjJobIndexTextField = new javax.swing.JTextField();
+			ivjJobIndexTextField.setName("JobIndexTextField");
+			ivjJobIndexTextField.setEditable(false);
+			ivjJobIndexTextField.setColumns(4);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJobIndexTextField;
+}
+
+/**
+ * Return the JPanel1 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel1() {
+	if (ivjJPanel1 == null) {
+		try {
+			ivjJPanel1 = new javax.swing.JPanel();
+			ivjJPanel1.setName("JPanel1");
+			ivjJPanel1.setLayout(getJPanel1GridLayout());
+			getJPanel1().add(getJPanel2(), getJPanel2().getName());
+			getJPanel1().add(getJPanel3(), getJPanel3().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel1;
+}
+
+
+/**
+ * Return the JPanel10 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel10() {
+	if (ivjJPanel10 == null) {
+		try {
+			ivjJPanel10 = new javax.swing.JPanel();
+			ivjJPanel10.setName("JPanel10");
+			ivjJPanel10.setLayout(new java.awt.GridLayout());
+			getJPanel10().add(getJPanel12(), getJPanel12().getName());
+			getJPanel10().add(getJPanel13(), getJPanel13().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel10;
+}
+
+/**
+ * Return the JPanel11 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel11() {
+	if (ivjJPanel11 == null) {
+		try {
+			ivjJPanel11 = new javax.swing.JPanel();
+			ivjJPanel11.setName("JPanel11");
+			ivjJPanel11.setLayout(getJPanel11GridLayout());
+			getJPanel11().add(getJScrollPane2(), getJScrollPane2().getName());
+			getJPanel11().add(getJScrollPane1(), getJScrollPane1().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel11;
+}
+
+
+/**
+ * Return the JPanel11GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel11GridLayout() {
+	java.awt.GridLayout ivjJPanel11GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel11GridLayout = new java.awt.GridLayout(0, 1);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel11GridLayout;
+}
+
+
+/**
+ * Return the JPanel12 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel12() {
+	if (ivjJPanel12 == null) {
+		try {
+			ivjJPanel12 = new javax.swing.JPanel();
+			ivjJPanel12.setName("JPanel12");
+			ivjJPanel12.setLayout(getJPanel12FlowLayout());
+			getJPanel12().add(getStopButton(), getStopButton().getName());
+			getJPanel12().add(getResubmitButton(), getResubmitButton().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel12;
+}
+
+/**
+ * Return the JPanel12FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel12FlowLayout() {
+	java.awt.FlowLayout ivjJPanel12FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel12FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel12FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel12FlowLayout;
+}
+
+/**
+ * Return the JPanel13 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel13() {
+	if (ivjJPanel13 == null) {
+		try {
+			ivjJPanel13 = new javax.swing.JPanel();
+			ivjJPanel13.setName("JPanel13");
+			ivjJPanel13.setLayout(getJPanel13FlowLayout());
+			getJPanel13().add(getPrevButton(), getPrevButton().getName());
+			getJPanel13().add(getNextButton(), getNextButton().getName());
+			getJPanel13().add(getCloseButton(), getCloseButton().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel13;
+}
+
+/**
+ * Return the JPanel13FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel13FlowLayout() {
+	java.awt.FlowLayout ivjJPanel13FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel13FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel13FlowLayout.setAlignment(java.awt.FlowLayout.RIGHT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel13FlowLayout;
+}
+
+
+/**
+ * Return the JPanel14 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel14() {
+	if (ivjJPanel14 == null) {
+		try {
+			ivjJPanel14 = new javax.swing.JPanel();
+			ivjJPanel14.setName("JPanel14");
+			ivjJPanel14.setLayout(getJPanel14FlowLayout());
+			getJPanel14().add(getJLabel7(), getJLabel7().getName());
+			getJPanel14().add(getServerIDTextField(), getServerIDTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel14;
+}
+
+
+/**
+ * Return the JPanel14FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel14FlowLayout() {
+	java.awt.FlowLayout ivjJPanel14FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel14FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel14FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel14FlowLayout;
+}
+
+
+/**
+ * Return the JPanel15 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel15() {
+	if (ivjJPanel15 == null) {
+		try {
+			ivjJPanel15 = new javax.swing.JPanel();
+			ivjJPanel15.setName("JPanel15");
+			ivjJPanel15.setLayout(getJPanel15FlowLayout());
+			getJPanel15().add(getJLabel8(), getJLabel8().getName());
+			getJPanel15().add(getTaskIDTextField(), getTaskIDTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel15;
+}
+
+
+/**
+ * Return the JPanel15FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel15FlowLayout() {
+	java.awt.FlowLayout ivjJPanel15FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel15FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel15FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel15FlowLayout;
+}
+
+
+/**
+ * Return the JPanel1GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel1GridLayout() {
+	java.awt.GridLayout ivjJPanel1GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel1GridLayout = new java.awt.GridLayout(0, 2);
+		ivjJPanel1GridLayout.setHgap(2);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel1GridLayout;
+}
+
+/**
+ * Return the JPanel2 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel2() {
+	if (ivjJPanel2 == null) {
+		try {
+			ivjJPanel2 = new javax.swing.JPanel();
+			ivjJPanel2.setName("JPanel2");
+			ivjJPanel2.setLayout(getJPanel2GridLayout());
+			getJPanel2().add(getJPanel4(), getJPanel4().getName());
+			getJPanel2().add(getJPanel5(), getJPanel5().getName());
+			getJPanel2().add(getJPanel6(), getJPanel6().getName());
+			getJPanel2().add(getJPanel14(), getJPanel14().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel2;
+}
+
+/**
+ * Return the JPanel2GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel2GridLayout() {
+	java.awt.GridLayout ivjJPanel2GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel2GridLayout = new java.awt.GridLayout(0, 1);
+		ivjJPanel2GridLayout.setVgap(3);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel2GridLayout;
+}
+
+/**
+ * Return the JPanel3 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel3() {
+	if (ivjJPanel3 == null) {
+		try {
+			ivjJPanel3 = new javax.swing.JPanel();
+			ivjJPanel3.setName("JPanel3");
+			ivjJPanel3.setLayout(getJPanel3GridLayout());
+			getJPanel3().add(getJPanel7(), getJPanel7().getName());
+			getJPanel3().add(getJPanel8(), getJPanel8().getName());
+			getJPanel3().add(getJPanel9(), getJPanel9().getName());
+			getJPanel3().add(getJPanel15(), getJPanel15().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel3;
+}
+
+/**
+ * Return the JPanel3GridLayout property value.
+ * @return java.awt.GridLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.GridLayout getJPanel3GridLayout() {
+	java.awt.GridLayout ivjJPanel3GridLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel3GridLayout = new java.awt.GridLayout(0, 1);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel3GridLayout;
+}
+
+/**
+ * Return the JPanel4 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel4() {
+	if (ivjJPanel4 == null) {
+		try {
+			ivjJPanel4 = new javax.swing.JPanel();
+			ivjJPanel4.setName("JPanel4");
+			ivjJPanel4.setLayout(getJPanel4FlowLayout());
+			getJPanel4().add(getJLabel1(), getJLabel1().getName());
+			getJPanel4().add(getUserTextField(), getUserTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel4;
+}
+
+
+/**
+ * Return the JPanel4FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel4FlowLayout() {
+	java.awt.FlowLayout ivjJPanel4FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel4FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel4FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel4FlowLayout;
+}
+
+
+/**
+ * Return the JPanel5 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel5() {
+	if (ivjJPanel5 == null) {
+		try {
+			ivjJPanel5 = new javax.swing.JPanel();
+			ivjJPanel5.setName("JPanel5");
+			ivjJPanel5.setLayout(getJPanel5FlowLayout());
+			getJPanel5().add(getJLabel2(), getJLabel2().getName());
+			getJPanel5().add(getSimIDTextField(), getSimIDTextField().getName());
+			getJPanel5().add(getJobIndexTextField(), getJobIndexTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel5;
+}
+
+/**
+ * Return the JPanel5FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel5FlowLayout() {
+	java.awt.FlowLayout ivjJPanel5FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel5FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel5FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel5FlowLayout;
+}
+
+
+/**
+ * Return the JPanel6 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel6() {
+	if (ivjJPanel6 == null) {
+		try {
+			ivjJPanel6 = new javax.swing.JPanel();
+			ivjJPanel6.setName("JPanel6");
+			ivjJPanel6.setLayout(getJPanel6FlowLayout());
+			getJPanel6().add(getJLabel3(), getJLabel3().getName());
+			getJPanel6().add(getComputeHostTextField(), getComputeHostTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel6;
+}
+
+
+/**
+ * Return the JPanel6FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel6FlowLayout() {
+	java.awt.FlowLayout ivjJPanel6FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel6FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel6FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel6FlowLayout;
+}
+
+
+/**
+ * Return the JPanel7 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel7() {
+	if (ivjJPanel7 == null) {
+		try {
+			ivjJPanel7 = new javax.swing.JPanel();
+			ivjJPanel7.setName("JPanel7");
+			ivjJPanel7.setLayout(getJPanel7FlowLayout());
+			getJPanel7().add(getJLabel4(), getJLabel4().getName());
+			getJPanel7().add(getSubmitDateTextField(), getSubmitDateTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel7;
+}
+
+
+/**
+ * Return the JPanel7FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel7FlowLayout() {
+	java.awt.FlowLayout ivjJPanel7FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel7FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel7FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel7FlowLayout;
+}
+
+
+/**
+ * Return the JPanel8 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel8() {
+	if (ivjJPanel8 == null) {
+		try {
+			ivjJPanel8 = new javax.swing.JPanel();
+			ivjJPanel8.setName("JPanel8");
+			ivjJPanel8.setLayout(getJPanel8FlowLayout());
+			getJPanel8().add(getJLabel5(), getJLabel5().getName());
+			getJPanel8().add(getStartDateTextField(), getStartDateTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel8;
+}
+
+
+/**
+ * Return the JPanel8FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel8FlowLayout() {
+	java.awt.FlowLayout ivjJPanel8FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel8FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel8FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel8FlowLayout;
+}
+
+
+/**
+ * Return the JPanel9 property value.
+ * @return javax.swing.JPanel
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JPanel getJPanel9() {
+	if (ivjJPanel9 == null) {
+		try {
+			ivjJPanel9 = new javax.swing.JPanel();
+			ivjJPanel9.setName("JPanel9");
+			ivjJPanel9.setLayout(getJPanel9FlowLayout());
+			getJPanel9().add(getJLabel6(), getJLabel6().getName());
+			getJPanel9().add(getEndDateTextField(), getEndDateTextField().getName());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJPanel9;
+}
+
+
+/**
+ * Return the JPanel9FlowLayout property value.
+ * @return java.awt.FlowLayout
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private java.awt.FlowLayout getJPanel9FlowLayout() {
+	java.awt.FlowLayout ivjJPanel9FlowLayout = null;
+	try {
+		/* Create part */
+		ivjJPanel9FlowLayout = new java.awt.FlowLayout();
+		ivjJPanel9FlowLayout.setAlignment(java.awt.FlowLayout.LEFT);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	};
+	return ivjJPanel9FlowLayout;
+}
+
+
+/**
+ * Return the JScrollPane1 property value.
+ * @return javax.swing.JScrollPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JScrollPane getJScrollPane1() {
+	if (ivjJScrollPane1 == null) {
+		try {
+			ivjJScrollPane1 = new javax.swing.JScrollPane();
+			ivjJScrollPane1.setName("JScrollPane1");
+			ivjJScrollPane1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), "Status Message"));
+			getJScrollPane1().setViewportView(getStatusMessageTextArea());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJScrollPane1;
+}
+
+/**
+ * Return the JScrollPane2 property value.
+ * @return javax.swing.JScrollPane
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JScrollPane getJScrollPane2() {
+	if (ivjJScrollPane2 == null) {
+		try {
+			ivjJScrollPane2 = new javax.swing.JScrollPane();
+			ivjJScrollPane2.setName("JScrollPane2");
+			ivjJScrollPane2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), "Solver Description"));
+			getJScrollPane2().setViewportView(getSolverDescTextArea());
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjJScrollPane2;
+}
+
+/**
+ * Return the NextButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getNextButton() {
+	if (ivjNextButton == null) {
+		try {
+			ivjNextButton = new javax.swing.JButton();
+			ivjNextButton.setName("NextButton");
+			ivjNextButton.setText("Next");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjNextButton;
+}
+
+
+/**
+ * Return the PrevButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getPrevButton() {
+	if (ivjPrevButton == null) {
+		try {
+			ivjPrevButton = new javax.swing.JButton();
+			ivjPrevButton.setName("PrevButton");
+			ivjPrevButton.setText("Previous");
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjPrevButton;
+}
+
+
+/**
+ * Return the ResubmitButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getResubmitButton() {
+	if (ivjResubmitButton == null) {
+		try {
+			ivjResubmitButton = new javax.swing.JButton();
+			ivjResubmitButton.setName("ResubmitButton");
+			ivjResubmitButton.setToolTipText("For Admin Use");
+			ivjResubmitButton.setText("Re-Submit");
+			ivjResubmitButton.setForeground(java.awt.Color.blue);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjResubmitButton;
+}
+
+/**
+ * Return the ServerIDTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getServerIDTextField() {
+	if (ivjServerIDTextField == null) {
+		try {
+			ivjServerIDTextField = new javax.swing.JTextField();
+			ivjServerIDTextField.setName("ServerIDTextField");
+			ivjServerIDTextField.setEditable(false);
+			ivjServerIDTextField.setColumns(18);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjServerIDTextField;
+}
+
+
+/**
+ * Return the JTextField2 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getSimIDTextField() {
+	if (ivjSimIDTextField == null) {
+		try {
+			ivjSimIDTextField = new javax.swing.JTextField();
+			ivjSimIDTextField.setName("SimIDTextField");
+			ivjSimIDTextField.setEditable(false);
+			ivjSimIDTextField.setColumns(12);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSimIDTextField;
+}
+
+/**
+ * Return the JTextArea1 property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getSolverDescTextArea() {
+	if (ivjSolverDescTextArea == null) {
+		try {
+			ivjSolverDescTextArea = new javax.swing.JTextArea();
+			ivjSolverDescTextArea.setName("SolverDescTextArea");
+			ivjSolverDescTextArea.setRows(0);
+			ivjSolverDescTextArea.setBackground(java.awt.Color.white);
+			ivjSolverDescTextArea.setBounds(0, 0, 1, 1);
+			ivjSolverDescTextArea.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSolverDescTextArea;
+}
+
+/**
+ * Return the JTextField4 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getStartDateTextField() {
+	if (ivjStartDateTextField == null) {
+		try {
+			ivjStartDateTextField = new javax.swing.JTextField();
+			ivjStartDateTextField.setName("StartDateTextField");
+			ivjStartDateTextField.setEditable(false);
+			ivjStartDateTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStartDateTextField;
+}
+
+/**
+ * Return the JTextArea1 property value.
+ * @return javax.swing.JTextArea
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextArea getStatusMessageTextArea() {
+	if (ivjStatusMessageTextArea == null) {
+		try {
+			ivjStatusMessageTextArea = new javax.swing.JTextArea();
+			ivjStatusMessageTextArea.setName("StatusMessageTextArea");
+			ivjStatusMessageTextArea.setLineWrap(true);
+			ivjStatusMessageTextArea.setWrapStyleWord(true);
+			ivjStatusMessageTextArea.setRows(0);
+			ivjStatusMessageTextArea.setBounds(0, 1, 1, 3);
+			ivjStatusMessageTextArea.setEditable(false);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStatusMessageTextArea;
+}
+
+/**
+ * Return the StopButton property value.
+ * @return javax.swing.JButton
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JButton getStopButton() {
+	if (ivjStopButton == null) {
+		try {
+			ivjStopButton = new javax.swing.JButton();
+			ivjStopButton.setName("StopButton");
+			ivjStopButton.setToolTipText("For Admin Use");
+			ivjStopButton.setText("Stop");
+			ivjStopButton.setForeground(java.awt.Color.red);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjStopButton;
+}
+
+/**
+ * Return the JTextField3 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getSubmitDateTextField() {
+	if (ivjSubmitDateTextField == null) {
+		try {
+			ivjSubmitDateTextField = new javax.swing.JTextField();
+			ivjSubmitDateTextField.setName("SubmitDateTextField");
+			ivjSubmitDateTextField.setEditable(false);
+			ivjSubmitDateTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjSubmitDateTextField;
+}
+
+/**
+ * Return the TaskIDTextField property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getTaskIDTextField() {
+	if (ivjTaskIDTextField == null) {
+		try {
+			ivjTaskIDTextField = new javax.swing.JTextField();
+			ivjTaskIDTextField.setName("TaskIDTextField");
+			ivjTaskIDTextField.setEditable(false);
+			ivjTaskIDTextField.setColumns(20);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjTaskIDTextField;
+}
+
+/**
+ * Return the JTextField1 property value.
+ * @return javax.swing.JTextField
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private javax.swing.JTextField getUserTextField() {
+	if (ivjUserTextField == null) {
+		try {
+			ivjUserTextField = new javax.swing.JTextField();
+			ivjUserTextField.setName("UserTextField");
+			ivjUserTextField.setEditable(false);
+			ivjUserTextField.setColumns(18);
+			// user code begin {1}
+			// user code end
+		} catch (java.lang.Throwable ivjExc) {
+			// user code begin {2}
+			// user code end
+			handleException(ivjExc);
+		}
+	}
+	return ivjUserTextField;
+}
+
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+
+
+/**
+ * Initializes connections
+ * @exception java.lang.Exception The exception description.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initConnections() throws java.lang.Exception {
+	// user code begin {1}
+	// user code end
+	getCloseButton().addActionListener(ivjEventHandler);
+	getStopButton().addActionListener(ivjEventHandler);
+	getResubmitButton().addActionListener(ivjEventHandler);
+	getNextButton().addActionListener(ivjEventHandler);
+	getPrevButton().addActionListener(ivjEventHandler);
+}
+
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		// user code begin {1}
+		// user code end
+		setName("SimulationJobStatusDetailDialog");
+		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+		setSize(561, 428);
+		setTitle("Simulation Status");
+		setContentPane(getJDialogContentPane());
+		initConnections();
+		connEtoC4();
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+	// user code begin {2}
+	// user code end
+}
+
+/**
+ * main entrypoint - starts the part when it is run as an application
+ * @param args java.lang.String[]
+ */
+public static void main(java.lang.String[] args) {
+	try {
+		SimulationJobStatusDetailDialog aSimulationJobStatusDetailDialog;
+		aSimulationJobStatusDetailDialog = new SimulationJobStatusDetailDialog();
+		aSimulationJobStatusDetailDialog.setModal(true);
+		aSimulationJobStatusDetailDialog.addWindowListener(new java.awt.event.WindowAdapter() {
+			public void windowClosing(java.awt.event.WindowEvent e) {
+				System.exit(0);
+			};
+		});
+		aSimulationJobStatusDetailDialog.show();
+		java.awt.Insets insets = aSimulationJobStatusDetailDialog.getInsets();
+		aSimulationJobStatusDetailDialog.setSize(aSimulationJobStatusDetailDialog.getWidth() + insets.left + insets.right, aSimulationJobStatusDetailDialog.getHeight() + insets.top + insets.bottom);
+		aSimulationJobStatusDetailDialog.setVisible(true);
+	} catch (Throwable exception) {
+		System.err.println("Exception occurred in main() of javax.swing.JDialog");
+		exception.printStackTrace(System.out);
+	}
+}
+
+
+/**
+ * Comment
+ */
+public void nextButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	currentSelected ++;
+	setStatus();
+}
+
+
+/**
+ * Comment
+ */
+public void prevButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	currentSelected --;
+	setStatus();
+}
+
+
+/**
+ * Comment
+ */
+public void resubmitButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	int n = javax.swing.JOptionPane.showConfirmDialog(this, "Are you sure you would like to resubmit this simulation?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+	if (n == javax.swing.JOptionPane.YES_OPTION) {	
+		resubmitSimulation();
+		getResubmitButton().setEnabled(false);
+		getStopButton().setEnabled(true);
+	}		
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:15:52 PM)
+ */
+public void resubmitSimulation() {
+	smConsole.resubmitSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:05:24 PM)
+ */
+public void setStatus() {
+	jobStatus = smConsole.getReturnedSimulationJobStatus(currentSelected);
+	setTitle("Simulation Status [" + jobStatus.getUserID() + "," + jobStatus.getVCSimulationIdentifier().getSimulationKey() + "]");
+	getUserTextField().setText(jobStatus.getUserID());
+	getSimIDTextField().setText(jobStatus.getVCSimulationIdentifier().getSimulationKey() + "");
+	getJobIndexTextField().setText(jobStatus.getJobIndex() + "");
+	getComputeHostTextField().setText(jobStatus.getComputeHost());
+	getSubmitDateTextField().setText(jobStatus.getSubmitDate() == null ? "" : dateTimeFormatter.format(jobStatus.getSubmitDate()));
+	getStartDateTextField().setText(jobStatus.getStartDate() == null ? "" : dateTimeFormatter.format(jobStatus.getStartDate()));
+	getEndDateTextField().setText(jobStatus.getEndDate() == null ? "" : dateTimeFormatter.format(jobStatus.getEndDate()));
+	getServerIDTextField().setText(jobStatus.getEndDate() == null ? "" : jobStatus.getServerID());
+	getTaskIDTextField().setText(jobStatus.getTaskID() == null ? "" : jobStatus.getTaskID() + "");
+	getSolverDescTextArea().setText(jobStatus.getSolverDescriptionVCML());
+	getSolverDescTextArea().setCaretPosition(0);
+	getStatusMessageTextArea().setText(jobStatus.getStatusMessage());
+	getStatusMessageTextArea().setCaretPosition(0);
+	getStopButton().setEnabled(false);
+	getResubmitButton().setEnabled(false);
+	if (jobStatus.isDone()) {
+		getResubmitButton().setEnabled(true);		
+	} else {
+		getStopButton().setEnabled(true);
+	}
+	
+	if (currentSelected <= 0) {
+		getPrevButton().setEnabled(false);
+	} else {
+		getPrevButton().setEnabled(true);
+	}
+
+	if (currentSelected >= totalNumber - 1) {
+		getNextButton().setEnabled(false);
+	} else {
+		getNextButton().setEnabled(true);
+	}
+	smConsole.setSelectedReturnedSimulationJobStatus(currentSelected);
+}
+
+
+/**
+ * Comment
+ */
+public void simulationJobStatusDetailDialog_Initialize() {
+	return;
+}
+
+
+/**
+ * Comment
+ */
+public void stopButton_ActionPerformed(java.awt.event.ActionEvent actionEvent) {
+	int n = javax.swing.JOptionPane.showConfirmDialog(this, "Are you sure you would like to stop this simulation?", "Confirm", javax.swing.JOptionPane.YES_NO_OPTION);
+	if (n == javax.swing.JOptionPane.YES_OPTION) {	
+		stopSimulation();
+		getStopButton().setEnabled(false);
+		getResubmitButton().setEnabled(true);
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:15:42 PM)
+ */
+public void stopSimulation() {
+	smConsole.stopSimulation(jobStatus.getUserID(), jobStatus.getVCSimulationIdentifier().getSimulationKey());
+}
+}
Index: src/cbit/vcell/messaging/admin/UserConnectionTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/UserConnectionTableModel.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/UserConnectionTableModel.java	(revision 12031)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import java.util.Comparator;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+/**
+ * Insert the type's description here.
+ * Creation date: (2/27/2006 10:21:21 AM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class UserConnectionTableModel extends VCellSortTableModel<ComparableObject> {
+	private final static int columnIndex_UserID = 0;
+	//private final static int columnIndex_ElapsedTime = 2;
+	//private final static int columnIndex_ConnectedTime = 1;
+
+/**
+ * UserConnectionTableModel constructor comment.
+ */
+public UserConnectionTableModel() {
+	super(new String[]{"User ID"});
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2003 2:14:05 PM)
+ * @return java.lang.Class
+ * @param columnIndex int
+ */
+public Class<?> getColumnClass(int columnIndex) {
+	if (columnIndex == columnIndex_UserID) {
+		return String.class;
+	}
+
+	return null;
+}
+
+
+	/**
+	 * Returns an attribute value for the cell at <I>columnIndex</I>
+	 * and <I>rowIndex</I>.
+	 *
+	 * @param	rowIndex	the row whose value is to be looked up
+	 * @param	columnIndex 	the column whose value is to be looked up
+	 * @return	the value Object at the specified cell
+	 */
+public Object getValueAt(int row, int col) {
+	ComparableObject userconn = getValueAt(row);
+	Object[] values = userconn.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+}
Index: src/cbit/vcell/messaging/admin/ServerPerformance.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServerPerformance.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServerPerformance.java	(revision 12031)
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+/**
+ * This type was created in VisualAge.
+ */
+public class ServerPerformance extends Performance {
+	
+	private float fractionFreeCPU = 0.0f;
+	private long freeMemoryBytes = -1;
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServerPerformance() {		
+}
+/**
+ * ProcessStatus constructor comment.
+ */
+public ServerPerformance(float aFractionFreeCPU, long aFreeMemoryBytes, long aFreeJavaMemoryBytes, long aTotalJavaMemoryBytes, long aMaxJavaMemoryBytes) {		
+	this.fractionFreeCPU = aFractionFreeCPU;
+	this.freeMemoryBytes = aFreeMemoryBytes;
+	this.freeJavaMemoryBytes = aFreeJavaMemoryBytes;
+	this.totalJavaMemoryBytes = aTotalJavaMemoryBytes;
+	this.maxJavaMemoryBytes = aMaxJavaMemoryBytes;	
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/28/01 7:04:11 PM)
+ * @return long
+ */
+public long getAvaillableJavaMemoryBytes() {
+
+	double JVM_MEMORY_TRUST_FACTOR = 0.8;
+	long currentJVMUsage = getTotalJavaMemoryBytes()-getFreeJavaMemoryBytes();
+	
+	return (long)(JVM_MEMORY_TRUST_FACTOR*(getMaxJavaMemoryBytes() - currentJVMUsage));
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public float getFractionFreeCPU() {
+	return fractionFreeCPU;
+}
+/**
+ * This method was created in VisualAge.
+ * @return float
+ */
+public long getFreeMemoryBytes() {
+	return freeMemoryBytes;
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public Object[] toObjects() {
+	return new Object[] {		
+		(new Double(getFractionFreeCPU()*100.0)),
+		new Long(getFreeMemoryBytes()),
+		new Long(getFreeJavaMemoryBytes()), new Long(getTotalJavaMemoryBytes()),  new Long(getMaxJavaMemoryBytes())
+	};
+}
+/**
+ * This method was created in VisualAge.
+ * @return java.lang.String
+ */
+public String toString() {
+	return "ServerPerformanceStatus: "+					
+			"FreeMemory="+getFreeMemoryBytes()+" bytes, "+
+			"FreeCPU="+(getFractionFreeCPU()*100.0)+"%\n"+
+			"JVM Memory (free="+getFreeJavaMemoryBytes()+", total="+getTotalJavaMemoryBytes()+", max="+getMaxJavaMemoryBytes()+") bytes";
+}
+}
Index: src/cbit/vcell/messaging/admin/SimpleJobStatus.java
===================================================================
--- src/cbit/vcell/messaging/admin/SimpleJobStatus.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/SimpleJobStatus.java	(revision 12031)
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+import cbit.vcell.solver.VCSimulationIdentifier;
+import java.math.BigDecimal;
+
+import org.vcell.util.ComparableObject;
+
+import cbit.vcell.messaging.db.SimulationJobStatus;
+import cbit.vcell.solver.SolverTaskDescription;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (9/3/2003 10:39:26 AM)
+ * @author: Fei Gao
+ */
+public class SimpleJobStatus implements ComparableObject {
+	private String userID = null;
+	private SimulationJobStatus jobStatus = null;
+	private SolverTaskDescription solverTaskDesc = null;
+	private Long elapsedTime = null;
+
+/**
+ * SimpleJobStatus constructor comment.
+ */
+public SimpleJobStatus(String user, SimulationJobStatus arg_jobStatus, SolverTaskDescription arg_solverTaskDesc) {	
+	super();
+	this.userID = user;
+	this.jobStatus = arg_jobStatus;
+	this.solverTaskDesc = arg_solverTaskDesc;
+	this.elapsedTime = null;
+	if (getStartDate()!=null){
+		if (getEndDate()!=null){
+			this.elapsedTime = ((getEndDate().getTime()-getStartDate().getTime()));
+		}else if (jobStatus.getSchedulerStatus().isRunning()){
+			this.elapsedTime = ((System.currentTimeMillis()-getStartDate().getTime()));
+		}
+	}
+
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getComputeHost() {
+	if (jobStatus == null) {
+		return null;
+	}	
+	return jobStatus.getComputeHost();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.util.Date
+ */
+public java.util.Date getEndDate() {
+	if (jobStatus == null) {
+		return null;
+	}
+	return jobStatus.getEndDate();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public Integer getJobIndex() {
+	if (jobStatus == null || jobStatus.getServerID() == null) {
+		return null;
+	}	
+	return new Integer(jobStatus.getJobIndex());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getServerID() {
+	if (jobStatus == null || jobStatus.getServerID() == null) {
+		return null;
+	}	
+	return jobStatus.getServerID().toString();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/8/2004 1:29:11 PM)
+ * @return java.lang.String
+ */
+public String getSolverDescriptionVCML() {
+	if (solverTaskDesc == null) {
+		return "Error: Null Solver Description";
+	}
+	return solverTaskDesc.getVCML();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.util.Date
+ */
+public java.util.Date getStartDate() {
+	if (jobStatus == null) {
+		return null;
+	}
+	return jobStatus.getStartDate();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 2:47:11 PM)
+ * @return java.lang.String
+ */
+public String getStatusMessage() {
+	return jobStatus.getSimulationMessage().getDisplayMessage();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.util.Date
+ */
+public java.util.Date getSubmitDate() {
+	return jobStatus.getSubmitDate();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public Integer getTaskID() {
+	if (jobStatus == null || jobStatus.getServerID() == null) {
+		return null;
+	}	
+	return new Integer(jobStatus.getTaskID());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (3/29/2004 2:09:31 PM)
+ * @return java.lang.String
+ */
+public java.lang.String getUserID() {
+	return userID;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/17/2003 2:54:17 PM)
+ * @return cbit.sql.KeyValue
+ */
+public VCSimulationIdentifier getVCSimulationIdentifier() {
+	return jobStatus.getVCSimulationIdentifier();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/19/2004 3:21:23 PM)
+ * @return boolean
+ */
+public boolean isDone() {
+	return jobStatus.getSchedulerStatus().isDone();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/7/2004 8:53:02 AM)
+ * @return boolean
+ */
+public boolean isRunning() {
+	return jobStatus.getSchedulerStatus().isRunning();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (9/3/2003 10:45:39 AM)
+ * @return java.lang.String[]
+ */
+public Object[] toObjects() {	
+	return new Object[] {userID,  new BigDecimal(getVCSimulationIdentifier().getSimulationKey().toString()), getJobIndex(), 
+		solverTaskDesc == null || solverTaskDesc.getSolverDescription() == null ? "" : solverTaskDesc.getSolverDescription().getDisplayLabel(), 		
+		getStatusMessage(), getComputeHost(), getServerID(), getTaskID(), getSubmitDate(), getStartDate(), getEndDate(),
+		elapsedTime};
+}
+}
Index: src/cbit/vcell/messaging/admin/SolverTaskDescriptionRenderer.java
===================================================================
--- src/cbit/vcell/messaging/admin/SolverTaskDescriptionRenderer.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/SolverTaskDescriptionRenderer.java	(revision 12031)
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+/**
+ * Insert the type's description here.
+ * Creation date: (7/8/2004 2:26:27 PM)
+ * @author: Fei Gao
+ */
+public class SolverTaskDescriptionRenderer extends javax.swing.table.DefaultTableCellRenderer {
+/**
+ * SolverTaskDescriptionRenderer constructor comment.
+ */
+public SolverTaskDescriptionRenderer() {
+	super();
+}
+
+
+	/**
+	 *  This method is sent to the renderer by the drawing table to
+	 *  configure the renderer appropriately before drawing.  Return
+	 *  the Component used for drawing.
+	 *
+	 * @param	table		the JTable that is asking the renderer to draw.
+	 *				This parameter can be null.
+	 * @param	value		the value of the cell to be rendered.  It is
+	 *				up to the specific renderer to interpret
+	 *				and draw the value.  eg. if value is the
+	 *				String "true", it could be rendered as a
+	 *				string or it could be rendered as a check
+	 *				box that is checked.  null is a valid value.
+	 * @param	isSelected	true is the cell is to be renderer with
+	 *				selection highlighting
+	 * @param	row	        the row index of the cell being drawn.  When
+	 *				drawing the header the rowIndex is -1.
+	 * @param	column	        the column index of the cell being drawn
+	 */
+public java.awt.Component getTableCellRendererComponent(javax.swing.JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
+	super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
+	setText(value.toString());
+	setToolTipText(value.toString());
+	return this;
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceInstanceStatus.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceInstanceStatus.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceInstanceStatus.java	(revision 12031)
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.io.Serializable;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.Matchable;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.document.VCellServerID;
+
+
+public class ServiceInstanceStatus implements Matchable, Serializable, ComparableObject {
+	private VCellServerID serverID;
+	private ServiceType type;
+	private int ordinal;
+	private Date startDate;
+	private String hostname;	
+	private boolean bRunning = false;
+		
+	public ServiceInstanceStatus(VCellServerID sID, ServiceType t, int o, String h, Date d, boolean br) {
+		super();
+		this.serverID = sID;
+		this.type = t;
+		this.ordinal = o;
+		hostname = h;
+		startDate = d;
+		this.bRunning = br;
+	}
+	
+	public int getOrdinal() {
+		return ordinal;
+	}
+
+	public VCellServerID getServerID() {
+		return serverID;
+	}
+
+	public ServiceType getType() {
+		return type;
+	}
+	
+	public String toString() {
+		return "[" + serverID + "," + type + "," + ordinal + "," + "," + hostname + "," + startDate + "," + bRunning + "]";
+	}
+
+	public String getID() {
+		return getSpecID() + "_" + hostname + "_" + startDate.getTime();
+	}
+	
+	public String getSpecID() {
+		return ServiceSpec.getServiceID(serverID, type, ordinal);
+	}
+	
+	public Object[] toObjects() {
+		return new Object[] {serverID, type, ordinal, hostname, startDate, bRunning};
+	}
+		
+	public boolean equals(Object obj) {
+		if (obj instanceof Matchable) {
+			return compareEqual((Matchable)obj);
+		}
+		return false;
+	}
+	
+	public int hashCode() {
+		return getID().hashCode();
+	}
+	
+	public boolean compareEqual(Matchable obj) {
+		if (obj instanceof ServiceInstanceStatus) {
+			ServiceInstanceStatus ss = (ServiceInstanceStatus)obj;
+		
+			if (!serverID.equals(ss.serverID)) {
+				return false;
+			}
+			if (!type.equals(ss.type)) {
+				return false;
+			}
+			if (ordinal != ss.ordinal) {
+				return false;
+			}		
+			if (!hostname.equals(ss.hostname)) {
+				return false;
+			}
+			if (!startDate.equals(ss.startDate)) {
+				return false;
+			}
+			return true;
+		}		
+		return false;
+	}
+
+	public boolean isRunning() {
+		return bRunning;
+	}
+
+	public void setRunning(boolean running) {
+		bRunning = running;
+	}
+
+	public Date getStartDate() {
+		return startDate;
+	}
+}
Index: src/cbit/vcell/messaging/admin/DatePanel.java
===================================================================
--- src/cbit/vcell/messaging/admin/DatePanel.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/DatePanel.java	(revision 12031)
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+
+import javax.swing.JLabel;
+import javax.swing.JTextField;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/29/2003 2:51:26 PM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class DatePanel extends javax.swing.JPanel {
+	private javax.swing.JComboBox ivjDayCombo = null;
+	private javax.swing.JComboBox ivjMonthCombo = null;
+	private javax.swing.JComboBox ivjYearCombo = null;
+	private IvjEventHandler ivjEventHandler = new IvjEventHandler();
+
+	private class IvjEventHandler implements java.awt.event.ItemListener {
+		public void itemStateChanged(java.awt.event.ItemEvent e) {
+			if (e.getSource() == DatePanel.this.getMonthCombo()) 
+				monthCombo_ItemEvent();
+			if (e.getSource() == DatePanel.this.getYearCombo()) 
+				yearCombo_ItemEvent();
+		}
+	};
+/**
+ * DatePanel constructor comment.
+ */
+public DatePanel() {
+	super();
+	initialize();
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/29/2003 3:04:18 PM)
+ */
+private void changeMonth() {
+	int month = Integer.parseInt((String)getMonthCombo().getSelectedItem());
+	int year = Integer.parseInt((String)getYearCombo().getSelectedItem());
+	java.util.GregorianCalendar cal = new java.util.GregorianCalendar(year, month - 1, 1);
+	getDayCombo().removeAllItems();
+
+	int maxday = cal.getActualMaximum(java.util.Calendar.DAY_OF_MONTH);
+	for (int i = 1; i <= maxday; i++){
+		getDayCombo().addItem(i + "");	
+	}
+}
+/**
+ * Comment
+ */
+public void reset() {
+	updateInterface(new GregorianCalendar());
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (8/29/2003 3:17:06 PM)
+ * @return java.util.Date
+ */
+public Date getDate() {
+	int month = Integer.parseInt((String)getMonthCombo().getSelectedItem());
+	int day  = Integer.parseInt((String)getDayCombo().getSelectedItem());
+	int year = Integer.parseInt((String)getYearCombo().getSelectedItem());
+
+	java.util.GregorianCalendar calendar = new java.util.GregorianCalendar(year, month - 1, day);
+	return calendar.getTime();
+}
+
+/**
+ * Return the JComboBox2 property value.
+ * @return javax.swing.JComboBox
+ */
+private javax.swing.JComboBox getDayCombo() {
+	if (ivjDayCombo == null) {
+		try {
+			ivjDayCombo = new javax.swing.JComboBox();
+			ivjDayCombo.setName("DayCombo");
+			ivjDayCombo.setToolTipText("Day");
+			JTextField tf = new JTextField(4);
+			ivjDayCombo.setPreferredSize(tf.getPreferredSize());
+			ivjDayCombo.setEditable(true);
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjDayCombo;
+}
+/**
+ * Return the JComboBox1 property value.
+ * @return javax.swing.JComboBox
+ */
+private javax.swing.JComboBox getMonthCombo() {
+	if (ivjMonthCombo == null) {
+		try {
+			ivjMonthCombo = new javax.swing.JComboBox();
+			ivjMonthCombo.setName("MonthCombo");
+			ivjMonthCombo.setToolTipText("Month");
+			ivjMonthCombo.setEditable(true);
+			JTextField tf = new JTextField(4);
+			ivjMonthCombo.setPreferredSize(tf.getPreferredSize());
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjMonthCombo;
+}
+/**
+ * Return the JComboBox3 property value.
+ * @return javax.swing.JComboBox
+ */
+private javax.swing.JComboBox getYearCombo() {
+	if (ivjYearCombo == null) {
+		try {
+			ivjYearCombo = new javax.swing.JComboBox();
+			ivjYearCombo.setName("YearCombo");
+			ivjYearCombo.setToolTipText("Year");
+			JTextField tf = new JTextField(6);
+			ivjYearCombo.setPreferredSize(tf.getPreferredSize());
+			ivjYearCombo.setEditable(true);
+		} catch (java.lang.Throwable ivjExc) {
+			handleException(ivjExc);
+		}
+	}
+	return ivjYearCombo;
+}
+/**
+ * Called whenever the part throws an exception.
+ * @param exception java.lang.Throwable
+ */
+private void handleException(java.lang.Throwable exception) {
+
+	/* Uncomment the following lines to print uncaught exceptions to stdout */
+	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
+	// exception.printStackTrace(System.out);
+}
+/**
+ * Initialize the class.
+ */
+/* WARNING: THIS METHOD WILL BE REGENERATED. */
+private void initialize() {
+	try {
+		setName("DatePanel");
+		setLayout(new GridBagLayout());
+		GridBagConstraints gbc = new GridBagConstraints();
+		gbc.gridx = 0;
+		gbc.gridy = 0;
+		gbc.weightx = 1.0;
+		gbc.anchor = GridBagConstraints.LINE_START;
+		gbc.fill = GridBagConstraints.HORIZONTAL;
+		add(getMonthCombo(), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 1;
+		gbc.gridy = 0;
+		add(new JLabel("/"), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 2;
+		gbc.gridy = 0;
+		gbc.weightx = 1.0;
+		gbc.anchor = GridBagConstraints.LINE_START;
+		gbc.fill = GridBagConstraints.HORIZONTAL;
+		add(getDayCombo(), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 3;
+		gbc.gridy = 0;
+		add(new JLabel("/"), gbc);
+		
+		gbc = new GridBagConstraints();
+		gbc.gridx = 4;
+		gbc.gridy = 0;
+		gbc.weightx = 1;
+		gbc.anchor = GridBagConstraints.LINE_START;
+		gbc.fill = GridBagConstraints.HORIZONTAL;
+		add(getYearCombo(), gbc);
+		
+		Calendar cal = new GregorianCalendar();
+		int currYear = cal.get(java.util.Calendar.YEAR);
+		for (int i = -20; i <= 0; i ++) {
+			getYearCombo().addItem((i + currYear) + "");
+		}
+		for (int i = 1; i <= 12; i ++) {
+			getMonthCombo().addItem(i + "");
+		}
+		updateInterface(cal);
+		getMonthCombo().addItemListener(ivjEventHandler);
+		getYearCombo().addItemListener(ivjEventHandler);
+	} catch (java.lang.Throwable ivjExc) {
+		handleException(ivjExc);
+	}
+}
+/**
+ * Comment
+ */
+private void monthCombo_ItemEvent() {
+	changeMonth();
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (9/3/2003 8:02:44 AM)
+ */
+private void updateInterface(Calendar calendar) {
+	for (int i = 1; i <= calendar.getActualMaximum(java.util.Calendar.DAY_OF_MONTH); i ++) {
+		getDayCombo().addItem(i + "");
+	}
+	getYearCombo().setSelectedItem(calendar.get(java.util.Calendar.YEAR) + "");
+	getMonthCombo().setSelectedItem((calendar.get(java.util.Calendar.MONTH) + 1) + "");
+	getDayCombo().setSelectedItem(calendar.get(java.util.Calendar.DATE) + "");	
+}
+
+@Override
+public void setEnabled(boolean enabled) {
+	getYearCombo().setEnabled(enabled);
+	getMonthCombo().setEnabled(enabled);
+	getDayCombo().setEnabled(enabled);
+	super.setEnabled(enabled);
+}
+/**
+ * Comment
+ */
+private void yearCombo_ItemEvent() {
+	changeMonth();
+	return;
+}
+
+public void setCalendar(Calendar cal) {
+	updateInterface(cal);
+}
+}
Index: src/cbit/vcell/messaging/admin/ServiceStatusTableModel.java
===================================================================
--- src/cbit/vcell/messaging/admin/ServiceStatusTableModel.java	(revision 0)
+++ src/cbit/vcell/messaging/admin/ServiceStatusTableModel.java	(revision 12031)
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging.admin;
+
+import java.util.Comparator;
+import java.util.Date;
+
+import org.vcell.util.ComparableObject;
+import org.vcell.util.MessageConstants.ServiceType;
+import org.vcell.util.gui.sorttable.ColumnComparator;
+
+import cbit.vcell.client.desktop.biomodel.VCellSortTableModel;
+
+
+/**
+ * Insert the type's description here.
+ * Creation date: (8/19/2003 2:24:48 PM)
+ * @author: Fei Gao
+ */
+@SuppressWarnings("serial")
+public class ServiceStatusTableModel extends VCellSortTableModel<ComparableObject> {
+/**
+ * ServiceStatusTableModel constructor comment.
+ */
+public ServiceStatusTableModel() {
+	super(new String[] {"Site", "Type", "Ordinal", "Startup Type", "MemoryMB", "Date", "Status", "Status Message", "PBS Job ID"});
+}
+
+/**
+ * Insert the method's description here.
+ * Creation date: (8/19/2003 2:14:05 PM)
+ * @return java.lang.Class
+ * @param columnIndex int
+ */
+public Class<?> getColumnClass(int columnIndex) {
+	if (columnIndex == 5) {
+		return Date.class;
+	} else if (columnIndex == 2 || columnIndex == 4) {
+		return Number.class;
+	} else if (columnIndex == 1) {
+		return ServiceType.class;
+	} else {
+		return String.class;
+	}
+}
+/**
+ * getValueAt method comment.
+ */
+public Object getValueAt(int row, int col) {	
+	ComparableObject serviceStatus = getValueAt(row);
+	Object[] values = serviceStatus.toObjects();
+	return values[col];
+}
+
+public Comparator<ComparableObject> getComparator(int col, boolean ascending) {
+	return new ColumnComparator(col, ascending);
+}
+}
Index: src/cbit/vcell/messaging/RpcServerMessaging.java
===================================================================
--- src/cbit/vcell/messaging/RpcServerMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/RpcServerMessaging.java	(revision 12031)
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.PropertyLoader;
+import org.vcell.util.SessionLog;
+
+import java.io.Serializable;
+import cbit.rmi.event.ExportEvent;
+import cbit.vcell.messaging.server.RpcServer;
+import cbit.vcell.messaging.server.RpcRequest;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/15/2003 10:08:03 AM)
+ * @author: Fei Gao
+ */
+public class RpcServerMessaging extends JmsServiceProviderMessaging implements QueueListener, ControlTopicListener {
+	private JmsSession clientRequestReceiver = null;
+	private String queueName = null;
+	private String msgSelector = null;
+
+/**
+ * RpcMessaging constructor comment.
+ * @param argJmsFactory cbit.vcell.messaging.JmsFactory
+ * @param slog cbit.vcell.server.SessionLog
+ */
+public RpcServerMessaging(RpcServer rpcServer, String qname, String selector, SessionLog log0) throws javax.jms.JMSException {
+	super(rpcServer, log0);
+	queueName = qname;
+	msgSelector = selector;
+
+	reconnect();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/23/2001 3:58:52 PM)
+ * @param message javax.jms.Message
+ */
+public void onQueueMessage(Message message) {
+	try {
+		long t = System.currentTimeMillis();
+		
+		if (message == null) {
+			try {
+				clientRequestReceiver.rollback(); // no message so far
+			} catch (Exception ex) {
+				log.exception(ex);
+			}			
+			return;
+		}
+			
+		log.print("onClientRequestMessage[" + JmsUtils.toString(message) + "]");
+		if (!(message instanceof ObjectMessage)) {
+			clientRequestReceiver.commit(); // ignore the bad messages
+			return;
+		}
+
+		Object obj = ((ObjectMessage) message).getObject();
+		if (!(obj instanceof RpcRequest)) {
+			clientRequestReceiver.commit(); // ignore the bad messages
+			return;
+		}
+		
+		RpcRequest request = (RpcRequest)obj;	
+		log.print(request + "");
+			
+		java.io.Serializable returnValue = null;
+		try {
+			returnValue = (Serializable) ((RpcServer)jmsServiceProvider).dispatchRPC(request);
+		} catch (Exception ex) {
+			log.exception(ex);
+			returnValue = ex; // if exception occurs, send client the exception
+		}
+
+		if (returnValue != null && returnValue.getClass().isArray()) {
+			Class<?> componentClass = returnValue.getClass().getComponentType();
+			if (!componentClass.isPrimitive() && !Serializable.class.isAssignableFrom(componentClass)) {
+				returnValue = new ClassCastException("Not serializable:" + componentClass);
+			}
+		}
+		t = System.currentTimeMillis() - t;
+
+		// if client is not waiting any more, why bother sending the reply. Plus the temporary queue
+		// has been deleted if client has timed out.
+		long clientTimeoutMS = Long.parseLong(org.vcell.util.PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.vcellClientTimeoutMS)); 
+		if (t < clientTimeoutMS) {		
+			Queue replyTo = (Queue)message.getJMSReplyTo();
+			if (replyTo != null) {
+				Message replyMessage = clientRequestReceiver.createObjectMessage(returnValue);
+				replyMessage.setStringProperty(MessageConstants.METHOD_NAME_PROPERTY, request.getMethodName());
+				replyMessage.setJMSCorrelationID(message.getJMSMessageID());
+				
+				clientRequestReceiver.sendMessage(replyTo, replyMessage, DeliveryMode.NON_PERSISTENT, clientTimeoutMS);
+				
+				if (returnValue == null) {
+					log.print("sendClientResponse[null]");
+				} else {
+					log.print("sendClientResponse[" + returnValue.getClass() + "@" + Integer.toHexString(returnValue.hashCode()) + "]");
+				}			
+			}
+		}
+		
+		clientRequestReceiver.commit();		//commit
+			
+	} catch (JMSException e) {
+		log.exception(e);
+		
+		// roll it back if fail
+		try {
+			clientRequestReceiver.rollback();
+		} catch (Exception ex) {
+			log.exception(ex);
+		}		
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+public void publishDataStatus(cbit.rmi.event.DataJobEvent event) throws JMSException  {
+	try {
+		JmsSession dataSession = jmsConn.getAutoSession();
+		Message rpcMessage = dataSession.createObjectMessage(event);
+		rpcMessage.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_DATA_EVENT_VALUE);
+		rpcMessage.setStringProperty(MessageConstants.USERNAME_PROPERTY, event.getUser().getName());
+		
+		dataSession.publishMessage(JmsUtils.getTopicClientStatus(), rpcMessage);
+		log.print("publishing data status: " + event);		
+		jmsConn.closeSession(dataSession);
+			
+	} catch (Exception e){
+		log.exception(e);
+		throw new JMSException("RpcServerMessaging.publishExportStatus(): " + e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ */
+public void publishExportStatus(ExportEvent event) throws JMSException  {
+	try {
+		JmsSession exportSession = jmsConn.getAutoSession();
+		Message rpcMessage = exportSession.createObjectMessage(event);
+		rpcMessage.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_EXPORT_EVENT_VALUE);
+		rpcMessage.setStringProperty(MessageConstants.USERNAME_PROPERTY, event.getUser().getName());
+		
+		exportSession.publishMessage(JmsUtils.getTopicClientStatus(), rpcMessage);
+		log.print("publishing export status: " + event);		
+		jmsConn.closeSession(exportSession);
+			
+	} catch (Exception e){
+		log.exception(e);
+		throw new JMSException("RpcServerMessaging.publishExportStatus(): " + e.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+protected void reconnect() throws JMSException {
+	super.reconnect();
+	
+	clientRequestReceiver = jmsConn.getTransactedSession(); // transactional	
+	int servicePrefetchCount = Integer.parseInt(PropertyLoader.getProperty(PropertyLoader.jmsServicePrefetchCount, "-1"));
+	if (servicePrefetchCount > 0) {
+		log.print("servicePrefetchCount=" + servicePrefetchCount);
+		clientRequestReceiver.setPrefetchCount(servicePrefetchCount); // get messages one by one
+	}
+	clientRequestReceiver.setupQueueListener(queueName, msgSelector, new QueueMessageCollector(this));
+	jmsConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+public void startListening() throws JMSException {
+	log.print("I am starting to take requests!");
+	jmsConn.startConnection();
+}
+}
Index: src/cbit/vcell/messaging/BatchScheduler.java
===================================================================
--- src/cbit/vcell/messaging/BatchScheduler.java	(revision 0)
+++ src/cbit/vcell/messaging/BatchScheduler.java	(revision 12031)
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import java.util.Hashtable;
+
+import org.vcell.util.SessionLog;
+import org.vcell.util.document.User;
+import org.vcell.util.document.VCellServerID;
+
+import cbit.vcell.messaging.db.SimulationJobStatusInfo;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/11/2006 9:32:17 AM)
+ * @author: Jim Schaff
+ */
+public class BatchScheduler {
+/**
+ * BatchScheduler constructor comment.
+ */
+public BatchScheduler() {
+	super();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (5/11/2006 9:32:58 AM)
+ */
+public static SimulationJobStatusInfo schedule(SimulationJobStatusInfo[] allActiveJobs, int globalPdeQuota, int userQuotaOde, int userQuotaPde, VCellServerID systemID, SessionLog log) {
+	Hashtable<User, Integer> userPdeRunningJobs = new Hashtable<User, Integer>();
+	Hashtable<User, Integer> userOdeRunningJobs = new Hashtable<User, Integer>();
+
+	cbit.vcell.messaging.db.SimulationJobStatus jobStatus = null;
+	int runningPDEs = 0;
+	for (int i = 0; i < allActiveJobs.length; i++){
+		jobStatus = allActiveJobs[i].getSimJobStatus();
+
+		if (!jobStatus.getSchedulerStatus().isActive()) {
+			continue;
+		}
+		
+		if (jobStatus.getSchedulerStatus().isWaiting()) {
+			continue;  // we only do statistics on running jobs;
+		}
+		
+		if (allActiveJobs[i].isPDE()) {
+			runningPDEs ++; // running PDE jobs
+		}
+		
+		if (jobStatus.getServerID().equals(systemID)) { // the number of running jobs on this site
+			User user = allActiveJobs[i].getUser();
+			if(allActiveJobs[i].isPDE()) {
+				Integer numUserPdeJobs = userPdeRunningJobs.get(user);
+				if (numUserPdeJobs == null) {
+					userPdeRunningJobs.put(user, 1);
+				} else {
+					userPdeRunningJobs.put(user, numUserPdeJobs.intValue() + 1);
+				}
+			} else {
+				Integer numUserOdeJobs = userOdeRunningJobs.get(user);
+				if (numUserOdeJobs == null) {
+					userOdeRunningJobs.put(user, 1);
+				} else {
+					userOdeRunningJobs.put(user, numUserOdeJobs.intValue() + 1);
+				}
+			}
+		}
+	}	
+	for (int i = 0; i < allActiveJobs.length; i++){
+		jobStatus = allActiveJobs[i].getSimJobStatus();
+			
+		if (!jobStatus.getSchedulerStatus().isWaiting()) {
+			continue; // ignore non-waiting job
+		}
+			
+		if (!jobStatus.getServerID().equals(systemID)) {
+			continue; // doesn't belong
+		}
+		
+		User user = allActiveJobs[i].getUser();
+		if (allActiveJobs[i].isPDE() && runningPDEs >= globalPdeQuota) {
+			log.print("Global PDE quota reached [" + jobStatus.getVCSimulationIdentifier() + "]");
+			continue; // global LSF quota violated
+		}							
+
+		if(allActiveJobs[i].isPDE()) {
+			Object numUserPdeJobs = userPdeRunningJobs.get(user);
+			if (numUserPdeJobs != null) {
+				if (((Integer)numUserPdeJobs).intValue() >= userQuotaPde) {
+					//log.print("User PDE quota reached [" + jobStatus.getVCSimulationIdentifier() + "]");
+					continue; // user PDE quota reached
+				}
+			}
+		} else {
+			Object numUserOdeJobs = userOdeRunningJobs.get(user);
+			if (numUserOdeJobs != null) {
+				if (((Integer)numUserOdeJobs).intValue() >= userQuotaOde) {
+					log.print("User ODE quota reached [" + jobStatus.getVCSimulationIdentifier() + "]");
+					continue; // user ODE quota reached
+				}
+			}
+		}	
+
+		return allActiveJobs[i];		
+	}
+
+	return null;
+}
+}
Index: src/cbit/vcell/messaging/JmsConnectionFactoryImpl.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnectionFactoryImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnectionFactoryImpl.java	(revision 12031)
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/24/2003 11:35:47 AM)
+ * @author: Fei Gao
+ */
+public class JmsConnectionFactoryImpl implements JmsConnectionFactory {
+	private JmsProvider jmsProvider = null;
+
+public JmsConnectionFactoryImpl() throws JMSException {
+	super();
+	jmsProvider = JmsProviderFactory.getJmsProvider();
+}
+
+public JmsConnectionFactoryImpl(JmsProvider jmsProvider0) {
+	super();
+	jmsProvider = jmsProvider0;
+}
+
+public JmsConnectionFactoryImpl(String provider, String url, String userid, String password) throws JMSException {
+	super();
+	jmsProvider = JmsProviderFactory.getJmsProvider(provider, url, userid, password);
+}
+
+public JmsConnection createConnection() throws JMSException {
+	return new JmsConnectionImpl(jmsProvider);
+}
+
+public JmsXAConnection createXAConnection() throws JMSException {
+	return new JmsXAConnectionImp(jmsProvider);
+}
+}
Index: src/cbit/vcell/messaging/MessagePropertyNotFoundException.java
===================================================================
--- src/cbit/vcell/messaging/MessagePropertyNotFoundException.java	(revision 0)
+++ src/cbit/vcell/messaging/MessagePropertyNotFoundException.java	(revision 12031)
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+/**
+ * Insert the type's description here.
+ * Creation date: (2/9/2004 11:29:16 AM)
+ * @author: Fei Gao
+ */
+public class MessagePropertyNotFoundException extends Exception {
+/**
+ * MessagePropertyNotFound constructor comment.
+ */
+public MessagePropertyNotFoundException() {
+	super();
+}
+
+
+/**
+ * MessagePropertyNotFound constructor comment.
+ * @param s java.lang.String
+ */
+public MessagePropertyNotFoundException(String s) {
+	super(s);
+}
+}
Index: src/cbit/vcell/messaging/ControlTopicListener.java
===================================================================
--- src/cbit/vcell/messaging/ControlTopicListener.java	(revision 0)
+++ src/cbit/vcell/messaging/ControlTopicListener.java	(revision 12031)
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (5/22/2003 2:43:23 PM)
+ * @author: Fei Gao
+ */
+public interface ControlTopicListener {
+void onControlTopicMessage(javax.jms.Message message) throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsXASession.java
===================================================================
--- src/cbit/vcell/messaging/JmsXASession.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsXASession.java	(revision 12031)
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+import javax.transaction.TransactionManager;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/8/2003 1:13:29 PM)
+ * @author: Fei Gao
+ */
+public interface JmsXASession extends JmsSession {
+	void setupXASession() throws JMSException;
+	boolean joinTransaction(TransactionManager tm) throws JMSException;
+}
Index: src/cbit/vcell/messaging/JmsClientMessaging.java
===================================================================
--- src/cbit/vcell/messaging/JmsClientMessaging.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsClientMessaging.java	(revision 12031)
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+import org.vcell.util.SessionLog;
+import org.vcell.util.MessageConstants.ServiceType;
+
+import cbit.vcell.messaging.server.RpcRequest;
+import cbit.vcell.server.UserLoginInfo;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (10/18/2001 4:31:45 PM)
+ * @author: Fei Gao
+ */
+public class JmsClientMessaging {
+
+	private JmsSession responseRequestor = null;
+	private JmsConnection queueConn = null;
+	private UserLoginInfo userLoginInfo = null;
+
+	private SessionLog log = null;
+	private long timeSinceLastMessage = System.currentTimeMillis();
+
+/**
+ * Client constructor comment.
+ */
+public JmsClientMessaging(JmsConnection queueConn0, SessionLog log0, UserLoginInfo userLoginInfo) throws JMSException {
+	log = log0;
+	queueConn = queueConn0;
+	this.userLoginInfo = userLoginInfo;
+	reconnect();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 12:08:02 PM)
+ * @return long
+ */
+public long getTimeSinceLastMessage() {
+	return timeSinceLastMessage;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (11/19/2001 5:29:47 PM)
+ */
+private void reconnect() throws JMSException {
+	responseRequestor = queueConn.getAutoSession();
+	queueConn.startConnection();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ * Since clientMessaging only send messages, we don't consider onException() because that's asynchronized. 
+ */
+public synchronized Object rpc(RpcRequest request, String queueName, boolean returnRequired, String[] specialProperties, Object[] specialValues) throws Exception {
+	return rpc(request, queueName, returnRequired, specialProperties, specialValues, true);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (10/24/2001 11:08:09 PM)
+ * @param simulation cbit.vcell.solver.Simulation
+ * Since clientMessaging only send messages, we don't consider onException() because that's asynchronized. 
+ */
+private synchronized Object rpc(RpcRequest request, String queueName, boolean returnRequired, String[] specialProperties, Object[] specialValues, boolean bEnableRetry) throws Exception {
+	ServiceType serviceType = request.getRequestedServiceType();
+	String methodName = request.getMethodName();
+	
+	try {		
+		ObjectMessage rpcMessage = responseRequestor.createObjectMessage(request);
+		rpcMessage.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY,MessageConstants.MESSAGE_TYPE_RPC_SERVICE_VALUE);
+		rpcMessage.setStringProperty(MessageConstants.SERVICE_TYPE_PROPERTY,serviceType.getName());
+		if (specialValues != null) {
+			for (int i = 0; i < specialValues.length; i ++) {
+				rpcMessage.setObjectProperty(specialProperties[i], specialValues[i]);
+			}
+		}
+
+		log.print("Sending request[" + serviceType + "," + methodName + "] to " + queueName);
+		setTimeSinceLastMessage(System.currentTimeMillis());
+		if (returnRequired) {
+			long clientTimeoutMS = Long.parseLong(org.vcell.util.PropertyLoader.getRequiredProperty(org.vcell.util.PropertyLoader.vcellClientTimeoutMS)); 
+			Message msg = responseRequestor.queueRequest(this, queueName, rpcMessage, DeliveryMode.PERSISTENT, clientTimeoutMS); 
+		
+			if (msg == null || !(msg instanceof ObjectMessage)) {
+				throw new JMSException("Server is temporarily not responding, please try again later. If problem persists, contact VCell_Support@uchc.edu. (server=" + serviceType + ", method=" + methodName +")");
+			} else {				
+				String methodResponseName = (String)JmsUtils.parseProperty(msg, MessageConstants.METHOD_NAME_PROPERTY, String.class);				
+				if (methodResponseName != null && methodResponseName.equals(methodName)){
+					log.print("server responded to RPC call (server=" + serviceType + ", method=" + methodName + ")");
+					Object returnValue = ((ObjectMessage)msg).getObject();
+					if (returnValue instanceof Exception){
+						throw (Exception)returnValue;
+					} else {
+						return returnValue;
+					}
+				} else {
+					return rpc(request, queueName, returnRequired, specialProperties, specialValues, false); // try again
+				}			
+			} 
+		} else {			
+			responseRequestor.sendMessage(queueName, rpcMessage, DeliveryMode.PERSISTENT, 0); // never expires
+			log.print("(service=" + serviceType + ", method=" + methodName + "), but no return is required");
+			return null;
+		}
+	} catch (JMSException e){
+		log.print("ClientMessaging.rpc() failed " + e.getMessage());
+		// if the connection is dropped, will retry
+		if (queueConn.isBadConnection(e) && bEnableRetry) {
+			log.print("ClientMessaging.rpc() retrying ");
+			return rpc(request, queueName, returnRequired, specialProperties, specialValues, false);
+		} else {
+			throw e;
+		}
+	}	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (4/19/2004 12:08:02 PM)
+ * @param newTimeSinceLastMessage long
+ */
+public void setTimeSinceLastMessage(long newTimeSinceLastMessage) {
+	timeSinceLastMessage = newTimeSinceLastMessage;
+}
+
+
+public UserLoginInfo getUserLoginInfo() {
+	return userLoginInfo;
+}
+
+
+}
Index: src/cbit/vcell/messaging/StatusMessage.java
===================================================================
--- src/cbit/vcell/messaging/StatusMessage.java	(revision 0)
+++ src/cbit/vcell/messaging/StatusMessage.java	(revision 12031)
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.*;
+
+import org.vcell.util.MessageConstants;
+
+import cbit.vcell.messaging.db.SimulationJobStatus;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/5/2004 12:35:20 PM)
+ * @author: Fei Gao
+ */
+public class StatusMessage {
+	private SimulationJobStatus jobStatus = null;
+	private Double timePoint = null;
+	private Double progress = null;
+
+	private static final String SIMULATION_STATUS_PROGRESS_PROPERTY	= "SimulationStatusProgress";
+	private static final String SIMULATION_STATUS_TIMEPOINT_PROPERTY = "SimulationStatusTimePoint";
+	
+	private java.lang.String userName = null;
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public StatusMessage(SimulationJobStatus jobStatus0, String userName0, Double progress0, Double timepoint0) {
+	jobStatus = jobStatus0;
+	userName = userName0;
+	progress = progress0;
+	timePoint = timepoint0;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:53:34 PM)
+ * @param param javax.jms.Message
+ */
+public StatusMessage(Message message) throws JMSException {
+	parseMessage(message);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:17:03 PM)
+ * @return cbit.vcell.messaging.db.SimulationJobStatus
+ */
+public SimulationJobStatus getJobStatus() {
+	return jobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:17:03 PM)
+ * @return java.lang.Double
+ */
+public java.lang.Double getProgress() {
+	return progress;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/31/2003 12:56:45 PM)
+ * @return cbit.vcell.solver.SimulationInfo
+ */
+public SimulationJobStatus getSimulationJobStatus() {
+	return jobStatus;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:17:03 PM)
+ * @return java.lang.Double
+ */
+public java.lang.Double getTimePoint() {
+	return timePoint;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/9/2004 10:24:41 AM)
+ * @return java.lang.String
+ */
+public java.lang.String getUserName() {
+	return userName;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 2:19:48 PM)
+ * @param message javax.jms.Message
+ */
+private void parseMessage(Message message) throws JMSException {
+	if (message == null) {
+		throw new RuntimeException("Null message");
+	}
+
+	try {
+		String msgType = (String)JmsUtils.parseProperty(message, MessageConstants.MESSAGE_TYPE_PROPERTY, String.class);
+		if (msgType != null && !msgType.equals(MessageConstants.MESSAGE_TYPE_SIMSTATUS_VALUE)) {
+			throw new RuntimeException("Wrong message");
+		}
+	} catch (MessagePropertyNotFoundException ex) {
+		ex.printStackTrace(System.out);
+		throw new RuntimeException("Wrong message");
+	}
+			
+	if (!(message instanceof ObjectMessage)) {
+		throw new IllegalArgumentException("Expecting object message.");
+	}
+
+	Object obj = ((ObjectMessage)message).getObject();
+	if (!(obj instanceof SimulationJobStatus)) {
+		throw new IllegalArgumentException("Expecting " + SimulationJobStatus.class.getName() + " in message.");
+	}
+
+	jobStatus = (SimulationJobStatus)obj;
+	try {
+		progress = (Double)JmsUtils.parseProperty(message, SIMULATION_STATUS_PROGRESS_PROPERTY, double.class);
+	} catch (MessagePropertyNotFoundException ex) {
+		//ex.printStackTrace(System.out);
+		//it's ok
+	}
+	
+	try {
+		timePoint = (Double)JmsUtils.parseProperty(message, SIMULATION_STATUS_TIMEPOINT_PROPERTY, double.class);
+	} catch (MessagePropertyNotFoundException ex) {
+		//ex.printStackTrace(System.out);
+		//it's ok
+	}
+	
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 1:59:04 PM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+public void sendToClient(JmsSession session) throws JMSException {
+	Message message = toMessage(session);
+	session.publishMessage(JmsUtils.getTopicClientStatus(), message);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/5/2004 1:59:04 PM)
+ * @return javax.jms.Message
+ * @param session cbit.vcell.messaging.VCellSession
+ */
+private Message toMessage(JmsSession session) throws JMSException {
+	Message message = session.createObjectMessage(jobStatus);
+	message.setStringProperty(MessageConstants.MESSAGE_TYPE_PROPERTY, MessageConstants.MESSAGE_TYPE_SIMSTATUS_VALUE);
+	message.setStringProperty(MessageConstants.USERNAME_PROPERTY, userName);
+	if (progress != null) {
+		message.setDoubleProperty(SIMULATION_STATUS_PROGRESS_PROPERTY, progress.doubleValue());
+	}
+	if (timePoint != null) {
+		message.setDoubleProperty(SIMULATION_STATUS_TIMEPOINT_PROPERTY, timePoint.doubleValue());
+	}
+
+	return message;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (2/13/2004 9:55:17 AM)
+ * @return java.lang.String
+ */
+public String toString() {
+	return "StatusMessage [" + jobStatus.getSimulationMessage().getDisplayMessage() + "," + progress + "," + timePoint + "]";
+}
+}
Index: src/cbit/vcell/messaging/AbstractJmsProvider.java
===================================================================
--- src/cbit/vcell/messaging/AbstractJmsProvider.java	(revision 0)
+++ src/cbit/vcell/messaging/AbstractJmsProvider.java	(revision 12031)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (12/16/2001 9:49:37 AM)
+ * @author: Jim Schaff
+ */
+public abstract class AbstractJmsProvider implements JmsProvider {
+	protected String fieldUserid;
+	protected String fieldPassword;	
+
+	protected XAConnectionFactory xaConnectionFactory = null;
+	protected ConnectionFactory connectionFactory = null;	
+	
+/**
+ * JmsFactory constructor comment.
+ */
+protected AbstractJmsProvider(String userid, String password) {
+	super();
+	this.fieldUserid = userid;
+	this.fieldPassword = password;
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (6/6/2003 11:51:19 AM)
+ * @return int
+ */
+public boolean isBadConnection(JMSException ex) {
+	if (getErrorCode(ex) == JmsErrorCode.ERR_CONNECTION_DROPPED) {
+		return true;
+	}
+
+	return false;
+}
+}
Index: src/cbit/vcell/messaging/JmsConnectionImpl.java
===================================================================
--- src/cbit/vcell/messaging/JmsConnectionImpl.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsConnectionImpl.java	(revision 12031)
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+import javax.jms.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (6/6/2003 11:16:18 AM)
+ * @author: Fei Gao
+ */
+public class JmsConnectionImpl extends AbstractJmsConnectionImpl {
+
+	protected JmsConnectionImpl(JmsProvider argJmsProvider) throws JMSException {
+		super(argJmsProvider);
+		setupConnection();
+	}
+
+	protected void setupConnection() {
+		connection = null;	
+		// Wait for a connection.
+		while (connection == null) {		
+			try {						
+				connection = jmsProvider.createConnection();
+				connection.setExceptionListener(this);
+				jmsProvider.setPingInterval(JMSCONNECTION_PING_INTERVAL, connection);
+				System.out.println(this + ": Connection established.");
+			} catch (Exception jmse) {		
+				System.out.println(this + ": Cannot connect to Message Server [" + jmse.getMessage() + "], Pausing " + JMSCONNECTION_RETRY_INTERVAL/1000 + " seconds before retry.");
+				try {
+					Thread.sleep(JMSCONNECTION_RETRY_INTERVAL);
+				} catch (InterruptedException ie) {
+					ie.printStackTrace(System.out);
+				}
+			}
+		}		
+	} 
+}
Index: src/cbit/vcell/messaging/JmsProviderFactory.java
===================================================================
--- src/cbit/vcell/messaging/JmsProviderFactory.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsProviderFactory.java	(revision 12031)
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+import javax.jms.JMSException;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (2/24/2004 2:54:42 PM)
+ * @author: Fei Gao
+ */
+public class JmsProviderFactory {
+/**
+ * JmsProviderFactory constructor comment.
+ */
+public JmsProviderFactory() {
+	super();
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/16/2001 4:48:25 PM)
+ * @return cbit.vcell.appserver.JmsFactory
+ * @param jmsProvider java.lang.String
+ * @param host java.lang.String
+ * @param userid java.lang.String
+ * @param password java.lang.String
+ */
+public static JmsProvider getJmsProvider() throws JMSException {
+	return getJmsProvider(JmsUtils.getJmsProvider(), JmsUtils.getJmsUrl(), JmsUtils.getJmsUserID(), JmsUtils.getJmsPassword());
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (12/16/2001 4:48:25 PM)
+ * @return cbit.vcell.appserver.JmsFactory
+ * @param jmsProvider java.lang.String
+ * @param host java.lang.String
+ * @param userid java.lang.String
+ * @param password java.lang.String
+ */
+public static JmsProvider getJmsProvider(String provider, String url, String userid, String password) throws JMSException {
+	if (provider.equalsIgnoreCase(JmsProvider.SONICMQ)){
+		return new SonicMQJmsProvider(url,userid,password);	 
+	} else {
+		throw new IllegalArgumentException("unexpected jmsProvider '" + provider + "', expecting " + JmsProvider.SONICMQ);// + " or " + JBOSSMQ);
+	}
+}
+}
Index: src/cbit/vcell/messaging/JmsErrorCode.java
===================================================================
--- src/cbit/vcell/messaging/JmsErrorCode.java	(revision 0)
+++ src/cbit/vcell/messaging/JmsErrorCode.java	(revision 12031)
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.messaging;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (6/6/2003 11:39:44 AM)
+ * @author: Fei Gao
+ */
+public interface JmsErrorCode {
+	public static final int ERR_UNKNOWN = -1;
+	
+	public static final int ERR_CAN_NOT_INSTANTIATE_CLASS = 0;            
+	public static final int ERR_CHANNEL_ACTIVE  = 1;            
+	public static final int ERR_CHANNEL_ALREADY_ESTABLISHED = 2;            
+	public static final int ERR_CHANNEL_DUPLICATE = 3;            
+	public static final int ERR_CHANNEL_DUPLICATE_DETECT_UNSUPPORTED = 4;            
+	public static final int ERR_CHANNEL_FATAL_DUP_DETECT_EXCEPTION = 5;            
+	public static final int ERR_CHANNEL_ID_ALREADY_EXISTS = 6;            
+	public static final int ERR_CHANNEL_IMPLICITLY_CANCELLED = 7;            
+	public static final int ERR_CHANNEL_INTERNAL_ERROR = 8;            
+	public static final int ERR_CHANNEL_INVALID_DECRYPTION_KEY = 9;	            
+	public static final int ERR_CHANNEL_INVALID_KEY_TYPE = 10;	            
+	public static final int ERR_CHANNEL_IO_ERROR = 11;	            
+	public static final int ERR_CHANNEL_JCE_UNAVAILABLE = 12;	            
+	public static final int ERR_CHANNEL_RECOVER_FILE_UNREADABLE = 13;	            
+	public static final int ERR_CHANNEL_RETRY_TIMEOUT = 14;	            
+	public static final int ERR_CHANNEL_TIMEOUT = 15;	            
+	public static final int ERR_CHANNEL_TRANSFER_CLOSED = 16;	            
+	public static final int ERR_CHANNEL_UUID_IN_USE = 17;	            
+	public static final int ERR_CLASS_ACCESS_ERROR = 18;	            
+	public static final int ERR_CLASS_CAST_ERROR = 19;	            
+	public static final int ERR_CLASS_NOT_FOUND = 20;	            
+	public static final int ERR_CONNECTION_DROPPED = 21;	            
+	public static final int ERR_CONNECTION_LIMIT_EXCEEDED = 22;	            
+	public static final int ERR_EXCEPTION_IN_INIT = 23;	            
+	public static final int ERR_EXTERNAL_AUTNENTICATION_FAILED = 24;	            
+	public static final int ERR_FLOW_CONTROL_EXCEPTION = 25;	            
+	public static final int ERR_GENERAL_SECURITY_ERR = 26;	            
+	public static final int ERR_GUARANTEE_NOT_AUTHORIZED = 27;	            
+	public static final int ERR_INTEGRITY_FAILED = 28;	            
+	public static final int ERR_JMS_OBJECT_CLOSED = 29;	            
+	public static final int ERR_LINKAGE_ERROR = 30;	            
+	public static final int ERR_MESSAGELISTENER_RUNTIME_EXCEPTION = 31;
+	public static final int ERR_NONREPUDIATION_FAILED = 32;	            
+	public static final int ERR_PRIVACY_FAILED = 33; 	            
+	public static final int ERR_PUBLISH_NOT_AUTHORIZED = 34;	            
+	public static final int ERR_REQUEST_NOSUB_FOR_SUBJECT = 35;	            
+	public static final int ERR_SECURITY_ERROR = 36; 	            
+	public static final int ERR_STORE = 37; 	            
+	public static final int ERR_STORE_INIT = 38;	            
+	public static final int ERR_STORE_SIZE_EXCEEDED = 39;	            
+	public static final int ERR_SUBSCRIBE_NOT_AUTHORIZED = 40; 	            
+	public static final int ERR_THREAD_INTERRUPTED = 41;	            
+	public static final int ERR_TOO_LARGE_FOR_QUEUE = 42;	            
+	public static final int ERR_TXN_ACCESS_VIOLATION = 43;	            
+	public static final int ERR_TXN_IDLE_TIMEOUT = 44;	            
+	public static final int ERR_TXN_NOT_FOUND = 45;	            
+	public static final int ERR_TXN_SEQUENCE_ERR = 46;	            
+	public static final int ERR_WRONG_SUBJECT_ADDR = 47;	            
+	public static final int ERROR = 48;	            
+	public static final int TXN_DATABASE_EXCEPTION = 49;	            
+	public static final int TXN_INDEX_ALREADY_EXISTS = 50;	            
+	public static final int TXN_INDICES_NOT_SUPPORTED = 51;	            
+	public static final int TXN_INVALID_DATA  = 52;	
+}
Index: src/cbit/vcell/mongodb/VCMongoMessage.java
===================================================================
--- src/cbit/vcell/mongodb/VCMongoMessage.java	(revision 12032)
+++ src/cbit/vcell/mongodb/VCMongoMessage.java	(revision 12031)
@@ -5,6 +5,7 @@
 import java.net.UnknownHostException;
 import java.util.Arrays;
 import java.util.Date;
+import java.util.Enumeration;
 
 import org.vcell.util.MessageConstants;
 import org.vcell.util.document.VCellServerID;
@@ -17,21 +18,24 @@
 import cbit.vcell.message.VCMessage;
 import cbit.vcell.message.VCRpcRequest;
 import cbit.vcell.message.messages.StatusMessage;
-import cbit.vcell.message.messages.WorkerEventMessage;
 import cbit.vcell.message.server.pbs.PbsProxy;
 import cbit.vcell.message.server.pbs.PbsProxy.CommandOutput;
+import cbit.vcell.messaging.WorkerEventMessage;
 import cbit.vcell.messaging.db.SimulationExecutionStatus;
 import cbit.vcell.messaging.db.SimulationJobStatus;
 import cbit.vcell.messaging.db.SimulationQueueEntryStatus;
+import cbit.vcell.messaging.server.RpcRequest;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.server.UserLoginInfo;
 import cbit.vcell.solver.SimulationJob;
 import cbit.vcell.solver.SimulationMessage;
 import cbit.vcell.solver.SimulationMessage.DetailedState;
 import cbit.vcell.solver.SolverEvent;
+import cbit.vcell.solver.SolverStatus;
 import cbit.vcell.solver.VCSimulationDataIdentifier;
 import cbit.vcell.solver.VCSimulationDataIdentifierOldStyle;
 import cbit.vcell.solver.VCSimulationIdentifier;
+import cbit.vcell.solver.ode.gui.SimulationStatus;
 import cbit.vcell.solvers.AbstractSolver;
 
 import com.mongodb.BasicDBObject;
@@ -477,6 +481,23 @@
 
 			addHeader(dbObject,MongoMessage_msgtype_workerEventMessage);
 
+			addObject(dbObject,workerEventMessage);
+				
+			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
+		} catch (Exception e){
+			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
+		}
+	}
+
+	public static void sendWorkerEvent(cbit.vcell.message.messages.WorkerEventMessage workerEventMessage) {
+		if (!enabled){
+			return;
+		}
+		try {
+			BasicDBObject dbObject = new BasicDBObject();
+
+			addHeader(dbObject,MongoMessage_msgtype_workerEventMessage);
+
 			addObject(dbObject,workerEventMessage.getWorkerEvent());
 				
 			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
@@ -562,6 +583,23 @@
 		}
 	}
 
+	public static void sendRpcRequestReceived(RpcRequest rpcRequest) {
+		if (!enabled){
+			return;
+		}
+		try {
+			BasicDBObject dbObject = new BasicDBObject();
+
+			addHeader(dbObject,MongoMessage_msgtype_rpcRequestReceived);
+
+			addObject(dbObject,rpcRequest);
+			
+			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
+		} catch (Exception e){
+			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
+		}
+	}
+
 	public static void sendRpcRequestReceived(VCRpcRequest rpcRequest) {
 		if (!enabled){
 			return;
@@ -579,6 +617,26 @@
 		}
 	}
 
+	public static void sendRpcRequestSent(RpcRequest rpcRequest, UserLoginInfo userLoginInfo) {
+		if (!enabled){
+			return;
+		}
+		try {
+			
+			BasicDBObject dbObject = new BasicDBObject();
+
+			addHeader(dbObject,MongoMessage_msgtype_rpcRequestSent);
+
+			addObject(dbObject,rpcRequest);
+			
+			addObject(dbObject,userLoginInfo);
+			
+			VCMongoDbDriver.getInstance().addMessage(new VCMongoMessage(dbObject));
+		} catch (Exception e){
+			VCMongoDbDriver.getInstance().getSessionLog().exception(e);
+		}
+	}
+
 	public static void sendRpcRequestSent(VCRpcRequest rpcRequest, UserLoginInfo userLoginInfo) {
 		if (!enabled){
 			return;
@@ -710,6 +768,25 @@
 		}			
 	}
 	
+	private static void addObject(BasicDBObject dbObject, RpcRequest rpcRequest){
+		dbObject.put(MongoMessage_rpcRequestArgs,Arrays.asList(rpcRequest.getArguments()).toString());
+		for (Object arg : rpcRequest.getArguments()){
+			//
+			// look for simulation IDs in rpcRequest arguments ... add to field.
+			//
+			if (arg instanceof VCSimulationIdentifier){
+				dbObject.put(MongoMessage_simId, ((VCSimulationIdentifier)arg).getSimulationKey().toString());
+			}else if (arg instanceof VCSimulationDataIdentifier){
+				dbObject.put(MongoMessage_simId, ((VCSimulationDataIdentifier)arg).getSimulationKey().toString());
+			}else if (arg instanceof VCSimulationDataIdentifierOldStyle){
+				dbObject.put(MongoMessage_simId, ((VCSimulationDataIdentifierOldStyle)arg).getSimulationKey().toString());
+			}
+		}
+		dbObject.put(MongoMessage_rpcRequestMethod,rpcRequest.getMethodName());
+		dbObject.put(MongoMessage_rpcRequestService,rpcRequest.getRequestedServiceType().getName());
+		dbObject.put(MongoMessage_userName,rpcRequest.getUserName());
+	}
+	
 	private static void addObject(BasicDBObject dbObject, VCRpcRequest rpcRequest){
 		dbObject.put(MongoMessage_rpcRequestArgs,Arrays.asList(rpcRequest.getArguments()).toString());
 		for (Object arg : rpcRequest.getArguments()){
Index: src/cbit/vcell/transaction/JtaTransactionManager.java
===================================================================
--- src/cbit/vcell/transaction/JtaTransactionManager.java	(revision 0)
+++ src/cbit/vcell/transaction/JtaTransactionManager.java	(revision 12031)
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+import javax.transaction.*;
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/21/2003 12:53:42 PM)
+ * @author: Fei Gao
+ */
+public class JtaTransactionManager implements TransactionManager, UserTransaction {
+   
+    
+    
+    public static final int DEFAULT_TRANSACTION_TIMEOUT = 30;
+    
+    
+    private Map bindings = Collections.synchronizedMap(new HashMap());
+    
+    
+    private Map timeouts = Collections.synchronizedMap(new HashMap());   
+    
+/**
+ * Insert the method's description here.
+ * Creation date: (7/25/2003 12:27:18 PM)
+ */
+public JtaTransactionManager() {}
+/**
+ * Create a new transaction and associate it with the current thread.
+ *
+ * @exception NotSupportedException Thrown if the thread is already
+ * associated with a transaction and the Transaction Manager
+ * implementation does not support nested transactions.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void begin() throws NotSupportedException, SystemException {
+
+	Transaction currentTransaction = getTransaction();
+	if (currentTransaction != null) {
+		throw new NotSupportedException();
+	}
+
+	currentTransaction = new JtaTransactionImpl(this);
+	bindings.put(Thread.currentThread(), currentTransaction);	
+}
+/**
+ * Complete the transaction associated with the current thread. When this
+ * method completes, the thread becomes associated with no transaction.
+ * If the commit is terminated with an exception, the rollback should be
+ * called, to do a proper clean-up.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void commit() throws	RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException {
+
+	Thread currentThread = Thread.currentThread();
+	Transaction currentTransaction = (Transaction) bindings.get(currentThread);
+	if (currentTransaction == null) {
+		throw new IllegalStateException();
+	}
+
+	timeouts.remove(currentThread);
+
+	try {
+		currentTransaction.commit();
+	} finally {
+		bindings.remove(currentThread);
+		currentTransaction = null;
+	}
+
+}
+/**
+ * Obtain the status of the transaction associated with the current thread.
+ *
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ * @return The transaction status. If no transaction is associated with
+ * the current thread, this method returns the Status.NoTransaction value.
+ */
+public int getStatus() throws SystemException {
+
+	Transaction currentTransaction = getTransaction();
+	if (currentTransaction == null) {
+		return Status.STATUS_NO_TRANSACTION;
+	}
+
+	return currentTransaction.getStatus();
+
+}
+/**
+ * Get the transaction object that represents the transaction context of
+ * the calling thread.
+ *
+ * @return the Transaction object representing the transaction associated
+ * with the calling thread.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public Transaction getTransaction() throws SystemException {
+	return (Transaction) bindings.get(Thread.currentThread());
+}
+/**
+ * Resume the transaction context association of the calling thread with
+ * the transaction represented by the supplied Transaction object. When
+ * this method returns, the calling thread is associated with the
+ * transaction context specified.
+ *
+ * @param tobj The Transaction object that represents the transaction to
+ * be resumed.
+ * @exception InvalidTransactionException Thrown if the parameter
+ * transaction object contains an invalid transaction.
+ * @exception IllegalStateException Thrown if the thread is already
+ * associated with another transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void resume(Transaction tobj) throws InvalidTransactionException, IllegalStateException, SystemException {
+
+	if (getTransaction() != null) {
+		throw new IllegalStateException();
+	}
+
+	if (tobj == null) {
+		throw new InvalidTransactionException();
+	}
+
+	bindings.put(Thread.currentThread(), tobj);
+
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void rollback() throws SecurityException, IllegalStateException, SystemException {
+
+	Thread currentThread = Thread.currentThread();
+	Transaction currentTransaction = (Transaction) bindings.remove(currentThread);
+	if (currentTransaction == null) {
+		throw new IllegalStateException();
+	}
+
+	timeouts.remove(currentThread);
+
+	currentTransaction.rollback();
+	currentTransaction = null;
+}
+/**
+ * Modify the transaction associated with the current thread such that
+ * the only possible outcome of the transaction is to roll back the
+ * transaction.
+ *
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void setRollbackOnly() throws IllegalStateException, SystemException {
+
+	Transaction currentTransaction = getTransaction();
+	if (currentTransaction == null) {
+		throw new IllegalStateException();
+	}
+
+	currentTransaction.setRollbackOnly();
+
+}
+/**
+ * Modify the value of the timeout value that is associated with the
+ * transactions started by the current thread with the begin method.
+ * <p>
+ * If an application has not called this method, the transaction service
+ * uses some default value for the transaction timeout.
+ *
+ * @param seconds The value of the timeout in seconds. If the value is
+ * zero, the transaction service restores the default value.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void setTransactionTimeout(int seconds) throws SystemException {
+	timeouts.put(Thread.currentThread(), new Integer(seconds));
+}
+/**
+ * Suspend the transaction currently associated with the calling thread
+ * and return a Transaction object that represents the transaction
+ * context being suspended. If the calling thread is not associated with
+ * a transaction, the method returns a null object reference. When this
+ * method returns, the calling thread is associated with no transaction.
+ *
+ * @return Transaction object representing the suspended transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public Transaction suspend() throws SystemException {
+
+	Transaction currentTransaction = getTransaction();
+
+	if (currentTransaction != null) {
+		Thread currentThread = Thread.currentThread();
+		bindings.remove(currentThread);
+		timeouts.remove(currentThread);
+	}
+
+	return currentTransaction;
+
+}
+}
Index: src/cbit/vcell/transaction/JtaDbConnection.java
===================================================================
--- src/cbit/vcell/transaction/JtaDbConnection.java	(revision 0)
+++ src/cbit/vcell/transaction/JtaDbConnection.java	(revision 12031)
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/31/2003 8:35:21 AM)
+ * @author: Fei Gao
+ */
+public interface JtaDbConnection {
+	public void close() throws java.sql.SQLException;
+	public void closeOnFailure() throws java.sql.SQLException;
+	public java.sql.Connection getConnection() throws java.sql.SQLException;
+	public boolean joinTransaction(javax.transaction.TransactionManager tm) throws java.sql.SQLException;
+}
Index: src/cbit/vcell/transaction/JtaOracleConnection.java
===================================================================
--- src/cbit/vcell/transaction/JtaOracleConnection.java	(revision 0)
+++ src/cbit/vcell/transaction/JtaOracleConnection.java	(revision 12031)
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+/**
+ * Insert the type's description here.
+ * Creation date: (7/29/2003 9:27:42 AM)
+ * @author: Fei Gao
+ */
+public class JtaOracleConnection implements NonXAResource, JtaDbConnection {
+	private Object lock = null;
+	private java.sql.Connection oracleConnection = null;
+	private cbit.sql.ConnectionFactory connFactory = null;
+
+/**
+ * JtaOracleConnectionFactory constructor comment.
+ * @param dbUrl java.lang.String
+ * @param username java.lang.String
+ * @param password java.lang.String
+ * @param ttm javax.transaction.TransactionManager
+ * @exception javax.transaction.RollbackException The exception description.
+ * @exception java.sql.SQLException The exception description.
+ * @exception javax.transaction.xa.XAException The exception description.
+ * @exception javax.transaction.SystemException The exception description.
+ */
+public JtaOracleConnection(cbit.sql.ConnectionFactory oracleFactory) throws java.sql.SQLException {
+	lock = new Object();
+	connFactory = oracleFactory;
+	oracleConnection = oracleFactory.getConnection(lock);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public void close() throws java.sql.SQLException {
+	connFactory.release(oracleConnection, lock);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public void closeOnFailure() throws java.sql.SQLException {
+	connFactory.failed(oracleConnection, lock);
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public void commit() throws javax.transaction.SystemException {
+	try {
+		oracleConnection.commit();
+	} catch (java.sql.SQLException ex) {
+		throw new javax.transaction.SystemException(ex.getMessage());
+	}
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:11:30 PM)
+ * @return cbit.sql.ConnectionFactory
+ */
+public java.sql.Connection getConnection() {
+	return oracleConnection;
+}
+
+
+/**
+ * Insert the method's description here.
+ * Creation date: (7/29/2003 1:52:35 PM)
+ */
+public boolean joinTransaction(javax.transaction.TransactionManager tm) throws java.sql.SQLException {
+	try {
+		((JtaTransactionImpl)tm.getTransaction()).enlistNonXAResource(this);
+		return true;
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+		throw new java.sql.SQLException(ex.getMessage());		
+	}
+}
+
+
+/**
+ * rollback method comment.
+ */
+public void rollback() throws javax.transaction.SystemException {
+	try {
+		oracleConnection.rollback();
+	} catch (java.sql.SQLException ex) {
+		throw new javax.transaction.SystemException(ex.getMessage());
+	}	
+}
+}
Index: src/cbit/vcell/transaction/JtaXidImpl.java
===================================================================
--- src/cbit/vcell/transaction/JtaXidImpl.java	(revision 0)
+++ src/cbit/vcell/transaction/JtaXidImpl.java	(revision 12031)
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+import java.io.Serializable;
+import javax.transaction.xa.Xid;
+
+/**
+ * Xid implementation for JTA
+ */
+public class JtaXidImpl implements Xid, Serializable {
+
+    private static final int FORMAT_ID = 0;    
+    
+    /**
+     * Branch qualifier.
+     */
+    private byte[] branchQualifier; 
+
+    
+    
+    /**
+     * Global transaction id.
+     */
+    private byte[] globalTransactionId;
+    
+    
+/**
+ * Constructor.
+ */
+public JtaXidImpl(byte[] globalTransactionId0, byte[] branchQualifier0) {
+	setGlobalTransactionId(globalTransactionId0);
+	setBranchQualifier(branchQualifier0);
+}
+/**
+ * Obtain the transaction branch identifier part of XID as an array of 
+ * bytes.
+ * 
+ * @return Global transaction identifier.
+ */
+public byte[] getBranchQualifier() {
+	return branchQualifier;
+}
+/**
+ * The formatID is usually zero, meaning that you are using the 
+ * OSI CCR (Open Systems Interconnection Commitment, Concurrency, and Recovery standard) 
+ * for naming. If you are using another format, the formatID should be greater than zero. 
+ * A value of -1 means that the Xid is null.
+ * 
+ * Obtain the format identifier part of the XID.
+ * 
+ * @return Format identifier. O means the OSI CCR format.
+ */
+public int getFormatId() {
+	return FORMAT_ID;
+}
+/**
+ * Obtain the global transaction identifier part of XID as an array of 
+ * bytes.
+ * 
+ * @return Global transaction identifier.
+ */
+public byte[] getGlobalTransactionId() {
+	return globalTransactionId;
+}
+/**
+ * Create a new branch based on this Xid.
+ */
+public Xid newBranch(int branchNumber) {
+	return new JtaXidImpl(getGlobalTransactionId(), Integer.toString(branchNumber).getBytes());
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (1/27/2004 1:26:39 PM)
+ * @param newBranchQualifier byte[]
+ */
+private void setBranchQualifier(byte[] aBranchQualifier) {
+	int length = 0;
+	if (aBranchQualifier == null) {
+		length = 0;
+		branchQualifier = new byte[length];
+	} else {
+		length = aBranchQualifier.length <= 64 ? aBranchQualifier.length : 64;
+		branchQualifier = new byte[length];
+		System.arraycopy(aBranchQualifier, 0, branchQualifier, 0, length);
+	}
+}
+/**
+ * Insert the method's description here.
+ * Creation date: (1/27/2004 1:26:39 PM)
+ * @param newGlobalTransactionId byte[]
+ */
+private void setGlobalTransactionId(byte[] aGlobalTransactionId) {
+	int length = 0;
+	if (aGlobalTransactionId == null) {
+		length = 0;
+		globalTransactionId = new byte[length];
+	} else {
+		length = aGlobalTransactionId.length <= 64 ? aGlobalTransactionId.length : 64;
+		globalTransactionId = new byte[length];
+		System.arraycopy(aGlobalTransactionId, 0, globalTransactionId, 0, length);
+	}
+}
+/**
+ * Obtain a String representation of this xid.
+ */
+public String toString() {
+	return "[" + new String(getGlobalTransactionId()) + "," + new String(getBranchQualifier()) + "]";
+}
+}
Index: src/cbit/vcell/transaction/JtaTransactionImpl.java
===================================================================
--- src/cbit/vcell/transaction/JtaTransactionImpl.java	(revision 0)
+++ src/cbit/vcell/transaction/JtaTransactionImpl.java	(revision 12031)
@@ -0,0 +1,817 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import javax.transaction.*;
+import javax.transaction.xa.*;
+
+import oracle.jdbc.xa.OracleXAException;
+
+import java.util.*;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/23/2003 4:12:01 PM)
+ * @author: Fei Gao
+ */
+public class JtaTransactionImpl implements Transaction {
+
+	private JtaXidImpl xid = null;
+
+	private Map<Xid, XAResource> branches = Collections.synchronizedMap(new HashMap<Xid, XAResource>());
+	private Map<Xid, Integer> prepareResults = Collections.synchronizedMap(new HashMap<Xid, Integer>());
+	
+	private Map<XAResource, Xid> activeBranches = Collections.synchronizedMap(new HashMap<XAResource, Xid>());
+	private List<XAResource> enlistedResources = Collections.synchronizedList(new ArrayList<XAResource>());
+	private List<NonXAResource> nonXAResources = Collections.synchronizedList(new ArrayList<NonXAResource>());
+	private Map<XAResource, Xid> suspendedResources = Collections.synchronizedMap(new HashMap<XAResource, Xid>());
+
+	private int status = Status.STATUS_ACTIVE;
+
+	private List<Synchronization> synchronizationObjects = Collections.synchronizedList(new ArrayList<Synchronization>());
+	private int branchCounter = 1;
+	private static int globalCreatedTransactions = 0;
+	private int currentTransactionNumber = 0;
+	private String currentThreadName = null;
+	private javax.transaction.TransactionManager transactionManager = null;
+
+/**
+ * Constructor.
+ */
+public JtaTransactionImpl(TransactionManager tm) {
+	// Generate the transaction id
+	globalCreatedTransactions ++;
+	currentTransactionNumber = globalCreatedTransactions;
+	currentThreadName = Thread.currentThread().getName();
+	xid = new JtaXidImpl((currentThreadName + "-" + System.currentTimeMillis() + "-" + currentTransactionNumber).getBytes(), new byte[0]);
+	this.transactionManager = tm;
+}
+
+/**
+ * Complete the transaction represented by this Transaction object.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void commit() throws	RollbackException, HeuristicMixedException, HeuristicRollbackException,	SecurityException, IllegalStateException, SystemException {	
+
+	if (status == Status.STATUS_MARKED_ROLLBACK) {
+		rollback();
+		return;
+	}
+
+	// Check status ACTIVE
+	if (status != Status.STATUS_ACTIVE)
+		throw new IllegalStateException();
+
+	// Call synchronized objects beforeCompletion
+	for (Synchronization sync : synchronizationObjects) {
+		sync.beforeCompletion();
+	}
+
+	List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<Throwable>());
+	boolean fail = false;
+
+	switch (enlistedResources.size()) {
+		case 0: {
+			// only commit nonXA
+			if (nonXAResources.size() > 0) {
+				try {
+					do_commitNonXA();
+					status = Status.STATUS_COMMITTED;
+				} catch (Throwable e) {				
+					fail = false;
+					try {
+						do_rollbackNonXA();
+					} catch (Throwable ex) {
+						exceptions.add(ex);
+						fail = true;
+					}
+					status = Status.STATUS_ROLLEDBACK;
+				}
+
+			}
+			break;
+		} // case 0
+
+		case 1:	{
+			//System.out.print("1-Phase commit started....");
+
+			// One phase commit		
+			try {
+				do_delist();
+			} catch (SystemException e) {
+				exceptions.add(e);
+				fail = true;
+				status = Status.STATUS_MARKED_ROLLBACK;
+			}
+				
+			if (!fail) {
+				try {
+					do_commitNonXA();
+					do_commit(true);
+				} catch (Throwable e) {					
+					if (e instanceof XAException) {
+						System.out.println("1-Phase commit XAException: " + getXAErrorCode((XAException)e));
+					}					
+					exceptions.add(e);
+					fail = true;				
+				}
+
+				status = Status.STATUS_COMMITTED;
+			} else {
+				try {
+					fail = false;
+					do_rollbackNonXA();
+					do_rollback();
+				} catch (Throwable e) {					
+					if (e instanceof XAException) {
+						System.out.println("1-Phase rollback XAException: " + getXAErrorCode((XAException)e));
+					}
+					exceptions.add(e);
+					fail = true;				
+				}
+				status = Status.STATUS_ROLLEDBACK;
+			}
+
+			//System.out.println("1-phase commit ended");
+			break;
+		} // case 1
+
+		default: {
+			// two phase commit						
+			// end each enlisted resource	
+			try {
+				// Preparing the resource manager using its branch xid
+				do_delist();
+			} catch (SystemException e) {
+				exceptions.add(e);
+				fail = true;
+				status = Status.STATUS_MARKED_ROLLBACK;
+			}
+
+			// Prepare each enlisted resource
+			if (!fail) {
+				try {
+					do_prepare();
+				} catch (XAException ex) {
+					ex.printStackTrace(System.out);
+					if (ex instanceof OracleXAException) {						
+						int oraerr = ((OracleXAException)ex).getOracleError();
+						System.out.println("2-Phase commit do_prepare Oracle error " + oraerr); 
+					} else {
+						System.out.println("2-Phase commit XAException: " + getXAErrorCode((XAException)ex));
+					}
+					fail = true;
+					exceptions.add(ex);
+					status = Status.STATUS_MARKED_ROLLBACK;
+				}
+			}		
+		
+			if (!fail) {
+				try {
+					do_commitNonXA();
+				} catch (Throwable e) {
+					exceptions.add(e);
+					fail = true;				
+				}
+				status = Status.STATUS_COMMITTED;
+			}
+
+			if (!fail) {
+				// Commit each enlisted resource
+				status = Status.STATUS_PREPARED;
+				status = Status.STATUS_COMMITTING;
+				
+				//System.out.print("2-Phase commit started....");
+				
+				try {
+					do_commit(false);	
+				} catch (XAException e) {
+					e.printStackTrace(System.out);
+					if (e instanceof OracleXAException) {						
+						int oraerr = ((OracleXAException)e).getOracleError();
+						System.out.println("2-Phase commit do_commit Oracle error " + oraerr); 
+					} else {
+						System.out.println("2-Phase commit XAException: " + getXAErrorCode((XAException)e));
+					}
+					exceptions.add(e);
+					fail = true;
+				}
+				status = Status.STATUS_COMMITTED;
+				//System.out.println("2-Phase commit ended");
+
+			} else {
+				System.out.println("2-Phase commit fail, rollback started....");
+				//If fail, rollback
+				status = Status.STATUS_ROLLING_BACK;
+				fail = false;
+				// Rolling back all the prepared (and unprepared) branches
+				try {
+					do_rollbackNonXA();
+					do_rollback();
+				} catch (Throwable e) {
+					if (e instanceof XAException) {
+						System.out.println("2-Phase rollback XAException: " + getXAErrorCode((XAException)e));
+					}
+					exceptions.add(e);
+					fail = true;
+				}
+				status = Status.STATUS_ROLLEDBACK;
+				//System.out.println("2-Phase rollback ended");
+			}
+
+			break;
+		} //default
+
+	}
+
+	// Call synchronized objects afterCompletion
+	for (Synchronization sync : synchronizationObjects) {
+		sync.afterCompletion(status);
+	}
+
+	// Parsing exception and throwing an appropriate exception
+	if (exceptions.size() > 0) {
+		System.out.println(this + "  COMMIT... \t\t[ FAILED ]");
+		if (status == Status.STATUS_ROLLEDBACK) {
+			if (!fail) {
+				throw new RollbackException();
+			} else {
+				throw new HeuristicRollbackException();
+			}
+		}
+		if (status == Status.STATUS_COMMITTED && fail) {
+			throw new HeuristicMixedException();
+		}
+	}
+	System.out.println(this + "  COMMIT... \t\t[ OK ]");
+}
+/**
+ * Delist the resource specified from the current transaction associated
+ * with the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @param flag One of the values of TMSUCCESS, TMSUSPEND, or TMFAIL
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is inactive.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public boolean delistResource(XAResource xaRes, int flag) throws IllegalStateException, SystemException { 
+
+	//System.out.println(this + "  DELIST " + xaRes);
+
+	// Check status ACTIVE
+	if (status != Status.STATUS_ACTIVE)
+		throw new IllegalStateException();
+
+	Xid xid = (Xid) activeBranches.get(xaRes);
+	if (xid == null) {
+		throw new IllegalStateException();
+	}
+	activeBranches.remove(xaRes);
+
+	try {
+		xaRes.end(xid, flag);
+	} catch (XAException e) {
+		e.printStackTrace(System.out);
+		return false;
+	}
+
+	if (flag == XAResource.TMSUSPEND) {
+		suspendedResources.put(xaRes, xid);
+	}
+
+	//System.out.println("Delisted ok(" + this + ") = " + xaRes + " xid: " + xid);
+
+	return true;
+
+}
+
+/**
+ * Complete the transaction represented by this Transaction object.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_commit(boolean onePhase) throws	XAException {
+
+	for (Xid key : branches.keySet()) {
+		XAResource resourceManager = branches.get(key);
+		if (onePhase) {
+			resourceManager.commit(key, true);
+		} else {
+			Integer prepareResult = prepareResults.get(key);
+			if (prepareResult != null && prepareResult == XAResource.XA_OK) {
+				resourceManager.commit(key, false);
+			}
+		}
+			
+	}	
+}
+
+/**
+ * Complete the transaction represented by this Transaction object.
+ *
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been rolled back rather than committed.
+ * @exception HeuristicMixedException Thrown to indicate that a heuristic
+ * decision was made and that some relevant updates have been committed
+ * while others have been rolled back.
+ * @exception HeuristicRollbackException Thrown to indicate that a
+ * heuristic decision was made and that some relevant updates have been
+ * rolled back.
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_commitNonXA() throws SystemException {
+	for (int i = 0; i < nonXAResources.size(); i++){
+		NonXAResource res = (NonXAResource)nonXAResources.get(i);	
+		res.commit();	
+	}
+}
+/**
+ * Delist the resource specified from the current transaction associated
+ * with the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @param flag One of the values of TMSUCCESS, TMSUSPEND, or TMFAIL
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is inactive.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_delist() throws SystemException {
+	// end each enlisted resource	
+	for (Xid key : branches.keySet()) {
+		XAResource resourceManager = branches.get(key);
+		// Preparing the resource manager using its branch xid
+		delistResource(resourceManager, XAResource.TMSUCCESS);
+	}
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_prepare() throws XAException { 	
+	for (Xid key : branches.keySet()) {
+		XAResource resourceManager = (XAResource) branches.get(key);
+		// Preparing the resource manager using its branch xid
+		int retval = resourceManager.prepare(key);
+		prepareResults.put(key, new Integer(retval));
+	}
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_rollback() throws XAException {
+	status = Status.STATUS_ROLLING_BACK;
+	for (Xid xid : branches.keySet()) {
+		XAResource resourceManager = branches.get(xid);
+		resourceManager.rollback(xid);
+	}
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void do_rollbackNonXA() throws SystemException {
+	for (int i = 0; i < nonXAResources.size(); i++){
+		NonXAResource res = (NonXAResource)nonXAResources.get(i);	
+		res.rollback();	
+	}
+}
+/**
+ * Enlist the resource specified with the current transaction context of
+ * the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @return true if the resource was enlisted successfully; otherwise false.
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been marked for rollback only.
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is in prepared state or the transaction is inactive.
+ * @exception SystemException Thrown if the transaction manager
+ * encounters an unexpected error condition.
+ */
+public boolean enlistNonXAResource(NonXAResource res) {
+	//System.out.println("Enlist a non XA Resource");
+	nonXAResources.add(res);		
+	return true;
+}
+/**
+ * Enlist the resource specified with the current transaction context of
+ * the calling thread.
+ *
+ * @param xaRes The XAResource object representing the resource to delist
+ * @return true if the resource was enlisted successfully; otherwise false.
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been marked for rollback only.
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is in prepared state or the transaction is inactive.
+ * @exception SystemException Thrown if the transaction manager
+ * encounters an unexpected error condition.
+ */
+public boolean enlistResource(XAResource xaRes)	throws RollbackException, IllegalStateException, SystemException {
+
+	//System.out.println(this + "  ENLIST " + xaRes);
+	if (status == Status.STATUS_MARKED_ROLLBACK) {
+		throw new RollbackException();
+	}
+
+	// Check status ACTIVE
+	if (status != Status.STATUS_ACTIVE) {
+		throw new IllegalStateException();
+	}
+
+	// Preventing two branches from being active at the same time on the
+	// same resource manager
+	Xid activeXid = (Xid) activeBranches.get(xaRes);
+	if (activeXid != null) {
+		return false;
+	}
+		
+	boolean alreadyEnlisted = false;
+	int flag = XAResource.TMNOFLAGS;
+
+	Xid branchXid = (Xid) suspendedResources.get(xaRes);
+
+	if (branchXid == null) {
+		for (XAResource resourceManager : enlistedResources) { 
+			if (alreadyEnlisted) {
+				break;
+			}
+			try {
+				if (resourceManager.isSameRM(xaRes)) {
+					System.out.println("Same Resource: " + xaRes + "," + resourceManager);
+
+					// TMJOIN is not support , because TMJOIN is allowed only after XAResource.end is invoked
+
+					//flag = XAResource.TMJOIN;
+					// use the same branch Xid to join the existing branch
+					//branchXid = (Xid)activeBranches.get(resourceManager);
+
+					alreadyEnlisted = true;
+				}
+			} catch (XAException e) {				
+				throw new SystemException(JtaTransactionImpl.getXAErrorCode(e));
+			}
+		}
+		
+		// use different branch Xid
+		branchXid = this.xid.newBranch(branchCounter ++);
+			
+		//System.out.println("Creating new branch for " + xaRes + "with Xid " + branchXid);
+
+	} else {
+		alreadyEnlisted = true;
+		flag = XAResource.TMRESUME;
+		suspendedResources.remove(xaRes);
+	}
+
+	try {
+		//System.out.println("Starting" + xaRes + " Branch: " + branchXid + ", Flag: " + getXAFlag(flag));
+		xaRes.start(branchXid, flag);
+		//System.out.println("End Starting" + xaRes + " Branch: " + branchXid + ", Flag: " + getXAFlag(flag));
+	} catch (XAException e) {
+		System.out.println("XAResource start Error code = " + getXAErrorCode(e));
+		return false;
+	}
+
+	if (!alreadyEnlisted) {
+		enlistedResources.add(xaRes);			
+	}
+		
+	branches.put(branchXid, xaRes);		
+	activeBranches.put(xaRes, branchXid);
+		
+	return true;
+}
+/**
+ * Obtain the status of the transaction associated with the current thread.
+ *
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ * @return The transaction status. If no transaction is associated with
+ * the current thread, this method returns the Status.NoTransaction value.
+ */
+public int getStatus() throws SystemException {
+	return status;
+}
+/**
+ * Return a String representation of the error code contained in a
+ * XAException.
+ */
+public static String getXAErrorCode(Throwable throww) {
+	String result = null;
+	if (throww instanceof XAException) {
+		result = getXAErrorCode((XAException) throww);
+	} else {
+		StringWriter sw = new StringWriter();
+		throww.printStackTrace(new PrintWriter(sw, true)); //autoFlush=true
+		result = sw.toString();
+	}
+	return result;
+}
+/**
+ * Return a String representation of the error code contained in a
+ * XAException.
+ */
+public static String getXAErrorCode(XAException xae) {
+	switch (xae.errorCode) {
+		case XAException.XA_HEURCOM :
+			{
+				return "XA_HEURCOM";
+			}
+		case XAException.XA_HEURHAZ :
+			{
+				return "XA_HEURHAZ";
+			}
+		case XAException.XA_HEURMIX :
+			{
+				return "XA_HEURMIX";
+			}
+		case XAException.XA_HEURRB :
+			{
+				return "XA_HEURRB";
+			}
+		case XAException.XA_NOMIGRATE :
+			{
+				return "XA_NOMIGRATE";
+			}
+		case XAException.XA_RBBASE :
+			{
+				return "XA_RBBASE";
+			}
+		case XAException.XA_RBCOMMFAIL :
+			{
+				return "XA_RBCOMMFAIL";
+			}
+		case XAException.XA_RBDEADLOCK :
+			{
+				return "XA_RBBEADLOCK";
+			}
+		case XAException.XA_RBEND :
+			{
+				return "XA_RBEND";
+			}
+		case XAException.XA_RBINTEGRITY :
+			{
+				return "XA_RBINTEGRITY";
+			}
+		case XAException.XA_RBOTHER :
+			{
+				return "XA_RBOTHER";
+			}
+		case XAException.XA_RBPROTO :
+			{
+				return "XA_RBPROTO";
+			}
+		case XAException.XA_RBTIMEOUT :
+			{
+				return "XA_RBTIMEOUT";
+			}
+		case XAException.XA_RDONLY :
+			{
+				return "XA_RDONLY";
+			}
+		case XAException.XA_RETRY :
+			{
+				return "XA_RETRY";
+			}
+		case XAException.XAER_ASYNC :
+			{
+				return "XAER_ASYNC";
+			}
+		case XAException.XAER_DUPID :
+			{
+				return "XAER_DUPID";
+			}
+		case XAException.XAER_INVAL :
+			{
+				return "XAER_INVAL";
+			}
+		case XAException.XAER_NOTA :
+			{
+				return "XAER_NOTA";
+			}
+		case XAException.XAER_OUTSIDE :
+			{
+				return "XAER_OUTSIDE";
+			}
+		case XAException.XAER_PROTO :
+			{
+				return "XAER_PROTO";
+			}
+		case XAException.XAER_RMERR :
+			{
+				return "XAER_RMERR";
+			}
+		case XAException.XAER_RMFAIL :
+			{
+				return "XAER_RMFAIL";
+			}
+		default :
+			{
+				return "UNKNOWN";
+			}
+	}
+}
+/**
+ * Return a String representation of a flag.
+ */
+public static String getXAFlag(int flag) {
+	switch (flag) {
+		case XAResource.TMENDRSCAN :
+			{
+				return "TMENDRSCAN";
+			}
+		case XAResource.TMFAIL :
+			{
+				return "TMFAIL";
+			}
+		case XAResource.TMJOIN :
+			{
+				return "TMJOIN";
+			}
+		case XAResource.TMNOFLAGS :
+			{
+				return "TMNOFLAGS";
+			}
+		case XAResource.TMONEPHASE :
+			{
+				return "TMONEPHASE";
+			}
+		case XAResource.TMRESUME :
+			{
+				return "TMRESUME";
+			}
+		case XAResource.TMSTARTRSCAN :
+			{
+				return "TMSTARTRSCAN";
+			}
+		case XAResource.TMSUCCESS :
+			{
+				return "TMSUCCESS";
+			}
+		case XAResource.TMSUSPEND :
+			{
+				return "TMSUSPEND";
+			}
+		default :
+			{
+				return "UNKNOWN";
+			}
+	}
+}
+/**
+ * Register a synchronization object for the transaction currently
+ * associated with the calling thread. The transction manager invokes the
+ * beforeCompletion method prior to starting the transaction commit
+ * process. After the transaction is completed, the transaction manager
+ * invokes the afterCompletion method.
+ *
+ * @param sync The Synchronization object for the transaction associated
+ * with the target object.
+ * @exception RollbackException Thrown to indicate that the transaction
+ * has been marked for rollback only.
+ * @exception IllegalStateException Thrown if the transaction in the
+ * target object is in prepared state or the transaction is inactive.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void registerSynchronization(Synchronization sync) throws RollbackException, IllegalStateException, SystemException {
+
+	if (status == Status.STATUS_MARKED_ROLLBACK) {
+		throw new RollbackException();
+	}
+
+	if (status != Status.STATUS_ACTIVE) {
+		throw new IllegalStateException();
+	}
+
+	synchronizationObjects.add(sync);
+
+}
+/**
+ * Roll back the transaction associated with the current thread. When
+ * this method completes, the thread becomes associated with no
+ * transaction.
+ *
+ * @exception SecurityException Thrown to indicate that the thread is not
+ * allowed to commit the transaction.
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void rollback() throws IllegalStateException, SystemException {
+
+	//System.out.println(this + "  ROLLBACK ");
+
+	// Check status ACTIVE	
+	if (status != Status.STATUS_ACTIVE && status != Status.STATUS_MARKED_ROLLBACK) {
+		throw new IllegalStateException();
+	}
+
+	status = Status.STATUS_ROLLING_BACK;
+
+	try {
+		do_rollbackNonXA();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+	}
+
+	try {
+		do_rollback();
+	} catch (Throwable e) {
+		e.printStackTrace(System.out);
+	}
+	
+	status = Status.STATUS_ROLLEDBACK;
+}
+/**
+ * Modify the transaction associated with the current thread such that
+ * the only possible outcome of the transaction is to roll back the
+ * transaction.
+ *
+ * @exception IllegalStateException Thrown if the current thread is not
+ * associated with a transaction.
+ * @exception SystemException Thrown if the transaction manager encounters
+ * an unexpected error condition.
+ */
+public void setRollbackOnly() throws IllegalStateException, SystemException {
+	status = Status.STATUS_MARKED_ROLLBACK;
+}
+/**
+ * Print the Transaction object in a debugger friendly manner
+ */
+public String toString() {
+	return "Transaction " + currentTransactionNumber + " xid " + xid + " in thread " + currentThreadName
+		+ ((currentThreadName.equals(Thread.currentThread().getName())) ? "" : (" current= " + Thread.currentThread().getName()));
+}
+}
Index: src/cbit/vcell/transaction/NonXAResource.java
===================================================================
--- src/cbit/vcell/transaction/NonXAResource.java	(revision 0)
+++ src/cbit/vcell/transaction/NonXAResource.java	(revision 12031)
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/29/2003 1:06:24 PM)
+ * @author: Fei Gao
+ */
+public interface NonXAResource {
+	public void commit() throws javax.transaction.SystemException;
+	public void rollback() throws javax.transaction.SystemException;
+}
Index: src/cbit/vcell/transaction/JtaXAOracleConnection.java
===================================================================
--- src/cbit/vcell/transaction/JtaXAOracleConnection.java	(revision 0)
+++ src/cbit/vcell/transaction/JtaXAOracleConnection.java	(revision 12031)
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 1999-2011 University of Connecticut Health Center
+ *
+ * Licensed under the MIT License (the "License").
+ * You may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *  http://www.opensource.org/licenses/mit-license.php
+ */
+
+package cbit.vcell.transaction;
+import javax.transaction.*;
+import java.sql.SQLException;
+import oracle.jdbc.xa.client.OracleXADataSource;
+import javax.sql.XAConnection;
+import javax.transaction.xa.XAResource;
+
+import org.vcell.util.PropertyLoader;
+
+/**
+ * Insert the type's description here.
+ * Creation date: (7/21/2003 1:54:33 PM)
+ * @author: Fei Gao
+ */
+public class JtaXAOracleConnection implements JtaDbConnection {
+	private OracleXADataSource oraXADataSource = null;
+	private XAConnection  xaConnection = null;
+	private java.sql.Connection connection = null;
+
+/**
+ * OracleJtaDataSource constructor comment.
+ * @param ur java.lang.String
+ * @param uname java.lang.String
+ * @param pw java.lang.String
+ */
+public JtaXAOracleConnection() throws SQLException {
+	oraXADataSource = new OracleXADataSource();
+	oraXADataSource.setURL(PropertyLoader.getRequiredProperty(PropertyLoader.dbConnectURL));
+	oraXADataSource.setUser(PropertyLoader.getRequiredProperty(PropertyLoader.dbUserid));
+	oraXADataSource.setPassword(PropertyLoader.getRequiredProperty(PropertyLoader.dbPassword));
+	xaConnection = oraXADataSource.getXAConnection();
+}
+
+
+/**
+ * close method comment.
+ */
+public void close() throws SQLException {
+	if (connection != null) {
+		connection.close();
+		connection = null;
+	}
+}
+
+
+/**
+ * closeOnFailure method comment.
+ */
+public void closeOnFailure() throws java.sql.SQLException {
+	close(); // close the connection handle
+	if (xaConnection != null) {
+		xaConnection.close(); // close the physical connection
+		xaConnection = null;
+	}
+}
+
+
+/**
+ * This method was created in VisualAge.
+ * @return java.sql.Connection
+ * @exception java.sql.SQLException The exception description.
+ * @exception java.lang.ClassNotFoundException The exception description.
+ */
+public java.sql.Connection getConnection() throws SQLException {
+	if (xaConnection == null) {
+		xaConnection = oraXADataSource.getXAConnection(); // get another physical connection
+	}
+	// From http://download-west.oracle.com/docs/cd/B14117_01/java.101/b10979/xadistra.htm#sthref552
+	// Each time an XA connection instance getConnection() method is called, it returns a new connection instance that 
+	// exhibits the default behavior, and closes any previous connection instance that still exists and had been returned 
+	// by the same XA connection instance. It is advisable to explicitly close any previous connection 
+	// instance before opening a new one, however.
+	
+	close();
+	connection = xaConnection.getConnection();	
+ 	return connection;
+}
+
+
+/**
+ * joinTransaction method comment.
+ */
+public boolean joinTransaction(TransactionManager tm) throws java.sql.SQLException {
+	try {
+		XAResource xaRes = xaConnection.getXAResource();
+		if (xaRes == null || !tm.getTransaction().enlistResource(xaRes)) {
+			return false;
+		}
+
+		return true;
+	} catch (Exception ex) {
+		ex.printStackTrace(System.out);
+		throw new SQLException(ex.getMessage());
+	}
+
+}
+}
Index: src/cbit/vcell/solvers/CppClassCoderSimulation.java
===================================================================
--- src/cbit/vcell/solvers/CppClassCoderSimulation.java	(revision 12032)
+++ src/cbit/vcell/solvers/CppClassCoderSimulation.java	(revision 12031)
@@ -9,42 +9,18 @@
  */
 
 package cbit.vcell.solvers;
-import java.io.File;
-import java.io.PrintWriter;
-import java.util.Enumeration;
-import java.util.Vector;
+import java.util.*;
+import java.io.*;
 
-import org.vcell.util.PropertyLoader;
-
+import cbit.vcell.parser.Expression;
+import cbit.vcell.simdata.SimDataConstants;
+import cbit.vcell.solver.*;
 import cbit.vcell.field.FieldDataIdentifierSpec;
 import cbit.vcell.field.FieldFunctionArguments;
 import cbit.vcell.field.FieldUtilities;
-import cbit.vcell.math.CompartmentSubDomain;
-import cbit.vcell.math.Equation;
-import cbit.vcell.math.FilamentVariable;
-import cbit.vcell.math.MathDescription;
-import cbit.vcell.math.MemVariable;
-import cbit.vcell.math.MembraneRegionVariable;
-import cbit.vcell.math.PdeEquation;
-import cbit.vcell.math.RandomVariable;
-import cbit.vcell.math.SubDomain;
-import cbit.vcell.math.Variable;
-import cbit.vcell.math.VariableType;
-import cbit.vcell.math.VolVariable;
-import cbit.vcell.math.VolumeRegionVariable;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
+import cbit.vcell.math.*;
+import cbit.vcell.messaging.JmsUtils;
 import cbit.vcell.messaging.server.SimulationTask;
-import cbit.vcell.parser.Expression;
-import cbit.vcell.simdata.SimDataConstants;
-import cbit.vcell.solver.DefaultOutputTimeSpec;
-import cbit.vcell.solver.ErrorTolerance;
-import cbit.vcell.solver.OutputTimeSpec;
-import cbit.vcell.solver.Simulation;
-import cbit.vcell.solver.SimulationSymbolTable;
-import cbit.vcell.solver.SolverDescription;
-import cbit.vcell.solver.SolverTaskDescription;
-import cbit.vcell.solver.UniformOutputTimeSpec;
 
 /**
  * This class was generated by a SmartGuide.
@@ -505,11 +481,11 @@
 	out.println("\t\t\tSimulationMessaging::create();");
 	out.println("\t\t} else {");
 	out.println("#ifdef USE_MESSAGING");
-	out.println("\t\t\tchar* broker = \"" + PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL) + "\";");
-    out.println("\t\t\tchar *smqusername = \"" + PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser) + "\";");
-    out.println("\t\t\tchar *password = \"" + PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword) + "\";");
-    out.println("\t\t\tchar *qname = \"" + VCellQueue.WorkerEventQueue.getName() + "\";");  
-	out.println("\t\t\tchar* tname = \"" + VCellTopic.ServiceControlTopic.getName() + "\";");
+	out.println("\t\t\tchar* broker = \"" + JmsUtils.getJmsUrl() + "\";");
+    out.println("\t\t\tchar *smqusername = \"" + JmsUtils.getJmsUserID() + "\";");
+    out.println("\t\t\tchar *password = \"" + JmsUtils.getJmsPassword() + "\";");
+    out.println("\t\t\tchar *qname = \"" + JmsUtils.getQueueWorkerEvent() + "\";");  
+	out.println("\t\t\tchar* tname = \"" + JmsUtils.getTopicServiceControl() + "\";");
 	out.println("\t\t\tchar* vcusername = \"" + simulation.getVersion().getOwner().getName() + "\";");
 	out.println("\t\t\tjint simKey = " + simulation.getVersion().getVersionKey() + ";");
 	out.println("\t\t\tjint jobIndex = " + simTask.getSimulationJob().getJobIndex() + ";");
Index: src/cbit/vcell/client/desktop/DatabaseSearchPanel.java
===================================================================
--- src/cbit/vcell/client/desktop/DatabaseSearchPanel.java	(revision 12032)
+++ src/cbit/vcell/client/desktop/DatabaseSearchPanel.java	(revision 12031)
@@ -42,7 +42,7 @@
 import org.vcell.util.gui.CollapsiblePanel;
 
 import cbit.gui.TextFieldAutoCompletion;
-import cbit.vcell.message.server.console.DatePanel;
+import cbit.vcell.messaging.admin.DatePanel;
 
 @SuppressWarnings("serial")
 public class DatabaseSearchPanel extends CollapsiblePanel {
Index: src/org/vcell/solver/smoldyn/SmoldynFileWriter.java
===================================================================
--- src/org/vcell/solver/smoldyn/SmoldynFileWriter.java	(revision 12032)
+++ src/org/vcell/solver/smoldyn/SmoldynFileWriter.java	(revision 12031)
@@ -82,8 +82,7 @@
 import cbit.vcell.math.Variable;
 import cbit.vcell.math.VariableType;
 import cbit.vcell.math.VolumeParticleVariable;
-import cbit.vcell.message.VCellQueue;
-import cbit.vcell.message.VCellTopic;
+import cbit.vcell.messaging.JmsUtils;
 import cbit.vcell.messaging.server.SimulationTask;
 import cbit.vcell.parser.DivideByZeroException;
 import cbit.vcell.parser.Expression;
@@ -1974,10 +1973,10 @@
 	if (simTask != null) {
 		printWriter.println("# JMS_Paramters");
 		printWriter.println("start_jms"); 
-		printWriter.println(PropertyLoader.getRequiredProperty(PropertyLoader.jmsProvider) + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsURL)
-			+ " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsUser) + " " + PropertyLoader.getRequiredProperty(PropertyLoader.jmsPassword)
-			+ " " + VCellQueue.WorkerEventQueue.getName()  
-			+ " " + VCellTopic.ServiceControlTopic.getName()
+		printWriter.println(JmsUtils.getJmsProvider() + " " + JmsUtils.getJmsUrl()
+			+ " " + JmsUtils.getJmsUserID() + " " + JmsUtils.getJmsPassword()
+			+ " " + JmsUtils.getQueueWorkerEvent()  
+			+ " " + JmsUtils.getTopicServiceControl()
 			+ " " + simulation.getVersion().getOwner().getName()
 			+ " " + simulation.getVersion().getVersionKey()
 			+ " " + simTask.getSimulationJob().getJobIndex());
