package cbit.vcell.mesh;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.util.*;
import java.io.*;
import cbit.util.*;
import cbit.vcell.geometry.*;
import cbit.vcell.math.VCML;
import cbit.vcell.math.MathException;
import cbit.vcell.math.MathFormatException;
import cbit.vcell.math.CoordinateIndex;
import cbit.vcell.math.VariableType;
/**
 * This class was generated by a SmartGuide.
 * 
 */
public class CartesianMesh implements Serializable, Matchable {

	//
	private static class MembraneMeshMetrics {
		public short[] regionIndexes;
		public float[] areas;
		public float[][] normals;
		public float[][] centroids;
	}
	//
	private byte[] compressedBytes = null;
		
	private transient MembraneElement membraneElements[] = null;
	private transient ContourElement contourElements[] = null;
	private transient MeshRegionInfo meshRegionInfo = null;
	private transient ISize size = null;
	private transient Origin origin = new Origin(0,0,0);
	private transient Extent extent = new Extent(10,10,10);
	private transient String version = VERSION_1_0;

	public final static String VERSION_1_0 = "1.0";		// origin, extent, sizeXYZ, 
														// membrane (membraneIndex, insideVolumeIndex, outsideVolumeIndex)
														
	public final static String VERSION_1_1 = "1.1";		// added: membrane connectivity 8/30/2000
	public final static String VERSION_1_2 = "1.2";		// added: Regions 07/02/2001
	

	private static final int NO_MEMBRANE_INDEX = -1;

/**
 * This method was created by a SmartGuide.
 */
private CartesianMesh () {
}


/**
 * This method was created by a SmartGuide.
 */
private CartesianMesh (int sizeX, int sizeY, int sizeZ) {
	this.size = new ISize(sizeX, sizeY, sizeZ);
}

/**
 * Insert the method's description here.
 * Creation date: (10/3/00 2:48:55 PM)
 * @return cbit.vcell.simdata.PDEVariableType
 * @param mesh cbit.vcell.solvers.CartesianMesh
 * @param dataLength int
 */
public static final VariableType getVariableTypeFromLength(CartesianMesh mesh, int dataLength) {
	VariableType result = null;
	if (mesh.getDataLength(VariableType.VOLUME) == dataLength) {
		result = VariableType.VOLUME;
	} else if (mesh.getDataLength(VariableType.MEMBRANE) == dataLength) {
		result = VariableType.MEMBRANE;
	} else if (mesh.getDataLength(VariableType.CONTOUR) == dataLength) {
		result = VariableType.CONTOUR;
	} else if (mesh.getDataLength(VariableType.VOLUME_REGION) == dataLength) {
		result = VariableType.VOLUME_REGION;
	} else if (mesh.getDataLength(VariableType.MEMBRANE_REGION) == dataLength) {
		result = VariableType.MEMBRANE_REGION;
	} else if (mesh.getDataLength(VariableType.CONTOUR_REGION) == dataLength) {
		result = VariableType.CONTOUR_REGION;
	}
	return result;
}

/**
 * Insert the method's description here.
 * Creation date: (2/23/2006 12:52:44 PM)
 */
public double calculateMeshElementVolumeFromVolumeIndex(int volumeIndex) {

	CoordinateIndex ci = getCoordinateIndexFromVolumeIndex(volumeIndex);
    double fxMESize = (ci.x == 0 || ci.x == (getSizeX()-1)?.5:1);
    double fyMESize = (getGeometryDimension() >= 2 ?(ci.y == 0 || ci.y == (getSizeY()-1)?.5:1):0);
    double fzMESize = (getGeometryDimension() == 3 ?(ci.z == 0 || ci.z == (getSizeZ()-1)?.5:1):0);
    
    return (fxMESize != 0?fxMESize*(getExtent().getX()/(getSizeX()-1)):1)*
    		(fyMESize != 0?fyMESize*(getExtent().getY()/(getSizeY()-1)):1)*
    		(fzMESize != 0?fzMESize*(getExtent().getZ()/(getSizeZ()-1)):1);
	
}


/**
 * This method was created in VisualAge.
 * @return boolean
 * @param object java.lang.Object
 */
public boolean compareEqual(Matchable object) {
	if(this == object){
		return true;
	}
	if (object == null){
		return false;
	}
	CartesianMesh mesh = null;
	if (!(object instanceof CartesianMesh)){
		return false;
	}else{
		mesh = (CartesianMesh)object;
	}

	if (!Compare.isEqualOrNullStrict(membraneElements,mesh.membraneElements)){
		return false;
	}
	if (!Compare.isEqualOrNullStrict(contourElements,mesh.contourElements)){
		return false;
	}
	if (!size.compareEqual(mesh.size)) {
		return false;
	}
	/*
	if (sizeX!=mesh.sizeX || sizeY!=mesh.sizeY || sizeZ!=mesh.sizeZ){
		return false;
	}
	*/
	if (!origin.compareEqual(mesh.origin)){
		return false;
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (8/4/2005 8:25:37 AM)
 */
public static boolean compareMesh(CartesianMesh mesh1, CartesianMesh mesh2, PrintWriter pw) {
	try {
		/*
		if (mesh1.compareEqual(mesh2)) {
			return true;
		}		
		*/
		
		int dimension = mesh1.getGeometryDimension();
		
		if (dimension != mesh2.getGeometryDimension()) {
			return false;
		}

		// Size
		if (mesh1.getSizeX() != mesh2.getSizeX() || dimension > 1 && mesh1.getSizeY() != mesh2.getSizeY()
			|| dimension > 2 && mesh1.getSizeZ() != mesh2.getSizeZ()) {
			pw.println("Size is differnt!");
			System.out.println("Size is differnt!");
			return false;
		}

		// Extent
		if (mesh1.getExtent().getX() != mesh2.getExtent().getX() || dimension > 1 && mesh1.getExtent().getY() != mesh2.getExtent().getY()
			|| dimension > 2 && mesh1.getExtent().getZ() != mesh2.getExtent().getZ()) {
			pw.println("Extent is differnt!");
			System.out.println("Extent is differnt!");
			return false;
		}

		// Origin
		if (mesh1.getOrigin().getX() != mesh2.getOrigin().getX() || dimension > 1 && mesh1.getOrigin().getY() != mesh2.getOrigin().getY()
			|| dimension > 2 && mesh1.getOrigin().getZ() != mesh2.getOrigin().getZ()) {
			pw.println("Origin is different!");
			System.out.println("Origin is different!");
			return false;
		}
		
		if (!Compare.isEqualOrNullStrict(mesh1.getContourElements(),mesh2.getContourElements())){
			pw.println("ContourElemment is different!");
			System.out.println("ContourElemment is different!");
			return false;
		}

		MeshRegionInfo meshRegionInfo1 = mesh1.getMeshRegionInfo();
		MeshRegionInfo meshRegionInfo2 = mesh2.getMeshRegionInfo();


		// Compare VolumeRegionMapSubVolume
		if (meshRegionInfo1.getNumVolumeRegions() != meshRegionInfo2.getNumVolumeRegions()) {
			pw.println("# of volume regions is different!");
			return false;
		}
		Vector vrmsv1 = meshRegionInfo1.getVolumeRegionMapSubvolume();
		Vector vrmsv2 = meshRegionInfo2.getVolumeRegionMapSubvolume();
		
		// The volume of volume regions or area of membrane regions are printed with 6 digits after the decimal point,
		// so we have to allow limited precision when comparing for equivalency. 1.1E-6 is used for safety, theoretically
		// 1E-6 should work.
		double precision = 1.1E-6;
		double MAX_REL_ERROR = 1E-8;

		// Areas and volumes are calculated using all 3 dimension sizes (e.g. size Z in 2D). Different versions of virtual cell
		// allow for different numbers in Z, but they are really equivalent. The volumes and areas have to be scaled before comparison.
		double scale = 0;
		switch (dimension) {
			case 1:
				scale = mesh1.getExtent().getY() * mesh1.getExtent().getZ() / (mesh2.getExtent().getY() * mesh2.getExtent().getZ());
				break;
			case 2:
				scale = mesh1.getExtent().getZ()/ mesh2.getExtent().getZ();
				break;
			case 3:
				scale = 1;
				break;
		}
		precision = Math.max(precision, precision/scale);

		for (int i = 0; i < meshRegionInfo1.getNumVolumeRegions(); i ++) {
			MeshRegionInfo.VolumeRegionMapSubvolume region1 = (MeshRegionInfo.VolumeRegionMapSubvolume)vrmsv1.elementAt(i);
			MeshRegionInfo.VolumeRegionMapSubvolume region2 = (MeshRegionInfo.VolumeRegionMapSubvolume)vrmsv2.elementAt(i);
			double region1Volume = region1.volumeRegionVolume/scale;
			double region2Volume = region2.volumeRegionVolume;			
			
			if (region1.volumeRegionID != region2.volumeRegionID 
				|| region1.subvolumeID != region2.subvolumeID
				|| (Math.abs(region1Volume - region2Volume) > precision && Math.abs(region1Volume - region2Volume)/region1Volume > MAX_REL_ERROR)) {
				System.out.println("VolumeRegionMapSubVolume is different!");
				pw.println("VolumeRegionMapSubVolume is different!");
				return false;
			}
		}

		// Compare MembraneRegionsMapVolumeRegion
		if (meshRegionInfo1.getNumMembraneRegions() != meshRegionInfo2.getNumMembraneRegions()) {
			System.out.println("# of MembraneRegions is different");
			pw.println("# of MembraneRegions is different");
			return false;
		}

		Vector mrmsv1 = meshRegionInfo1.getMembraneRegionMapVolumeRegion();
		Vector mrmsv2 = meshRegionInfo2.getMembraneRegionMapVolumeRegion();

		int[] membraneRegionMapping = new int[meshRegionInfo1.getNumMembraneRegions()];
		
		for (int i = 0; i < meshRegionInfo2.getNumMembraneRegions(); i ++) {			
			MeshRegionInfo.MembraneRegionMapVolumeRegion region2 = (MeshRegionInfo.MembraneRegionMapVolumeRegion)mrmsv2.elementAt(i);
			int correspondingMemRegionIndex = -1;
			int count = 0;			
			for (int j = 0; j < meshRegionInfo1.getNumMembraneRegions(); j ++) {
				MeshRegionInfo.MembraneRegionMapVolumeRegion region1 = (MeshRegionInfo.MembraneRegionMapVolumeRegion)mrmsv1.elementAt(j);
					if (region1.volumeRegionInsideID == region2.volumeRegionInsideID && region1.volumeRegionOutsideID == region2.volumeRegionOutsideID) {
						correspondingMemRegionIndex = j;
						count ++;
						if (count > 1) {
							System.out.println("There are two membrane regions in the first mesh that's mapped to " + i + "th membrane region in the second mesh");
							pw.println("There are two membrane regions in the first mesh that's mapped to " + i + "th membrane region in the second mesh");
							return false;
						}
					}
			}
			if (correspondingMemRegionIndex==-1){
				return false;
			}
			// make sure every element in the first mesh has only one mapping in the second mesh
			for (int k = 0; k < i; k ++) {
				if (correspondingMemRegionIndex == membraneRegionMapping[k]) {
					System.out.println("There are two membrane regions in the second mesh that's mapped to " + correspondingMemRegionIndex + "th membrane region element in the first mesh");
					pw.println("There are two membrane regions in the second mesh that's mapped to " + correspondingMemRegionIndex + "th membrane region element in the first mesh");
					return false;
				}
			}
			membraneRegionMapping[i] = correspondingMemRegionIndex;		
			MeshRegionInfo.MembraneRegionMapVolumeRegion region1 = (MeshRegionInfo.MembraneRegionMapVolumeRegion)mrmsv1.elementAt(correspondingMemRegionIndex);

			double region1Surface = region1.membraneRegionSurface/scale;
			double region2Surface = region2.membraneRegionSurface;
			
			// compare surface area, ignoring the index
			if (Math.abs(region1Surface - region2Surface)/region1Surface > MAX_REL_ERROR && Math.abs(region1Surface - region2Surface) > precision) {
				System.out.println("MembraneRegionsMapVolumeRegion is different!");
				pw.println("MembraneRegionsMapVolumeRegion is different!");
				return false;
			}
		}
		
		// Compare VolumeElementsMapVolumeRegion
		if (mesh1.getNumVolumeElements() != mesh2.getNumVolumeElements()) {
			return false;
		}
		for (int i = 0; i < mesh1.getNumVolumeElements(); i ++) {
			if (mesh1.getVolumeRegionIndex(i) != mesh2.getVolumeRegionIndex(i)) {
				System.out.println("VolumeElementsMapVolumeRegion is different at " + i);
				pw.println("VolumeElementsMapVolumeRegion is different at " + i);
				return false;
			}
		}

		// Compare Membrane Elements
		if (mesh1.getNumMembraneElements() != mesh2.getNumMembraneElements()){
			return false;
		}
		if (mesh1.getNumMembraneElements()==0){
			return true;
		}
		MembraneElement[] memElements1 = mesh1.getMembraneElements();
		MembraneElement[] memElements2 = mesh2.getMembraneElements();
		int[] mapping = new int[memElements2.length];
		for (int i = 0; i < memElements2.length; i++){
			int insideIndex2 = memElements2[i].getInsideVolumeIndex();
			int outsideIndex2 = memElements2[i].getOutsideVolumeIndex();
			int correspondingMemIndex = -1;
			int count = 0;
			for (int j = 0; j < memElements1.length; j++){
				int insideIndex1 = memElements1[j].getInsideVolumeIndex();
				int outsideIndex1 = memElements1[j].getOutsideVolumeIndex();
				if (insideIndex1==insideIndex2 && outsideIndex1==outsideIndex2){
					correspondingMemIndex = j;
					count ++;
					// make sure every element in the second mesh has only one mapping in the first mesh
					if (count > 1) {
						System.out.println("There are two membrane elements in the first mesh that's mapped to " + i + "th membrane element in the second mesh");
						pw.println("There are two membrane elements in the first mesh that's mapped to " + i + "th membrane element in the second mesh");
						return false;
					}
				}
			}
			
			if (correspondingMemIndex==-1){
				return false;
			}
			// make sure every element in the first mesh has only one mapping in the second mesh
			for (int k = 0; k < i; k ++) {
				if (correspondingMemIndex == mapping[k]) {
					System.out.println("There are two membrane elements in the second mesh that's mapped to " + correspondingMemIndex + "th membrane element in the first mesh");
					pw.println("There are two membrane elements in the second mesh that's mapped to " + correspondingMemIndex + "th membrane element in the first mesh");
					return false;
				}
			}
			mapping[i] = correspondingMemIndex;
		}
		for (int i = 0; i < mapping.length; i++){
			int correspondingMemIndex = mapping[i]; // corresponding membrane index of the second mesh in the first mesh 

			// compare membrane elements, ignoring the index
			/*
			if (memIndex != memElement.memIndex){
				return false;
			}
			*/

			// Inside
			if (memElements1[correspondingMemIndex].getInsideVolumeIndex() != memElements2[i].getInsideVolumeIndex()){
				return false;
			}

			// Outside
			if (memElements1[correspondingMemIndex].getOutsideVolumeIndex() != memElements2[i].getOutsideVolumeIndex()){
				return false;
			}
			
			// Neighbors	
			int[] neighborIndexes1 = memElements1[correspondingMemIndex].getMembraneNeighborIndexes();
			int[] neighborIndexes2 = memElements2[i].getMembraneNeighborIndexes();
			if ((neighborIndexes1!=null && neighborIndexes2==null) ||
				(neighborIndexes1==null && neighborIndexes2!=null)){
				return false;
			}
			if (neighborIndexes1!=null && neighborIndexes2!=null){
				if (neighborIndexes1.length!=neighborIndexes2.length){
					return false;
				}
				for (int k=0;k<neighborIndexes1.length;k++){
					if (neighborIndexes1[k] != mapping[neighborIndexes2[k]]){
						return false;
					}
				}
			}
			// Membrane Region ID
			if (mesh1.getMembraneRegionIndex(correspondingMemIndex) != membraneRegionMapping[mesh2.getMembraneRegionIndex(i)]) {
				return false;
			}		
		}
			
	} catch (Exception ex) {
		ex.printStackTrace();
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (8/12/2005 1:06:21 PM)
 * @return cbit.vcell.geometry.Coordinate
 * @param orig cbit.util.Origin
 * @param ext cbit.util.Extent
 * @param dimensionFlag int
 */
public static double coordComponentFromSinglePlanePolicy(Origin argOrigin, Extent argExtent, int argAxisFlag) {
	
	if(argAxisFlag == Coordinate.X_AXIS){
		return argExtent.getX()/2.0 + argOrigin.getX();
	}else if(argAxisFlag == Coordinate.Y_AXIS){
		return argExtent.getY()/2.0 + argOrigin.getY();
	}else if(argAxisFlag == Coordinate.Z_AXIS){
		return argExtent.getZ()/2.0 + argOrigin.getZ();
	}

	throw new IllegalArgumentException("Unknown Axis Flag="+argAxisFlag);
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
public static CartesianMesh fromTokens(cbit.vcell.math.CommentStringTokenizer meshTokens,cbit.vcell.math.CommentStringTokenizer membraneMeshMetricsTokens) throws MathException {
	CartesianMesh mesh = new CartesianMesh();

	MembraneMeshMetrics membraneMeshMetrics = null;
	if(membraneMeshMetricsTokens != null){
		membraneMeshMetrics = mesh.readMembraneMeshMetrics(membraneMeshMetricsTokens);
	}
	mesh.read(meshTokens,membraneMeshMetrics);
	return mesh;
}


/**
 * Insert the method's description here.
 * Creation date: (7/10/01 4:05:48 PM)
 * @return cbit.vcell.solvers.ContourElement[]
 */
public ContourElement[] getContourElements() {
	if (contourElements == null) {
		inflate();
	}
	return contourElements;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getContourRegionIndex(int contourIndex) {
	ContourElement contourElement = getContourElements()[contourIndex];
	throw new RuntimeException("CartesianMesh.getContourRegionIndex() not yet implemented");
	//return contourElement.getRegionIndex();
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinate(cbit.vcell.math.CoordinateIndex coordIndex) {
	//
	//
	// calculate coordinates based on element coordinates 
	//     
	//     1--------2--------3-------4--------N
	//
	// so spacing is divided into (N-1) regions.
	//
	//
	// if N is 1, then take middle of that dimension
	//
	//
	double x = coordComponentFromSinglePlanePolicy(origin,extent,Coordinate.X_AXIS);//extent.getX()/2.0 + origin.getX();
	if (getSizeX()>1){
		x = (((double)coordIndex.x)/(getSizeX()-1))*extent.getX()+origin.getX();
	}
	double y = coordComponentFromSinglePlanePolicy(origin,extent,Coordinate.Y_AXIS);//extent.getY()/2.0 + origin.getY();
	if (getSizeY()>1){
		y = (((double)coordIndex.y)/(getSizeY()-1))*extent.getY()+origin.getY();
	}
	double z = coordComponentFromSinglePlanePolicy(origin,extent,Coordinate.Z_AXIS);//extent.getZ()/2.0 + origin.getZ();
	if (getSizeZ()>1){
		z = (((double)coordIndex.z)/(getSizeZ()-1))*extent.getZ()+origin.getZ();
	}
	return (new Coordinate(x, y, z));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinateFromContourIndex(int contourIndex) {
    ContourElement ce = getContourElements()[contourIndex];
    Coordinate begCoord = ce.getBeginCoordinate();
    Coordinate endCoord = ce.getEndCoordinate();
    return (new Coordinate(
		0.5*(begCoord.getX() + endCoord.getX()),
		0.5*(begCoord.getY() + endCoord.getY()),
		0.5*(begCoord.getZ() + endCoord.getZ())));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinateFromMembraneIndex(int membraneIndex) {
    MembraneElement me = getMembraneElements()[membraneIndex];
    Coordinate inCoord = getCoordinateFromVolumeIndex(me.getInsideVolumeIndex());
    Coordinate outCoord = getCoordinateFromVolumeIndex(me.getOutsideVolumeIndex());
    return (new Coordinate(
		0.5*(inCoord.getX() + outCoord.getX()),
		0.5*(inCoord.getY() + outCoord.getY()),
		0.5*(inCoord.getZ() + outCoord.getZ())));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getCoordinateFromVolumeIndex(int volumeIndex) {
	return getCoordinate(getCoordinateIndexFromVolumeIndex(volumeIndex));
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public CoordinateIndex getCoordinateIndexFromFractionalIndex(Coordinate fractionalIndex) {
	return new CoordinateIndex(	(int)Math.round(fractionalIndex.getX()),
								(int)Math.round(fractionalIndex.getY()),
								(int)Math.round(fractionalIndex.getZ()));
}


/**
 * Insert the method's description here.
 * Creation date: (8/29/00 10:51:55 AM)
 * @return cbit.vcell.math.CoordinateIndex
 * @param volIndex int
 */
public CoordinateIndex getCoordinateIndexFromVolumeIndex(int volIndex) {
	int volZ = volIndex / (getSizeX() * getSizeY());
	volIndex -= volZ * (getSizeX() * getSizeY());
	int volY = volIndex / getSizeX();
	volIndex -= volY * getSizeX();
	int volX = volIndex;
	return new CoordinateIndex(volX, volY, volZ);
}


/**
 * This method was created in VisualAge.
 * @return int
 */
public int getDataLength(VariableType pdeVariableType) {
	int num = 0;
	if (pdeVariableType.equals(VariableType.VOLUME)) {
		num = getSizeX() * getSizeY() * getSizeZ();
	} else if (pdeVariableType.equals(VariableType.MEMBRANE)) {
		num = (membraneElements == null ? 0 : membraneElements.length);
	} else if (pdeVariableType.equals(VariableType.CONTOUR)) {
		throw new RuntimeException("CartesianMesh.getDataLength("+pdeVariableType+") not yet implemented");
	} else if (pdeVariableType.equals(VariableType.VOLUME_REGION)) {
		num = getNumVolumeRegions();
	} else if (pdeVariableType.equals(VariableType.MEMBRANE_REGION)) {
		num = getNumMembraneRegions();
	} else if (pdeVariableType.equals(VariableType.CONTOUR_REGION)) {
		throw new RuntimeException("CartesianMesh.getDataLength("+pdeVariableType+") not yet implemented");
	}
	return num;
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 */
public Extent getExtent() {
	if (extent == null) {
		inflate();
	}
	return extent;
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 * @param coordIndex cbit.vcell.math.CoordinateIndex
 */
public Coordinate getFractionalCoordinateIndex(Coordinate worldCoord) {
	//
	//
	// calculate coordinates based on element coordinates 
	//     
	//     1--------2--------3-------4--------N
	//
	// so spacing is divided into (N-1) regions.
	//
	//
	// if N is 1, then take middle of that dimension
	//
	//
	double fractX;
	double fractY;
	double fractZ;
	
	if (getSizeX()>1){
		fractX = (worldCoord.getX()-origin.getX())/extent.getX()*(getSizeX()-1);
	}else{
		fractX = 0;
	}
	
	if (getSizeY()>1){
		fractY = (worldCoord.getY()-origin.getY())/extent.getY()*(getSizeY()-1);
	}else{
		fractY = 0;
	}
	
	if (getSizeZ()>1){
		fractZ = (worldCoord.getZ()-origin.getZ())/extent.getZ()*(getSizeZ()-1);
	}else{
		fractZ = 0;
	}

	return new Coordinate(fractX,fractY,fractZ);
}


/**
 * Insert the method's description here.
 * Creation date: (2/4/2004 5:18:45 PM)
 * @return int
 * @param mesh cbit.vcell.solvers.CartesianMesh
 */
public int getGeometryDimension() {
	// Get dimension of geometry using mesh variables to use appropriate resampling algorithm.
	int dimension = 0;
	
	if ( (getSizeX() > 1) && (getSizeY() > 1) && (getSizeZ() > 1) ) {
		dimension = 3;
	} else if ( ( (getSizeX() > 1) && (getSizeY() > 1) && (getSizeZ() == 1) ) ||
				( (getSizeX() > 1) && (getSizeY() == 1) && (getSizeZ() > 1) ) ||
				( (getSizeX() == 1) && (getSizeY() > 1) && (getSizeZ() > 1) )  ) {
		dimension = 2;
	} else if ( ( (getSizeX() > 1) && (getSizeY() == 1) && (getSizeZ() == 1) ) ||
				( (getSizeX() == 1) && (getSizeY() > 1) && (getSizeZ() == 1) ) ||
				( (getSizeX() == 1) && (getSizeY() == 1) && (getSizeZ() > 1) )  ) {
		dimension = 1;
	}
				
	return dimension;
}


/**
 * Insert the method's description here.
 * Creation date: (7/10/01 4:05:48 PM)
 * @return cbit.vcell.solvers.MembraneElement[]
 */
public MembraneElement[] getMembraneElements() {
	if (membraneElements == null) {
		inflate();
	}
	return membraneElements;
}


/**
 * Insert the method's description here.
 * Creation date: (5/2/2005 10:20:34 AM)
 * @return int[]
 * @param referenceMesh cbit.vcell.solvers.CartesianMesh
 */
public int[] getMembraneIndexMapping(CartesianMesh referenceMesh) {
	//
	// this method gets a mapping between the membrane element indexes of this mesh and the reference mesh.
	// the assumption is that the volume indices don't require any mappings, but the surfaces may have their normals flipped.
	// 
	//
	//   e.g.  this allows comparing membrane values as follows: 
	//
	//       int[] mapping = this.getMembraneIndexMapping(refMesh);
	//       double difference = refData[i] - data[mapping[i]];
	//
	if (getNumMembraneElements()!=referenceMesh.getNumMembraneElements()){
		throw new RuntimeException("this mesh and reference mesh have different number of membrane elements '"+getNumMembraneElements()+" and "+referenceMesh.getNumMembraneElements());
	}
	if (getNumMembraneElements()==0){
		return null;
	}
	MembraneElement[] memElements = getMembraneElements();
	MembraneElement[] refMemElements = referenceMesh.getMembraneElements();
	int[] mapping = new int[refMemElements.length];
	for (int i = 0; i < refMemElements.length; i++){
		int refInsideIndex = refMemElements[i].getInsideVolumeIndex();
		int refOutsideIndex = refMemElements[i].getOutsideVolumeIndex();
		int correspondingMemIndex = -1;
		for (int j = 0; j < memElements.length; j++){
			int insideIndex = memElements[j].getInsideVolumeIndex();
			int outsideIndex = memElements[j].getOutsideVolumeIndex();
			//
			// just in case inside/outside are flipped we will check both ways.
			//
			if ((insideIndex==refInsideIndex && outsideIndex==refOutsideIndex) || (insideIndex==refOutsideIndex && outsideIndex==refInsideIndex)){
				correspondingMemIndex = j;
				break;
			}
		}
		if (correspondingMemIndex==-1){
			throw new RuntimeException("couldn't find corresponding membrane element in reference mesh for index = "+i);
		}
		mapping[i] = correspondingMemIndex;
	}
	
	return mapping;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getMembraneRegionIndex(int membraneIndex) {
	return getMeshRegionInfo().getMembraneRegionForMembraneElement(membraneIndex);
}


/**
 * Insert the method's description here.
 * Creation date: (7/9/2001 12:29:36 PM)
 * @return cbit.vcell.solvers.MeshRegionInfo
 */
private MeshRegionInfo getMeshRegionInfo() {
	//
	// mesh region info is a very low-level object, it should be encapsulated.
	//
	if (meshRegionInfo == null) {
		inflate();
	}
	return meshRegionInfo;
}


/**
 * Insert the method's description here.
 * Creation date: (5/2/2005 10:52:06 AM)
 * @return int
 */
public int getNumMembraneElements() {
	MembraneElement memElement[] = getMembraneElements();
	if (memElement!=null){
		return memElement.length;
	}else{
		return 0;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (3/3/2002 11:20:04 PM)
 * @return int
 */
public int getNumMembraneRegions() {
	MeshRegionInfo mri = getMeshRegionInfo();
	if (mri == null){
		return 0;
	}
	return mri.getNumMembraneRegions();
}


/**
 * Insert the method's description here.
 * Creation date: (5/2/2005 10:52:06 AM)
 * @return int
 */
public int getNumVolumeElements() {
	return size.getX()*size.getY()*size.getZ();
}


/**
 * Insert the method's description here.
 * Creation date: (3/3/2002 11:20:04 PM)
 * @return int
 */
public int getNumVolumeRegions() {
	MeshRegionInfo mri = getMeshRegionInfo();
	if (mri == null){
		return 0;
	}
	return mri.getNumVolumeRegions();
}


/**
 * This method was created in VisualAge.
 * @return cbit.vcell.geometry.Coordinate
 */
public Origin getOrigin() {
	if (origin == null) {
		inflate();
	}	
	return origin;
}


/**
 * Insert the method's description here.
 * Creation date: (9/20/2005 5:05:53 PM)
 * @return double
 */
public double getRegionMembraneSurfaceAreaFromMembraneIndex(int membraneIndex) {
	return getMeshRegionInfo().getRegionMembraneSurfaceAreaFromMembraneIndex(membraneIndex);
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getSizeX() {
	if (size == null) {
		inflate();
	}	
	return size.getX();
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getSizeY() {
	if (size == null) {
		inflate();
	}	
	return size.getY();
}


/**
 * This method was created by a SmartGuide.
 * @return int
 */
public int getSizeZ() {
	if (size == null) {
		inflate();
	}

	return size.getZ();
}


/**
 * Insert the method's description here.
 * Creation date: (8/20/2003 1:46:44 PM)
 * @return int
 * @param volIndex int
 */
public int getSubVolumeFromVolumeIndex(int volIndex) {
	int regionIndex = getVolumeRegionIndex(volIndex);
	return meshRegionInfo.getSubVolumeIDfromVolRegion(regionIndex);
}


/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String getVCML() {
	String version = VERSION_1_0;
	boolean bConnectivity = false;
	if(membraneElements != null && membraneElements[0].getMembraneNeighborIndexes().length == 0){
		bConnectivity = true;
		version = VERSION_1_1;
	}
	boolean bRegion = (meshRegionInfo != null);
	if(bRegion){
		version = VERSION_1_2;
	}
	StringBuffer buffer = new StringBuffer();
	buffer.append(version+"\n");
	buffer.append(VCML.CartesianMesh+" {\n");
	buffer.append("\t"+VCML.Size+" "+getSizeX()+" "+getSizeY()+" "+getSizeZ()+"\n");
	buffer.append("\t"+VCML.Extent+" "+getExtent().getX()+" "+getExtent().getY()+" "+getExtent().getZ()+"\n");
	buffer.append("\t"+VCML.Origin+" "+getOrigin().getX()+" "+getOrigin().getY()+" "+getOrigin().getZ()+"\n");
	if(bRegion){
		buffer.append(meshRegionInfo.getVCMLVolumeRegionMapSubvolume());
		buffer.append(meshRegionInfo.getVCMLMembraneRegionsMapVolumeRegion());
		buffer.append(meshRegionInfo.getVCMLVolumeElementsMapVolumeRegion(getSizeX(),false));
	}
	if (membraneElements != null){
		buffer.append("\t"+VCML.MembraneElements+" {\n");
		buffer.append("\t"+membraneElements.length+"\n");
		for (int i=0;i<membraneElements.length;i++){
			buffer.append("\t\t"+membraneElements[i].toString());
			if(bRegion){
				buffer.append(" "+meshRegionInfo.getMembraneRegionForMembraneElement(i));
			}
			buffer.append("\n");
		}
		buffer.append("\t}\n");
	}
	if(contourElements != null){
		buffer.append("\t"+VCML.ContourElements+" {\n");
		buffer.append("\t"+contourElements.length+"\n");
		for (int i=0;i<contourElements.length;i++){
			buffer.append("\t\t"+contourElements[i].toString());
			buffer.append("\n");
		}
		buffer.append("\t}\n");

	}
	buffer.append("}\n");
	return buffer.toString();		
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
private int getVolumeIndex(int coordX,int coordY,int coordZ) {
	return coordX + getSizeX()*(coordY + getSizeY()*coordZ);
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getVolumeIndex(CoordinateIndex coordIndex) {
	return getVolumeIndex(coordIndex.x,coordIndex.y,coordIndex.z);
	//return coordIndex.x + getSizeX()*(coordIndex.y + getSizeY()*coordIndex.z);
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getVolumeRegionIndex(int volumeIndex) {
	byte regionIndex = getMeshRegionInfo().getVolumeElementMapVolumeRegion()[volumeIndex];
	return ((int)regionIndex)&0xff;
}


/**
 * This method was created in VisualAge.
 * @return int
 * @param coordIndex CoordinateIndex
 */
public int getVolumeRegionIndex(CoordinateIndex coordIndex) {
	int volumeIndex = getVolumeIndex(coordIndex);
	byte regionIndex = getMeshRegionInfo().getVolumeElementMapVolumeRegion()[volumeIndex];
	return ((int)regionIndex)&0xff;
}


/**
 * This method was created in VisualAge.
 * @return java.lang.String
 * @param variable java.lang.String
 * @param time double
 */
public int[] getVolumeSliceIndices(int normalAxis, int sliceNumber) {

	Coordinate normalAxisDimension = Coordinate.convertAxisFromStandardXYZToNormal(getSizeX(),getSizeY(),getSizeZ(),normalAxis);
	int indices[] = new int[(int)normalAxisDimension.getX()*(int)normalAxisDimension.getY()];
	int counter = 0;
	CoordinateIndex coordIndex = new CoordinateIndex();
	for (int y = 0;y < normalAxisDimension.getY();y+= 1){
		for (int x = 0;x < normalAxisDimension.getX();x+= 1){
			//
			// indexing through "normal" slice, converting each X,Y pair into equivalent
			// (X,Y,Z) in mesh coordinates.
			//
			coordIndex.x = x;
			coordIndex.y = y;
			coordIndex.z = sliceNumber;
			Coordinate.convertCoordinateIndexFromNormalToStandardXYZ(coordIndex,normalAxis);
			//
			// store mesh coordinates in "normal" slice sample array. 
			//
			indices[counter] = getVolumeIndex(coordIndex.x,coordIndex.y,coordIndex.z);
			counter+= 1;
		}
	}
	return indices;
}

/**
 * Insert the method's description here.
 * Creation date: (7/10/01 4:15:09 PM)
 * @return boolean
 */
public boolean hasRegionInfo() {
	return (meshRegionInfo!=null);
}


/**
 * Insert the method's description here.
 * Creation date: (9/13/2004 9:33:11 AM)
 * @param out java.io.ObjectOutputStream
 * @exception java.io.IOException The exception description.
 */
private void inflate() {
	if (compressedBytes == null) {
		return;
	}

	try {
		//Object objArray[] =  { version, size, origin, extent, meshRegionInfo, membraneElements, contourElements};
		Object objArray[] = (Object[])cbit.util.BeanUtils.fromCompressedSerialized(compressedBytes);
		version = (String)objArray[0];
		size = (ISize)objArray[1];
		origin = (Origin)objArray[2];
		extent = (Extent)objArray[3];
		meshRegionInfo = (MeshRegionInfo)objArray[4];
		membraneElements = (MembraneElement[])objArray[5];
		contourElements = (ContourElement[])objArray[6];

		compressedBytes = null;
		
	} catch (Exception ex) {
		ex.printStackTrace(System.out);
		throw new RuntimeException(ex.getMessage());
	}
}


/**
 * Insert the method's description here.
 * Creation date: (6/14/2001 4:54:52 PM)
 * @return boolean
 * @param from cbit.vcell.solvers.MembraneElement
 * @param to cbit.vcell.solvers.MembraneElement
 */
private boolean isFriendshipMutual(MembraneElement neighbor1,MembraneElement neighbor2) {
	//
	if(!isInList(neighbor1.getMembraneIndex(),neighbor2.getMembraneNeighborIndexes())){
		return false;
	}
	if(!isInList(neighbor2.getMembraneIndex(),neighbor1.getMembraneNeighborIndexes())){
		return false;
	}
	return true;
}


/**
 * Insert the method's description here.
 * Creation date: (6/14/2001 5:14:36 PM)
 * @return boolean
 * @param checkMe int
 * @param checkList int[]
 */
private boolean isInList(int checkMe, int[] checkList) {
	boolean bInList = false;
    for (int i = 0; i < checkList.length; i += 1) {
        if (checkMe == checkList[i]) {
	        bInList = true;
            break;
        }
    }
    return bInList;
}


/**
 * Insert the method's description here.
 * Creation date: (6/14/2001 4:26:36 PM)
 * @return boolean
 */
public boolean isMembraneConnectivityOK() {
    for (int c = 0; c < membraneElements.length; c += 1) {
        //Get the next membraneElement in the list
        MembraneElement currentMembraneElement = membraneElements[c];
        int[] membraneNeighborIndexes =
            currentMembraneElement.getMembraneNeighborIndexes();
        //Search the neighbors the the currentMembraneElement
        for (int mnic = 0; mnic < membraneNeighborIndexes.length; mnic += 1) {
            //Get the connectivity neighbors the of the next neighbor in the list
            if (!isFriendshipMutual(currentMembraneElement,membraneElements[membraneNeighborIndexes[mnic]])) {
                return false;
            }
        }
    }
    return true;
}


/**
 * This method was created by a SmartGuide.
 * @param tokens java.util.StringTokenizer
 * @exception java.lang.Exception The exception description.
 */
private void read(cbit.vcell.math.CommentStringTokenizer tokens,MembraneMeshMetrics membraneMeshMetrics) throws MathException {
	//
	// clear previous contents
	//
	membraneElements = null;

	//
	// read new stuff
	//
	String token = null;
	token = tokens.nextToken();
	if (token.equalsIgnoreCase(VCML.Version)){
		//
		// read version number 
		//
		token = tokens.nextToken(); 
		this.version = token;
		token = tokens.nextToken();
	}
	if (token.equalsIgnoreCase(VCML.CartesianMesh)){
		token = tokens.nextToken();
	}else{
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.CartesianMesh);
	}
	//
	// only Version 1.1 and later supports membrane connectivity  (as of 8/30/2000)
	//
	boolean bConnectivity = false;
	if (version.equals(VERSION_1_1) || version.equals(VERSION_1_2)){
		bConnectivity = true;
	}
	//
	// only Version 1.2 and later supports Regions
	//
	boolean bRegions = false;
	if (version.equals(VERSION_1_2)){
		bRegions = true;
		meshRegionInfo = new MeshRegionInfo();
	}
	
	if (!token.equalsIgnoreCase(VCML.BeginBlock)){
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
	}			
	while (tokens.hasMoreTokens()){
		token = tokens.nextToken();
		if (token.equalsIgnoreCase(VCML.EndBlock)){
			break;
		}			
		if (token.equalsIgnoreCase(VCML.Size)){
			int sx, sy, sz;
			try {
				token = tokens.nextToken();
				sx = Integer.valueOf(token).intValue();
				token = tokens.nextToken();
				sy = Integer.valueOf(token).intValue();
				token = tokens.nextToken();
				sz = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("expected:  "+VCML.Size+" # # #");
			}
			setSize(sx,sy,sz);
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.Extent)){
			double ex, ey, ez;
			try {
				token = tokens.nextToken();
				ex = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				ey = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				ez = Double.valueOf(token).doubleValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("expected:  "+VCML.Extent+" # # #");
			}
			setExtent(new Extent(ex,ey,ez));
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.Origin)){
			double ox, oy, oz;
			try {
				token = tokens.nextToken();
				ox = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				oy = Double.valueOf(token).doubleValue();
				token = tokens.nextToken();
				oz = Double.valueOf(token).doubleValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("expected:  "+VCML.Origin+" # # #");
			}
			setOrigin(new Origin(ox,oy,oz));
			continue;
		}
		//
		//
		//
		if (token.equalsIgnoreCase(VCML.VolumeRegionsMapSubvolume)){
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numVolumeRegions = 0;
			try {
				numVolumeRegions = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the VolumeRegionsMapSubvolume list length");
			}
			int checkCount = 0;
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				try{
					int volRegionID = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int subvolumeID = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					double volume = Double.valueOf(token).doubleValue();
					meshRegionInfo.mapVolumeRegionToSubvolume(volRegionID,subvolumeID,volume);
				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  # # #");
				}
				checkCount+= 1;
			}
			if(checkCount != numVolumeRegions){
				throw new MathFormatException("CartesianMesh.read->VolumeRegionsMapSubvolume: read "+checkCount+" VolRegions but was expecting "+numVolumeRegions);
			}
			continue;
		}	
		if (token.equalsIgnoreCase(VCML.MembraneRegionsMapVolumeRegion)){
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numMembraneRegions = 0;
			try {
				numMembraneRegions = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the MembraneRegionsMapVolumeRegion list length");
			}
			int checkCount = 0;
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				try{
					int memRegionID = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int volRegionIn = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int volRegionOut = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					double surface = Double.valueOf(token).doubleValue();
					meshRegionInfo.mapMembraneRegionToVolumeRegion(memRegionID,volRegionIn,volRegionOut,surface);
				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  # # #");
				}
				checkCount+= 1;
			}
			if(checkCount != numMembraneRegions){
				throw new MathFormatException("CartesianMesh.read->MembraneRegionsMapVolumeRegion: read "+checkCount+" MembraneRegions but was expecting "+numMembraneRegions);
			}
			continue;
		}	
		if (token.equalsIgnoreCase(VCML.VolumeElementsMapVolumeRegion)){
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numVolumeElements = 0;
			try {
				numVolumeElements = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the VolumeElementsMapVolumeRegion list length");
			}
			token  = tokens.nextToken();
			boolean bCompressed = token.equalsIgnoreCase("Compressed");
			if(!bCompressed){
				if(!token.equalsIgnoreCase("UnCompressed")){
					throw new MathFormatException("unexpected token "+token+" expecting Compress or UnCompress");
				}
			}
			byte[] volumeElementMap = new byte[numVolumeElements];
			int checkCount = 0;
			if(bCompressed){
				//Get HEX encoded bytes of the compressed VolumeElements-RegionID Map
				StringBuffer hexOfCompressed = new StringBuffer();
				while (tokens.hasMoreTokens()){
					token = tokens.nextToken();
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}
					hexOfCompressed.append(token);
				}
				//Un-HEX the compressed data
				byte[] compressedData = Hex.toBytes(hexOfCompressed.toString());
				try{
					meshRegionInfo.setCompressedVolumeElementMapVolumeRegion(compressedData);
				}catch(IOException e){
					throw new MathFormatException("CartesianMesh.read->VolumeElementsMapVolumeRegion "+e.toString());
				}
				checkCount = meshRegionInfo.getVolumeElementMapVolumeRegion().length;
			}else{
				while (tokens.hasMoreTokens()){
					token = tokens.nextToken();
					if (token.equalsIgnoreCase(VCML.EndBlock)){
						break;
					}
					try{
						int volumeRegionID = Integer.valueOf(token).intValue();
						volumeElementMap[checkCount] = (byte)volumeRegionID;
					}catch (NumberFormatException e){
						throw new MathFormatException("expected:  # # #");
					}
					checkCount+= 1;
				}
			}
			if(checkCount != numVolumeElements){
				throw new MathFormatException("CartesianMesh.read->VolumeElementsMapVolumeRegion: read "+checkCount+" VolumeElements but was expecting "+numVolumeElements);
			}
			continue;
		}
		//
		//
		//	
		if (token.equalsIgnoreCase(VCML.MembraneElements)){
			//
			// read '{'
			//
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numMemElements = 0;
			try {
				numMemElements = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the membraneElement list length");
			}
			//
			// read list of the following format:
			//
			//		memIndex insideVolIndex outsideVolIndex
			//
			membraneElements = new MembraneElement[numMemElements];
			int index = 0;
			int[] membraneElementMapMembraneRegion = null;
			if(bRegions){
				membraneElementMapMembraneRegion = new int[numMemElements];
				meshRegionInfo.mapMembraneElementsToMembraneRegions(membraneElementMapMembraneRegion);
			}
			//
			// loop until read a "}"
			//
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				int memIndex = -1;
				int insideIndex = -1;
				int outsideIndex = -1;
				try {
					//
					// read first three tokens of a membrane element
					//
					//     membraneIndex   insideIndex    outsideIndex
					//
					memIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					insideIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					outsideIndex = Integer.valueOf(token).intValue();

				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  # # #");
				}
				
				MembraneElement me = null;
				//
				// grab connectivity if enabled (additional four tokens)
				//
				//     memNeighbor1  memNeighbor2  memNeighbor3  memNeighbor4
				//
				//	where memNeighborX = -1 for missing connections.   
				//
				if (bConnectivity){
					try {
						token = tokens.nextToken();
						int neighbor1 = Integer.valueOf(token).intValue();
						token = tokens.nextToken();
						int neighbor2 = Integer.valueOf(token).intValue();
						token = tokens.nextToken();
						int neighbor3 = Integer.valueOf(token).intValue();
						token = tokens.nextToken();
						int neighbor4 = Integer.valueOf(token).intValue();
						//
						if(bRegions){
							token = tokens.nextToken();
							int regionID = Integer.valueOf(token).intValue();
							membraneElementMapMembraneRegion[memIndex] = regionID;
						}
						if(membraneMeshMetrics == null){
							me = new MembraneElement(	memIndex,insideIndex,outsideIndex,
													neighbor1,neighbor2,neighbor3,neighbor4,MembraneElement.AREA_UNDEFINED,0,0,0,0,0,0);
						}else{
							me = new MembraneElement(	memIndex,insideIndex,outsideIndex,
													neighbor1,neighbor2,neighbor3,neighbor4,
													membraneMeshMetrics.areas[memIndex],
													membraneMeshMetrics.normals[memIndex][0],
													membraneMeshMetrics.normals[memIndex][1],
													membraneMeshMetrics.normals[memIndex][2],
													membraneMeshMetrics.centroids[memIndex][0],
													membraneMeshMetrics.centroids[memIndex][1],
													membraneMeshMetrics.centroids[memIndex][2]);
						}
					}catch (NumberFormatException e){
						throw new MathFormatException("expected:  # # # # # # #");
					}
				}else{
					me = new MembraneElement(memIndex,insideIndex,outsideIndex);
				}
				
				membraneElements[index] = me;
				index++;
			}
			continue;
		}			
		if (token.equalsIgnoreCase(VCML.ContourElements)){
			//
			// read '{'
			//
			token = tokens.nextToken();
			if (!token.equalsIgnoreCase(VCML.BeginBlock)){
				throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
			}
			token = tokens.nextToken();
			int numContourElements = 0;
			try {
				numContourElements = Integer.valueOf(token).intValue();
			}catch (NumberFormatException e){
				throw new MathFormatException("unexpected token "+token+" expecting the contourElement list length");
			}
			//
			// read list of the following format:
			//
			//		contourIndex volumeIndex beginCoord endCoord prevIndex nextIndex
			//
			contourElements = new ContourElement[numContourElements];
			int index = 0;
			//
			// loop until read a "}"
			//
			while (tokens.hasMoreTokens()){
				token = tokens.nextToken();
				if (token.equalsIgnoreCase(VCML.EndBlock)){
					break;
				}
				ContourElement ce = null;
				try {
					//
					// read first two tokens of a contour element
					//
					//     contourIndex volumeIndex
					//
					int contourIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int volumeIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();

					//
					// read beginCoord endCoord
					//
					double beginX = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double beginY = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double beginZ = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();

					double endX = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double endY = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();
					double endZ = Double.valueOf(token).doubleValue();
					token = tokens.nextToken();

					Coordinate begin = new Coordinate(beginX,beginY,beginZ);
					Coordinate end = new Coordinate(endX,endY,endZ);

					//
					// read last two tokens of a contour element
					//
					//     prevContourIndex nextContourIndex
					//
					int prevContourIndex = Integer.valueOf(token).intValue();
					token = tokens.nextToken();
					int nextContourIndex = Integer.valueOf(token).intValue();

					ce = new ContourElement(contourIndex, volumeIndex, begin, end, prevContourIndex, nextContourIndex);

				}catch (NumberFormatException e){
					throw new MathFormatException("expected:  %d %d   %f %f %f    %f %f %f   %d %d");
				}
				
				contourElements[index] = ce;
				
				index++;
			}
			continue;
		}
		throw new MathFormatException("unexpected identifier "+token);
	}
	switch (getGeometryDimension()) {
		case 1 : {
			if (extent.getY() != 1 || extent.getZ() != 1) {
				System.out.println("Extent "+extent.toString()+" for a 1-D mesh truncated to 1 for y and z");
				setExtent(new Extent(extent.getX(), 1.0, 1.0));
			}
			break;
		}
		case 2 : {
			if (extent.getZ() != 1) {
				System.out.println("Extent "+extent.toString()+" for a 2-D mesh truncated to 1 for z");
				setExtent(new Extent(extent.getX(), extent.getY(), 1.0));
			}
			break;			
		}
	}
}


/**
 * Insert the method's description here.
 * Creation date: (2/15/2006 2:06:21 PM)
 */
public MembraneMeshMetrics readMembraneMeshMetrics(cbit.vcell.math.CommentStringTokenizer tokens) throws MathException{

	MembraneMeshMetrics membraneMeshMetrics = new MembraneMeshMetrics();
	
	String token = null;
	token = tokens.nextToken();
	if (token.equalsIgnoreCase(VCML.MembraneElements)){
		token = tokens.nextToken();
	}else{
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.CartesianMesh);
	}
	if (!token.equalsIgnoreCase(VCML.BeginBlock)){
		throw new MathFormatException("unexpected token "+token+" expecting "+VCML.BeginBlock);
	}
	
	token = tokens.nextToken();
	int numMembraneElements = 0;
	try{
		numMembraneElements = Integer.valueOf(token).intValue();
	}catch(NumberFormatException e){
		throw new MathFormatException("unexpected token "+token+" expecting MembraneElement count");
	}
	
	short[] regionIndex = new short[numMembraneElements];
	float[] areas = new float[numMembraneElements];
	float[][] normals = new float[numMembraneElements][3];
	float[][] centroids = new float[numMembraneElements][3];

	if(
		!(token = tokens.nextToken()).equals("Index") ||
		!(token = tokens.nextToken()).equals("RegionIndex") ||
		!(token = tokens.nextToken()).equals("X") ||
		!(token = tokens.nextToken()).equals("Y") ||
		!(token = tokens.nextToken()).equals("Z") ||
		!(token = tokens.nextToken()).equals("Area") ||
		!(token = tokens.nextToken()).equals("Nx") ||
		!(token = tokens.nextToken()).equals("Ny") ||
		!(token = tokens.nextToken()).equals("Nz")
	){
		throw new MathFormatException("unexpected MeshMetrics column description = "+token);
	}
	int counter = 0;
	while (tokens.hasMoreTokens()){
		token = tokens.nextToken();
		if (token.equalsIgnoreCase(VCML.EndBlock)){
			break;
		}			
		if(counter >= numMembraneElements){
			throw new MathFormatException("Error parsing MembraneMeshMetrics values index="+counter+".  Expecting only "+numMembraneElements+" MembraneElements");
		}
		try {
			int index = Integer.valueOf(token).intValue();
			if(index != counter){
				throw new MathFormatException("unexpected token "+token+" expecting "+counter);
			}
			regionIndex[counter] = Short.parseShort(tokens.nextToken());
			//centroids
			centroids[counter][0] = Float.parseFloat(tokens.nextToken());
			centroids[counter][1] = Float.parseFloat(tokens.nextToken());
			centroids[counter][2] = Float.parseFloat(tokens.nextToken());
			//area
			areas[counter] = Float.parseFloat(tokens.nextToken());
			//normals
			normals[counter][0] = Float.parseFloat(tokens.nextToken());
			normals[counter][1] = Float.parseFloat(tokens.nextToken());
			normals[counter][2] = Float.parseFloat(tokens.nextToken());
			
		}catch (NumberFormatException e){
			throw new MathFormatException("Error parsing MembraneMeshMetrics values index="+counter+"  "+e.getMessage());
		}
		counter+= 1;
	}

	membraneMeshMetrics.regionIndexes = regionIndex;
	membraneMeshMetrics.areas = areas;
	membraneMeshMetrics.normals = normals;
	membraneMeshMetrics.centroids = centroids;
	
	return membraneMeshMetrics;	
}


/**
 * Insert the method's description here.
 * Creation date: (9/13/2004 9:33:11 AM)
 * @param out java.io.ObjectOutputStream
 * @exception java.io.IOException The exception description.
 */
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
	int compressedSize = s.readInt();
	compressedBytes = new byte[compressedSize];
	s.readFully(compressedBytes, 0, compressedSize);
}


/**
 * This method was created in VisualAge.
 * @param extent cbit.util.Extent
 */
private void setExtent(cbit.util.Extent argExtent) {
	this.extent = argExtent;
}


/**
 * This method was created in VisualAge.
 * @param extent cbit.util.Extent
 */
private void setOrigin(cbit.util.Origin origin) {
	this.origin = origin;
}


/**
 * This method was created in VisualAge.
 * @param x int
 * @param y int
 * @param z int
 */
private void setSize(int x, int y, int z) {
	size = new ISize(x, y, z);
}


/**
 * Insert the method's description here.
 * Creation date: (9/13/2004 9:33:11 AM)
 * @param out java.io.ObjectOutputStream
 * @exception java.io.IOException The exception description.
 */
private void writeObject(ObjectOutputStream s) throws IOException {
	Object objArray[] =  { version, size, origin, extent, meshRegionInfo, membraneElements, contourElements};

	if (compressedBytes == null) {
		compressedBytes = cbit.util.BeanUtils.toCompressedSerialized(objArray);
	}
	s.writeInt(compressedBytes.length);
	s.write(compressedBytes);
}
}