package cbit.gui;
/*©
 * (C) Copyright University of Connecticut Health Center 2001.
 * All rights reserved.
©*/
import java.awt.*;
import cbit.vcell.parser.Expression;
import cbit.vcell.parser.ExpressionPrintFormatter;

/**
 * This class was generated by a SmartGuide.
 * 
 */
public class ExpressionCanvas extends javax.swing.JPanel implements javax.swing.Scrollable {
	private java.awt.Image offScreenImage = null;
	private java.awt.Dimension offScreenImageSize = null;
	private boolean bImageDirty = true;
	private cbit.vcell.parser.Expression[] fieldExpressions = null;
	private String fieldSuffixLabels[] = null;
	private String fieldPrefixLabels[] = null;
	private cbit.vcell.parser.NameScope fieldNameScope = null;


/**
 * Constructor
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
public ExpressionCanvas() {
	super();
	initialize();
}


	//used by the publish package.
	/** 
	 * @deprecated moved to ExpressionPrintFormatter.getExpressionAsImage()
	 */
	public static void getExpressionAsImage (Expression expArray [], java.awt.image.BufferedImage image, int scale) {    
		ExpressionPrintFormatter.getExpressionAsImage(expArray,image,scale);
	}


	/** 
	 * @deprecated moved to ExpressionPrintFormatter.getExpressionImageSize()
	 */
	public static Dimension getExpressionImageSize(Expression expArray [], Graphics2D g) throws cbit.vcell.parser.ExpressionException {
		return ExpressionPrintFormatter.getExpressionImageSize(expArray, g);
	}


/**
 * Gets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @return The expressions property value.
 * @see #setExpressions
 */
public cbit.vcell.parser.Expression[] getExpressions() {
	return fieldExpressions;
}


/**
 * Gets the expressions index property (cbit.vcell.parser.Expression) value.
 * @return The expressions property value.
 * @param index The index value into the property array.
 * @see #setExpressions
 */
public cbit.vcell.parser.Expression getExpressions(int index) {
	return getExpressions()[index];
}


/**
 * Insert the method's description here.
 * Creation date: (3/28/01 5:38:58 PM)
 * @return javax.swing.JScrollPane
 */
private javax.swing.JScrollPane getJScrollPaneParent() {
	if (getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent();
	}else if (getParent() instanceof javax.swing.JViewport && getParent().getParent() instanceof javax.swing.JScrollPane){
		return (javax.swing.JScrollPane)getParent().getParent();
	}else{
		return null;
	}
}


/**
 * Insert the method's description here.
 * Creation date: (11/19/2002 11:26:26 AM)
 * @return java.awt.Dimension
 */
public Dimension getMinimumSize() {
	Graphics2D g = (Graphics2D)getGraphics();
	if (g != null){
		g.setClip(0,0,getSize().width,getSize().height);
		g.setFont(new Font("SansSerif", Font.ITALIC, 11));
		try {
			Dimension minSize = new java.awt.Dimension(10,10);
			for (int i=0;i<fieldExpressions.length;i++){
				cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(fieldExpressions[i],getNameScope());
				java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
				int labelWidth = 0;
				if (fieldPrefixLabels!=null){
					labelWidth += g.getFontMetrics().stringWidth(fieldPrefixLabels[i]) + 20;
				}
				if (fieldSuffixLabels!=null){
					labelWidth += g.getFontMetrics().stringWidth(fieldSuffixLabels[i]) + 20;
				}
				minSize.width = Math.max(minSize.width, expressionDim.width + 20 + labelWidth);
				minSize.height += expressionDim.height+20;
			}
			return minSize;
		}catch (cbit.vcell.parser.ExpressionException e){
			e.printStackTrace(System.out);
			return super.getMinimumSize();
		}
	}else{
		return super.getMinimumSize();
	}
}


/**
 * Gets the nameScope property (cbit.vcell.parser.NameScope) value.
 * @return The nameScope property value.
 * @see #setNameScope
 */
public cbit.vcell.parser.NameScope getNameScope() {
	return fieldNameScope;
}


	/**
	 * Returns the preferred size of the viewport for a view component.
	 * For example the preferredSize of a JList component is the size
	 * required to acommodate all of the cells in its list however the
	 * value of preferredScrollableViewportSize is the size required for
	 * JList.getVisibleRowCount() rows.   A component without any properties
	 * that would effect the viewport size should just return 
	 * getPreferredSize() here.
	 * 
	 * @return The preferredSize of a JViewport whose view is this Scrollable.
	 * @see JViewport#getPreferredSize
	 */
public java.awt.Dimension getPreferredScrollableViewportSize() {
	return getPreferredSize();
}


/**
 * Insert the method's description here.
 * Creation date: (9/6/2002 12:17:16 PM)
 * @return java.awt.Dimension
 */
public Dimension getPreferredSize() {
	if (fieldExpressions!=null){
		Dimension prefSize = getMinimumSize();
		if (getJScrollPaneParent()!=null){
			java.awt.Rectangle viewBorderBounds = getJScrollPaneParent().getViewportBorderBounds();
			prefSize = new Dimension(Math.max(viewBorderBounds.width,prefSize.width),Math.max(viewBorderBounds.height,prefSize.height));
		}
		return prefSize;
	}else{
		return super.getPreferredSize();
	}
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one block
	 * of rows or columns, depending on the value of orientation. 
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a block scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "block" increment for scrolling in the specified direction.
	 * @see JScrollBar#setBlockIncrement
	 */
public int getScrollableBlockIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	if (javax.swing.SwingConstants.VERTICAL == orientation){
		return visibleRect.height/4;
	}else{
		return visibleRect.width/4;
	}
}


	/**
	 * Return true if a viewport should always force the height of this 
	 * Scrollable to match the height of the viewport.  For example a 
	 * columnar text view that flowed text in left to right columns 
	 * could effectively disable vertical scrolling by returning
	 * true here.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables height to match its own.
	 */
public boolean getScrollableTracksViewportHeight() {
	return false;
}


	/**
	 * Return true if a viewport should always force the width of this 
	 * Scrollable to match the width of the viewport.  For example a noraml 
	 * text view that supported line wrapping would return true here, since it
	 * would be undesirable for wrapped lines to disappear beyond the right
	 * edge of the viewport.  Note that returning true for a Scrollable
	 * whose ancestor is a JScrollPane effectively disables horizontal
	 * scrolling.
	 * <p>
	 * Scrolling containers, like JViewport, will use this method each 
	 * time they are validated.  
	 * 
	 * @return True if a viewport should force the Scrollables width to match its own.
	 */
public boolean getScrollableTracksViewportWidth() {
	return false;
}


	/**
	 * Components that display logical rows or columns should compute
	 * the scroll increment that will completely expose one new row
	 * or column, depending on the value of orientation.  Ideally, 
	 * components should handle a partially exposed row or column by 
	 * returning the distance required to completely expose the item.
	 * <p>
	 * Scrolling containers, like JScrollPane, will use this method
	 * each time the user requests a unit scroll.
	 * 
	 * @param visibleRect The view area visible within the viewport
	 * @param orientation Either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL.
	 * @param direction Less than zero to scroll up/left, greater than zero for down/right.
	 * @return The "unit" increment for scrolling in the specified direction
	 * @see JScrollBar#setUnitIncrement
	 */
public int getScrollableUnitIncrement(java.awt.Rectangle visibleRect, int orientation, int direction) {
	return 1;
}


/**
 * Called whenever the part throws an exception.
 * @param exception java.lang.Throwable
 */
private void handleException(java.lang.Throwable exception) {

	/* Uncomment the following lines to print uncaught exceptions to stdout */
	// System.out.println("--------- UNCAUGHT EXCEPTION ---------");
	// exception.printStackTrace(System.out);
}


/**
 * Initialize the class.
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private void initialize() {
	try {
		// user code begin {1}
		// user code end
		setName("ExpressionCanvas");
		setLayout(null);
		setSize(160, 120);
	} catch (java.lang.Throwable ivjExc) {
		handleException(ivjExc);
	}
	// user code begin {2}
	// user code end
}


/**
 * main entrypoint - starts the part when it is run as an application
 * @param args java.lang.String[]
 */
public static void main(java.lang.String[] args) {
	try {
		javax.swing.JFrame frame = new javax.swing.JFrame();
		ExpressionCanvas aExpressionCanvas;
		aExpressionCanvas = new ExpressionCanvas();
		frame.setContentPane(aExpressionCanvas);
		frame.setSize(aExpressionCanvas.getSize());
		frame.addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent e) {
				System.exit(0);
			};
		});
		frame.show();
		java.awt.Insets insets = frame.getInsets();
		frame.setSize(frame.getWidth() + insets.left + insets.right, frame.getHeight() + insets.top + insets.bottom);
		frame.setVisible(true);
	} catch (Throwable exception) {
		System.err.println("Exception occurred in main() of javax.swing.JPanel");
		exception.printStackTrace(System.out);
	}
}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
public void paintComponent(java.awt.Graphics g) {
	super.paintComponent(g);
	if (bImageDirty){
		refreshGraphics();
	}
	if (offScreenImage != null){
		g.drawImage(offScreenImage,-1,-1,this);
	}	
	return;
}


/**
 * This method was created by a SmartGuide.
 * @param g java.awt.Graphics
 */
private void refreshGraphics () {

	try {
		offScreenImageSize = new java.awt.Dimension(getSize().width,getSize().height);
		offScreenImage = createImage(offScreenImageSize.width,offScreenImageSize.height);
		if (offScreenImage==null){
			return;
		}	

		java.awt.Graphics2D g = (Graphics2D)offScreenImage.getGraphics();
//		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
		g.setClip(0,0,getSize().width,getSize().height);
		g.setFont(new Font("SansSerif", Font.ITALIC, 11));
		g.setColor(getBackground());
	  	g.fillRect(0,0,getSize().width,getSize().height);
  	
		if (fieldExpressions!=null){
			g.setColor(getForeground());
			java.awt.Rectangle rect = g.getClipBounds();
			int posY = 0; //Math.max(0,(rect.height - getSize().height)/2);
			int posX = Math.max(5,(rect.width - getSize().width)/2);
			for (int i=0;i<fieldExpressions.length;i++){
				int prefixWidth = 0;
				cbit.vcell.parser.ExpressionPrintFormatter expPrintFormatter = new cbit.vcell.parser.ExpressionPrintFormatter(fieldExpressions[i], getNameScope());
				java.awt.Dimension expressionDim = expPrintFormatter.getSize(g);
				if (fieldPrefixLabels!=null && fieldPrefixLabels[i]!=null){
					prefixWidth = g.getFontMetrics().stringWidth(fieldPrefixLabels[i]) + 10;
					g.setClip(posX,posY,getSize().width,getSize().height);
					g.setColor(Color.blue);
					g.drawString(fieldPrefixLabels[i],posX,posY+expressionDim.height/2+g.getFontMetrics().getDescent());
				}
				g.setColor(getForeground());
				g.setClip(posX+prefixWidth,posY,expressionDim.width,expressionDim.height);
				expPrintFormatter.paint(g);
				if (fieldSuffixLabels!=null && fieldSuffixLabels[i]!=null){
					g.setColor(Color.blue);
					g.setClip(posX,posY,getSize().width,getSize().height);
					g.drawString(fieldSuffixLabels[i],posX+expressionDim.width+prefixWidth+20,posY+expressionDim.height/2+g.getFontMetrics().getDescent());
				}
				posY += expressionDim.height+20;
			}
		}		
	}catch (Exception e){
		offScreenImage = null;
		System.out.println("exception in ExpressionCanvas.refreshGraphics()");
		e.printStackTrace(System.out);
	}

	bImageDirty = false;
	return;
}


/**
 * Insert the method's description here.
 * Creation date: (11/19/2002 12:25:45 PM)
 * @param x int
 * @param y int
 * @param w int
 * @param h int
 */
public void reshape(int x, int y, int w, int h) {
	if (w!=getSize().width || h!=getHeight()){
		bImageDirty = true;
	}
	super.reshape(x,y,w,h);
}


/**
 * This method was created by a SmartGuide.
 * @param expression cbit.vcell.parser.Expression
 */
public void setExpression(Expression expression) {
	Expression expList[] = null;
	if (expression != null){
		expList = new Expression[1];
		expList[0] = expression;
	}		
	setExpressions(expList,null,null);
}


/**
 * Sets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @param expressions The new value for the property.
 * @see #getExpressions
 */
public void setExpressions(cbit.vcell.parser.Expression[] expressions) {
	setExpressions(expressions,null,null);
}


/**
 * Sets the expressions property (cbit.vcell.parser.Expression[]) value.
 * @param expressions The new value for the property.
 * @see #getExpressions
 */
public void setExpressions(cbit.vcell.parser.Expression[] expressions, String prefixLabels[], String suffixLabels[]) {
	fieldExpressions = expressions;
	fieldPrefixLabels = prefixLabels;
	fieldSuffixLabels = suffixLabels;
	bImageDirty = true;
	updateAll();
}


/**
 * Sets the nameScope property (cbit.vcell.parser.NameScope) value.
 * @param nameScope The new value for the property.
 * @see #getNameScope
 */
public void setNameScope(cbit.vcell.parser.NameScope nameScope) {
	cbit.vcell.parser.NameScope oldValue = fieldNameScope;
	fieldNameScope = nameScope;
	firePropertyChange("nameScope", oldValue, nameScope);
}


/**
 * This method was created by a SmartGuide.
 * @param o java.util.Observable
 * @param obj java.lang.Object
 */
public void updateAll() {
	try {
		if (fieldExpressions!=null){
			if (getJScrollPaneParent()!=null){
				invalidate();
				getJScrollPaneParent().revalidate();
			}
			setSize(getPreferredSize());
			repaint();
		}
	}catch (Exception e){
		handleException(e);
	}			
}


/**
 * 
 */
/* WARNING: THIS METHOD WILL BE REGENERATED. */
private static void getBuilderData() {
/*V1.1
**start of data**
	D0CB838494G88G88G590171B4GGGGGGGGGGGG8CGGGE2F5E9ECE4E5F2A0E4E1F4E135D7EBECDC4595B6A52DDC2925C18D69C60A40C2902515DBD2612896750F34EA2528D8D5DA859429C682A9A92006D7618720D04DBEECA73513BA0F22C409083157F60055C2A0823AF2D19DBBA58683A6F196D70D545C5D9D5B975F575EBBF79FB846BDE7664E6E3559CDCC242C74E96E1C19B9F366BC3E19A5070E573586C307888936926F77CE10103A03045CEA9D3DDB4AD69A498E627B3D8C58CF56AD
	C4202D0331F65E5F5153896DBEC0A348300D18490EAE72C24FE1CF5E6249A502A1C2FE45679C6EBD66494EC27F92A0G28B74B7377701D3F19F8576BDF3CF9BDF966B7F6E8AF6A7169146834445AB73C361BBC9F5CE661DEC33D1D5E1A996857817070E17273502B508E0E4FCE3F17CE29AC1ECBD3CD0B6B8A1B09CF3BEAA2F126E05954F1D45398D60C1C6290B211C5FD5F6E5D4D5793F28C7A8FF2D973G6E91006F8D004DGE17FBF8786BD7BA667FEC636CF7FFA4F5F2A589F35055DE3F6597E6ED7D361A35C
	57FFA46853DA982B87EC82EC87C41CE4C794F094468E12479670BCC3A9B6EC6A3AE98CD956E9ADE3FFE4E628865F09840CF832F3B4ED5A99C2C49C5F6F0DD53067CA906BAEFC6DF542A76B5F12B12DBF779352F2776AD0FB851F342C1F8B8DBA429793CE59A7E26F1B2A6E4D1C45B937F86F4F08FFEF72681B6D2D9576BEF67F1B6D351E1E353E3D1B9D0C753FCEE02C1B60BB68650110FF4065DD2CAC977977FB1E9B586F063195CC664664BEE94BD864F652F57287957D907865F7C20FB0E183F14B36083CF8A2
	04F5948379D940A5C08190GB4GB63BB2B75EA62FAFB3B746951B1DF6D5ADC3EDA256BEC1DE041696182D0C9A8ED30CB4CDAA362A24B48AB5A166BC4BF3A235E85D8BBCE75330477B542036422012C03B22D3C6EDC74CE98B6E47B9B66523932ACEE1835DA2D26F3EA0D093519407DD30B28A236599E27C45A07AB227A4C1A3A800EF6117E3917479A3F0FE12039864249FEE667ABE2436C135C4E24CB4E7DDEB82CFC2AE61BCF2A72F6DA8FC8F82042E07E7D1F687741BCAFAB6878F78740C28E9B4DF310B32B6
	7EFD8239F2CBCE467A71C9996B113DBFA6317BEE29986B1510F7BBF39E176617667CB85709F6097E360149E5545C16DC65FAD8DE0DBF352CBD425720FFDFA9D697F40CD58C4EFB96B01317BE8E073AC54E1ED69CAA3374939B920CE64A9E97F31F8BA12F529CB55888352811018F474B91925ED34E5FA93314DBEDDCEEC13E8FC302B9A5F9E798F3D2E14CD6D3AE2367A9E32AB1DD9EBF94463D9CB7E515CBC56EF5B40CFCE266A15FCB733B4387F89D988665C61716F863BDBCD729C6F5B0FA58F48DA664A7A298
	6FD9DA74EAA596E963392E39D8F7628E5B2060C5ED592A8E2E4052A5DB721847CD3D728EC654008C6F62BB20ED4C4B1C4C774A1C0CFE71C33269FFD6289297866E7CDE68F0C164D02CD04EC9E1534E594A367F19570CA7F7042D3BDF6E02F6692DAAF260A683750C017ECB00C2C16600219D715519977CE1D35304ABCBBE7E2F0E3A9D1AF5A95093967407A53F257483CB46121E8F457867BA7AD073F101307769D750077CFD703912D38AF1A78FF910C8FCB02E00B562AD509F45F3627C15857996B84279FEB376
	814F96243FFF37D73E85D64D2EA7AD0F1EEC2F761669AA8ABF1FAA167D9DFBF228CD78EA1B09FBB298DBD114FE5A217BF9ED48F14C344AA955BB63AA439F8FA1DBE37C955AA955F658A894CCC17A63B6836DC54E75449E973C96DDFA67860AE5EE29AFFE15E7443D78DD6E0FCDC5F1AF86CB7255DC5E6C130B7B727800FC2FED033141AFA48F7FBD0B712803FE93E0ABE0A720F3AE59911B13FE98B05FA2D73967C68D38FE8CC5BB3F28003D33BFE006C54DF97D074CD6D9F3500ABB62B40F79D95873A2C048EA7B
	D0D6837D401C64676F8F10126F567A3E7B164529578A3147FB57F58F611B173255B937AFDB19F3DF4BD6665C13597DC28EBA7CAF90B97E0F6C15B9F9A8DB091343FC6CBF51B61E4FC553E5D0CB17B1DED6D472E39344EB6B1C485D5D17453DAF6A7F27F96405A9F83040D667AD1AA63B785A5B7A645A9968DF862C85B481DAGA20783D11943A373B0E7DE6A1C6E69A372BF07294755149EF7F3FADCC931B84D28AC1178585534B14FD4A27864BE2E2B81F4B483364FCBBEA974CBBE29DFF7BB593223B21FBCB8B1
	9F5AB56F714817E5BEB9857FAD840775766F7656DD0471D5DF226C537EC3BE9D684727GF100983FF151B8466615C5639B970D233DC3C17F78430B46DBFD6B45596E6D13E75BF56F8622EDDCD175FFDF0BF7A632601D6D37EB02350171B6D18737FE053316D7BF75DFFB1D603451BE0C553B8BCB396E9C170FACAC653ABF1472E49C469A96A457059D4C3143B5490ED300B1C0863082D0D7A3396E7E6C9B64AADCB7E1DAE3D0201A2F244479CE74DF5BFF37DF344B38B45C73A352782D11D0C71538B45408F8EC75
	5A4666B5C1EC4579D6B3BCDF6406E4C7B7E084F091E081EAEF1067FB490E09731D014A98E2CCC94F705BCB9EAE2952FCD90C85AA4E768916189747C95F77C3516B4F3B4FDF57BD3C7729D31DF78FBA15F97708D319F70FBBD7665581277ADBB76E785F3AA22EADAE5675DA08E1A3208570A4A0728D9953A627C74434C2BC4FE4266930497FE13252DB04D5BF6BBAF6757F25F7B1FC6324CC46CC9D75CB79C60671E2264505C2F68FC39F596A748C93D3BD79A6067C2851A9AE96326DEEF53B7E64DE5D2EE7DC7E9E
	83FD93C54B53791C0B7714B9B5655052797F62F615E4234E38692878287BBFD0CB8788D033F5774587GG4893GGD0CB818294G94G88G88G590171B4D033F5774587GG4893GG8CGGGGGGGGGGGGGGGGGE2F5E9ECE4E5F2A0E4E1F4E1D0CB8586GGGG81G81GBAGGG7F87GGGG
**end of data**/
}
}